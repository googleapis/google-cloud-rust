// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for
/// [VmwareEngine.ListPrivateClouds][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateClouds]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateClouds]: crate::client::VmwareEngine::list_private_clouds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateCloudsRequest {
    /// Required. The resource name of the private cloud to be queried for
    /// clusters. Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of private clouds to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListPrivateClouds` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListPrivateClouds` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison operator, and the
    /// value that you want to use for filtering. The value must be a string, a
    /// number, or a boolean. The comparison operator must be `=`, `!=`, `>`, or
    /// `<`.
    ///
    /// For example, if you are filtering a list of private clouds, you can exclude
    /// the ones named `example-pc` by specifying `name != "example-pc"`.
    ///
    /// You can also filter nested fields. For example, you could specify
    /// `networkConfig.managementCidr = "192.168.0.0/24"` to include private clouds
    /// only if they have a matching address in their network configuration.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-pc")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you can
    /// include `AND` and `OR` expressions explicitly. For example:
    ///
    /// ```norust
    /// (name = "private-cloud-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "private-cloud-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results are
    /// ordered by `name` in ascending order. You can also sort results in
    /// descending order based on the `name` value using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateCloudsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateCloudsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateCloudsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateCloudsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPrivateCloudsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPrivateCloudsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateCloudsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPrivateCloudsRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListPrivateClouds][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateClouds]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateClouds]: crate::client::VmwareEngine::list_private_clouds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateCloudsResponse {
    /// A list of private clouds.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub private_clouds: std::vec::Vec<crate::model::PrivateCloud>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateCloudsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_clouds][crate::model::ListPrivateCloudsResponse::private_clouds].
    pub fn set_private_clouds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PrivateCloud>,
    {
        use std::iter::Iterator;
        self.private_clouds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateCloudsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPrivateCloudsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPrivateCloudsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPrivateCloudsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPrivateCloudsResponse {
    type PageItem = crate::model::PrivateCloud;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.private_clouds
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetPrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.GetPrivateCloud]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetPrivateCloud]: crate::client::VmwareEngine::get_private_cloud
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPrivateCloudRequest {
    /// Required. The resource name of the private cloud to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPrivateCloudRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPrivateCloudRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPrivateCloudRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetPrivateCloudRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreatePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.CreatePrivateCloud]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreatePrivateCloud]: crate::client::VmwareEngine::create_private_cloud
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePrivateCloudRequest {
    /// Required. The resource name of the location to create the new
    /// private cloud in. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-provided identifier of the private cloud to be created.
    /// This identifier must be unique among each `PrivateCloud` within the parent
    /// and becomes the final token in the name URI.
    /// The identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_cloud_id: std::string::String,

    /// Required. The initial description of the new private cloud.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_cloud: std::option::Option<crate::model::PrivateCloud>,

    /// Optional. The request ID must be a valid UUID with the exception that zero
    /// UUID is not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. True if you want the request to be validated and not executed;
    /// false otherwise.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePrivateCloudRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePrivateCloudRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [private_cloud_id][crate::model::CreatePrivateCloudRequest::private_cloud_id].
    pub fn set_private_cloud_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_cloud_id = v.into();
        self
    }

    /// Sets the value of [private_cloud][crate::model::CreatePrivateCloudRequest::private_cloud].
    pub fn set_private_cloud<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateCloud>,
    {
        self.private_cloud = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_cloud][crate::model::CreatePrivateCloudRequest::private_cloud].
    pub fn set_or_clear_private_cloud<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateCloud>,
    {
        self.private_cloud = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePrivateCloudRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreatePrivateCloudRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreatePrivateCloudRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreatePrivateCloudRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdatePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.UpdatePrivateCloud]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdatePrivateCloud]: crate::client::VmwareEngine::update_private_cloud
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePrivateCloudRequest {
    /// Required. Private cloud description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_cloud: std::option::Option<crate::model::PrivateCloud>,

    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `PrivateCloud` resource by the update. The fields specified in `updateMask`
    /// are relative to the resource, not the full request. A field will be
    /// overwritten if it is in the mask. If the user does not provide a mask then
    /// all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The request ID must be a valid UUID with the exception that zero
    /// UUID is not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePrivateCloudRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_cloud][crate::model::UpdatePrivateCloudRequest::private_cloud].
    pub fn set_private_cloud<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateCloud>,
    {
        self.private_cloud = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_cloud][crate::model::UpdatePrivateCloudRequest::private_cloud].
    pub fn set_or_clear_private_cloud<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateCloud>,
    {
        self.private_cloud = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePrivateCloudRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePrivateCloudRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdatePrivateCloudRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePrivateCloudRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdatePrivateCloudRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeletePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.DeletePrivateCloud]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeletePrivateCloud]: crate::client::VmwareEngine::delete_private_cloud
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePrivateCloudRequest {
    /// Required. The resource name of the private cloud to delete.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The request ID must be a valid UUID with the exception that zero
    /// UUID is not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, cascade delete is enabled and all children of
    /// this private cloud resource are also deleted. When this flag is set to
    /// false, the private cloud will not be deleted if there are any children
    /// other than the management cluster. The management cluster is always
    /// deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    /// Optional. Time delay of the deletion specified in hours. The default value
    /// is `3`. Specifying a non-zero value for this field changes the value of
    /// `PrivateCloud.state` to `DELETED` and sets `expire_time` to the planned
    /// deletion time. Deletion can be cancelled before `expire_time` elapses using
    /// [VmwareEngine.UndeletePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.UndeletePrivateCloud].
    /// Specifying a value of `0` for this field instead begins the deletion
    /// process and ceases billing immediately. During the final deletion process,
    /// the value of `PrivateCloud.state` becomes `PURGING`.
    ///
    /// [google.cloud.vmwareengine.v1.VmwareEngine.UndeletePrivateCloud]: crate::client::VmwareEngine::undelete_private_cloud
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
    pub delay_hours: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePrivateCloudRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePrivateCloudRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePrivateCloudRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeletePrivateCloudRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [delay_hours][crate::model::DeletePrivateCloudRequest::delay_hours].
    pub fn set_delay_hours<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.delay_hours = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delay_hours][crate::model::DeletePrivateCloudRequest::delay_hours].
    pub fn set_or_clear_delay_hours<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.delay_hours = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeletePrivateCloudRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeletePrivateCloudRequest"
    }
}

/// Request message for
/// [VmwareEngine.UndeletePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.UndeletePrivateCloud]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UndeletePrivateCloud]: crate::client::VmwareEngine::undelete_private_cloud
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeletePrivateCloudRequest {
    /// Required. The resource name of the private cloud scheduled for deletion.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The request ID must be a valid UUID with the exception that zero
    /// UUID is not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeletePrivateCloudRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeletePrivateCloudRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UndeletePrivateCloudRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UndeletePrivateCloudRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UndeletePrivateCloudRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListClusters][google.cloud.vmwareengine.v1.VmwareEngine.ListClusters]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListClusters]: crate::client::VmwareEngine::list_clusters
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The resource name of the private cloud to query for clusters.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of clusters to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListClusters` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListClusters`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-cluster")
    /// (nodeCount = "3")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you can
    /// include `AND` and `OR` expressions explicitly. For example:
    ///
    /// ```norust
    /// (name = "example-cluster-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-cluster-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results are
    /// ordered by `name` in ascending order. You can also sort results in
    /// descending order based on the `name` value using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListClustersRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListClusters][google.cloud.vmwareengine.v1.VmwareEngine.ListClusters]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListClusters]: crate::client::VmwareEngine::list_clusters
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// A list of private cloud clusters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetCluster][google.cloud.vmwareengine.v1.VmwareEngine.GetCluster]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetCluster]: crate::client::VmwareEngine::get_cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The cluster resource name to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetClusterRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateCluster][google.cloud.vmwareengine.v1.VmwareEngine.CreateCluster]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateCluster]: crate::client::VmwareEngine::create_cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The resource name of the private cloud to create a new cluster
    /// in. Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-provided identifier of the new `Cluster`.
    /// This identifier must be unique among clusters within the parent and becomes
    /// the final token in the name URI.
    /// The identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The initial description of the new cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. The request ID must be a valid UUID with the exception that zero
    /// UUID is not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. True if you want the request to be validated and not executed;
    /// false otherwise.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateClusterRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateCluster][google.cloud.vmwareengine.v1.VmwareEngine.UpdateCluster]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateCluster]: crate::client::VmwareEngine::update_cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Cluster` resource by the update. The fields specified in the `updateMask`
    /// are relative to the resource, not the full request. A field will be
    /// overwritten if it is in the mask. If the user does not provide a mask then
    /// all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The description of the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. The request ID must be a valid UUID with the exception that
    /// zero UUID is not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. True if you want the request to be validated and not executed;
    /// false otherwise.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateClusterRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteCluster][google.cloud.vmwareengine.v1.VmwareEngine.DeleteCluster]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteCluster]: crate::client::VmwareEngine::delete_cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The resource name of the cluster to delete.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The request ID must be a valid UUID with the exception that zero
    /// UUID is not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteClusterRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListNodes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNodes]: crate::client::VmwareEngine::list_nodes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodesRequest {
    /// Required. The resource name of the cluster to be queried for nodes.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of nodes to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListNodes` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListNodes` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNodesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNodesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNodesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNodesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNodesRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListNodes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNodes]: crate::client::VmwareEngine::list_nodes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodesResponse {
    /// The nodes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nodes: std::vec::Vec<crate::model::Node>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nodes][crate::model::ListNodesResponse::nodes].
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Node>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNodesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNodesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNodesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNodesResponse {
    type PageItem = crate::model::Node;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nodes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetNode][google.cloud.vmwareengine.v1.VmwareEngine.GetNode]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetNode]: crate::client::VmwareEngine::get_node
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNodeRequest {
    /// Required. The resource name of the node to retrieve.
    /// For example:
    /// `projects/{project}/locations/{location}/privateClouds/{private_cloud}/clusters/{cluster}/nodes/{node}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNodeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetNodeRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAddresses]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAddresses]: crate::client::VmwareEngine::list_external_addresses
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExternalAddressesRequest {
    /// Required. The resource name of the private cloud to be queried for
    /// external IP addresses.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of external IP addresses to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListExternalAddresses` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListExternalAddresses` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of IP addresses, you can
    /// exclude the ones named `example-ip` by specifying
    /// `name != "example-ip"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-ip")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-ip-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-ip-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExternalAddressesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExternalAddressesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExternalAddressesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExternalAddressesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExternalAddressesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListExternalAddressesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListExternalAddressesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListExternalAddressesRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAddresses]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAddresses]: crate::client::VmwareEngine::list_external_addresses
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExternalAddressesResponse {
    /// A list of external IP addresses.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub external_addresses: std::vec::Vec<crate::model::ExternalAddress>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExternalAddressesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_addresses][crate::model::ListExternalAddressesResponse::external_addresses].
    pub fn set_external_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExternalAddress>,
    {
        use std::iter::Iterator;
        self.external_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExternalAddressesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListExternalAddressesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListExternalAddressesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListExternalAddressesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExternalAddressesResponse {
    type PageItem = crate::model::ExternalAddress;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.external_addresses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.FetchNetworkPolicyExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.FetchNetworkPolicyExternalAddresses]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.FetchNetworkPolicyExternalAddresses]: crate::client::VmwareEngine::fetch_network_policy_external_addresses
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchNetworkPolicyExternalAddressesRequest {
    /// Required. The resource name of the network policy to query for assigned
    /// external IP addresses. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>. For
    /// example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-policy`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_policy: std::string::String,

    /// The maximum number of external IP addresses to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// `FetchNetworkPolicyExternalAddresses` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all parameters provided to
    /// `FetchNetworkPolicyExternalAddresses`, except for `page_size` and
    /// `page_token`, must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchNetworkPolicyExternalAddressesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_policy][crate::model::FetchNetworkPolicyExternalAddressesRequest::network_policy].
    pub fn set_network_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_policy = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchNetworkPolicyExternalAddressesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchNetworkPolicyExternalAddressesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchNetworkPolicyExternalAddressesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.FetchNetworkPolicyExternalAddressesRequest"
    }
}

/// Response message for
/// [VmwareEngine.FetchNetworkPolicyExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.FetchNetworkPolicyExternalAddresses]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.FetchNetworkPolicyExternalAddresses]: crate::client::VmwareEngine::fetch_network_policy_external_addresses
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchNetworkPolicyExternalAddressesResponse {
    /// A list of external IP addresses assigned to VMware workload VMs within the
    /// scope of the given network policy.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub external_addresses: std::vec::Vec<crate::model::ExternalAddress>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchNetworkPolicyExternalAddressesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_addresses][crate::model::FetchNetworkPolicyExternalAddressesResponse::external_addresses].
    pub fn set_external_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExternalAddress>,
    {
        use std::iter::Iterator;
        self.external_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchNetworkPolicyExternalAddressesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchNetworkPolicyExternalAddressesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.FetchNetworkPolicyExternalAddressesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchNetworkPolicyExternalAddressesResponse {
    type PageItem = crate::model::ExternalAddress;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.external_addresses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.GetExternalAddress]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetExternalAddress]: crate::client::VmwareEngine::get_external_address
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetExternalAddressRequest {
    /// Required. The resource name of the external IP address to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-ip`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExternalAddressRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExternalAddressRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExternalAddressRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetExternalAddressRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.CreateExternalAddress]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateExternalAddress]: crate::client::VmwareEngine::create_external_address
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateExternalAddressRequest {
    /// Required. The resource name of the private cloud
    /// to create a new external IP address in.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The initial description of a new external IP address.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_address: std::option::Option<crate::model::ExternalAddress>,

    /// Required. The user-provided identifier of the `ExternalAddress` to be
    /// created. This identifier must be unique among `ExternalAddress` resources
    /// within the parent and becomes the final token in the name URI. The
    /// identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_address_id: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if the original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateExternalAddressRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExternalAddressRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [external_address][crate::model::CreateExternalAddressRequest::external_address].
    pub fn set_external_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAddress>,
    {
        self.external_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_address][crate::model::CreateExternalAddressRequest::external_address].
    pub fn set_or_clear_external_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAddress>,
    {
        self.external_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_address_id][crate::model::CreateExternalAddressRequest::external_address_id].
    pub fn set_external_address_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_address_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateExternalAddressRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateExternalAddressRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateExternalAddressRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.UpdateExternalAddress]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateExternalAddress]: crate::client::VmwareEngine::update_external_address
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExternalAddressRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `ExternalAddress` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. External IP address description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_address: std::option::Option<crate::model::ExternalAddress>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if the original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateExternalAddressRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateExternalAddressRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExternalAddressRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_address][crate::model::UpdateExternalAddressRequest::external_address].
    pub fn set_external_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAddress>,
    {
        self.external_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_address][crate::model::UpdateExternalAddressRequest::external_address].
    pub fn set_or_clear_external_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAddress>,
    {
        self.external_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateExternalAddressRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateExternalAddressRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateExternalAddressRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.DeleteExternalAddress]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteExternalAddress]: crate::client::VmwareEngine::delete_external_address
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteExternalAddressRequest {
    /// Required. The resource name of the external IP address to delete.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-ip`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExternalAddressRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExternalAddressRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteExternalAddressRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExternalAddressRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteExternalAddressRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListSubnets][google.cloud.vmwareengine.v1.VmwareEngine.ListSubnets]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListSubnets]: crate::client::VmwareEngine::list_subnets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSubnetsRequest {
    /// Required. The resource name of the private cloud to be queried for
    /// subnets.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of subnets to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListSubnetsRequest` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListSubnetsRequest` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubnetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSubnetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSubnetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSubnetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSubnetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListSubnetsRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListSubnets][google.cloud.vmwareengine.v1.VmwareEngine.ListSubnets]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListSubnets]: crate::client::VmwareEngine::list_subnets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSubnetsResponse {
    /// A list of subnets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subnets: std::vec::Vec<crate::model::Subnet>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubnetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnets][crate::model::ListSubnetsResponse::subnets].
    pub fn set_subnets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subnet>,
    {
        use std::iter::Iterator;
        self.subnets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSubnetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSubnetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSubnetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListSubnetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSubnetsResponse {
    type PageItem = crate::model::Subnet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.subnets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetSubnet][google.cloud.vmwareengine.v1.VmwareEngine.GetSubnet]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetSubnet]: crate::client::VmwareEngine::get_subnet
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSubnetRequest {
    /// Required. The resource name of the subnet to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/subnets/my-subnet`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSubnetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSubnetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSubnetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetSubnetRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateSubnet][google.cloud.vmwareengine.v1.VmwareEngine.UpdateSubnet]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateSubnet]: crate::client::VmwareEngine::update_subnet
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSubnetRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `Subnet` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Subnet description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub subnet: std::option::Option<crate::model::Subnet>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSubnetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSubnetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSubnetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnet][crate::model::UpdateSubnetRequest::subnet].
    pub fn set_subnet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Subnet>,
    {
        self.subnet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnet][crate::model::UpdateSubnetRequest::subnet].
    pub fn set_or_clear_subnet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Subnet>,
    {
        self.subnet = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSubnetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateSubnetRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListExternalAccessRules][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAccessRules]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAccessRules]: crate::client::VmwareEngine::list_external_access_rules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExternalAccessRulesRequest {
    /// Required. The resource name of the network policy to query for external
    /// access firewall rules. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>. For
    /// example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-policy`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of external access rules to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListExternalAccessRulesRequest`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListExternalAccessRulesRequest` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of external access rules, you can
    /// exclude the ones named `example-rule` by specifying
    /// `name != "example-rule"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-rule")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-rule-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-rule-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExternalAccessRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExternalAccessRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExternalAccessRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExternalAccessRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExternalAccessRulesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListExternalAccessRulesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListExternalAccessRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListExternalAccessRulesRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListExternalAccessRules][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAccessRules]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAccessRules]: crate::client::VmwareEngine::list_external_access_rules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExternalAccessRulesResponse {
    /// A list of external access firewall rules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub external_access_rules: std::vec::Vec<crate::model::ExternalAccessRule>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExternalAccessRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_access_rules][crate::model::ListExternalAccessRulesResponse::external_access_rules].
    pub fn set_external_access_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExternalAccessRule>,
    {
        use std::iter::Iterator;
        self.external_access_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExternalAccessRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListExternalAccessRulesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListExternalAccessRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListExternalAccessRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExternalAccessRulesResponse {
    type PageItem = crate::model::ExternalAccessRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.external_access_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.GetExternalAccessRule]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetExternalAccessRule]: crate::client::VmwareEngine::get_external_access_rule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetExternalAccessRuleRequest {
    /// Required. The resource name of the external access firewall rule to
    /// retrieve. Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-policy/externalAccessRules/my-rule`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExternalAccessRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExternalAccessRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExternalAccessRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetExternalAccessRuleRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.CreateExternalAccessRule]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateExternalAccessRule]: crate::client::VmwareEngine::create_external_access_rule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateExternalAccessRuleRequest {
    /// Required. The resource name of the network policy
    /// to create a new external access firewall rule in.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-policy`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The initial description of a new external access rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_access_rule: std::option::Option<crate::model::ExternalAccessRule>,

    /// Required. The user-provided identifier of the `ExternalAccessRule` to be
    /// created. This identifier must be unique among `ExternalAccessRule`
    /// resources within the parent and becomes the final token in the name URI.
    /// The identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_access_rule_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if the original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateExternalAccessRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExternalAccessRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [external_access_rule][crate::model::CreateExternalAccessRuleRequest::external_access_rule].
    pub fn set_external_access_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAccessRule>,
    {
        self.external_access_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_access_rule][crate::model::CreateExternalAccessRuleRequest::external_access_rule].
    pub fn set_or_clear_external_access_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAccessRule>,
    {
        self.external_access_rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_access_rule_id][crate::model::CreateExternalAccessRuleRequest::external_access_rule_id].
    pub fn set_external_access_rule_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_access_rule_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateExternalAccessRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateExternalAccessRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateExternalAccessRuleRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.UpdateExternalAccessRule]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateExternalAccessRule]: crate::client::VmwareEngine::update_external_access_rule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExternalAccessRuleRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `ExternalAccessRule` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Description of the external access rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_access_rule: std::option::Option<crate::model::ExternalAccessRule>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if the original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateExternalAccessRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateExternalAccessRuleRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExternalAccessRuleRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_access_rule][crate::model::UpdateExternalAccessRuleRequest::external_access_rule].
    pub fn set_external_access_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAccessRule>,
    {
        self.external_access_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_access_rule][crate::model::UpdateExternalAccessRuleRequest::external_access_rule].
    pub fn set_or_clear_external_access_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalAccessRule>,
    {
        self.external_access_rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateExternalAccessRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateExternalAccessRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateExternalAccessRuleRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.DeleteExternalAccessRule]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteExternalAccessRule]: crate::client::VmwareEngine::delete_external_access_rule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteExternalAccessRuleRequest {
    /// Required. The resource name of the external access firewall rule to delete.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-policy/externalAccessRules/my-rule`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExternalAccessRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExternalAccessRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteExternalAccessRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExternalAccessRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteExternalAccessRuleRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListLoggingServers][google.cloud.vmwareengine.v1.VmwareEngine.ListLoggingServers]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListLoggingServers]: crate::client::VmwareEngine::list_logging_servers
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLoggingServersRequest {
    /// Required. The resource name of the private cloud to be queried for
    /// logging servers.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of logging servers to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListLoggingServersRequest` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListLoggingServersRequest` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of logging servers, you can
    /// exclude the ones named `example-server` by specifying
    /// `name != "example-server"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-server")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-server-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-server-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLoggingServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLoggingServersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLoggingServersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLoggingServersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListLoggingServersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListLoggingServersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListLoggingServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListLoggingServersRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListLoggingServers][google.cloud.vmwareengine.v1.VmwareEngine.ListLoggingServers]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListLoggingServers]: crate::client::VmwareEngine::list_logging_servers
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLoggingServersResponse {
    /// A list of Logging Servers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub logging_servers: std::vec::Vec<crate::model::LoggingServer>,

    /// A token, which can be send as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLoggingServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [logging_servers][crate::model::ListLoggingServersResponse::logging_servers].
    pub fn set_logging_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LoggingServer>,
    {
        use std::iter::Iterator;
        self.logging_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLoggingServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListLoggingServersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLoggingServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListLoggingServersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLoggingServersResponse {
    type PageItem = crate::model::LoggingServer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.logging_servers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.GetLoggingServer]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetLoggingServer]: crate::client::VmwareEngine::get_logging_server
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLoggingServerRequest {
    /// Required. The resource name of the Logging Server to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/loggingServers/my-logging-server`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLoggingServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLoggingServerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLoggingServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetLoggingServerRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.CreateLoggingServer]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateLoggingServer]: crate::client::VmwareEngine::create_logging_server
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateLoggingServerRequest {
    /// Required. The resource name of the private cloud
    /// to create a new Logging Server in.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The initial description of a new logging server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_server: std::option::Option<crate::model::LoggingServer>,

    /// Required. The user-provided identifier of the `LoggingServer` to be
    /// created. This identifier must be unique among `LoggingServer` resources
    /// within the parent and becomes the final token in the name URI.
    /// The identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub logging_server_id: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLoggingServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLoggingServerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [logging_server][crate::model::CreateLoggingServerRequest::logging_server].
    pub fn set_logging_server<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingServer>,
    {
        self.logging_server = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_server][crate::model::CreateLoggingServerRequest::logging_server].
    pub fn set_or_clear_logging_server<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingServer>,
    {
        self.logging_server = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_server_id][crate::model::CreateLoggingServerRequest::logging_server_id].
    pub fn set_logging_server_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.logging_server_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateLoggingServerRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateLoggingServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateLoggingServerRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.UpdateLoggingServer]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateLoggingServer]: crate::client::VmwareEngine::update_logging_server
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateLoggingServerRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `LoggingServer` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Logging server description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_server: std::option::Option<crate::model::LoggingServer>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLoggingServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateLoggingServerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateLoggingServerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_server][crate::model::UpdateLoggingServerRequest::logging_server].
    pub fn set_logging_server<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingServer>,
    {
        self.logging_server = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_server][crate::model::UpdateLoggingServerRequest::logging_server].
    pub fn set_or_clear_logging_server<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingServer>,
    {
        self.logging_server = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateLoggingServerRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateLoggingServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateLoggingServerRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.DeleteLoggingServer]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteLoggingServer]: crate::client::VmwareEngine::delete_logging_server
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteLoggingServerRequest {
    /// Required. The resource name of the logging server to delete.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/loggingServers/my-logging-server`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLoggingServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLoggingServerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteLoggingServerRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLoggingServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteLoggingServerRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. True if the user has requested cancellation
    /// of the operation; false otherwise.
    /// Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.OperationMetadata"
    }
}

/// Request message for
/// [VmwareEngine.ListNodeTypes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodeTypes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNodeTypes]: crate::client::VmwareEngine::list_node_types
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodeTypesRequest {
    /// Required. The resource name of the location to be queried for node types.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of node types to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListNodeTypes` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListNodeTypes` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of node types, you can
    /// exclude the ones named `standard-72` by specifying
    /// `name != "standard-72"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "standard-72")
    /// (virtual_cpu_count > 2)
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "standard-96") AND
    /// (virtual_cpu_count > 2) OR
    /// (name = "standard-72")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodeTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNodeTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNodeTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNodeTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNodeTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListNodeTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNodeTypesRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListNodeTypes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodeTypes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNodeTypes]: crate::client::VmwareEngine::list_node_types
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodeTypesResponse {
    /// A list of Node Types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_types: std::vec::Vec<crate::model::NodeType>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodeTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_types][crate::model::ListNodeTypesResponse::node_types].
    pub fn set_node_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeType>,
    {
        use std::iter::Iterator;
        self.node_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNodeTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNodeTypesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNodeTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNodeTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNodeTypesResponse {
    type PageItem = crate::model::NodeType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.node_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetNodeType][google.cloud.vmwareengine.v1.VmwareEngine.GetNodeType]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetNodeType]: crate::client::VmwareEngine::get_node_type
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNodeTypeRequest {
    /// Required. The resource name of the node type to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-proj/locations/us-central1-a/nodeTypes/standard-72`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodeTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNodeTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodeTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetNodeTypeRequest"
    }
}

/// Request message for
/// [VmwareEngine.ShowNsxCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ShowNsxCredentials]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ShowNsxCredentials]: crate::client::VmwareEngine::show_nsx_credentials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShowNsxCredentialsRequest {
    /// Required. The resource name of the private cloud
    /// to be queried for credentials.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_cloud: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShowNsxCredentialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_cloud][crate::model::ShowNsxCredentialsRequest::private_cloud].
    pub fn set_private_cloud<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_cloud = v.into();
        self
    }
}

impl wkt::message::Message for ShowNsxCredentialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ShowNsxCredentialsRequest"
    }
}

/// Request message for
/// [VmwareEngine.ShowVcenterCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ShowVcenterCredentials]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ShowVcenterCredentials]: crate::client::VmwareEngine::show_vcenter_credentials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShowVcenterCredentialsRequest {
    /// Required. The resource name of the private cloud
    /// to be queried for credentials.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_cloud: std::string::String,

    /// Optional. The username of the user to be queried for credentials.
    /// The default value of this field is CloudOwner@gve.local.
    /// The provided value must be one of the following:
    /// CloudOwner@gve.local,
    /// solution-user-01@gve.local,
    /// solution-user-02@gve.local,
    /// solution-user-03@gve.local,
    /// solution-user-04@gve.local,
    /// solution-user-05@gve.local,
    /// zertoadmin@gve.local.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShowVcenterCredentialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_cloud][crate::model::ShowVcenterCredentialsRequest::private_cloud].
    pub fn set_private_cloud<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_cloud = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ShowVcenterCredentialsRequest::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for ShowVcenterCredentialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ShowVcenterCredentialsRequest"
    }
}

/// Request message for
/// [VmwareEngine.ResetNsxCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ResetNsxCredentials]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ResetNsxCredentials]: crate::client::VmwareEngine::reset_nsx_credentials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetNsxCredentialsRequest {
    /// Required. The resource name of the private cloud
    /// to reset credentials for.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_cloud: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetNsxCredentialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_cloud][crate::model::ResetNsxCredentialsRequest::private_cloud].
    pub fn set_private_cloud<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_cloud = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ResetNsxCredentialsRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for ResetNsxCredentialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ResetNsxCredentialsRequest"
    }
}

/// Request message for
/// [VmwareEngine.ResetVcenterCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ResetVcenterCredentials]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ResetVcenterCredentials]: crate::client::VmwareEngine::reset_vcenter_credentials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetVcenterCredentialsRequest {
    /// Required. The resource name of the private cloud
    /// to reset credentials for.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_cloud: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. The username of the user to be to reset the credentials.
    /// The default value of this field is CloudOwner@gve.local.
    /// The provided value should be one of the following:
    /// solution-user-01@gve.local,
    /// solution-user-02@gve.local,
    /// solution-user-03@gve.local,
    /// solution-user-04@gve.local,
    /// solution-user-05@gve.local,
    /// zertoadmin@gve.local.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetVcenterCredentialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_cloud][crate::model::ResetVcenterCredentialsRequest::private_cloud].
    pub fn set_private_cloud<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_cloud = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ResetVcenterCredentialsRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ResetVcenterCredentialsRequest::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for ResetVcenterCredentialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ResetVcenterCredentialsRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListHcxActivationKeys][google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]: crate::client::VmwareEngine::list_hcx_activation_keys
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHcxActivationKeysResponse {
    /// List of HCX activation keys.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hcx_activation_keys: std::vec::Vec<crate::model::HcxActivationKey>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHcxActivationKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hcx_activation_keys][crate::model::ListHcxActivationKeysResponse::hcx_activation_keys].
    pub fn set_hcx_activation_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HcxActivationKey>,
    {
        use std::iter::Iterator;
        self.hcx_activation_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListHcxActivationKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListHcxActivationKeysResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListHcxActivationKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListHcxActivationKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListHcxActivationKeysResponse {
    type PageItem = crate::model::HcxActivationKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.hcx_activation_keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.ListHcxActivationKeys][google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]: crate::client::VmwareEngine::list_hcx_activation_keys
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHcxActivationKeysRequest {
    /// Required. The resource name of the private cloud
    /// to be queried for HCX activation keys.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of HCX activation keys to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListHcxActivationKeys` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListHcxActivationKeys` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHcxActivationKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListHcxActivationKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListHcxActivationKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHcxActivationKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHcxActivationKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListHcxActivationKeysRequest"
    }
}

/// Request message for [VmwareEngine.GetHcxActivationKeys][]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetHcxActivationKeyRequest {
    /// Required. The resource name of the HCX activation key to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/privateClouds/my-cloud/hcxActivationKeys/my-key`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetHcxActivationKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetHcxActivationKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetHcxActivationKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetHcxActivationKeyRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateHcxActivationKey][google.cloud.vmwareengine.v1.VmwareEngine.CreateHcxActivationKey]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateHcxActivationKey]: crate::client::VmwareEngine::create_hcx_activation_key
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateHcxActivationKeyRequest {
    /// Required. The resource name of the private cloud to create the key for.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The initial description of a new HCX activation key. When
    /// creating a new key, this field must be an empty object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hcx_activation_key: std::option::Option<crate::model::HcxActivationKey>,

    /// Required. The user-provided identifier of the `HcxActivationKey` to be
    /// created. This identifier must be unique among `HcxActivationKey` resources
    /// within the parent and becomes the final token in the name URI.
    /// The identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hcx_activation_key_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateHcxActivationKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateHcxActivationKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [hcx_activation_key][crate::model::CreateHcxActivationKeyRequest::hcx_activation_key].
    pub fn set_hcx_activation_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HcxActivationKey>,
    {
        self.hcx_activation_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hcx_activation_key][crate::model::CreateHcxActivationKeyRequest::hcx_activation_key].
    pub fn set_or_clear_hcx_activation_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HcxActivationKey>,
    {
        self.hcx_activation_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hcx_activation_key_id][crate::model::CreateHcxActivationKeyRequest::hcx_activation_key_id].
    pub fn set_hcx_activation_key_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.hcx_activation_key_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateHcxActivationKeyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateHcxActivationKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateHcxActivationKeyRequest"
    }
}

/// Request message for
/// [VmwareEngine.GetDnsForwarding][google.cloud.vmwareengine.v1.VmwareEngine.GetDnsForwarding]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetDnsForwarding]: crate::client::VmwareEngine::get_dns_forwarding
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDnsForwardingRequest {
    /// Required. The resource name of a `DnsForwarding` to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/dnsForwarding`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDnsForwardingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDnsForwardingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDnsForwardingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetDnsForwardingRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateDnsForwarding][google.cloud.vmwareengine.v1.VmwareEngine.UpdateDnsForwarding]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateDnsForwarding]: crate::client::VmwareEngine::update_dns_forwarding
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDnsForwardingRequest {
    /// Required. DnsForwarding config details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_forwarding: std::option::Option<crate::model::DnsForwarding>,

    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `DnsForwarding` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDnsForwardingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dns_forwarding][crate::model::UpdateDnsForwardingRequest::dns_forwarding].
    pub fn set_dns_forwarding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DnsForwarding>,
    {
        self.dns_forwarding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dns_forwarding][crate::model::UpdateDnsForwardingRequest::dns_forwarding].
    pub fn set_or_clear_dns_forwarding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DnsForwarding>,
    {
        self.dns_forwarding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDnsForwardingRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDnsForwardingRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDnsForwardingRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDnsForwardingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateDnsForwardingRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.CreateNetworkPeering]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateNetworkPeering]: crate::client::VmwareEngine::create_network_peering
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNetworkPeeringRequest {
    /// Required. The resource name of the location to create the new network
    /// peering in. This value is always `global`, because `NetworkPeering` is a
    /// global resource. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>. For
    /// example: `projects/my-project/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-provided identifier of the new `NetworkPeering`.
    /// This identifier must be unique among `NetworkPeering` resources within the
    /// parent and becomes the final token in the name URI.
    /// The identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_peering_id: std::string::String,

    /// Required. The initial description of the new network peering.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_peering: std::option::Option<crate::model::NetworkPeering>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNetworkPeeringRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNetworkPeeringRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [network_peering_id][crate::model::CreateNetworkPeeringRequest::network_peering_id].
    pub fn set_network_peering_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_peering_id = v.into();
        self
    }

    /// Sets the value of [network_peering][crate::model::CreateNetworkPeeringRequest::network_peering].
    pub fn set_network_peering<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPeering>,
    {
        self.network_peering = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_peering][crate::model::CreateNetworkPeeringRequest::network_peering].
    pub fn set_or_clear_network_peering<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPeering>,
    {
        self.network_peering = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateNetworkPeeringRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNetworkPeeringRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateNetworkPeeringRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.DeleteNetworkPeering]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteNetworkPeering]: crate::client::VmwareEngine::delete_network_peering
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNetworkPeeringRequest {
    /// Required. The resource name of the network peering to be deleted.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/global/networkPeerings/my-peering`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNetworkPeeringRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNetworkPeeringRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteNetworkPeeringRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNetworkPeeringRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteNetworkPeeringRequest"
    }
}

/// Request message for
/// [VmwareEngine.GetNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.GetNetworkPeering]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetNetworkPeering]: crate::client::VmwareEngine::get_network_peering
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNetworkPeeringRequest {
    /// Required. The resource name of the network peering to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/global/networkPeerings/my-peering`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNetworkPeeringRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNetworkPeeringRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNetworkPeeringRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetNetworkPeeringRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListNetworkPeerings][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPeerings]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPeerings]: crate::client::VmwareEngine::list_network_peerings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworkPeeringsRequest {
    /// Required. The resource name of the location (global) to query for
    /// network peerings. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>. For
    /// example: `projects/my-project/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of network peerings to return in one page.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListNetworkPeerings` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListNetworkPeerings` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of network peerings, you can
    /// exclude the ones named `example-peering` by specifying
    /// `name != "example-peering"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-peering")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-peering-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-peering-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkPeeringsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNetworkPeeringsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNetworkPeeringsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNetworkPeeringsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNetworkPeeringsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNetworkPeeringsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworkPeeringsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNetworkPeeringsRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.UpdateNetworkPeering]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateNetworkPeering]: crate::client::VmwareEngine::update_network_peering
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNetworkPeeringRequest {
    /// Required. Network peering description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_peering: std::option::Option<crate::model::NetworkPeering>,

    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `NetworkPeering` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNetworkPeeringRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_peering][crate::model::UpdateNetworkPeeringRequest::network_peering].
    pub fn set_network_peering<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPeering>,
    {
        self.network_peering = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_peering][crate::model::UpdateNetworkPeeringRequest::network_peering].
    pub fn set_or_clear_network_peering<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPeering>,
    {
        self.network_peering = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNetworkPeeringRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNetworkPeeringRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateNetworkPeeringRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNetworkPeeringRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateNetworkPeeringRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListNetworkPeerings][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPeerings]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPeerings]: crate::client::VmwareEngine::list_network_peerings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworkPeeringsResponse {
    /// A list of network peerings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_peerings: std::vec::Vec<crate::model::NetworkPeering>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkPeeringsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_peerings][crate::model::ListNetworkPeeringsResponse::network_peerings].
    pub fn set_network_peerings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkPeering>,
    {
        use std::iter::Iterator;
        self.network_peerings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNetworkPeeringsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNetworkPeeringsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworkPeeringsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNetworkPeeringsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNetworkPeeringsResponse {
    type PageItem = crate::model::NetworkPeering;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.network_peerings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.ListPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPeeringRoutes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPeeringRoutes]: crate::client::VmwareEngine::list_peering_routes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPeeringRoutesRequest {
    /// Required. The resource name of the network peering to retrieve peering
    /// routes from. Resource names are schemeless URIs that follow the conventions
    /// in <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/global/networkPeerings/my-peering`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of peering routes to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListPeeringRoutes` call.
    /// Provide this to retrieve the subsequent page.
    /// When paginating, all other parameters provided to `ListPeeringRoutes` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// Currently, only filtering on the `direction` field is supported. To return
    /// routes imported from the peer network, provide "direction=INCOMING". To
    /// return routes exported from the VMware Engine network, provide
    /// "direction=OUTGOING". Other filter expressions return an error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPeeringRoutesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPeeringRoutesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPeeringRoutesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPeeringRoutesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPeeringRoutesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPeeringRoutesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPeeringRoutesRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPeeringRoutes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPeeringRoutes]: crate::client::VmwareEngine::list_peering_routes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPeeringRoutesResponse {
    /// A list of peering routes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub peering_routes: std::vec::Vec<crate::model::PeeringRoute>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPeeringRoutesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [peering_routes][crate::model::ListPeeringRoutesResponse::peering_routes].
    pub fn set_peering_routes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PeeringRoute>,
    {
        use std::iter::Iterator;
        self.peering_routes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPeeringRoutesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPeeringRoutesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPeeringRoutesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPeeringRoutesResponse {
    type PageItem = crate::model::PeeringRoute;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.peering_routes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.ListNetworkPolicies][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPolicies]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPolicies]: crate::client::VmwareEngine::list_network_policies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworkPoliciesRequest {
    /// Required. The resource name of the location (region) to query for
    /// network policies. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>. For
    /// example: `projects/my-project/locations/us-central1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of network policies to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListNetworkPolicies` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListNetworkPolicies` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of network policies, you can
    /// exclude the ones named `example-policy` by specifying
    /// `name != "example-policy"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-policy")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-policy-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-policy-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNetworkPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNetworkPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNetworkPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNetworkPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNetworkPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworkPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNetworkPoliciesRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListNetworkPolicies][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPolicies]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPolicies]: crate::client::VmwareEngine::list_network_policies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworkPoliciesResponse {
    /// A list of network policies.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_policies: std::vec::Vec<crate::model::NetworkPolicy>,

    /// A token, which can be send as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_policies][crate::model::ListNetworkPoliciesResponse::network_policies].
    pub fn set_network_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkPolicy>,
    {
        use std::iter::Iterator;
        self.network_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNetworkPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNetworkPoliciesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworkPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListNetworkPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNetworkPoliciesResponse {
    type PageItem = crate::model::NetworkPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.network_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.GetNetworkPolicy]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetNetworkPolicy]: crate::client::VmwareEngine::get_network_policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNetworkPolicyRequest {
    /// Required. The resource name of the network policy to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-network-policy`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNetworkPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNetworkPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNetworkPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetNetworkPolicyRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.UpdateNetworkPolicy]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateNetworkPolicy]: crate::client::VmwareEngine::update_network_policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNetworkPolicyRequest {
    /// Required. Network policy description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_policy: std::option::Option<crate::model::NetworkPolicy>,

    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `NetworkPolicy` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNetworkPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_policy][crate::model::UpdateNetworkPolicyRequest::network_policy].
    pub fn set_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_policy][crate::model::UpdateNetworkPolicyRequest::network_policy].
    pub fn set_or_clear_network_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNetworkPolicyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNetworkPolicyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateNetworkPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNetworkPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateNetworkPolicyRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.CreateNetworkPolicy]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateNetworkPolicy]: crate::client::VmwareEngine::create_network_policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNetworkPolicyRequest {
    /// Required. The resource name of the location (region)
    /// to create the new network policy in.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-provided identifier of the network policy to be created.
    /// This identifier must be unique within parent
    /// `projects/{my-project}/locations/{us-central1}/networkPolicies` and becomes
    /// the final token in the name URI.
    /// The identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_policy_id: std::string::String,

    /// Required. The network policy configuration to use in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_policy: std::option::Option<crate::model::NetworkPolicy>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNetworkPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNetworkPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [network_policy_id][crate::model::CreateNetworkPolicyRequest::network_policy_id].
    pub fn set_network_policy_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_policy_id = v.into();
        self
    }

    /// Sets the value of [network_policy][crate::model::CreateNetworkPolicyRequest::network_policy].
    pub fn set_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_policy][crate::model::CreateNetworkPolicyRequest::network_policy].
    pub fn set_or_clear_network_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateNetworkPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNetworkPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateNetworkPolicyRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.DeleteNetworkPolicy]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteNetworkPolicy]: crate::client::VmwareEngine::delete_network_policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNetworkPolicyRequest {
    /// Required. The resource name of the network policy to delete.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-network-policy`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNetworkPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNetworkPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteNetworkPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNetworkPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteNetworkPolicyRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListManagementDnsZoneBindings][google.cloud.vmwareengine.v1.VmwareEngine.ListManagementDnsZoneBindings]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListManagementDnsZoneBindings]: crate::client::VmwareEngine::list_management_dns_zone_bindings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListManagementDnsZoneBindingsRequest {
    /// Required. The resource name of the private cloud to be queried for
    /// management DNS zone bindings.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of management DNS zone bindings to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListManagementDnsZoneBindings`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListManagementDnsZoneBindings` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of Management DNS Zone Bindings,
    /// you can exclude the ones named `example-management-dns-zone-binding` by
    /// specifying `name != "example-management-dns-zone-binding"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-management-dns-zone-binding")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-management-dns-zone-binding-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-management-dns-zone-binding-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListManagementDnsZoneBindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListManagementDnsZoneBindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListManagementDnsZoneBindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListManagementDnsZoneBindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListManagementDnsZoneBindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListManagementDnsZoneBindingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListManagementDnsZoneBindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListManagementDnsZoneBindingsRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListManagementDnsZoneBindings][google.cloud.vmwareengine.v1.VmwareEngine.ListManagementDnsZoneBindings]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListManagementDnsZoneBindings]: crate::client::VmwareEngine::list_management_dns_zone_bindings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListManagementDnsZoneBindingsResponse {
    /// A list of management DNS zone bindings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub management_dns_zone_bindings: std::vec::Vec<crate::model::ManagementDnsZoneBinding>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached when making an aggregated query using
    /// wildcards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListManagementDnsZoneBindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [management_dns_zone_bindings][crate::model::ListManagementDnsZoneBindingsResponse::management_dns_zone_bindings].
    pub fn set_management_dns_zone_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagementDnsZoneBinding>,
    {
        use std::iter::Iterator;
        self.management_dns_zone_bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListManagementDnsZoneBindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListManagementDnsZoneBindingsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListManagementDnsZoneBindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListManagementDnsZoneBindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListManagementDnsZoneBindingsResponse {
    type PageItem = crate::model::ManagementDnsZoneBinding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.management_dns_zone_bindings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GetManagementDnsZoneBinding][google.cloud.vmwareengine.v1.VmwareEngine.GetManagementDnsZoneBinding]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetManagementDnsZoneBinding]: crate::client::VmwareEngine::get_management_dns_zone_binding
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetManagementDnsZoneBindingRequest {
    /// Required. The resource name of the management DNS zone binding to
    /// retrieve. Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetManagementDnsZoneBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetManagementDnsZoneBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetManagementDnsZoneBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetManagementDnsZoneBindingRequest"
    }
}

/// Request message for [VmwareEngine.CreateManagementDnsZoneBindings][]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateManagementDnsZoneBindingRequest {
    /// Required. The resource name of the private cloud
    /// to create a new management DNS zone binding for.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The initial values for a new management DNS zone binding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management_dns_zone_binding: std::option::Option<crate::model::ManagementDnsZoneBinding>,

    /// Required. The user-provided identifier of the `ManagementDnsZoneBinding`
    /// resource to be created. This identifier must be unique among
    /// `ManagementDnsZoneBinding` resources within the parent and becomes the
    /// final token in the name URI. The identifier must meet the following
    /// requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub management_dns_zone_binding_id: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if the original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateManagementDnsZoneBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateManagementDnsZoneBindingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [management_dns_zone_binding][crate::model::CreateManagementDnsZoneBindingRequest::management_dns_zone_binding].
    pub fn set_management_dns_zone_binding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagementDnsZoneBinding>,
    {
        self.management_dns_zone_binding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management_dns_zone_binding][crate::model::CreateManagementDnsZoneBindingRequest::management_dns_zone_binding].
    pub fn set_or_clear_management_dns_zone_binding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagementDnsZoneBinding>,
    {
        self.management_dns_zone_binding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [management_dns_zone_binding_id][crate::model::CreateManagementDnsZoneBindingRequest::management_dns_zone_binding_id].
    pub fn set_management_dns_zone_binding_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.management_dns_zone_binding_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateManagementDnsZoneBindingRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateManagementDnsZoneBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateManagementDnsZoneBindingRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateManagementDnsZoneBinding][google.cloud.vmwareengine.v1.VmwareEngine.UpdateManagementDnsZoneBinding]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateManagementDnsZoneBinding]: crate::client::VmwareEngine::update_management_dns_zone_binding
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateManagementDnsZoneBindingRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `ManagementDnsZoneBinding` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. New values to update the management DNS zone binding with.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management_dns_zone_binding: std::option::Option<crate::model::ManagementDnsZoneBinding>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if the original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateManagementDnsZoneBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateManagementDnsZoneBindingRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateManagementDnsZoneBindingRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [management_dns_zone_binding][crate::model::UpdateManagementDnsZoneBindingRequest::management_dns_zone_binding].
    pub fn set_management_dns_zone_binding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagementDnsZoneBinding>,
    {
        self.management_dns_zone_binding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management_dns_zone_binding][crate::model::UpdateManagementDnsZoneBindingRequest::management_dns_zone_binding].
    pub fn set_or_clear_management_dns_zone_binding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagementDnsZoneBinding>,
    {
        self.management_dns_zone_binding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateManagementDnsZoneBindingRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateManagementDnsZoneBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateManagementDnsZoneBindingRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteManagementDnsZoneBinding][google.cloud.vmwareengine.v1.VmwareEngine.DeleteManagementDnsZoneBinding]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteManagementDnsZoneBinding]: crate::client::VmwareEngine::delete_management_dns_zone_binding
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteManagementDnsZoneBindingRequest {
    /// Required. The resource name of the management DNS zone binding to delete.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteManagementDnsZoneBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteManagementDnsZoneBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteManagementDnsZoneBindingRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteManagementDnsZoneBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteManagementDnsZoneBindingRequest"
    }
}

/// Request message for [VmwareEngine.RepairManagementDnsZoneBindings][]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepairManagementDnsZoneBindingRequest {
    /// Required. The resource name of the management DNS zone binding to repair.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if the original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairManagementDnsZoneBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RepairManagementDnsZoneBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RepairManagementDnsZoneBindingRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for RepairManagementDnsZoneBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.RepairManagementDnsZoneBindingRequest"
    }
}

/// Request message for
/// [VmwareEngine.CreateVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.CreateVmwareEngineNetwork]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateVmwareEngineNetwork]: crate::client::VmwareEngine::create_vmware_engine_network
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVmwareEngineNetworkRequest {
    /// Required. The resource name of the location to create the new VMware Engine
    /// network in. A VMware Engine network of type
    /// `LEGACY` is a regional resource, and a VMware
    /// Engine network of type `STANDARD` is a global resource.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-provided identifier of the new VMware Engine network.
    /// This identifier must be unique among VMware Engine network resources
    /// within the parent and becomes the final token in the name URI. The
    /// identifier must meet the following requirements:
    ///
    /// * For networks of type LEGACY, adheres to the format:
    ///   `{region-id}-default`. Replace `{region-id}` with the region where you want
    ///   to create the VMware Engine network. For example, "us-central1-default".
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network_id: std::string::String,

    /// Required. The initial description of the new VMware Engine network.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vmware_engine_network: std::option::Option<crate::model::VmwareEngineNetwork>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVmwareEngineNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVmwareEngineNetworkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network_id][crate::model::CreateVmwareEngineNetworkRequest::vmware_engine_network_id].
    pub fn set_vmware_engine_network_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network_id = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network][crate::model::CreateVmwareEngineNetworkRequest::vmware_engine_network].
    pub fn set_vmware_engine_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmwareEngineNetwork>,
    {
        self.vmware_engine_network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vmware_engine_network][crate::model::CreateVmwareEngineNetworkRequest::vmware_engine_network].
    pub fn set_or_clear_vmware_engine_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmwareEngineNetwork>,
    {
        self.vmware_engine_network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateVmwareEngineNetworkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVmwareEngineNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreateVmwareEngineNetworkRequest"
    }
}

/// Request message for
/// [VmwareEngine.UpdateVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.UpdateVmwareEngineNetwork]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdateVmwareEngineNetwork]: crate::client::VmwareEngine::update_vmware_engine_network
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVmwareEngineNetworkRequest {
    /// Required. VMware Engine network description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vmware_engine_network: std::option::Option<crate::model::VmwareEngineNetwork>,

    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// VMware Engine network resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten. Only the
    /// following fields can be updated: `description`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVmwareEngineNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vmware_engine_network][crate::model::UpdateVmwareEngineNetworkRequest::vmware_engine_network].
    pub fn set_vmware_engine_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmwareEngineNetwork>,
    {
        self.vmware_engine_network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vmware_engine_network][crate::model::UpdateVmwareEngineNetworkRequest::vmware_engine_network].
    pub fn set_or_clear_vmware_engine_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmwareEngineNetwork>,
    {
        self.vmware_engine_network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVmwareEngineNetworkRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVmwareEngineNetworkRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateVmwareEngineNetworkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateVmwareEngineNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdateVmwareEngineNetworkRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeleteVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.DeleteVmwareEngineNetwork]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeleteVmwareEngineNetwork]: crate::client::VmwareEngine::delete_vmware_engine_network
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVmwareEngineNetworkRequest {
    /// Required. The resource name of the VMware Engine network to be deleted.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/global/vmwareEngineNetworks/my-network`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Checksum used to ensure that the user-provided value is up to
    /// date before the server processes the request. The server compares provided
    /// checksum with the current checksum of the resource. If the user-provided
    /// value is out of date, this request returns an `ABORTED` error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVmwareEngineNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVmwareEngineNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteVmwareEngineNetworkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteVmwareEngineNetworkRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVmwareEngineNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeleteVmwareEngineNetworkRequest"
    }
}

/// Request message for
/// [VmwareEngine.GetVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.GetVmwareEngineNetwork]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetVmwareEngineNetwork]: crate::client::VmwareEngine::get_vmware_engine_network
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVmwareEngineNetworkRequest {
    /// Required. The resource name of the VMware Engine network to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/global/vmwareEngineNetworks/my-network`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVmwareEngineNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVmwareEngineNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVmwareEngineNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetVmwareEngineNetworkRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListVmwareEngineNetworks][google.cloud.vmwareengine.v1.VmwareEngine.ListVmwareEngineNetworks]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListVmwareEngineNetworks]: crate::client::VmwareEngine::list_vmware_engine_networks
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVmwareEngineNetworksRequest {
    /// Required. The resource name of the location to query for
    /// VMware Engine networks. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>. For
    /// example: `projects/my-project/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of results to return in one page.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListVmwareEngineNetworks` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListVmwareEngineNetworks` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of network peerings, you can
    /// exclude the ones named `example-network` by specifying
    /// `name != "example-network"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-network")
    /// (createTime > "2021-04-12T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-network-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-network-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVmwareEngineNetworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVmwareEngineNetworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVmwareEngineNetworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVmwareEngineNetworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVmwareEngineNetworksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVmwareEngineNetworksRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVmwareEngineNetworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListVmwareEngineNetworksRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListVmwareEngineNetworks][google.cloud.vmwareengine.v1.VmwareEngine.ListVmwareEngineNetworks]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListVmwareEngineNetworks]: crate::client::VmwareEngine::list_vmware_engine_networks
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVmwareEngineNetworksResponse {
    /// A list of VMware Engine networks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vmware_engine_networks: std::vec::Vec<crate::model::VmwareEngineNetwork>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVmwareEngineNetworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vmware_engine_networks][crate::model::ListVmwareEngineNetworksResponse::vmware_engine_networks].
    pub fn set_vmware_engine_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VmwareEngineNetwork>,
    {
        use std::iter::Iterator;
        self.vmware_engine_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVmwareEngineNetworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVmwareEngineNetworksResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVmwareEngineNetworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListVmwareEngineNetworksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVmwareEngineNetworksResponse {
    type PageItem = crate::model::VmwareEngineNetwork;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vmware_engine_networks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.CreatePrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.CreatePrivateConnection]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreatePrivateConnection]: crate::client::VmwareEngine::create_private_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePrivateConnectionRequest {
    /// Required. The resource name of the location to create the new private
    /// connection in. Private connection is a regional resource.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/us-central1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-provided identifier of the new private connection.
    /// This identifier must be unique among private connection resources
    /// within the parent and becomes the final token in the name URI. The
    /// identifier must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
    ///   (section 3.5)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_connection_id: std::string::String,

    /// Required. The initial description of the new private connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_connection: std::option::Option<crate::model::PrivateConnection>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePrivateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [private_connection_id][crate::model::CreatePrivateConnectionRequest::private_connection_id].
    pub fn set_private_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection_id = v.into();
        self
    }

    /// Sets the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_private_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_or_clear_private_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreatePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.CreatePrivateConnectionRequest"
    }
}

/// Request message for
/// [VmwareEngine.GetPrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.GetPrivateConnection]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetPrivateConnection]: crate::client::VmwareEngine::get_private_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPrivateConnectionRequest {
    /// Required. The resource name of the private connection to retrieve.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/privateConnections/my-connection`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetPrivateConnectionRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListPrivateConnections][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnections]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnections]: crate::client::VmwareEngine::list_private_connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsRequest {
    /// Required. The resource name of the location to query for
    /// private connections. Resource names are schemeless URIs that follow the
    /// conventions in <https://cloud.google.com/apis/design/resource_names>. For
    /// example: `projects/my-project/locations/us-central1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of private connections to return in one page.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListPrivateConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateConnections` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that matches resources returned in the response.
    /// The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value
    /// must be a string, a number, or a boolean. The comparison operator
    /// must be `=`, `!=`, `>`, or `<`.
    ///
    /// For example, if you are filtering a list of private connections, you can
    /// exclude the ones named `example-connection` by specifying
    /// `name != "example-connection"`.
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. For example:
    ///
    /// ```norust
    /// (name = "example-connection")
    /// (createTime > "2022-09-22T08:15:10.40Z")
    /// ```
    ///
    /// By default, each expression is an `AND` expression. However, you
    /// can include `AND` and `OR` expressions explicitly.
    /// For example:
    ///
    /// ```norust
    /// (name = "example-connection-1") AND
    /// (createTime > "2021-04-12T08:15:10.40Z") OR
    /// (name = "example-connection-2")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sorts list results by a certain order. By default, returned results
    /// are ordered by `name` in ascending order.
    /// You can also sort results in descending order based on the `name` value
    /// using `orderBy="name desc"`.
    /// Currently, only ordering by `name` is supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPrivateConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPrivateConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPrivateConnectionsRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListPrivateConnections][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnections]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnections]: crate::client::VmwareEngine::list_private_connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsResponse {
    /// A list of private connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub private_connections: std::vec::Vec<crate::model::PrivateConnection>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connections][crate::model::ListPrivateConnectionsResponse::private_connections].
    pub fn set_private_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PrivateConnection>,
    {
        use std::iter::Iterator;
        self.private_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPrivateConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPrivateConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPrivateConnectionsResponse {
    type PageItem = crate::model::PrivateConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.private_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.UpdatePrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.UpdatePrivateConnection]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.UpdatePrivateConnection]: crate::client::VmwareEngine::update_private_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePrivateConnectionRequest {
    /// Required. Private connection description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_connection: std::option::Option<crate::model::PrivateConnection>,

    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `PrivateConnection` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connection][crate::model::UpdatePrivateConnectionRequest::private_connection].
    pub fn set_private_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_connection][crate::model::UpdatePrivateConnectionRequest::private_connection].
    pub fn set_or_clear_private_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePrivateConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePrivateConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdatePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.UpdatePrivateConnectionRequest"
    }
}

/// Request message for
/// [VmwareEngine.DeletePrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.DeletePrivateConnection]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.DeletePrivateConnection]: crate::client::VmwareEngine::delete_private_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePrivateConnectionRequest {
    /// Required. The resource name of the private connection to be deleted.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/privateConnections/my-connection`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeletePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DeletePrivateConnectionRequest"
    }
}

/// Request message for
/// [VmwareEngine.ListPrivateConnectionPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnectionPeeringRoutes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnectionPeeringRoutes]: crate::client::VmwareEngine::list_private_connection_peering_routes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionPeeringRoutesRequest {
    /// Required. The resource name of the private connection to retrieve peering
    /// routes from. Resource names are schemeless URIs that follow the conventions
    /// in <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/us-west1/privateConnections/my-connection`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of peering routes to return in one page.
    /// The service may return fewer than this value.
    /// The maximum value is coerced to 1000.
    /// The default value of this field is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListPrivateConnectionPeeringRoutes`
    /// call. Provide this to retrieve the subsequent page. When paginating, all
    /// other parameters provided to `ListPrivateConnectionPeeringRoutes` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionPeeringRoutesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateConnectionPeeringRoutesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateConnectionPeeringRoutesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateConnectionPeeringRoutesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionPeeringRoutesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPrivateConnectionPeeringRoutesRequest"
    }
}

/// Response message for
/// [VmwareEngine.ListPrivateConnectionPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnectionPeeringRoutes]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnectionPeeringRoutes]: crate::client::VmwareEngine::list_private_connection_peering_routes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionPeeringRoutesResponse {
    /// A list of peering routes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub peering_routes: std::vec::Vec<crate::model::PeeringRoute>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionPeeringRoutesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [peering_routes][crate::model::ListPrivateConnectionPeeringRoutesResponse::peering_routes].
    pub fn set_peering_routes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PeeringRoute>,
    {
        use std::iter::Iterator;
        self.peering_routes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateConnectionPeeringRoutesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionPeeringRoutesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ListPrivateConnectionPeeringRoutesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPrivateConnectionPeeringRoutesResponse {
    type PageItem = crate::model::PeeringRoute;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.peering_routes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VmwareEngine.GrantDnsBindPermission][google.cloud.vmwareengine.v1.VmwareEngine.GrantDnsBindPermission]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GrantDnsBindPermission]: crate::client::VmwareEngine::grant_dns_bind_permission
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GrantDnsBindPermissionRequest {
    /// Required. The name of the resource which stores the users/service accounts
    /// having the permission to bind to the corresponding intranet VPC of the
    /// consumer project. DnsBindPermission is a global resource. Resource names
    /// are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/global/dnsBindPermission`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The consumer provided user/service account which needs to be
    /// granted permission to bind with the intranet VPC corresponding to the
    /// consumer project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub principal: std::option::Option<crate::model::Principal>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GrantDnsBindPermissionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GrantDnsBindPermissionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [principal][crate::model::GrantDnsBindPermissionRequest::principal].
    pub fn set_principal<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Principal>,
    {
        self.principal = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [principal][crate::model::GrantDnsBindPermissionRequest::principal].
    pub fn set_or_clear_principal<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Principal>,
    {
        self.principal = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::GrantDnsBindPermissionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for GrantDnsBindPermissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GrantDnsBindPermissionRequest"
    }
}

/// Request message for
/// [VmwareEngine.RevokeDnsBindPermission][google.cloud.vmwareengine.v1.VmwareEngine.RevokeDnsBindPermission]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.RevokeDnsBindPermission]: crate::client::VmwareEngine::revoke_dns_bind_permission
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevokeDnsBindPermissionRequest {
    /// Required. The name of the resource which stores the users/service accounts
    /// having the permission to bind to the corresponding intranet VPC of the
    /// consumer project. DnsBindPermission is a global resource. Resource names
    /// are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/global/dnsBindPermission`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The consumer provided user/service account which needs to be
    /// granted permission to bind with the intranet VPC corresponding to the
    /// consumer project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub principal: std::option::Option<crate::model::Principal>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server guarantees that a
    /// request doesn't result in creation of duplicate commitments for at least 60
    /// minutes.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevokeDnsBindPermissionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevokeDnsBindPermissionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [principal][crate::model::RevokeDnsBindPermissionRequest::principal].
    pub fn set_principal<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Principal>,
    {
        self.principal = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [principal][crate::model::RevokeDnsBindPermissionRequest::principal].
    pub fn set_or_clear_principal<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Principal>,
    {
        self.principal = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::RevokeDnsBindPermissionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for RevokeDnsBindPermissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.RevokeDnsBindPermissionRequest"
    }
}

/// Request message for
/// [VmwareEngine.GetDnsBindPermission][google.cloud.vmwareengine.v1.VmwareEngine.GetDnsBindPermission]
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.GetDnsBindPermission]: crate::client::VmwareEngine::get_dns_bind_permission
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDnsBindPermissionRequest {
    /// Required. The name of the resource which stores the users/service accounts
    /// having the permission to bind to the corresponding intranet VPC of the
    /// consumer project. DnsBindPermission is a global resource. Resource names
    /// are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/global/dnsBindPermission`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDnsBindPermissionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDnsBindPermissionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDnsBindPermissionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.GetDnsBindPermissionRequest"
    }
}

/// Network configuration in the consumer project
/// with which the peering has to be done.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Required. Management CIDR used by VMware management appliances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub management_cidr: std::string::String,

    /// Optional. The relative resource name of the VMware Engine network attached
    /// to the private cloud. Specify the name in the following form:
    /// `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
    /// where `{project}` can either be a project number or a project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network: std::string::String,

    /// Output only. The canonical name of the VMware Engine network in the form:
    /// `projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network_canonical: std::string::String,

    /// Output only. The IP address layout version of the management IP address
    /// range. Possible versions include:
    ///
    /// * `managementIpAddressLayoutVersion=1`: Indicates the legacy IP address
    ///   layout used by some existing private clouds. This is no longer supported
    ///   for new private clouds as it does not support all features.
    /// * `managementIpAddressLayoutVersion=2`: Indicates the latest IP address
    ///   layout used by all newly created private clouds. This version supports all
    ///   current features.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub management_ip_address_layout_version: i32,

    /// Output only. DNS Server IP of the Private Cloud.
    /// All DNS queries can be forwarded to this address for name resolution of
    /// Private Cloud's management entities like vCenter, NSX-T Manager and
    /// ESXi hosts.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dns_server_ip: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [management_cidr][crate::model::NetworkConfig::management_cidr].
    pub fn set_management_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.management_cidr = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network][crate::model::NetworkConfig::vmware_engine_network].
    pub fn set_vmware_engine_network<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network_canonical][crate::model::NetworkConfig::vmware_engine_network_canonical].
    pub fn set_vmware_engine_network_canonical<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network_canonical = v.into();
        self
    }

    /// Sets the value of [management_ip_address_layout_version][crate::model::NetworkConfig::management_ip_address_layout_version].
    pub fn set_management_ip_address_layout_version<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.management_ip_address_layout_version = v.into();
        self
    }

    /// Sets the value of [dns_server_ip][crate::model::NetworkConfig::dns_server_ip].
    pub fn set_dns_server_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_server_ip = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.NetworkConfig"
    }
}

/// Information about the type and number of nodes associated with the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeTypeConfig {
    /// Required. The number of nodes of this type in the cluster
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub node_count: i32,

    /// Optional. Customized number of cores available to each node of the type.
    /// This number must always be one of `nodeType.availableCustomCoreCounts`.
    /// If zero is provided max value from `nodeType.availableCustomCoreCounts`
    /// will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub custom_core_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_count][crate::model::NodeTypeConfig::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [custom_core_count][crate::model::NodeTypeConfig::custom_core_count].
    pub fn set_custom_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.custom_core_count = v.into();
        self
    }
}

impl wkt::message::Message for NodeTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.NodeTypeConfig"
    }
}

/// Configuration of a stretched cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StretchedClusterConfig {
    /// Required. Zone that will remain operational when connection between the two
    /// zones is lost. Specify the resource name of a zone that belongs to the
    /// region of the private cloud. For example:
    /// `projects/{project}/locations/europe-west3-a` where `{project}` can either
    /// be a project number or a project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub preferred_location: std::string::String,

    /// Required. Additional zone for a higher level of availability and load
    /// balancing. Specify the resource name of a zone that belongs to the region
    /// of the private cloud. For example:
    /// `projects/{project}/locations/europe-west3-b` where `{project}` can either
    /// be a project number or a project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StretchedClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preferred_location][crate::model::StretchedClusterConfig::preferred_location].
    pub fn set_preferred_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.preferred_location = v.into();
        self
    }

    /// Sets the value of [secondary_location][crate::model::StretchedClusterConfig::secondary_location].
    pub fn set_secondary_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_location = v.into();
        self
    }
}

impl wkt::message::Message for StretchedClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.StretchedClusterConfig"
    }
}

/// Represents a private cloud resource. Private clouds of type `STANDARD` and
/// `TIME_LIMITED` are zonal resources, `STRETCHED` private clouds are
/// regional.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateCloud {
    /// Output only. The resource name of this private cloud.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the resource was scheduled for deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the resource will be irreversibly deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the resource. New values may be added to this enum
    /// when appropriate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::private_cloud::State,

    /// Required. Network configuration of the private cloud.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::NetworkConfig>,

    /// Required. Input only. The management cluster for this private cloud.
    /// This field is required during creation of the private cloud to provide
    /// details for the default cluster.
    ///
    /// The following fields can't be changed after private cloud creation:
    /// `ManagementCluster.clusterId`, `ManagementCluster.nodeTypeId`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management_cluster: std::option::Option<crate::model::private_cloud::ManagementCluster>,

    /// User-provided description for this private cloud.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. HCX appliance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hcx: std::option::Option<crate::model::Hcx>,

    /// Output only. NSX appliance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nsx: std::option::Option<crate::model::Nsx>,

    /// Output only. Vcenter appliance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vcenter: std::option::Option<crate::model::Vcenter>,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. Type of the private cloud. Defaults to STANDARD.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::private_cloud::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateCloud {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PrivateCloud::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PrivateCloud::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PrivateCloud::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PrivateCloud::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PrivateCloud::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::PrivateCloud::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::PrivateCloud::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::PrivateCloud::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::PrivateCloud::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::PrivateCloud::state].
    pub fn set_state<T: std::convert::Into<crate::model::private_cloud::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::PrivateCloud::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::PrivateCloud::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [management_cluster][crate::model::PrivateCloud::management_cluster].
    pub fn set_management_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::private_cloud::ManagementCluster>,
    {
        self.management_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management_cluster][crate::model::PrivateCloud::management_cluster].
    pub fn set_or_clear_management_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::private_cloud::ManagementCluster>,
    {
        self.management_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::PrivateCloud::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [hcx][crate::model::PrivateCloud::hcx].
    pub fn set_hcx<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Hcx>,
    {
        self.hcx = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hcx][crate::model::PrivateCloud::hcx].
    pub fn set_or_clear_hcx<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Hcx>,
    {
        self.hcx = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nsx][crate::model::PrivateCloud::nsx].
    pub fn set_nsx<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Nsx>,
    {
        self.nsx = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nsx][crate::model::PrivateCloud::nsx].
    pub fn set_or_clear_nsx<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Nsx>,
    {
        self.nsx = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vcenter][crate::model::PrivateCloud::vcenter].
    pub fn set_vcenter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Vcenter>,
    {
        self.vcenter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vcenter][crate::model::PrivateCloud::vcenter].
    pub fn set_or_clear_vcenter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Vcenter>,
    {
        self.vcenter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uid][crate::model::PrivateCloud::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::PrivateCloud::type].
    pub fn set_type<T: std::convert::Into<crate::model::private_cloud::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for PrivateCloud {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.PrivateCloud"
    }
}

/// Defines additional types related to [PrivateCloud].
pub mod private_cloud {
    #[allow(unused_imports)]
    use super::*;

    /// Management cluster configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManagementCluster {
        /// Required. The user-provided identifier of the new `Cluster`.
        /// The identifier must meet the following requirements:
        ///
        /// * Only contains 1-63 alphanumeric characters and hyphens
        /// * Begins with an alphabetical character
        /// * Ends with a non-hyphen character
        /// * Not formatted as a UUID
        /// * Complies with [RFC
        ///   1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster_id: std::string::String,

        /// Required. The map of cluster node types in this cluster, where the key is
        /// canonical identifier of the node type (corresponds to the `NodeType`).
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub node_type_configs:
            std::collections::HashMap<std::string::String, crate::model::NodeTypeConfig>,

        /// Optional. Configuration of a stretched cluster. Required for STRETCHED
        /// private clouds.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub stretched_cluster_config: std::option::Option<crate::model::StretchedClusterConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManagementCluster {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cluster_id][crate::model::private_cloud::ManagementCluster::cluster_id].
        pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster_id = v.into();
            self
        }

        /// Sets the value of [node_type_configs][crate::model::private_cloud::ManagementCluster::node_type_configs].
        pub fn set_node_type_configs<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::NodeTypeConfig>,
        {
            use std::iter::Iterator;
            self.node_type_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [stretched_cluster_config][crate::model::private_cloud::ManagementCluster::stretched_cluster_config].
        pub fn set_stretched_cluster_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::StretchedClusterConfig>,
        {
            self.stretched_cluster_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [stretched_cluster_config][crate::model::private_cloud::ManagementCluster::stretched_cluster_config].
        pub fn set_or_clear_stretched_cluster_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::StretchedClusterConfig>,
        {
            self.stretched_cluster_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ManagementCluster {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmwareengine.v1.PrivateCloud.ManagementCluster"
        }
    }

    /// Enum State defines possible states of private clouds.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value should never be used.
        Unspecified,
        /// The private cloud is ready.
        Active,
        /// The private cloud is being created.
        Creating,
        /// The private cloud is being updated.
        Updating,
        /// The private cloud is in failed state.
        Failed,
        /// The private cloud is scheduled for deletion. The deletion process can be
        /// cancelled by using the corresponding undelete method.
        Deleted,
        /// The private cloud is irreversibly deleted and is being removed from the
        /// system.
        Purging,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(5),
                Self::Deleted => std::option::Option::Some(6),
                Self::Purging => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Purging => std::option::Option::Some("PURGING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Updating,
                5 => Self::Failed,
                6 => Self::Deleted,
                7 => Self::Purging,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "FAILED" => Self::Failed,
                "DELETED" => Self::Deleted,
                "PURGING" => Self::Purging,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(5),
                Self::Deleted => serializer.serialize_i32(6),
                Self::Purging => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.PrivateCloud.State",
            ))
        }
    }

    /// Enum Type defines private cloud type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Standard private is a zonal resource, with 3+ nodes. Default type.
        Standard,
        /// Time limited private cloud is a zonal resource, can have only 1 node and
        /// has limited life span. Will be deleted after defined period of time,
        /// can be converted into standard private cloud by expanding it up to 3
        /// or more nodes.
        TimeLimited,
        /// Stretched private cloud is a regional resource with redundancy,
        /// with a minimum of 6 nodes, nodes count has to be even.
        Stretched,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Standard => std::option::Option::Some(0),
                Self::TimeLimited => std::option::Option::Some(1),
                Self::Stretched => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::TimeLimited => std::option::Option::Some("TIME_LIMITED"),
                Self::Stretched => std::option::Option::Some("STRETCHED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Standard,
                1 => Self::TimeLimited,
                2 => Self::Stretched,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STANDARD" => Self::Standard,
                "TIME_LIMITED" => Self::TimeLimited,
                "STRETCHED" => Self::Stretched,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Standard => serializer.serialize_i32(0),
                Self::TimeLimited => serializer.serialize_i32(1),
                Self::Stretched => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmwareengine.v1.PrivateCloud.Type",
            ))
        }
    }
}

/// A cluster in a private cloud.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// Output only. The resource name of this cluster.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the resource.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::cluster::State,

    /// Output only. True if the cluster is a management cluster; false otherwise.
    /// There can only be one management cluster in a private cloud
    /// and it has to be the first one.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub management: bool,

    /// Optional. Configuration of the autoscaling applied to this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_settings: std::option::Option<crate::model::AutoscalingSettings>,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Required. The map of cluster node types in this cluster, where the key is
    /// canonical identifier of the node type (corresponds to the `NodeType`).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub node_type_configs:
        std::collections::HashMap<std::string::String, crate::model::NodeTypeConfig>,

    /// Optional. Configuration of a stretched cluster. Required for clusters that
    /// belong to a STRETCHED private cloud.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stretched_cluster_config: std::option::Option<crate::model::StretchedClusterConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [management][crate::model::Cluster::management].
    pub fn set_management<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.management = v.into();
        self
    }

    /// Sets the value of [autoscaling_settings][crate::model::Cluster::autoscaling_settings].
    pub fn set_autoscaling_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingSettings>,
    {
        self.autoscaling_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_settings][crate::model::Cluster::autoscaling_settings].
    pub fn set_or_clear_autoscaling_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingSettings>,
    {
        self.autoscaling_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uid][crate::model::Cluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [node_type_configs][crate::model::Cluster::node_type_configs].
    pub fn set_node_type_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::NodeTypeConfig>,
    {
        use std::iter::Iterator;
        self.node_type_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [stretched_cluster_config][crate::model::Cluster::stretched_cluster_config].
    pub fn set_stretched_cluster_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StretchedClusterConfig>,
    {
        self.stretched_cluster_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stretched_cluster_config][crate::model::Cluster::stretched_cluster_config].
    pub fn set_or_clear_stretched_cluster_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StretchedClusterConfig>,
    {
        self.stretched_cluster_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Cluster"
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Enum State defines possible states of private cloud clusters.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value should never be used.
        Unspecified,
        /// The Cluster is operational and can be used by the user.
        Active,
        /// The Cluster is being deployed.
        Creating,
        /// Adding or removing of a node to the cluster, any other cluster specific
        /// updates.
        Updating,
        /// The Cluster is being deleted.
        Deleting,
        /// The Cluster is undergoing maintenance, for example: a failed node is
        /// getting replaced.
        Repairing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Repairing => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Repairing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "REPAIRING" => Self::Repairing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Repairing => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.Cluster.State",
            ))
        }
    }
}

/// Node in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Node {
    /// Output only. The resource name of this node.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster/nodes/my-node
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Fully qualified domain name of the node.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    /// Output only. Internal IP address of the node.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// Output only. The canonical identifier of the node type (corresponds to the
    /// `NodeType`).
    /// For example: standard-72.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_type_id: std::string::String,

    /// Output only. The version number of the VMware ESXi
    /// management component in this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. Customized number of cores
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub custom_core_count: i64,

    /// Output only. The state of the appliance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::node::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Node {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Node::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Node::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::Node::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [node_type_id][crate::model::Node::node_type_id].
    pub fn set_node_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_type_id = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Node::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [custom_core_count][crate::model::Node::custom_core_count].
    pub fn set_custom_core_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.custom_core_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Node::state].
    pub fn set_state<T: std::convert::Into<crate::model::node::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Node {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Node"
    }
}

/// Defines additional types related to [Node].
pub mod node {
    #[allow(unused_imports)]
    use super::*;

    /// Enum State defines possible states of a node in a cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value should never be used.
        Unspecified,
        /// Node is operational and can be used by the user.
        Active,
        /// Node is being provisioned.
        Creating,
        /// Node is in a failed state.
        Failed,
        /// Node is undergoing maintenance, e.g.: during private cloud upgrade.
        Upgrading,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Upgrading => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Upgrading => std::option::Option::Some("UPGRADING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Failed,
                4 => Self::Upgrading,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "FAILED" => Self::Failed,
                "UPGRADING" => Self::Upgrading,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Upgrading => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.Node.State",
            ))
        }
    }
}

/// Represents an allocated external IP address and its corresponding internal IP
/// address in a private cloud.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalAddress {
    /// Output only. The resource name of this external IP address.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-address`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The internal IP address of a workload VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// Output only. The external IP address of a workload VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_ip: std::string::String,

    /// Output only. The state of the resource.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::external_address::State,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// User-provided description for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalAddress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExternalAddress::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ExternalAddress::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExternalAddress::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ExternalAddress::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ExternalAddress::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_ip][crate::model::ExternalAddress::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::ExternalAddress::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ExternalAddress::state].
    pub fn set_state<T: std::convert::Into<crate::model::external_address::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::ExternalAddress::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ExternalAddress::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for ExternalAddress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ExternalAddress"
    }
}

/// Defines additional types related to [ExternalAddress].
pub mod external_address {
    #[allow(unused_imports)]
    use super::*;

    /// Enum State defines possible states of external addresses.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value should never be used.
        Unspecified,
        /// The address is ready.
        Active,
        /// The address is being created.
        Creating,
        /// The address is being updated.
        Updating,
        /// The address is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Updating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.ExternalAddress.State",
            ))
        }
    }
}

/// Subnet in a private cloud. Either `management` subnets (such as vMotion) that
/// are read-only, or `userDefined`, which can also be updated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Subnet {
    /// Output only. The resource name of this subnet.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/subnets/my-subnet`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The IP address range of the subnet in CIDR format '10.0.0.0/24'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_cidr_range: std::string::String,

    /// The IP address of the gateway of this subnet.
    /// Must fall within the IP prefix defined above.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gateway_ip: std::string::String,

    /// Output only. The type of the subnet. For example "management" or
    /// "userDefined".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Output only. The state of the resource.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::subnet::State,

    /// Output only. VLAN ID of the VLAN on which the subnet is configured
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub vlan_id: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subnet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Subnet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_cidr_range][crate::model::Subnet::ip_cidr_range].
    pub fn set_ip_cidr_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_cidr_range = v.into();
        self
    }

    /// Sets the value of [gateway_ip][crate::model::Subnet::gateway_ip].
    pub fn set_gateway_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gateway_ip = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Subnet::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Subnet::state].
    pub fn set_state<T: std::convert::Into<crate::model::subnet::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [vlan_id][crate::model::Subnet::vlan_id].
    pub fn set_vlan_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vlan_id = v.into();
        self
    }
}

impl wkt::message::Message for Subnet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Subnet"
    }
}

/// Defines additional types related to [Subnet].
pub mod subnet {
    #[allow(unused_imports)]
    use super::*;

    /// Defines possible states of subnets.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value should never be used.
        Unspecified,
        /// The subnet is ready.
        Active,
        /// The subnet is being created.
        Creating,
        /// The subnet is being updated.
        Updating,
        /// The subnet is being deleted.
        Deleting,
        /// Changes requested in the last operation are being propagated.
        Reconciling,
        /// Last operation on the subnet did not succeed. Subnet's payload is
        /// reverted back to its most recent working state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Reconciling => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Reconciling,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "RECONCILING" => Self::Reconciling,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Reconciling => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.Subnet.State",
            ))
        }
    }
}

/// External access firewall rules for filtering incoming traffic destined to
/// `ExternalAddress` resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalAccessRule {
    /// Output only. The resource name of this external access rule.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-policy/externalAccessRules/my-rule`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-provided description for this external access rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// External access rule priority, which determines the external access rule to
    /// use when multiple rules apply. If multiple rules have the same priority,
    /// their ordering is non-deterministic. If specific ordering is required,
    /// assign unique priorities to enforce such ordering. The external access rule
    /// priority is an integer from 100 to 4096, both inclusive. Lower integers
    /// indicate higher precedence. For example, a rule with priority `100` has
    /// higher precedence than a rule with priority `101`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub priority: i32,

    /// The action that the external access rule performs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub action: crate::model::external_access_rule::Action,

    /// The IP protocol to which the external access rule applies. This value can
    /// be one of the following three protocol strings (not case-sensitive):
    /// `tcp`, `udp`, or `icmp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_protocol: std::string::String,

    /// If source ranges are specified, the external access rule applies only to
    /// traffic that has a source IP address in these ranges. These ranges can
    /// either be expressed in the CIDR format or as an IP address. As only inbound
    /// rules are supported, `ExternalAddress` resources cannot be the source IP
    /// addresses of an external access rule. To match all source addresses,
    /// specify `0.0.0.0/0`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_ip_ranges: std::vec::Vec<crate::model::external_access_rule::IpRange>,

    /// A list of source ports to which the external access rule applies. This
    /// field is only applicable for the UDP or TCP protocol.
    /// Each entry must be either an integer or a range. For example: `["22"]`,
    /// `["80","443"]`, or `["12345-12349"]`. To match all source ports, specify
    /// `["0-65535"]`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_ports: std::vec::Vec<std::string::String>,

    /// If destination ranges are specified, the external access rule applies only
    /// to the traffic that has a destination IP address in these ranges. The
    /// specified IP addresses must have reserved external IP addresses in the
    /// scope of the parent network policy. To match all external IP addresses in
    /// the scope of the parent network policy, specify `0.0.0.0/0`. To match a
    /// specific external IP address, specify it using the
    /// `IpRange.external_address` property.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub destination_ip_ranges: std::vec::Vec<crate::model::external_access_rule::IpRange>,

    /// A list of destination ports to which the external access rule applies. This
    /// field is only applicable for the UDP or TCP protocol.
    /// Each entry must be either an integer or a range. For example: `["22"]`,
    /// `["80","443"]`, or `["12345-12349"]`. To match all destination ports,
    /// specify `["0-65535"]`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub destination_ports: std::vec::Vec<std::string::String>,

    /// Output only. The state of the resource.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::external_access_rule::State,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalAccessRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExternalAccessRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ExternalAccessRule::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExternalAccessRule::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ExternalAccessRule::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ExternalAccessRule::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::ExternalAccessRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::ExternalAccessRule::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [action][crate::model::ExternalAccessRule::action].
    pub fn set_action<T: std::convert::Into<crate::model::external_access_rule::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [ip_protocol][crate::model::ExternalAccessRule::ip_protocol].
    pub fn set_ip_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_protocol = v.into();
        self
    }

    /// Sets the value of [source_ip_ranges][crate::model::ExternalAccessRule::source_ip_ranges].
    pub fn set_source_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::external_access_rule::IpRange>,
    {
        use std::iter::Iterator;
        self.source_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_ports][crate::model::ExternalAccessRule::source_ports].
    pub fn set_source_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination_ip_ranges][crate::model::ExternalAccessRule::destination_ip_ranges].
    pub fn set_destination_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::external_access_rule::IpRange>,
    {
        use std::iter::Iterator;
        self.destination_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination_ports][crate::model::ExternalAccessRule::destination_ports].
    pub fn set_destination_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.destination_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::ExternalAccessRule::state].
    pub fn set_state<T: std::convert::Into<crate::model::external_access_rule::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::ExternalAccessRule::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for ExternalAccessRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ExternalAccessRule"
    }
}

/// Defines additional types related to [ExternalAccessRule].
pub mod external_access_rule {
    #[allow(unused_imports)]
    use super::*;

    /// An IP range provided in any one of the supported formats.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IpRange {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub ip_range: std::option::Option<crate::model::external_access_rule::ip_range::IpRange>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IpRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip_range][crate::model::external_access_rule::IpRange::ip_range].
        ///
        /// Note that all the setters affecting `ip_range` are mutually
        /// exclusive.
        pub fn set_ip_range<
            T: std::convert::Into<
                    std::option::Option<crate::model::external_access_rule::ip_range::IpRange>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ip_range = v.into();
            self
        }

        /// The value of [ip_range][crate::model::external_access_rule::IpRange::ip_range]
        /// if it holds a `IpAddress`, `None` if the field is not set or
        /// holds a different branch.
        pub fn ip_address(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.ip_range.as_ref().and_then(|v| match v {
                crate::model::external_access_rule::ip_range::IpRange::IpAddress(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [ip_range][crate::model::external_access_rule::IpRange::ip_range]
        /// to hold a `IpAddress`.
        ///
        /// Note that all the setters affecting `ip_range` are
        /// mutually exclusive.
        pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip_range = std::option::Option::Some(
                crate::model::external_access_rule::ip_range::IpRange::IpAddress(v.into()),
            );
            self
        }

        /// The value of [ip_range][crate::model::external_access_rule::IpRange::ip_range]
        /// if it holds a `IpAddressRange`, `None` if the field is not set or
        /// holds a different branch.
        pub fn ip_address_range(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.ip_range.as_ref().and_then(|v| match v {
                crate::model::external_access_rule::ip_range::IpRange::IpAddressRange(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [ip_range][crate::model::external_access_rule::IpRange::ip_range]
        /// to hold a `IpAddressRange`.
        ///
        /// Note that all the setters affecting `ip_range` are
        /// mutually exclusive.
        pub fn set_ip_address_range<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ip_range = std::option::Option::Some(
                crate::model::external_access_rule::ip_range::IpRange::IpAddressRange(v.into()),
            );
            self
        }

        /// The value of [ip_range][crate::model::external_access_rule::IpRange::ip_range]
        /// if it holds a `ExternalAddress`, `None` if the field is not set or
        /// holds a different branch.
        pub fn external_address(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.ip_range.as_ref().and_then(|v| match v {
                crate::model::external_access_rule::ip_range::IpRange::ExternalAddress(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [ip_range][crate::model::external_access_rule::IpRange::ip_range]
        /// to hold a `ExternalAddress`.
        ///
        /// Note that all the setters affecting `ip_range` are
        /// mutually exclusive.
        pub fn set_external_address<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ip_range = std::option::Option::Some(
                crate::model::external_access_rule::ip_range::IpRange::ExternalAddress(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for IpRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmwareengine.v1.ExternalAccessRule.IpRange"
        }
    }

    /// Defines additional types related to [IpRange].
    pub mod ip_range {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum IpRange {
            /// A single IP address. For example: `10.0.0.5`.
            IpAddress(std::string::String),
            /// An IP address range in the CIDR format. For example: `10.0.0.0/24`.
            IpAddressRange(std::string::String),
            /// The name of an `ExternalAddress` resource. The external address must
            /// have been reserved in the scope of this external access rule's parent
            /// network policy.  Provide the external address name in the form of
            /// `projects/{project}/locations/{location}/privateClouds/{private_cloud}/externalAddresses/{external_address}`.
            /// For example:
            /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-address`.
            ExternalAddress(std::string::String),
        }
    }

    /// Action determines whether the external access rule permits or blocks
    /// traffic, subject to the other components of the rule matching the traffic.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Defaults to allow.
        Unspecified,
        /// Allows connections that match the other specified components.
        Allow,
        /// Blocks connections that match the other specified components.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.cloud.vmwareengine.v1.ExternalAccessRule.Action",
            ))
        }
    }

    /// Defines possible states of external access firewall rules.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// The rule is ready.
        Active,
        /// The rule is being created.
        Creating,
        /// The rule is being updated.
        Updating,
        /// The rule is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Updating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.ExternalAccessRule.State",
            ))
        }
    }
}

/// Logging server to receive vCenter or ESXi logs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingServer {
    /// Output only. The resource name of this logging server.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/loggingServers/my-logging-server`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. Fully-qualified domain name (FQDN) or IP Address of the logging
    /// server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Required. Port number at which the logging server receives logs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub port: i32,

    /// Required. Protocol used by vCenter to send logs to a logging server.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub protocol: crate::model::logging_server::Protocol,

    /// Required. The type of component that produces logs that will be forwarded
    /// to this logging server.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub source_type: crate::model::logging_server::SourceType,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingServer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LoggingServer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LoggingServer::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LoggingServer::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LoggingServer::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LoggingServer::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hostname][crate::model::LoggingServer::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [port][crate::model::LoggingServer::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::LoggingServer::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::logging_server::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::LoggingServer::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::logging_server::SourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::LoggingServer::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for LoggingServer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.LoggingServer"
    }
}

/// Defines additional types related to [LoggingServer].
pub mod logging_server {
    #[allow(unused_imports)]
    use super::*;

    /// Defines possible protocols used to send logs to
    /// a logging server.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Unspecified communications protocol. This is the default value.
        Unspecified,
        /// UDP
        Udp,
        /// TCP
        Tcp,
        /// TLS
        Tls,
        /// SSL
        Ssl,
        /// RELP
        Relp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Udp => std::option::Option::Some(1),
                Self::Tcp => std::option::Option::Some(2),
                Self::Tls => std::option::Option::Some(3),
                Self::Ssl => std::option::Option::Some(4),
                Self::Relp => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::Udp => std::option::Option::Some("UDP"),
                Self::Tcp => std::option::Option::Some("TCP"),
                Self::Tls => std::option::Option::Some("TLS"),
                Self::Ssl => std::option::Option::Some("SSL"),
                Self::Relp => std::option::Option::Some("RELP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Udp,
                2 => Self::Tcp,
                3 => Self::Tls,
                4 => Self::Ssl,
                5 => Self::Relp,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "UDP" => Self::Udp,
                "TCP" => Self::Tcp,
                "TLS" => Self::Tls,
                "SSL" => Self::Ssl,
                "RELP" => Self::Relp,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Udp => serializer.serialize_i32(1),
                Self::Tcp => serializer.serialize_i32(2),
                Self::Tls => serializer.serialize_i32(3),
                Self::Ssl => serializer.serialize_i32(4),
                Self::Relp => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.vmwareengine.v1.LoggingServer.Protocol",
            ))
        }
    }

    /// Defines possible types of component that produces logs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        /// The default value. This value should never be used.
        Unspecified,
        /// Logs produced by ESXI hosts
        Esxi,
        /// Logs produced by vCenter server
        Vcsa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Esxi => std::option::Option::Some(1),
                Self::Vcsa => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                Self::Esxi => std::option::Option::Some("ESXI"),
                Self::Vcsa => std::option::Option::Some("VCSA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Esxi,
                2 => Self::Vcsa,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ESXI" => Self::Esxi,
                "VCSA" => Self::Vcsa,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Esxi => serializer.serialize_i32(1),
                Self::Vcsa => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.vmwareengine.v1.LoggingServer.SourceType",
            ))
        }
    }
}

/// Describes node type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeType {
    /// Output only. The resource name of this node type.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-proj/locations/us-central1-a/nodeTypes/standard-72`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The canonical identifier of the node type
    /// (corresponds to the `NodeType`). For example: standard-72.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_type_id: std::string::String,

    /// Output only. The friendly name for this node type.
    /// For example: ve1-standard-72
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The total number of virtual CPUs in a single node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub virtual_cpu_count: i32,

    /// Output only. The total number of CPU cores in a single node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub total_core_count: i32,

    /// Output only. The amount of physical memory available, defined in GB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub memory_gb: i32,

    /// Output only. The amount of storage available, defined in GB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub disk_size_gb: i32,

    /// Output only. List of possible values of custom core count.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<wkt::internal::I32>")]
    pub available_custom_core_counts: std::vec::Vec<i32>,

    /// Output only. The type of the resource.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kind: crate::model::node_type::Kind,

    /// Output only. Families of the node type.
    /// For node types to be in the same cluster
    /// they must share at least one element in the `families`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub families: std::vec::Vec<std::string::String>,

    /// Output only. Capabilities of this node type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub capabilities: std::vec::Vec<crate::model::node_type::Capability>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodeType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [node_type_id][crate::model::NodeType::node_type_id].
    pub fn set_node_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_type_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NodeType::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [virtual_cpu_count][crate::model::NodeType::virtual_cpu_count].
    pub fn set_virtual_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.virtual_cpu_count = v.into();
        self
    }

    /// Sets the value of [total_core_count][crate::model::NodeType::total_core_count].
    pub fn set_total_core_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_core_count = v.into();
        self
    }

    /// Sets the value of [memory_gb][crate::model::NodeType::memory_gb].
    pub fn set_memory_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_gb = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::NodeType::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [available_custom_core_counts][crate::model::NodeType::available_custom_core_counts].
    pub fn set_available_custom_core_counts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.available_custom_core_counts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::NodeType::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::node_type::Kind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [families][crate::model::NodeType::families].
    pub fn set_families<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.families = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [capabilities][crate::model::NodeType::capabilities].
    pub fn set_capabilities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::node_type::Capability>,
    {
        use std::iter::Iterator;
        self.capabilities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NodeType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.NodeType"
    }
}

/// Defines additional types related to [NodeType].
pub mod node_type {
    #[allow(unused_imports)]
    use super::*;

    /// Enum Kind defines possible types of a NodeType.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// The default value. This value should never be used.
        Unspecified,
        /// Standard HCI node.
        Standard,
        /// Storage only Node.
        StorageOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::StorageOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KIND_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::StorageOnly => std::option::Option::Some("STORAGE_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::StorageOnly,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KIND_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "STORAGE_ONLY" => Self::StorageOnly,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::StorageOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".google.cloud.vmwareengine.v1.NodeType.Kind",
            ))
        }
    }

    /// Capability of a node type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Capability {
        /// The default value. This value is used if the capability is omitted or
        /// unknown.
        Unspecified,
        /// This node type supports stretch clusters.
        StretchedClusters,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Capability::value] or
        /// [Capability::name].
        UnknownValue(capability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod capability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Capability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StretchedClusters => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CAPABILITY_UNSPECIFIED"),
                Self::StretchedClusters => std::option::Option::Some("STRETCHED_CLUSTERS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Capability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Capability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Capability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StretchedClusters,
                _ => Self::UnknownValue(capability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Capability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CAPABILITY_UNSPECIFIED" => Self::Unspecified,
                "STRETCHED_CLUSTERS" => Self::StretchedClusters,
                _ => Self::UnknownValue(capability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Capability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StretchedClusters => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Capability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Capability>::new(
                ".google.cloud.vmwareengine.v1.NodeType.Capability",
            ))
        }
    }
}

/// Credentials for a private cloud.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Credentials {
    /// Initial username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Initial password.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Credentials {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::Credentials::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::Credentials::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for Credentials {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Credentials"
    }
}

/// HCX activation key. A default key is created during
/// private cloud provisioning, but this behavior is subject to change
/// and you should always verify active keys.
/// Use
/// [VmwareEngine.ListHcxActivationKeys][google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]
/// to retrieve existing keys and
/// [VmwareEngine.CreateHcxActivationKey][google.cloud.vmwareengine.v1.VmwareEngine.CreateHcxActivationKey]
/// to create new ones.
///
/// [google.cloud.vmwareengine.v1.VmwareEngine.CreateHcxActivationKey]: crate::client::VmwareEngine::create_hcx_activation_key
/// [google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]: crate::client::VmwareEngine::list_hcx_activation_keys
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HcxActivationKey {
    /// Output only. The resource name of this HcxActivationKey.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/privateClouds/my-cloud/hcxActivationKeys/my-key`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of HCX activation key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of HCX activation key.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::hcx_activation_key::State,

    /// Output only. HCX activation key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub activation_key: std::string::String,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HcxActivationKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HcxActivationKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::HcxActivationKey::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::HcxActivationKey::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::HcxActivationKey::state].
    pub fn set_state<T: std::convert::Into<crate::model::hcx_activation_key::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [activation_key][crate::model::HcxActivationKey::activation_key].
    pub fn set_activation_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.activation_key = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::HcxActivationKey::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for HcxActivationKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.HcxActivationKey"
    }
}

/// Defines additional types related to [HcxActivationKey].
pub mod hcx_activation_key {
    #[allow(unused_imports)]
    use super::*;

    /// State of HCX activation key
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// State of a newly generated activation key.
        Available,
        /// State of key when it has been used to activate HCX appliance.
        Consumed,
        /// State of key when it is being created.
        Creating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Available => std::option::Option::Some(1),
                Self::Consumed => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Consumed => std::option::Option::Some("CONSUMED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Available,
                2 => Self::Consumed,
                3 => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "AVAILABLE" => Self::Available,
                "CONSUMED" => Self::Consumed,
                "CREATING" => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Available => serializer.serialize_i32(1),
                Self::Consumed => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.HcxActivationKey.State",
            ))
        }
    }
}

/// Details about a HCX Cloud Manager appliance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Hcx {
    /// Internal IP address of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// Version of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The state of the appliance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::hcx::State,

    /// Fully qualified domain name of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Hcx {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [internal_ip][crate::model::Hcx::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Hcx::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Hcx::state].
    pub fn set_state<T: std::convert::Into<crate::model::hcx::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Hcx::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }
}

impl wkt::message::Message for Hcx {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Hcx"
    }
}

/// Defines additional types related to [Hcx].
pub mod hcx {
    #[allow(unused_imports)]
    use super::*;

    /// State of the appliance
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified appliance state. This is the default value.
        Unspecified,
        /// The appliance is operational and can be used.
        Active,
        /// The appliance is being deployed.
        Creating,
        /// The appliance is being activated.
        Activating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Activating => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Activating => std::option::Option::Some("ACTIVATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Activating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "ACTIVATING" => Self::Activating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Activating => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.Hcx.State",
            ))
        }
    }
}

/// Details about a NSX Manager appliance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Nsx {
    /// Internal IP address of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// Version of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The state of the appliance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::nsx::State,

    /// Fully qualified domain name of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Nsx {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [internal_ip][crate::model::Nsx::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Nsx::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Nsx::state].
    pub fn set_state<T: std::convert::Into<crate::model::nsx::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Nsx::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }
}

impl wkt::message::Message for Nsx {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Nsx"
    }
}

/// Defines additional types related to [Nsx].
pub mod nsx {
    #[allow(unused_imports)]
    use super::*;

    /// State of the appliance
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified appliance state. This is the default value.
        Unspecified,
        /// The appliance is operational and can be used.
        Active,
        /// The appliance is being deployed.
        Creating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.Nsx.State",
            ))
        }
    }
}

/// Details about a vCenter Server management appliance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Vcenter {
    /// Internal IP address of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// Version of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The state of the appliance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::vcenter::State,

    /// Fully qualified domain name of the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Vcenter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [internal_ip][crate::model::Vcenter::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Vcenter::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Vcenter::state].
    pub fn set_state<T: std::convert::Into<crate::model::vcenter::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Vcenter::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }
}

impl wkt::message::Message for Vcenter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Vcenter"
    }
}

/// Defines additional types related to [Vcenter].
pub mod vcenter {
    #[allow(unused_imports)]
    use super::*;

    /// State of the appliance
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified appliance state. This is the default value.
        Unspecified,
        /// The appliance is operational and can be used.
        Active,
        /// The appliance is being deployed.
        Creating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.Vcenter.State",
            ))
        }
    }
}

/// Autoscaling settings define the rules used by VMware Engine to
/// automatically scale-out and scale-in the clusters in a private cloud.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingSettings {
    /// Required. The map with autoscaling policies applied to the cluster.
    /// The key is the identifier of the policy.
    /// It must meet the following requirements:
    ///
    /// * Only contains 1-63 alphanumeric characters and hyphens
    /// * Begins with an alphabetical character
    /// * Ends with a non-hyphen character
    /// * Not formatted as a UUID
    /// * Complies with [RFC
    ///   1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
    ///
    /// Currently there map must contain only one element
    /// that describes the autoscaling policy for compute nodes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub autoscaling_policies: std::collections::HashMap<
        std::string::String,
        crate::model::autoscaling_settings::AutoscalingPolicy,
    >,

    /// Optional. Minimum number of nodes of any type in a cluster.
    /// If not specified the default limits apply.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub min_cluster_node_count: i32,

    /// Optional. Maximum number of nodes of any type in a cluster.
    /// If not specified the default limits apply.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_cluster_node_count: i32,

    /// Optional. The minimum duration between consecutive autoscale operations.
    /// It starts once addition or removal of nodes is fully completed.
    /// Defaults to 30 minutes if not specified. Cool down period must be in whole
    /// minutes (for example, 30, 31, 50, 180 minutes).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cool_down_period: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autoscaling_policies][crate::model::AutoscalingSettings::autoscaling_policies].
    pub fn set_autoscaling_policies<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::autoscaling_settings::AutoscalingPolicy>,
    {
        use std::iter::Iterator;
        self.autoscaling_policies = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [min_cluster_node_count][crate::model::AutoscalingSettings::min_cluster_node_count].
    pub fn set_min_cluster_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_cluster_node_count = v.into();
        self
    }

    /// Sets the value of [max_cluster_node_count][crate::model::AutoscalingSettings::max_cluster_node_count].
    pub fn set_max_cluster_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_cluster_node_count = v.into();
        self
    }

    /// Sets the value of [cool_down_period][crate::model::AutoscalingSettings::cool_down_period].
    pub fn set_cool_down_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cool_down_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cool_down_period][crate::model::AutoscalingSettings::cool_down_period].
    pub fn set_or_clear_cool_down_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cool_down_period = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoscalingSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.AutoscalingSettings"
    }
}

/// Defines additional types related to [AutoscalingSettings].
pub mod autoscaling_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Thresholds define the utilization of resources triggering
    /// scale-out and scale-in operations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Thresholds {
        /// Required. The utilization triggering the scale-out operation in percent.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub scale_out: i32,

        /// Required. The utilization triggering the scale-in operation in percent.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub scale_in: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Thresholds {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scale_out][crate::model::autoscaling_settings::Thresholds::scale_out].
        pub fn set_scale_out<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.scale_out = v.into();
            self
        }

        /// Sets the value of [scale_in][crate::model::autoscaling_settings::Thresholds::scale_in].
        pub fn set_scale_in<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.scale_in = v.into();
            self
        }
    }

    impl wkt::message::Message for Thresholds {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmwareengine.v1.AutoscalingSettings.Thresholds"
        }
    }

    /// Autoscaling policy describes the behavior of the autoscaling
    /// with respect to the resource utilization.
    /// The scale-out operation is initiated if the utilization
    /// exceeds ANY of the respective thresholds.
    /// The scale-in operation is initiated if the utilization
    /// is below ALL of the respective thresholds.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutoscalingPolicy {
        /// Required. The canonical identifier of the node type to add or remove.
        /// Corresponds to the `NodeType`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub node_type_id: std::string::String,

        /// Required. Number of nodes to add to a cluster during a scale-out
        /// operation. Must be divisible by 2 for stretched clusters. During a
        /// scale-in operation only one node (or 2 for stretched clusters) are
        /// removed in a single iteration.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub scale_out_size: i32,

        /// Optional. Utilization thresholds pertaining to CPU utilization.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub cpu_thresholds: std::option::Option<crate::model::autoscaling_settings::Thresholds>,

        /// Optional. Utilization thresholds pertaining to amount of granted memory.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub granted_memory_thresholds:
            std::option::Option<crate::model::autoscaling_settings::Thresholds>,

        /// Optional. Utilization thresholds pertaining to amount of consumed memory.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub consumed_memory_thresholds:
            std::option::Option<crate::model::autoscaling_settings::Thresholds>,

        /// Optional. Utilization thresholds pertaining to amount of consumed
        /// storage.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub storage_thresholds: std::option::Option<crate::model::autoscaling_settings::Thresholds>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoscalingPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node_type_id][crate::model::autoscaling_settings::AutoscalingPolicy::node_type_id].
        pub fn set_node_type_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.node_type_id = v.into();
            self
        }

        /// Sets the value of [scale_out_size][crate::model::autoscaling_settings::AutoscalingPolicy::scale_out_size].
        pub fn set_scale_out_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.scale_out_size = v.into();
            self
        }

        /// Sets the value of [cpu_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::cpu_thresholds].
        pub fn set_cpu_thresholds<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.cpu_thresholds = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cpu_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::cpu_thresholds].
        pub fn set_or_clear_cpu_thresholds<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.cpu_thresholds = v.map(|x| x.into());
            self
        }

        /// Sets the value of [granted_memory_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::granted_memory_thresholds].
        pub fn set_granted_memory_thresholds<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.granted_memory_thresholds = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [granted_memory_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::granted_memory_thresholds].
        pub fn set_or_clear_granted_memory_thresholds<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.granted_memory_thresholds = v.map(|x| x.into());
            self
        }

        /// Sets the value of [consumed_memory_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::consumed_memory_thresholds].
        pub fn set_consumed_memory_thresholds<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.consumed_memory_thresholds = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [consumed_memory_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::consumed_memory_thresholds].
        pub fn set_or_clear_consumed_memory_thresholds<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.consumed_memory_thresholds = v.map(|x| x.into());
            self
        }

        /// Sets the value of [storage_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::storage_thresholds].
        pub fn set_storage_thresholds<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.storage_thresholds = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [storage_thresholds][crate::model::autoscaling_settings::AutoscalingPolicy::storage_thresholds].
        pub fn set_or_clear_storage_thresholds<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::autoscaling_settings::Thresholds>,
        {
            self.storage_thresholds = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AutoscalingPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmwareengine.v1.AutoscalingSettings.AutoscalingPolicy"
        }
    }
}

/// DNS forwarding config.
/// This config defines a list of domain to name server mappings,
/// and is attached to the private cloud for custom domain resolution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DnsForwarding {
    /// Output only. The resource name of this DNS profile.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/dnsForwarding`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. List of domain mappings to configure
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub forwarding_rules: std::vec::Vec<crate::model::dns_forwarding::ForwardingRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DnsForwarding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DnsForwarding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DnsForwarding::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DnsForwarding::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DnsForwarding::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DnsForwarding::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [forwarding_rules][crate::model::DnsForwarding::forwarding_rules].
    pub fn set_forwarding_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dns_forwarding::ForwardingRule>,
    {
        use std::iter::Iterator;
        self.forwarding_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DnsForwarding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DnsForwarding"
    }
}

/// Defines additional types related to [DnsForwarding].
pub mod dns_forwarding {
    #[allow(unused_imports)]
    use super::*;

    /// A forwarding rule is a mapping of a `domain` to `name_servers`.
    /// This mapping allows VMware Engine to resolve domains for attached private
    /// clouds by forwarding DNS requests for a given domain to the specified
    /// nameservers.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ForwardingRule {
        /// Required. Domain used to resolve a `name_servers` list.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub domain: std::string::String,

        /// Required. List of DNS servers to use for domain resolution
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub name_servers: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ForwardingRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [domain][crate::model::dns_forwarding::ForwardingRule::domain].
        pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.domain = v.into();
            self
        }

        /// Sets the value of [name_servers][crate::model::dns_forwarding::ForwardingRule::name_servers].
        pub fn set_name_servers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.name_servers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ForwardingRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmwareengine.v1.DnsForwarding.ForwardingRule"
        }
    }
}

/// Details of a network peering.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkPeering {
    /// Output only. The resource name of the network peering. NetworkPeering is a
    /// global resource and location can only be global. Resource names are
    /// scheme-less URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/global/networkPeerings/my-peering`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The relative resource name of the network to peer with
    /// a standard VMware Engine network. The provided network can be a
    /// consumer VPC network or another standard VMware Engine network. If the
    /// `peer_network_type` is VMWARE_ENGINE_NETWORK, specify the name in the form:
    /// `projects/{project}/locations/global/vmwareEngineNetworks/{vmware_engine_network_id}`.
    /// Otherwise specify the name in the form:
    /// `projects/{project}/global/networks/{network_id}`, where
    /// `{project}` can either be a project number or a project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_network: std::string::String,

    /// Optional. True if custom routes are exported to the peered network;
    /// false otherwise. The default value is true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_custom_routes: std::option::Option<bool>,

    /// Optional. True if custom routes are imported from the peered network;
    /// false otherwise. The default value is true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_custom_routes: std::option::Option<bool>,

    /// Optional. True if full mesh connectivity is created and managed
    /// automatically between peered networks; false otherwise. Currently this
    /// field is always true because Google Compute Engine automatically creates
    /// and manages subnetwork routes between two VPC networks when peering state
    /// is 'ACTIVE'.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exchange_subnet_routes: std::option::Option<bool>,

    /// Optional. True if all subnet routes with a public IP address range are
    /// exported; false otherwise. The default value is true. IPv4 special-use
    /// ranges (<https://en.wikipedia.org/wiki/IPv4#Special_addresses>) are always
    /// exported to peers and are not controlled by this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_custom_routes_with_public_ip: std::option::Option<bool>,

    /// Optional. True if all subnet routes with public IP address range are
    /// imported; false otherwise. The default value is true. IPv4 special-use
    /// ranges (<https://en.wikipedia.org/wiki/IPv4#Special_addresses>) are always
    /// imported to peers and are not controlled by this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_custom_routes_with_public_ip: std::option::Option<bool>,

    /// Output only. State of the network peering. This field
    /// has a value of 'ACTIVE' when there's a matching configuration in the peer
    /// network. New values may be added to this enum when appropriate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::network_peering::State,

    /// Output only. Output Only. Details about the current state of the network
    /// peering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    /// Optional. Maximum transmission unit (MTU) in bytes.
    /// The default value is `1500`. If a value of `0` is provided for this field,
    /// VMware Engine uses the default value instead.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub peer_mtu: i32,

    /// Required. The type of the network to peer with the VMware Engine network.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub peer_network_type: crate::model::network_peering::PeerNetworkType,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Required. The relative resource name of the VMware Engine network.
    /// Specify the name in the following form:
    /// `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
    /// where `{project}` can either be a project number or a project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network: std::string::String,

    /// Optional. User-provided description for this network peering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPeering {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NetworkPeering::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NetworkPeering::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::NetworkPeering::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::NetworkPeering::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::NetworkPeering::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [peer_network][crate::model::NetworkPeering::peer_network].
    pub fn set_peer_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_network = v.into();
        self
    }

    /// Sets the value of [export_custom_routes][crate::model::NetworkPeering::export_custom_routes].
    pub fn set_export_custom_routes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.export_custom_routes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [export_custom_routes][crate::model::NetworkPeering::export_custom_routes].
    pub fn set_or_clear_export_custom_routes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.export_custom_routes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_custom_routes][crate::model::NetworkPeering::import_custom_routes].
    pub fn set_import_custom_routes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.import_custom_routes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_custom_routes][crate::model::NetworkPeering::import_custom_routes].
    pub fn set_or_clear_import_custom_routes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.import_custom_routes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exchange_subnet_routes][crate::model::NetworkPeering::exchange_subnet_routes].
    pub fn set_exchange_subnet_routes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.exchange_subnet_routes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exchange_subnet_routes][crate::model::NetworkPeering::exchange_subnet_routes].
    pub fn set_or_clear_exchange_subnet_routes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.exchange_subnet_routes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [export_custom_routes_with_public_ip][crate::model::NetworkPeering::export_custom_routes_with_public_ip].
    pub fn set_export_custom_routes_with_public_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.export_custom_routes_with_public_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [export_custom_routes_with_public_ip][crate::model::NetworkPeering::export_custom_routes_with_public_ip].
    pub fn set_or_clear_export_custom_routes_with_public_ip<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.export_custom_routes_with_public_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_custom_routes_with_public_ip][crate::model::NetworkPeering::import_custom_routes_with_public_ip].
    pub fn set_import_custom_routes_with_public_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.import_custom_routes_with_public_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_custom_routes_with_public_ip][crate::model::NetworkPeering::import_custom_routes_with_public_ip].
    pub fn set_or_clear_import_custom_routes_with_public_ip<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.import_custom_routes_with_public_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::NetworkPeering::state].
    pub fn set_state<T: std::convert::Into<crate::model::network_peering::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::NetworkPeering::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [peer_mtu][crate::model::NetworkPeering::peer_mtu].
    pub fn set_peer_mtu<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.peer_mtu = v.into();
        self
    }

    /// Sets the value of [peer_network_type][crate::model::NetworkPeering::peer_network_type].
    pub fn set_peer_network_type<
        T: std::convert::Into<crate::model::network_peering::PeerNetworkType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.peer_network_type = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::NetworkPeering::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network][crate::model::NetworkPeering::vmware_engine_network].
    pub fn set_vmware_engine_network<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NetworkPeering::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for NetworkPeering {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.NetworkPeering"
    }
}

/// Defines additional types related to [NetworkPeering].
pub mod network_peering {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a network peering.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified network peering state. This is the default value.
        Unspecified,
        /// The peering is not active.
        Inactive,
        /// The peering is active.
        Active,
        /// The peering is being created.
        Creating,
        /// The peering is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inactive => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inactive,
                2 => Self::Active,
                3 => Self::Creating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INACTIVE" => Self::Inactive,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inactive => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.NetworkPeering.State",
            ))
        }
    }

    /// Type or purpose of the network peering connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PeerNetworkType {
        /// Unspecified
        Unspecified,
        /// Peering connection used for connecting to another VPC network established
        /// by the same user. For example, a peering connection to another VPC
        /// network in the same project or to an on-premises network.
        Standard,
        /// Peering connection used for connecting to another VMware Engine network.
        VmwareEngineNetwork,
        /// Peering connection used for establishing [private services
        /// access](https://cloud.google.com/vpc/docs/private-services-access).
        PrivateServicesAccess,
        /// Peering connection used for connecting to NetApp Cloud Volumes.
        NetappCloudVolumes,
        /// Peering connection used for connecting to third-party services. Most
        /// third-party services require manual setup of reverse peering on the VPC
        /// network associated with the third-party service.
        ThirdPartyService,
        /// Peering connection used for connecting to Dell PowerScale Filers
        DellPowerscale,
        /// Peering connection used for connecting to Google Cloud NetApp Volumes.
        GoogleCloudNetappVolumes,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PeerNetworkType::value] or
        /// [PeerNetworkType::name].
        UnknownValue(peer_network_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod peer_network_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PeerNetworkType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::VmwareEngineNetwork => std::option::Option::Some(2),
                Self::PrivateServicesAccess => std::option::Option::Some(3),
                Self::NetappCloudVolumes => std::option::Option::Some(4),
                Self::ThirdPartyService => std::option::Option::Some(5),
                Self::DellPowerscale => std::option::Option::Some(6),
                Self::GoogleCloudNetappVolumes => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PEER_NETWORK_TYPE_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::VmwareEngineNetwork => std::option::Option::Some("VMWARE_ENGINE_NETWORK"),
                Self::PrivateServicesAccess => std::option::Option::Some("PRIVATE_SERVICES_ACCESS"),
                Self::NetappCloudVolumes => std::option::Option::Some("NETAPP_CLOUD_VOLUMES"),
                Self::ThirdPartyService => std::option::Option::Some("THIRD_PARTY_SERVICE"),
                Self::DellPowerscale => std::option::Option::Some("DELL_POWERSCALE"),
                Self::GoogleCloudNetappVolumes => {
                    std::option::Option::Some("GOOGLE_CLOUD_NETAPP_VOLUMES")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PeerNetworkType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PeerNetworkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PeerNetworkType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::VmwareEngineNetwork,
                3 => Self::PrivateServicesAccess,
                4 => Self::NetappCloudVolumes,
                5 => Self::ThirdPartyService,
                6 => Self::DellPowerscale,
                7 => Self::GoogleCloudNetappVolumes,
                _ => Self::UnknownValue(peer_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PeerNetworkType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PEER_NETWORK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "VMWARE_ENGINE_NETWORK" => Self::VmwareEngineNetwork,
                "PRIVATE_SERVICES_ACCESS" => Self::PrivateServicesAccess,
                "NETAPP_CLOUD_VOLUMES" => Self::NetappCloudVolumes,
                "THIRD_PARTY_SERVICE" => Self::ThirdPartyService,
                "DELL_POWERSCALE" => Self::DellPowerscale,
                "GOOGLE_CLOUD_NETAPP_VOLUMES" => Self::GoogleCloudNetappVolumes,
                _ => Self::UnknownValue(peer_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PeerNetworkType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::VmwareEngineNetwork => serializer.serialize_i32(2),
                Self::PrivateServicesAccess => serializer.serialize_i32(3),
                Self::NetappCloudVolumes => serializer.serialize_i32(4),
                Self::ThirdPartyService => serializer.serialize_i32(5),
                Self::DellPowerscale => serializer.serialize_i32(6),
                Self::GoogleCloudNetappVolumes => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PeerNetworkType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PeerNetworkType>::new(
                ".google.cloud.vmwareengine.v1.NetworkPeering.PeerNetworkType",
            ))
        }
    }
}

/// Exchanged network peering route.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PeeringRoute {
    /// Output only. Destination range of the peering route in CIDR notation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dest_range: std::string::String,

    /// Output only. Type of the route in the peer VPC network.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::peering_route::Type,

    /// Output only. Region containing the next hop of the peering route. This
    /// field only applies to dynamic routes in the peer VPC network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_hop_region: std::string::String,

    /// Output only. The priority of the peering route.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub priority: i64,

    /// Output only. True if the peering route has been imported from a peered
    /// VPC network; false otherwise. The import happens if the field
    /// `NetworkPeering.importCustomRoutes` is true for this network,
    /// `NetworkPeering.exportCustomRoutes` is true for the peer VPC network, and
    /// the import does not result in a route conflict.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub imported: bool,

    /// Output only. Direction of the routes exchanged with the peer network, from
    /// the VMware Engine network perspective:
    ///
    /// * Routes of direction `INCOMING` are imported from the peer network.
    /// * Routes of direction `OUTGOING` are exported from the intranet VPC network
    ///   of the VMware Engine network.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub direction: crate::model::peering_route::Direction,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PeeringRoute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dest_range][crate::model::PeeringRoute::dest_range].
    pub fn set_dest_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dest_range = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::PeeringRoute::type].
    pub fn set_type<T: std::convert::Into<crate::model::peering_route::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [next_hop_region][crate::model::PeeringRoute::next_hop_region].
    pub fn set_next_hop_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_hop_region = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::PeeringRoute::priority].
    pub fn set_priority<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [imported][crate::model::PeeringRoute::imported].
    pub fn set_imported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.imported = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::PeeringRoute::direction].
    pub fn set_direction<T: std::convert::Into<crate::model::peering_route::Direction>>(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }
}

impl wkt::message::Message for PeeringRoute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.PeeringRoute"
    }
}

/// Defines additional types related to [PeeringRoute].
pub mod peering_route {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the peering route.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified peering route type. This is the default value.
        Unspecified,
        /// Dynamic routes in the peer network.
        DynamicPeeringRoute,
        /// Static routes in the peer network.
        StaticPeeringRoute,
        /// Created, updated, and removed automatically by Google Cloud when subnets
        /// are created, modified, or deleted in the peer network.
        SubnetPeeringRoute,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DynamicPeeringRoute => std::option::Option::Some(1),
                Self::StaticPeeringRoute => std::option::Option::Some(2),
                Self::SubnetPeeringRoute => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::DynamicPeeringRoute => std::option::Option::Some("DYNAMIC_PEERING_ROUTE"),
                Self::StaticPeeringRoute => std::option::Option::Some("STATIC_PEERING_ROUTE"),
                Self::SubnetPeeringRoute => std::option::Option::Some("SUBNET_PEERING_ROUTE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DynamicPeeringRoute,
                2 => Self::StaticPeeringRoute,
                3 => Self::SubnetPeeringRoute,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "DYNAMIC_PEERING_ROUTE" => Self::DynamicPeeringRoute,
                "STATIC_PEERING_ROUTE" => Self::StaticPeeringRoute,
                "SUBNET_PEERING_ROUTE" => Self::SubnetPeeringRoute,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DynamicPeeringRoute => serializer.serialize_i32(1),
                Self::StaticPeeringRoute => serializer.serialize_i32(2),
                Self::SubnetPeeringRoute => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmwareengine.v1.PeeringRoute.Type",
            ))
        }
    }

    /// The direction of the exchanged routes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Unspecified exchanged routes direction. This is default.
        Unspecified,
        /// Routes imported from the peer network.
        Incoming,
        /// Routes exported to the peer network.
        Outgoing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incoming => std::option::Option::Some(1),
                Self::Outgoing => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Incoming => std::option::Option::Some("INCOMING"),
                Self::Outgoing => std::option::Option::Some("OUTGOING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incoming,
                2 => Self::Outgoing,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "INCOMING" => Self::Incoming,
                "OUTGOING" => Self::Outgoing,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incoming => serializer.serialize_i32(1),
                Self::Outgoing => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.cloud.vmwareengine.v1.PeeringRoute.Direction",
            ))
        }
    }
}

/// Represents a network policy resource. Network policies are regional
/// resources. You can use a network policy to enable or disable internet access
/// and external IP access. Network policies are associated with a VMware Engine
/// network, which might span across regions. For a given region, a network
/// policy applies to all private clouds in the VMware Engine network associated
/// with the policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkPolicy {
    /// Output only. The resource name of this network policy.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/networkPolicies/my-network-policy`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Network service that allows VMware workloads to access the internet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub internet_access: std::option::Option<crate::model::network_policy::NetworkService>,

    /// Network service that allows External IP addresses to be assigned to VMware
    /// workloads. This service can only be enabled when `internet_access` is also
    /// enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_ip: std::option::Option<crate::model::network_policy::NetworkService>,

    /// Required. IP address range in CIDR notation used to create internet access
    /// and external IP access. An RFC 1918 CIDR block, with a "/26" prefix, is
    /// required. The range cannot overlap with any prefixes either in the consumer
    /// VPC network or in use by the private clouds attached to that VPC network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub edge_services_cidr: std::string::String,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. The relative resource name of the VMware Engine network.
    /// Specify the name in the following form:
    /// `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
    /// where `{project}` can either be a project number or a project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network: std::string::String,

    /// Optional. User-provided description for this network policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The canonical name of the VMware Engine network in the form:
    /// `projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network_canonical: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NetworkPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NetworkPolicy::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::NetworkPolicy::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::NetworkPolicy::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::NetworkPolicy::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internet_access][crate::model::NetworkPolicy::internet_access].
    pub fn set_internet_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_policy::NetworkService>,
    {
        self.internet_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internet_access][crate::model::NetworkPolicy::internet_access].
    pub fn set_or_clear_internet_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_policy::NetworkService>,
    {
        self.internet_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_ip][crate::model::NetworkPolicy::external_ip].
    pub fn set_external_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_policy::NetworkService>,
    {
        self.external_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ip][crate::model::NetworkPolicy::external_ip].
    pub fn set_or_clear_external_ip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_policy::NetworkService>,
    {
        self.external_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [edge_services_cidr][crate::model::NetworkPolicy::edge_services_cidr].
    pub fn set_edge_services_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.edge_services_cidr = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::NetworkPolicy::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network][crate::model::NetworkPolicy::vmware_engine_network].
    pub fn set_vmware_engine_network<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NetworkPolicy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network_canonical][crate::model::NetworkPolicy::vmware_engine_network_canonical].
    pub fn set_vmware_engine_network_canonical<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network_canonical = v.into();
        self
    }
}

impl wkt::message::Message for NetworkPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.NetworkPolicy"
    }
}

/// Defines additional types related to [NetworkPolicy].
pub mod network_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a network service that is managed by a `NetworkPolicy` resource.
    /// A network service provides a way to control an aspect of external access to
    /// VMware workloads. For example, whether the VMware workloads in the
    /// private clouds governed by a network policy can access or be accessed from
    /// the internet.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NetworkService {
        /// True if the service is enabled; false otherwise.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        /// Output only. State of the service. New values may be added to this enum
        /// when appropriate.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub state: crate::model::network_policy::network_service::State,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkService {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::network_policy::NetworkService::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [state][crate::model::network_policy::NetworkService::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::network_policy::network_service::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmwareengine.v1.NetworkPolicy.NetworkService"
        }
    }

    /// Defines additional types related to [NetworkService].
    pub mod network_service {
        #[allow(unused_imports)]
        use super::*;

        /// Enum State defines possible states of a network policy controlled
        /// service.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unspecified service state. This is the default value.
            Unspecified,
            /// Service is not provisioned.
            Unprovisioned,
            /// Service is in the process of being provisioned/deprovisioned.
            Reconciling,
            /// Service is active.
            Active,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Unprovisioned => std::option::Option::Some(1),
                    Self::Reconciling => std::option::Option::Some(2),
                    Self::Active => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Unprovisioned => std::option::Option::Some("UNPROVISIONED"),
                    Self::Reconciling => std::option::Option::Some("RECONCILING"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Unprovisioned,
                    2 => Self::Reconciling,
                    3 => Self::Active,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "UNPROVISIONED" => Self::Unprovisioned,
                    "RECONCILING" => Self::Reconciling,
                    "ACTIVE" => Self::Active,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Unprovisioned => serializer.serialize_i32(1),
                    Self::Reconciling => serializer.serialize_i32(2),
                    Self::Active => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.vmwareengine.v1.NetworkPolicy.NetworkService.State",
                ))
            }
        }
    }
}

/// Represents a binding between a network and the management DNS zone.
/// A management DNS zone is the Cloud DNS cross-project binding zone that
/// VMware Engine creates for each private cloud. It contains FQDNs and
/// corresponding IP addresses for the private cloud's ESXi hosts and management
/// VM appliances like vCenter and NSX Manager.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagementDnsZoneBinding {
    /// Output only. The resource name of this binding.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the resource.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::management_dns_zone_binding::State,

    /// User-provided description for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Required. The relative resource name of the network to bind to the
    /// management DNS zone. This network can be a consumer VPC network or a
    /// VMware engine network.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub bind_network: std::option::Option<crate::model::management_dns_zone_binding::BindNetwork>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagementDnsZoneBinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ManagementDnsZoneBinding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ManagementDnsZoneBinding::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ManagementDnsZoneBinding::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ManagementDnsZoneBinding::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ManagementDnsZoneBinding::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ManagementDnsZoneBinding::state].
    pub fn set_state<T: std::convert::Into<crate::model::management_dns_zone_binding::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ManagementDnsZoneBinding::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::ManagementDnsZoneBinding::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [bind_network][crate::model::ManagementDnsZoneBinding::bind_network].
    ///
    /// Note that all the setters affecting `bind_network` are mutually
    /// exclusive.
    pub fn set_bind_network<
        T: std::convert::Into<
                std::option::Option<crate::model::management_dns_zone_binding::BindNetwork>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bind_network = v.into();
        self
    }

    /// The value of [bind_network][crate::model::ManagementDnsZoneBinding::bind_network]
    /// if it holds a `VpcNetwork`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpc_network(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.bind_network.as_ref().and_then(|v| match v {
            crate::model::management_dns_zone_binding::BindNetwork::VpcNetwork(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [bind_network][crate::model::ManagementDnsZoneBinding::bind_network]
    /// to hold a `VpcNetwork`.
    ///
    /// Note that all the setters affecting `bind_network` are
    /// mutually exclusive.
    pub fn set_vpc_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bind_network = std::option::Option::Some(
            crate::model::management_dns_zone_binding::BindNetwork::VpcNetwork(v.into()),
        );
        self
    }

    /// The value of [bind_network][crate::model::ManagementDnsZoneBinding::bind_network]
    /// if it holds a `VmwareEngineNetwork`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_engine_network(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.bind_network.as_ref().and_then(|v| match v {
            crate::model::management_dns_zone_binding::BindNetwork::VmwareEngineNetwork(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [bind_network][crate::model::ManagementDnsZoneBinding::bind_network]
    /// to hold a `VmwareEngineNetwork`.
    ///
    /// Note that all the setters affecting `bind_network` are
    /// mutually exclusive.
    pub fn set_vmware_engine_network<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bind_network = std::option::Option::Some(
            crate::model::management_dns_zone_binding::BindNetwork::VmwareEngineNetwork(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ManagementDnsZoneBinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.ManagementDnsZoneBinding"
    }
}

/// Defines additional types related to [ManagementDnsZoneBinding].
pub mod management_dns_zone_binding {
    #[allow(unused_imports)]
    use super::*;

    /// Enum State defines possible states of binding between the consumer VPC
    /// network and the management DNS zone.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value should never be used.
        Unspecified,
        /// The binding is ready.
        Active,
        /// The binding is being created.
        Creating,
        /// The binding is being updated.
        Updating,
        /// The binding is being deleted.
        Deleting,
        /// The binding has failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Creating,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.ManagementDnsZoneBinding.State",
            ))
        }
    }

    /// Required. The relative resource name of the network to bind to the
    /// management DNS zone. This network can be a consumer VPC network or a
    /// VMware engine network.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BindNetwork {
        /// Network to bind is a standard consumer VPC.
        /// Specify the name in the following form for consumer
        /// VPC network: `projects/{project}/global/networks/{network_id}`.
        /// `{project}` can either be a project number or a project ID.
        VpcNetwork(std::string::String),
        /// Network to bind is a VMware Engine network.
        /// Specify the name in the following form for VMware engine network:
        /// `projects/{project}/locations/global/vmwareEngineNetworks/{vmware_engine_network_id}`.
        /// `{project}` can either be a project number or a project ID.
        VmwareEngineNetwork(std::string::String),
    }
}

/// VMware Engine network resource that provides connectivity for VMware Engine
/// private clouds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmwareEngineNetwork {
    /// Output only. The resource name of the VMware Engine network.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/global/vmwareEngineNetworks/my-network`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-provided description for this VMware Engine network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. VMware Engine service VPC networks that provide connectivity
    /// from a private cloud to customer projects, the internet, and other Google
    /// Cloud services.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vpc_networks: std::vec::Vec<crate::model::vmware_engine_network::VpcNetwork>,

    /// Output only. State of the VMware Engine network.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::vmware_engine_network::State,

    /// Required. VMware Engine network type.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::vmware_engine_network::Type,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Checksum that may be sent on update and delete requests to ensure that the
    /// user-provided value is up to date before the server processes a request.
    /// The server computes checksums based on the value of other fields in the
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareEngineNetwork {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VmwareEngineNetwork::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VmwareEngineNetwork::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VmwareEngineNetwork::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::VmwareEngineNetwork::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VmwareEngineNetwork::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::VmwareEngineNetwork::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [vpc_networks][crate::model::VmwareEngineNetwork::vpc_networks].
    pub fn set_vpc_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vmware_engine_network::VpcNetwork>,
    {
        use std::iter::Iterator;
        self.vpc_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::VmwareEngineNetwork::state].
    pub fn set_state<T: std::convert::Into<crate::model::vmware_engine_network::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::VmwareEngineNetwork::type].
    pub fn set_type<T: std::convert::Into<crate::model::vmware_engine_network::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::VmwareEngineNetwork::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::VmwareEngineNetwork::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for VmwareEngineNetwork {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.VmwareEngineNetwork"
    }
}

/// Defines additional types related to [VmwareEngineNetwork].
pub mod vmware_engine_network {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a VMware Engine VPC network that is managed by a
    /// VMware Engine network resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VpcNetwork {
        /// Output only. Type of VPC network (INTRANET, INTERNET, or
        /// GOOGLE_CLOUD)
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub r#type: crate::model::vmware_engine_network::vpc_network::Type,

        /// Output only. The relative resource name of the service VPC network this
        /// VMware Engine network is attached to. For example:
        /// `projects/123123/global/networks/my-network`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VpcNetwork {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::vmware_engine_network::VpcNetwork::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::vmware_engine_network::vpc_network::Type>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [network][crate::model::vmware_engine_network::VpcNetwork::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }
    }

    impl wkt::message::Message for VpcNetwork {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmwareengine.v1.VmwareEngineNetwork.VpcNetwork"
        }
    }

    /// Defines additional types related to [VpcNetwork].
    pub mod vpc_network {
        #[allow(unused_imports)]
        use super::*;

        /// Enum Type defines possible types of a VMware Engine network controlled
        /// service.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// The default value. This value should never be used.
            Unspecified,
            /// VPC network that will be peered with a consumer VPC network or the
            /// intranet VPC of another VMware Engine network. Access a private cloud
            /// through Compute Engine VMs on a peered VPC network or an on-premises
            /// resource connected to a peered consumer VPC network.
            Intranet,
            /// VPC network used for internet access to and from a private cloud.
            Internet,
            /// VPC network used for access to Google Cloud services like
            /// Cloud Storage.
            GoogleCloud,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Intranet => std::option::Option::Some(1),
                    Self::Internet => std::option::Option::Some(2),
                    Self::GoogleCloud => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::Intranet => std::option::Option::Some("INTRANET"),
                    Self::Internet => std::option::Option::Some("INTERNET"),
                    Self::GoogleCloud => std::option::Option::Some("GOOGLE_CLOUD"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Intranet,
                    2 => Self::Internet,
                    3 => Self::GoogleCloud,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "INTRANET" => Self::Intranet,
                    "INTERNET" => Self::Internet,
                    "GOOGLE_CLOUD" => Self::GoogleCloud,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Intranet => serializer.serialize_i32(1),
                    Self::Internet => serializer.serialize_i32(2),
                    Self::GoogleCloud => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.vmwareengine.v1.VmwareEngineNetwork.VpcNetwork.Type",
                ))
            }
        }
    }

    /// Enum State defines possible states of VMware Engine network.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// The VMware Engine network is being created.
        Creating,
        /// The VMware Engine network is ready.
        Active,
        /// The VMware Engine network is being updated.
        Updating,
        /// The VMware Engine network is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Updating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.VmwareEngineNetwork.State",
            ))
        }
    }

    /// Enum Type defines possible types of VMware Engine network.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The default value. This value should never be used.
        Unspecified,
        /// Network type used by private clouds created in projects without a network
        /// of type `STANDARD`. This network type is no longer used for new VMware
        /// Engine private cloud deployments.
        Legacy,
        /// Standard network type used for private cloud connectivity.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Legacy => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Legacy => std::option::Option::Some("LEGACY"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Legacy,
                2 => Self::Standard,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "LEGACY" => Self::Legacy,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Legacy => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmwareengine.v1.VmwareEngineNetwork.Type",
            ))
        }
    }
}

/// Private connection resource that provides connectivity for VMware Engine
/// private clouds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateConnection {
    /// Output only. The resource name of the private connection.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// For example:
    /// `projects/my-project/locations/us-central1/privateConnections/my-connection`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-provided description for this private connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. State of the private connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::private_connection::State,

    /// Required. The relative resource name of Legacy VMware Engine network.
    /// Specify the name in the following form:
    /// `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
    /// where `{project}`, `{location}` will be same as specified in private
    /// connection resource name and `{vmware_engine_network_id}` will be in the
    /// form of `{location}`-default e.g.
    /// projects/project/locations/us-central1/vmwareEngineNetworks/us-central1-default.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network: std::string::String,

    /// Output only. The canonical name of the VMware Engine network in the form:
    /// `projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vmware_engine_network_canonical: std::string::String,

    /// Required. Private connection type.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::private_connection::Type,

    /// Output only. VPC network peering id between given network VPC and
    /// VMwareEngineNetwork.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peering_id: std::string::String,

    /// Optional. Routing Mode.
    /// Default value is set to GLOBAL.
    /// For type = PRIVATE_SERVICE_ACCESS, this field can be set to GLOBAL or
    /// REGIONAL, for other types only GLOBAL is supported.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub routing_mode: crate::model::private_connection::RoutingMode,

    /// Output only. System-generated unique identifier for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Required. Service network to create private connection.
    /// Specify the name in the following form:
    /// `projects/{project}/global/networks/{network_id}`
    /// For type = PRIVATE_SERVICE_ACCESS, this field represents servicenetworking
    /// VPC, e.g. projects/project-tp/global/networks/servicenetworking.
    /// For type = NETAPP_CLOUD_VOLUME, this field represents NetApp service VPC,
    /// e.g. projects/project-tp/global/networks/netapp-tenant-vpc.
    /// For type = DELL_POWERSCALE, this field represent Dell service VPC, e.g.
    /// projects/project-tp/global/networks/dell-tenant-vpc.
    /// For type= THIRD_PARTY_SERVICE, this field could represent a consumer VPC or
    /// any other producer VPC to which the VMware Engine Network needs to be
    /// connected, e.g. projects/project/global/networks/vpc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_network: std::string::String,

    /// Output only. Peering state between service network and VMware Engine
    /// network.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub peering_state: crate::model::private_connection::PeeringState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PrivateConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::PrivateConnection::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PrivateConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::private_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network][crate::model::PrivateConnection::vmware_engine_network].
    pub fn set_vmware_engine_network<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network = v.into();
        self
    }

    /// Sets the value of [vmware_engine_network_canonical][crate::model::PrivateConnection::vmware_engine_network_canonical].
    pub fn set_vmware_engine_network_canonical<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vmware_engine_network_canonical = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::PrivateConnection::type].
    pub fn set_type<T: std::convert::Into<crate::model::private_connection::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [peering_id][crate::model::PrivateConnection::peering_id].
    pub fn set_peering_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peering_id = v.into();
        self
    }

    /// Sets the value of [routing_mode][crate::model::PrivateConnection::routing_mode].
    pub fn set_routing_mode<
        T: std::convert::Into<crate::model::private_connection::RoutingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routing_mode = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::PrivateConnection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [service_network][crate::model::PrivateConnection::service_network].
    pub fn set_service_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_network = v.into();
        self
    }

    /// Sets the value of [peering_state][crate::model::PrivateConnection::peering_state].
    pub fn set_peering_state<
        T: std::convert::Into<crate::model::private_connection::PeeringState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.peering_state = v.into();
        self
    }
}

impl wkt::message::Message for PrivateConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.PrivateConnection"
    }
}

/// Defines additional types related to [PrivateConnection].
pub mod private_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Enum State defines possible states of private connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// The private connection is being created.
        Creating,
        /// The private connection is ready.
        Active,
        /// The private connection is being updated.
        Updating,
        /// The private connection is being deleted.
        Deleting,
        /// The private connection is not provisioned, since no private cloud is
        /// present for which this private connection is needed.
        Unprovisioned,
        /// The private connection is in failed state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Unprovisioned => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Unprovisioned => std::option::Option::Some("UNPROVISIONED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Unprovisioned,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "UNPROVISIONED" => Self::Unprovisioned,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Unprovisioned => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmwareengine.v1.PrivateConnection.State",
            ))
        }
    }

    /// Enum Type defines possible types of private connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The default value. This value should never be used.
        Unspecified,
        /// Connection used for establishing [private services
        /// access](https://cloud.google.com/vpc/docs/private-services-access).
        PrivateServiceAccess,
        /// Connection used for connecting to NetApp Cloud Volumes.
        NetappCloudVolumes,
        /// Connection used for connecting to Dell PowerScale.
        DellPowerscale,
        /// Connection used for connecting to third-party services.
        ThirdPartyService,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PrivateServiceAccess => std::option::Option::Some(1),
                Self::NetappCloudVolumes => std::option::Option::Some(2),
                Self::DellPowerscale => std::option::Option::Some(3),
                Self::ThirdPartyService => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::PrivateServiceAccess => std::option::Option::Some("PRIVATE_SERVICE_ACCESS"),
                Self::NetappCloudVolumes => std::option::Option::Some("NETAPP_CLOUD_VOLUMES"),
                Self::DellPowerscale => std::option::Option::Some("DELL_POWERSCALE"),
                Self::ThirdPartyService => std::option::Option::Some("THIRD_PARTY_SERVICE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PrivateServiceAccess,
                2 => Self::NetappCloudVolumes,
                3 => Self::DellPowerscale,
                4 => Self::ThirdPartyService,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PRIVATE_SERVICE_ACCESS" => Self::PrivateServiceAccess,
                "NETAPP_CLOUD_VOLUMES" => Self::NetappCloudVolumes,
                "DELL_POWERSCALE" => Self::DellPowerscale,
                "THIRD_PARTY_SERVICE" => Self::ThirdPartyService,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PrivateServiceAccess => serializer.serialize_i32(1),
                Self::NetappCloudVolumes => serializer.serialize_i32(2),
                Self::DellPowerscale => serializer.serialize_i32(3),
                Self::ThirdPartyService => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmwareengine.v1.PrivateConnection.Type",
            ))
        }
    }

    /// Possible types for RoutingMode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoutingMode {
        /// The default value. This value should never be used.
        Unspecified,
        /// Global Routing Mode
        Global,
        /// Regional Routing Mode
        Regional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RoutingMode::value] or
        /// [RoutingMode::name].
        UnknownValue(routing_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod routing_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RoutingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Global => std::option::Option::Some(1),
                Self::Regional => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUTING_MODE_UNSPECIFIED"),
                Self::Global => std::option::Option::Some("GLOBAL"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RoutingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RoutingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RoutingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Global,
                2 => Self::Regional,
                _ => Self::UnknownValue(routing_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RoutingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUTING_MODE_UNSPECIFIED" => Self::Unspecified,
                "GLOBAL" => Self::Global,
                "REGIONAL" => Self::Regional,
                _ => Self::UnknownValue(routing_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RoutingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Global => serializer.serialize_i32(1),
                Self::Regional => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RoutingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RoutingMode>::new(
                ".google.cloud.vmwareengine.v1.PrivateConnection.RoutingMode",
            ))
        }
    }

    /// Enum PeeringState defines the possible states of peering between service
    /// network and the vpc network peered to service network
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PeeringState {
        /// The default value. This value is used if the peering state is omitted or
        /// unknown.
        Unspecified,
        /// The peering is in active state.
        PeeringActive,
        /// The peering is in inactive state.
        PeeringInactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PeeringState::value] or
        /// [PeeringState::name].
        UnknownValue(peering_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod peering_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PeeringState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PeeringActive => std::option::Option::Some(1),
                Self::PeeringInactive => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PEERING_STATE_UNSPECIFIED"),
                Self::PeeringActive => std::option::Option::Some("PEERING_ACTIVE"),
                Self::PeeringInactive => std::option::Option::Some("PEERING_INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PeeringState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PeeringState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PeeringState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PeeringActive,
                2 => Self::PeeringInactive,
                _ => Self::UnknownValue(peering_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PeeringState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PEERING_STATE_UNSPECIFIED" => Self::Unspecified,
                "PEERING_ACTIVE" => Self::PeeringActive,
                "PEERING_INACTIVE" => Self::PeeringInactive,
                _ => Self::UnknownValue(peering_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PeeringState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PeeringActive => serializer.serialize_i32(1),
                Self::PeeringInactive => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PeeringState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PeeringState>::new(
                ".google.cloud.vmwareengine.v1.PrivateConnection.PeeringState",
            ))
        }
    }
}

/// VmwareEngine specific metadata for the given
/// [google.cloud.location.Location][google.cloud.location.Location]. It is
/// returned as a content of the `google.cloud.location.Location.metadata` field.
///
/// [google.cloud.location.Location]: location::model::Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Output only. Capabilities of this location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub capabilities: std::vec::Vec<crate::model::location_metadata::Capability>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [capabilities][crate::model::LocationMetadata::capabilities].
    pub fn set_capabilities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::location_metadata::Capability>,
    {
        use std::iter::Iterator;
        self.capabilities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.LocationMetadata"
    }
}

/// Defines additional types related to [LocationMetadata].
pub mod location_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Capability of a location.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Capability {
        /// The default value. This value is used if the capability is omitted or
        /// unknown.
        Unspecified,
        /// Stretch clusters are supported in this location.
        StretchedClusters,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Capability::value] or
        /// [Capability::name].
        UnknownValue(capability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod capability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Capability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StretchedClusters => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CAPABILITY_UNSPECIFIED"),
                Self::StretchedClusters => std::option::Option::Some("STRETCHED_CLUSTERS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Capability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Capability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Capability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StretchedClusters,
                _ => Self::UnknownValue(capability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Capability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CAPABILITY_UNSPECIFIED" => Self::Unspecified,
                "STRETCHED_CLUSTERS" => Self::StretchedClusters,
                _ => Self::UnknownValue(capability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Capability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StretchedClusters => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Capability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Capability>::new(
                ".google.cloud.vmwareengine.v1.LocationMetadata.Capability",
            ))
        }
    }
}

/// DnsBindPermission resource that contains the accounts having the consumer DNS
/// bind permission on the corresponding intranet VPC of the consumer project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DnsBindPermission {
    /// Required. Output only. The name of the resource which stores the
    /// users/service accounts having the permission to bind to the corresponding
    /// intranet VPC of the consumer project. DnsBindPermission is a global
    /// resource and location can only be global. Resource names are schemeless
    /// URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>. For example:
    /// `projects/my-project/locations/global/dnsBindPermission`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Users/Service accounts which have access for binding on the
    /// intranet VPC project corresponding to the consumer project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub principals: std::vec::Vec<crate::model::Principal>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DnsBindPermission {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DnsBindPermission::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [principals][crate::model::DnsBindPermission::principals].
    pub fn set_principals<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Principal>,
    {
        use std::iter::Iterator;
        self.principals = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DnsBindPermission {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.DnsBindPermission"
    }
}

/// Users/Service accounts which have access for DNS binding on the intranet
/// VPC corresponding to the consumer project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Principal {
    /// The consumer provided user/service account which needs to be
    /// granted permission to DNS bind with the intranet VPC corresponding to the
    /// consumer project.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub principal: std::option::Option<crate::model::principal::Principal>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Principal {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal][crate::model::Principal::principal].
    ///
    /// Note that all the setters affecting `principal` are mutually
    /// exclusive.
    pub fn set_principal<
        T: std::convert::Into<std::option::Option<crate::model::principal::Principal>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.principal = v.into();
        self
    }

    /// The value of [principal][crate::model::Principal::principal]
    /// if it holds a `User`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.principal.as_ref().and_then(|v| match v {
            crate::model::principal::Principal::User(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [principal][crate::model::Principal::principal]
    /// to hold a `User`.
    ///
    /// Note that all the setters affecting `principal` are
    /// mutually exclusive.
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal =
            std::option::Option::Some(crate::model::principal::Principal::User(v.into()));
        self
    }

    /// The value of [principal][crate::model::Principal::principal]
    /// if it holds a `ServiceAccount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_account(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.principal.as_ref().and_then(|v| match v {
            crate::model::principal::Principal::ServiceAccount(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [principal][crate::model::Principal::principal]
    /// to hold a `ServiceAccount`.
    ///
    /// Note that all the setters affecting `principal` are
    /// mutually exclusive.
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal =
            std::option::Option::Some(crate::model::principal::Principal::ServiceAccount(v.into()));
        self
    }
}

impl wkt::message::Message for Principal {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmwareengine.v1.Principal"
    }
}

/// Defines additional types related to [Principal].
pub mod principal {
    #[allow(unused_imports)]
    use super::*;

    /// The consumer provided user/service account which needs to be
    /// granted permission to DNS bind with the intranet VPC corresponding to the
    /// consumer project.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Principal {
        /// The user who needs to be granted permission.
        User(std::string::String),
        /// The service account which needs to be granted the permission.
        ServiceAccount(std::string::String),
    }
}
