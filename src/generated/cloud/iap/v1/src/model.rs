// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request to ListTunnelDestGroups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTunnelDestGroupsRequest {
    /// Required. Google Cloud Project ID and location.
    /// In the following format:
    /// `projects/{project_number/id}/iap_tunnel/locations/{location}`.
    /// A `-` can be used for the location to group across all locations.
    pub parent: std::string::String,

    /// The maximum number of groups to return. The service might return fewer than
    /// this value.
    /// If unspecified, at most 100 groups are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListTunnelDestGroups`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListTunnelDestGroups` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTunnelDestGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTunnelDestGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTunnelDestGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTunnelDestGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTunnelDestGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ListTunnelDestGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTunnelDestGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTunnelDestGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTunnelDestGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTunnelDestGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTunnelDestGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response from ListTunnelDestGroups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTunnelDestGroupsResponse {
    /// TunnelDestGroup existing in the project.
    pub tunnel_dest_groups: std::vec::Vec<crate::model::TunnelDestGroup>,

    /// A token that you can send as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTunnelDestGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tunnel_dest_groups][crate::model::ListTunnelDestGroupsResponse::tunnel_dest_groups].
    pub fn set_tunnel_dest_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TunnelDestGroup>,
    {
        use std::iter::Iterator;
        self.tunnel_dest_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTunnelDestGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTunnelDestGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ListTunnelDestGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTunnelDestGroupsResponse {
    type PageItem = crate::model::TunnelDestGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tunnel_dest_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTunnelDestGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tunnel_dest_groups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTunnelDestGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tunnelDestGroups" => Ok(__FieldTag::__tunnel_dest_groups),
                            "tunnel_dest_groups" => Ok(__FieldTag::__tunnel_dest_groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTunnelDestGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTunnelDestGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tunnel_dest_groups => {
                            if !fields.insert(__FieldTag::__tunnel_dest_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tunnel_dest_groups",
                                ));
                            }
                            result.tunnel_dest_groups =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TunnelDestGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTunnelDestGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tunnel_dest_groups.is_empty() {
            state.serialize_entry("tunnelDestGroups", &self.tunnel_dest_groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request to CreateTunnelDestGroup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTunnelDestGroupRequest {
    /// Required. Google Cloud Project ID and location.
    /// In the following format:
    /// `projects/{project_number/id}/iap_tunnel/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The TunnelDestGroup to create.
    pub tunnel_dest_group: std::option::Option<crate::model::TunnelDestGroup>,

    /// Required. The ID to use for the TunnelDestGroup, which becomes the final
    /// component of the resource name.
    ///
    /// This value must be 4-63 characters, and valid characters
    /// are `[a-z]-`.
    pub tunnel_dest_group_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTunnelDestGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTunnelDestGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tunnel_dest_group][crate::model::CreateTunnelDestGroupRequest::tunnel_dest_group].
    pub fn set_tunnel_dest_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TunnelDestGroup>,
    {
        self.tunnel_dest_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tunnel_dest_group][crate::model::CreateTunnelDestGroupRequest::tunnel_dest_group].
    pub fn set_or_clear_tunnel_dest_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TunnelDestGroup>,
    {
        self.tunnel_dest_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tunnel_dest_group_id][crate::model::CreateTunnelDestGroupRequest::tunnel_dest_group_id].
    pub fn set_tunnel_dest_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tunnel_dest_group_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTunnelDestGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.CreateTunnelDestGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTunnelDestGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __tunnel_dest_group,
            __tunnel_dest_group_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTunnelDestGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tunnelDestGroup" => Ok(__FieldTag::__tunnel_dest_group),
                            "tunnel_dest_group" => Ok(__FieldTag::__tunnel_dest_group),
                            "tunnelDestGroupId" => Ok(__FieldTag::__tunnel_dest_group_id),
                            "tunnel_dest_group_id" => Ok(__FieldTag::__tunnel_dest_group_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTunnelDestGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTunnelDestGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tunnel_dest_group => {
                            if !fields.insert(__FieldTag::__tunnel_dest_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tunnel_dest_group",
                                ));
                            }
                            result.tunnel_dest_group = map
                                .next_value::<std::option::Option<crate::model::TunnelDestGroup>>(
                                )?;
                        }
                        __FieldTag::__tunnel_dest_group_id => {
                            if !fields.insert(__FieldTag::__tunnel_dest_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tunnel_dest_group_id",
                                ));
                            }
                            result.tunnel_dest_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTunnelDestGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.tunnel_dest_group.is_some() {
            state.serialize_entry("tunnelDestGroup", &self.tunnel_dest_group)?;
        }
        if !self.tunnel_dest_group_id.is_empty() {
            state.serialize_entry("tunnelDestGroupId", &self.tunnel_dest_group_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request to GetTunnelDestGroup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTunnelDestGroupRequest {
    /// Required. Name of the TunnelDestGroup to be fetched.
    /// In the following format:
    /// `projects/{project_number/id}/iap_tunnel/locations/{location}/destGroups/{dest_group}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTunnelDestGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTunnelDestGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTunnelDestGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.GetTunnelDestGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTunnelDestGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTunnelDestGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTunnelDestGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTunnelDestGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTunnelDestGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request to DeleteTunnelDestGroup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTunnelDestGroupRequest {
    /// Required. Name of the TunnelDestGroup to delete.
    /// In the following format:
    /// `projects/{project_number/id}/iap_tunnel/locations/{location}/destGroups/{dest_group}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTunnelDestGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTunnelDestGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTunnelDestGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.DeleteTunnelDestGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTunnelDestGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTunnelDestGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTunnelDestGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTunnelDestGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTunnelDestGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request to UpdateTunnelDestGroup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTunnelDestGroupRequest {
    /// Required. The new values for the TunnelDestGroup.
    pub tunnel_dest_group: std::option::Option<crate::model::TunnelDestGroup>,

    /// A field mask that specifies which IAP settings to update.
    /// If omitted, then all of the settings are updated. See
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTunnelDestGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tunnel_dest_group][crate::model::UpdateTunnelDestGroupRequest::tunnel_dest_group].
    pub fn set_tunnel_dest_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TunnelDestGroup>,
    {
        self.tunnel_dest_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tunnel_dest_group][crate::model::UpdateTunnelDestGroupRequest::tunnel_dest_group].
    pub fn set_or_clear_tunnel_dest_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TunnelDestGroup>,
    {
        self.tunnel_dest_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTunnelDestGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTunnelDestGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTunnelDestGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.UpdateTunnelDestGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTunnelDestGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tunnel_dest_group,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTunnelDestGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tunnelDestGroup" => Ok(__FieldTag::__tunnel_dest_group),
                            "tunnel_dest_group" => Ok(__FieldTag::__tunnel_dest_group),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTunnelDestGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTunnelDestGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tunnel_dest_group => {
                            if !fields.insert(__FieldTag::__tunnel_dest_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tunnel_dest_group",
                                ));
                            }
                            result.tunnel_dest_group = map
                                .next_value::<std::option::Option<crate::model::TunnelDestGroup>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTunnelDestGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tunnel_dest_group.is_some() {
            state.serialize_entry("tunnelDestGroup", &self.tunnel_dest_group)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A TunnelDestGroup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TunnelDestGroup {
    /// Identifier. Identifier for the TunnelDestGroup. Must be unique within the
    /// project and contain only lower case letters (a-z) and dashes (-).
    pub name: std::string::String,

    /// Optional. Unordered list. List of CIDRs that this group applies to.
    pub cidrs: std::vec::Vec<std::string::String>,

    /// Optional. Unordered list. List of FQDNs that this group applies to.
    pub fqdns: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TunnelDestGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TunnelDestGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cidrs][crate::model::TunnelDestGroup::cidrs].
    pub fn set_cidrs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cidrs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [fqdns][crate::model::TunnelDestGroup::fqdns].
    pub fn set_fqdns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fqdns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TunnelDestGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.TunnelDestGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TunnelDestGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cidrs,
            __fqdns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TunnelDestGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cidrs" => Ok(__FieldTag::__cidrs),
                            "fqdns" => Ok(__FieldTag::__fqdns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TunnelDestGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TunnelDestGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidrs => {
                            if !fields.insert(__FieldTag::__cidrs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidrs",
                                ));
                            }
                            result.cidrs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__fqdns => {
                            if !fields.insert(__FieldTag::__fqdns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fqdns",
                                ));
                            }
                            result.fqdns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TunnelDestGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.cidrs.is_empty() {
            state.serialize_entry("cidrs", &self.cidrs)?;
        }
        if !self.fqdns.is_empty() {
            state.serialize_entry("fqdns", &self.fqdns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to GetIapSettings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIapSettingsRequest {
    /// Required. The resource name for which to retrieve the settings.
    /// Authorization: Requires the `getSettings` permission for the associated
    /// resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIapSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIapSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIapSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.GetIapSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIapSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIapSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIapSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIapSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetIapSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to UpdateIapSettings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateIapSettingsRequest {
    /// Required. The new values for the IAP settings to be updated.
    /// Authorization: Requires the `updateSettings` permission for the associated
    /// resource.
    pub iap_settings: std::option::Option<crate::model::IapSettings>,

    /// The field mask specifying which IAP settings should be updated.
    /// If omitted, then all of the settings are updated. See
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>.
    ///
    /// Note: All IAP reauth settings must always be set together, using the
    /// field mask: `iapSettings.accessSettings.reauthSettings`.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIapSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [iap_settings][crate::model::UpdateIapSettingsRequest::iap_settings].
    pub fn set_iap_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IapSettings>,
    {
        self.iap_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [iap_settings][crate::model::UpdateIapSettingsRequest::iap_settings].
    pub fn set_or_clear_iap_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IapSettings>,
    {
        self.iap_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIapSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateIapSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateIapSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.UpdateIapSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateIapSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __iap_settings,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateIapSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "iapSettings" => Ok(__FieldTag::__iap_settings),
                            "iap_settings" => Ok(__FieldTag::__iap_settings),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateIapSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateIapSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__iap_settings => {
                            if !fields.insert(__FieldTag::__iap_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iap_settings",
                                ));
                            }
                            result.iap_settings =
                                map.next_value::<std::option::Option<crate::model::IapSettings>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateIapSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.iap_settings.is_some() {
            state.serialize_entry("iapSettings", &self.iap_settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The IAP configurable settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IapSettings {
    /// Required. The resource name of the IAP protected resource.
    pub name: std::string::String,

    /// Optional. Top level wrapper for all access related setting in IAP
    pub access_settings: std::option::Option<crate::model::AccessSettings>,

    /// Optional. Top level wrapper for all application related settings in IAP
    pub application_settings: std::option::Option<crate::model::ApplicationSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IapSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IapSettings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [access_settings][crate::model::IapSettings::access_settings].
    pub fn set_access_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessSettings>,
    {
        self.access_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_settings][crate::model::IapSettings::access_settings].
    pub fn set_or_clear_access_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessSettings>,
    {
        self.access_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [application_settings][crate::model::IapSettings::application_settings].
    pub fn set_application_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApplicationSettings>,
    {
        self.application_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [application_settings][crate::model::IapSettings::application_settings].
    pub fn set_or_clear_application_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApplicationSettings>,
    {
        self.application_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IapSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.IapSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IapSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __access_settings,
            __application_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IapSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "accessSettings" => Ok(__FieldTag::__access_settings),
                            "access_settings" => Ok(__FieldTag::__access_settings),
                            "applicationSettings" => Ok(__FieldTag::__application_settings),
                            "application_settings" => Ok(__FieldTag::__application_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IapSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IapSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_settings => {
                            if !fields.insert(__FieldTag::__access_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_settings",
                                ));
                            }
                            result.access_settings = map
                                .next_value::<std::option::Option<crate::model::AccessSettings>>(
                                )?;
                        }
                        __FieldTag::__application_settings => {
                            if !fields.insert(__FieldTag::__application_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_settings",
                                ));
                            }
                            result.application_settings = map.next_value::<std::option::Option<crate::model::ApplicationSettings>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IapSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.access_settings.is_some() {
            state.serialize_entry("accessSettings", &self.access_settings)?;
        }
        if self.application_settings.is_some() {
            state.serialize_entry("applicationSettings", &self.application_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Access related settings for IAP protected apps.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessSettings {
    /// Optional. GCIP claims and endpoint configurations for 3p identity
    /// providers.
    pub gcip_settings: std::option::Option<crate::model::GcipSettings>,

    /// Optional. Configuration to allow cross-origin requests via IAP.
    pub cors_settings: std::option::Option<crate::model::CorsSettings>,

    /// Optional. Settings to configure IAP's OAuth behavior.
    pub oauth_settings: std::option::Option<crate::model::OAuthSettings>,

    /// Optional. Settings to configure reauthentication policies in IAP.
    pub reauth_settings: std::option::Option<crate::model::ReauthSettings>,

    /// Optional. Settings to configure and enable allowed domains.
    pub allowed_domains_settings: std::option::Option<crate::model::AllowedDomainsSettings>,

    /// Optional. Settings to configure the workforce identity federation,
    /// including workforce pools and OAuth 2.0 settings.
    pub workforce_identity_settings: std::option::Option<crate::model::WorkforceIdentitySettings>,

    /// Optional. Identity sources that IAP can use to authenticate the end user.
    /// Only one identity source can be configured.
    pub identity_sources: std::vec::Vec<crate::model::access_settings::IdentitySource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcip_settings][crate::model::AccessSettings::gcip_settings].
    pub fn set_gcip_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcipSettings>,
    {
        self.gcip_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcip_settings][crate::model::AccessSettings::gcip_settings].
    pub fn set_or_clear_gcip_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcipSettings>,
    {
        self.gcip_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cors_settings][crate::model::AccessSettings::cors_settings].
    pub fn set_cors_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CorsSettings>,
    {
        self.cors_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cors_settings][crate::model::AccessSettings::cors_settings].
    pub fn set_or_clear_cors_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CorsSettings>,
    {
        self.cors_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [oauth_settings][crate::model::AccessSettings::oauth_settings].
    pub fn set_oauth_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OAuthSettings>,
    {
        self.oauth_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oauth_settings][crate::model::AccessSettings::oauth_settings].
    pub fn set_or_clear_oauth_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OAuthSettings>,
    {
        self.oauth_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reauth_settings][crate::model::AccessSettings::reauth_settings].
    pub fn set_reauth_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReauthSettings>,
    {
        self.reauth_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reauth_settings][crate::model::AccessSettings::reauth_settings].
    pub fn set_or_clear_reauth_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReauthSettings>,
    {
        self.reauth_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allowed_domains_settings][crate::model::AccessSettings::allowed_domains_settings].
    pub fn set_allowed_domains_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AllowedDomainsSettings>,
    {
        self.allowed_domains_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allowed_domains_settings][crate::model::AccessSettings::allowed_domains_settings].
    pub fn set_or_clear_allowed_domains_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AllowedDomainsSettings>,
    {
        self.allowed_domains_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workforce_identity_settings][crate::model::AccessSettings::workforce_identity_settings].
    pub fn set_workforce_identity_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkforceIdentitySettings>,
    {
        self.workforce_identity_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workforce_identity_settings][crate::model::AccessSettings::workforce_identity_settings].
    pub fn set_or_clear_workforce_identity_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkforceIdentitySettings>,
    {
        self.workforce_identity_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [identity_sources][crate::model::AccessSettings::identity_sources].
    pub fn set_identity_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::access_settings::IdentitySource>,
    {
        use std::iter::Iterator;
        self.identity_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccessSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.AccessSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcip_settings,
            __cors_settings,
            __oauth_settings,
            __reauth_settings,
            __allowed_domains_settings,
            __workforce_identity_settings,
            __identity_sources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcipSettings" => Ok(__FieldTag::__gcip_settings),
                            "gcip_settings" => Ok(__FieldTag::__gcip_settings),
                            "corsSettings" => Ok(__FieldTag::__cors_settings),
                            "cors_settings" => Ok(__FieldTag::__cors_settings),
                            "oauthSettings" => Ok(__FieldTag::__oauth_settings),
                            "oauth_settings" => Ok(__FieldTag::__oauth_settings),
                            "reauthSettings" => Ok(__FieldTag::__reauth_settings),
                            "reauth_settings" => Ok(__FieldTag::__reauth_settings),
                            "allowedDomainsSettings" => Ok(__FieldTag::__allowed_domains_settings),
                            "allowed_domains_settings" => {
                                Ok(__FieldTag::__allowed_domains_settings)
                            }
                            "workforceIdentitySettings" => {
                                Ok(__FieldTag::__workforce_identity_settings)
                            }
                            "workforce_identity_settings" => {
                                Ok(__FieldTag::__workforce_identity_settings)
                            }
                            "identitySources" => Ok(__FieldTag::__identity_sources),
                            "identity_sources" => Ok(__FieldTag::__identity_sources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcip_settings => {
                            if !fields.insert(__FieldTag::__gcip_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcip_settings",
                                ));
                            }
                            result.gcip_settings = map
                                .next_value::<std::option::Option<crate::model::GcipSettings>>()?;
                        }
                        __FieldTag::__cors_settings => {
                            if !fields.insert(__FieldTag::__cors_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cors_settings",
                                ));
                            }
                            result.cors_settings = map
                                .next_value::<std::option::Option<crate::model::CorsSettings>>()?;
                        }
                        __FieldTag::__oauth_settings => {
                            if !fields.insert(__FieldTag::__oauth_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_settings",
                                ));
                            }
                            result.oauth_settings = map
                                .next_value::<std::option::Option<crate::model::OAuthSettings>>()?;
                        }
                        __FieldTag::__reauth_settings => {
                            if !fields.insert(__FieldTag::__reauth_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reauth_settings",
                                ));
                            }
                            result.reauth_settings = map
                                .next_value::<std::option::Option<crate::model::ReauthSettings>>(
                                )?;
                        }
                        __FieldTag::__allowed_domains_settings => {
                            if !fields.insert(__FieldTag::__allowed_domains_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_domains_settings",
                                ));
                            }
                            result.allowed_domains_settings = map.next_value::<std::option::Option<crate::model::AllowedDomainsSettings>>()?
                                ;
                        }
                        __FieldTag::__workforce_identity_settings => {
                            if !fields.insert(__FieldTag::__workforce_identity_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workforce_identity_settings",
                                ));
                            }
                            result.workforce_identity_settings = map.next_value::<std::option::Option<crate::model::WorkforceIdentitySettings>>()?
                                ;
                        }
                        __FieldTag::__identity_sources => {
                            if !fields.insert(__FieldTag::__identity_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_sources",
                                ));
                            }
                            result.identity_sources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::access_settings::IdentitySource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gcip_settings.is_some() {
            state.serialize_entry("gcipSettings", &self.gcip_settings)?;
        }
        if self.cors_settings.is_some() {
            state.serialize_entry("corsSettings", &self.cors_settings)?;
        }
        if self.oauth_settings.is_some() {
            state.serialize_entry("oauthSettings", &self.oauth_settings)?;
        }
        if self.reauth_settings.is_some() {
            state.serialize_entry("reauthSettings", &self.reauth_settings)?;
        }
        if self.allowed_domains_settings.is_some() {
            state.serialize_entry("allowedDomainsSettings", &self.allowed_domains_settings)?;
        }
        if self.workforce_identity_settings.is_some() {
            state.serialize_entry(
                "workforceIdentitySettings",
                &self.workforce_identity_settings,
            )?;
        }
        if !self.identity_sources.is_empty() {
            state.serialize_entry("identitySources", &self.identity_sources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccessSettings].
pub mod access_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Types of identity source supported by IAP.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IdentitySource {
        /// IdentitySource Unspecified.
        /// When selected, IAP relies on which identity settings are fully configured
        /// to redirect the traffic to. The precedence order is
        /// WorkforceIdentitySettings > GcipSettings. If none is set, default to use
        /// Google identity.
        Unspecified,
        /// Use external identities set up on Google Cloud Workforce Identity
        /// Federation.
        WorkforceIdentityFederation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IdentitySource::value] or
        /// [IdentitySource::name].
        UnknownValue(identity_source::UnknownValue),
    }

    #[doc(hidden)]
    pub mod identity_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IdentitySource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::WorkforceIdentityFederation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IDENTITY_SOURCE_UNSPECIFIED"),
                Self::WorkforceIdentityFederation => {
                    std::option::Option::Some("WORKFORCE_IDENTITY_FEDERATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IdentitySource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IdentitySource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IdentitySource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                3 => Self::WorkforceIdentityFederation,
                _ => Self::UnknownValue(identity_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IdentitySource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IDENTITY_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "WORKFORCE_IDENTITY_FEDERATION" => Self::WorkforceIdentityFederation,
                _ => Self::UnknownValue(identity_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IdentitySource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::WorkforceIdentityFederation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IdentitySource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IdentitySource>::new(
                ".google.cloud.iap.v1.AccessSettings.IdentitySource",
            ))
        }
    }
}

/// Allows customers to configure tenant IDs for a Cloud Identity Platform (GCIP)
/// instance for each application.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcipSettings {
    /// Optional. GCIP tenant IDs that are linked to the IAP resource. `tenant_ids`
    /// could be a string beginning with a number character to indicate
    /// authenticating with GCIP tenant flow, or in the format of
    /// `_<ProjectNumber>` to indicate authenticating with GCIP agent flow. If
    /// agent flow is used, `tenant_ids` should only contain one single element,
    /// while for tenant flow, `tenant_ids` can contain multiple elements.
    pub tenant_ids: std::vec::Vec<std::string::String>,

    /// Login page URI associated with the GCIP tenants.
    /// Typically, all resources within the same project share the same login page,
    /// though it could be overridden at the sub resource level.
    pub login_page_uri: std::option::Option<wkt::StringValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcipSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenant_ids][crate::model::GcipSettings::tenant_ids].
    pub fn set_tenant_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tenant_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [login_page_uri][crate::model::GcipSettings::login_page_uri].
    pub fn set_login_page_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.login_page_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [login_page_uri][crate::model::GcipSettings::login_page_uri].
    pub fn set_or_clear_login_page_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.login_page_uri = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GcipSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.GcipSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcipSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tenant_ids,
            __login_page_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcipSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tenantIds" => Ok(__FieldTag::__tenant_ids),
                            "tenant_ids" => Ok(__FieldTag::__tenant_ids),
                            "loginPageUri" => Ok(__FieldTag::__login_page_uri),
                            "login_page_uri" => Ok(__FieldTag::__login_page_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcipSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcipSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tenant_ids => {
                            if !fields.insert(__FieldTag::__tenant_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant_ids",
                                ));
                            }
                            result.tenant_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__login_page_uri => {
                            if !fields.insert(__FieldTag::__login_page_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for login_page_uri",
                                ));
                            }
                            result.login_page_uri =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcipSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tenant_ids.is_empty() {
            state.serialize_entry("tenantIds", &self.tenant_ids)?;
        }
        if self.login_page_uri.is_some() {
            state.serialize_entry("loginPageUri", &self.login_page_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Allows customers to configure HTTP request paths that'll allow HTTP
/// `OPTIONS` call to bypass authentication and authorization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CorsSettings {
    /// Configuration to allow HTTP `OPTIONS` calls to skip
    /// authentication and authorization. If undefined, IAP will not apply any
    /// special logic to `OPTIONS` requests.
    pub allow_http_options: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CorsSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_http_options][crate::model::CorsSettings::allow_http_options].
    pub fn set_allow_http_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_http_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allow_http_options][crate::model::CorsSettings::allow_http_options].
    pub fn set_or_clear_allow_http_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_http_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CorsSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.CorsSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CorsSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_http_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CorsSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowHttpOptions" => Ok(__FieldTag::__allow_http_options),
                            "allow_http_options" => Ok(__FieldTag::__allow_http_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CorsSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CorsSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_http_options => {
                            if !fields.insert(__FieldTag::__allow_http_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_http_options",
                                ));
                            }
                            result.allow_http_options =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CorsSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.allow_http_options.is_some() {
            state.serialize_entry("allowHttpOptions", &self.allow_http_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for OAuth login&consent flow behavior as well as for OAuth
/// Credentials.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OAuthSettings {
    /// Domain hint to send as hd=? parameter in OAuth request flow. Enables
    /// redirect to primary IDP by skipping Google's login screen.
    /// <https://developers.google.com/identity/protocols/OpenIDConnect#hd-param>
    /// Note: IAP does not verify that the id token's hd claim matches this value
    /// since access behavior is managed by IAM policies.
    pub login_hint: std::option::Option<wkt::StringValue>,

    /// Optional. List of client ids allowed to use IAP programmatically.
    pub programmatic_clients: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OAuthSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [login_hint][crate::model::OAuthSettings::login_hint].
    pub fn set_login_hint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.login_hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [login_hint][crate::model::OAuthSettings::login_hint].
    pub fn set_or_clear_login_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.login_hint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [programmatic_clients][crate::model::OAuthSettings::programmatic_clients].
    pub fn set_programmatic_clients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.programmatic_clients = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OAuthSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.OAuthSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OAuthSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __login_hint,
            __programmatic_clients,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OAuthSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "loginHint" => Ok(__FieldTag::__login_hint),
                            "login_hint" => Ok(__FieldTag::__login_hint),
                            "programmaticClients" => Ok(__FieldTag::__programmatic_clients),
                            "programmatic_clients" => Ok(__FieldTag::__programmatic_clients),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OAuthSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OAuthSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__login_hint => {
                            if !fields.insert(__FieldTag::__login_hint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for login_hint",
                                ));
                            }
                            result.login_hint =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__programmatic_clients => {
                            if !fields.insert(__FieldTag::__programmatic_clients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for programmatic_clients",
                                ));
                            }
                            result.programmatic_clients = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OAuthSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.login_hint.is_some() {
            state.serialize_entry("loginHint", &self.login_hint)?;
        }
        if !self.programmatic_clients.is_empty() {
            state.serialize_entry("programmaticClients", &self.programmatic_clients)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// WorkforceIdentitySettings allows customers to configure workforce pools and
/// OAuth 2.0 settings to gate their applications using a third-party IdP with
/// access control.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkforceIdentitySettings {
    /// The workforce pool resources. Only one workforce pool is accepted.
    pub workforce_pools: std::vec::Vec<std::string::String>,

    /// OAuth 2.0 settings for IAP to perform OIDC flow with workforce identity
    /// federation services.
    pub oauth2: std::option::Option<crate::model::OAuth2>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkforceIdentitySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workforce_pools][crate::model::WorkforceIdentitySettings::workforce_pools].
    pub fn set_workforce_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.workforce_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [oauth2][crate::model::WorkforceIdentitySettings::oauth2].
    pub fn set_oauth2<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OAuth2>,
    {
        self.oauth2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oauth2][crate::model::WorkforceIdentitySettings::oauth2].
    pub fn set_or_clear_oauth2<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OAuth2>,
    {
        self.oauth2 = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WorkforceIdentitySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.WorkforceIdentitySettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkforceIdentitySettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workforce_pools,
            __oauth2,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkforceIdentitySettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workforcePools" => Ok(__FieldTag::__workforce_pools),
                            "workforce_pools" => Ok(__FieldTag::__workforce_pools),
                            "oauth2" => Ok(__FieldTag::__oauth2),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkforceIdentitySettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkforceIdentitySettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workforce_pools => {
                            if !fields.insert(__FieldTag::__workforce_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workforce_pools",
                                ));
                            }
                            result.workforce_pools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__oauth2 => {
                            if !fields.insert(__FieldTag::__oauth2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth2",
                                ));
                            }
                            result.oauth2 =
                                map.next_value::<std::option::Option<crate::model::OAuth2>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkforceIdentitySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workforce_pools.is_empty() {
            state.serialize_entry("workforcePools", &self.workforce_pools)?;
        }
        if self.oauth2.is_some() {
            state.serialize_entry("oauth2", &self.oauth2)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The OAuth 2.0 Settings
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OAuth2 {
    /// The OAuth 2.0 client ID registered in the workforce identity federation
    /// OAuth 2.0 Server.
    pub client_id: std::string::String,

    /// Input only. The OAuth 2.0 client secret created while registering the
    /// client ID.
    pub client_secret: std::string::String,

    /// Output only. SHA256 hash value for the client secret. This field is
    /// returned by IAP when the settings are retrieved.
    pub client_secret_sha256: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OAuth2 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_id][crate::model::OAuth2::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [client_secret][crate::model::OAuth2::client_secret].
    pub fn set_client_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_secret = v.into();
        self
    }

    /// Sets the value of [client_secret_sha256][crate::model::OAuth2::client_secret_sha256].
    pub fn set_client_secret_sha256<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_secret_sha256 = v.into();
        self
    }
}

impl wkt::message::Message for OAuth2 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.OAuth2"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OAuth2 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __client_id,
            __client_secret,
            __client_secret_sha256,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OAuth2")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clientId" => Ok(__FieldTag::__client_id),
                            "client_id" => Ok(__FieldTag::__client_id),
                            "clientSecret" => Ok(__FieldTag::__client_secret),
                            "client_secret" => Ok(__FieldTag::__client_secret),
                            "clientSecretSha256" => Ok(__FieldTag::__client_secret_sha256),
                            "client_secret_sha256" => Ok(__FieldTag::__client_secret_sha256),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OAuth2;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OAuth2")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__client_id => {
                            if !fields.insert(__FieldTag::__client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_id",
                                ));
                            }
                            result.client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_secret => {
                            if !fields.insert(__FieldTag::__client_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_secret",
                                ));
                            }
                            result.client_secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_secret_sha256 => {
                            if !fields.insert(__FieldTag::__client_secret_sha256) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_secret_sha256",
                                ));
                            }
                            result.client_secret_sha256 = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OAuth2 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.client_id.is_empty() {
            state.serialize_entry("clientId", &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            state.serialize_entry("clientSecret", &self.client_secret)?;
        }
        if !self.client_secret_sha256.is_empty() {
            state.serialize_entry("clientSecretSha256", &self.client_secret_sha256)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for IAP reauthentication policies.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReauthSettings {
    /// Optional. Reauth method requested.
    pub method: crate::model::reauth_settings::Method,

    /// Optional. Reauth session lifetime, how long before a user has to
    /// reauthenticate again.
    pub max_age: std::option::Option<wkt::Duration>,

    /// Optional. How IAP determines the effective policy in cases of hierarchical
    /// policies. Policies are merged from higher in the hierarchy to lower in the
    /// hierarchy.
    pub policy_type: crate::model::reauth_settings::PolicyType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReauthSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::ReauthSettings::method].
    pub fn set_method<T: std::convert::Into<crate::model::reauth_settings::Method>>(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [max_age][crate::model::ReauthSettings::max_age].
    pub fn set_max_age<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_age = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_age][crate::model::ReauthSettings::max_age].
    pub fn set_or_clear_max_age<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_age = v.map(|x| x.into());
        self
    }

    /// Sets the value of [policy_type][crate::model::ReauthSettings::policy_type].
    pub fn set_policy_type<T: std::convert::Into<crate::model::reauth_settings::PolicyType>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy_type = v.into();
        self
    }
}

impl wkt::message::Message for ReauthSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ReauthSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReauthSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __method,
            __max_age,
            __policy_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReauthSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "method" => Ok(__FieldTag::__method),
                            "maxAge" => Ok(__FieldTag::__max_age),
                            "max_age" => Ok(__FieldTag::__max_age),
                            "policyType" => Ok(__FieldTag::__policy_type),
                            "policy_type" => Ok(__FieldTag::__policy_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReauthSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReauthSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__method => {
                            if !fields.insert(__FieldTag::__method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method",
                                ));
                            }
                            result.method = map.next_value::<std::option::Option<crate::model::reauth_settings::Method>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_age => {
                            if !fields.insert(__FieldTag::__max_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_age",
                                ));
                            }
                            result.max_age =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__policy_type => {
                            if !fields.insert(__FieldTag::__policy_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_type",
                                ));
                            }
                            result.policy_type = map.next_value::<std::option::Option<crate::model::reauth_settings::PolicyType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReauthSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.method) {
            state.serialize_entry("method", &self.method)?;
        }
        if self.max_age.is_some() {
            state.serialize_entry("maxAge", &self.max_age)?;
        }
        if !wkt::internal::is_default(&self.policy_type) {
            state.serialize_entry("policyType", &self.policy_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReauthSettings].
pub mod reauth_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Types of reauthentication methods supported by IAP.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Reauthentication disabled.
        Unspecified,
        /// Prompts the user to log in again.
        Login,
        #[deprecated]
        Password,
        /// User must use their secure key 2nd factor device.
        SecureKey,
        /// User can use any enabled 2nd factor.
        EnrolledSecondFactors,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Method::value] or
        /// [Method::name].
        UnknownValue(method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Method {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Login => std::option::Option::Some(1),
                Self::Password => std::option::Option::Some(2),
                Self::SecureKey => std::option::Option::Some(3),
                Self::EnrolledSecondFactors => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                Self::Login => std::option::Option::Some("LOGIN"),
                Self::Password => std::option::Option::Some("PASSWORD"),
                Self::SecureKey => std::option::Option::Some("SECURE_KEY"),
                Self::EnrolledSecondFactors => std::option::Option::Some("ENROLLED_SECOND_FACTORS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Method {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Login,
                2 => Self::Password,
                3 => Self::SecureKey,
                4 => Self::EnrolledSecondFactors,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Method {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_UNSPECIFIED" => Self::Unspecified,
                "LOGIN" => Self::Login,
                "PASSWORD" => Self::Password,
                "SECURE_KEY" => Self::SecureKey,
                "ENROLLED_SECOND_FACTORS" => Self::EnrolledSecondFactors,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Method {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Login => serializer.serialize_i32(1),
                Self::Password => serializer.serialize_i32(2),
                Self::SecureKey => serializer.serialize_i32(3),
                Self::EnrolledSecondFactors => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Method {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                ".google.cloud.iap.v1.ReauthSettings.Method",
            ))
        }
    }

    /// Type of policy in the case of hierarchical policies.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PolicyType {
        /// Default value. This value is unused.
        Unspecified,
        /// This policy acts as a minimum to other policies, lower in the hierarchy.
        /// Effective policy may only be the same or stricter.
        Minimum,
        /// This policy acts as a default if no other reauth policy is set.
        Default,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PolicyType::value] or
        /// [PolicyType::name].
        UnknownValue(policy_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod policy_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PolicyType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Minimum => std::option::Option::Some(1),
                Self::Default => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POLICY_TYPE_UNSPECIFIED"),
                Self::Minimum => std::option::Option::Some("MINIMUM"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PolicyType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PolicyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PolicyType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Minimum,
                2 => Self::Default,
                _ => Self::UnknownValue(policy_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PolicyType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POLICY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MINIMUM" => Self::Minimum,
                "DEFAULT" => Self::Default,
                _ => Self::UnknownValue(policy_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PolicyType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Minimum => serializer.serialize_i32(1),
                Self::Default => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PolicyType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PolicyType>::new(
                ".google.cloud.iap.v1.ReauthSettings.PolicyType",
            ))
        }
    }
}

/// Configuration for IAP allowed domains. Lets you to restrict access to an app
/// and allow access to only the domains that you list.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AllowedDomainsSettings {
    /// Optional. Configuration for customers to opt in for the feature.
    pub enable: std::option::Option<bool>,

    /// Optional. List of trusted domains.
    pub domains: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllowedDomainsSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable][crate::model::AllowedDomainsSettings::enable].
    pub fn set_enable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable][crate::model::AllowedDomainsSettings::enable].
    pub fn set_or_clear_enable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = v.map(|x| x.into());
        self
    }

    /// Sets the value of [domains][crate::model::AllowedDomainsSettings::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AllowedDomainsSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.AllowedDomainsSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllowedDomainsSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable,
            __domains,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllowedDomainsSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enable" => Ok(__FieldTag::__enable),
                            "domains" => Ok(__FieldTag::__domains),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllowedDomainsSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllowedDomainsSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable => {
                            if !fields.insert(__FieldTag::__enable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable",
                                ));
                            }
                            result.enable = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__domains => {
                            if !fields.insert(__FieldTag::__domains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domains",
                                ));
                            }
                            result.domains = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllowedDomainsSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if !self.domains.is_empty() {
            state.serialize_entry("domains", &self.domains)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Wrapper over application specific settings for IAP.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ApplicationSettings {
    /// Optional. Settings to configure IAP's behavior for a service mesh.
    pub csm_settings: std::option::Option<crate::model::CsmSettings>,

    /// Optional. Customization for Access Denied page.
    pub access_denied_page_settings: std::option::Option<crate::model::AccessDeniedPageSettings>,

    /// The Domain value to set for cookies generated by IAP. This value is not
    /// validated by the API, but will be ignored at runtime if invalid.
    pub cookie_domain: std::option::Option<wkt::StringValue>,

    /// Optional. Settings to configure attribute propagation.
    pub attribute_propagation_settings:
        std::option::Option<crate::model::AttributePropagationSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplicationSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [csm_settings][crate::model::ApplicationSettings::csm_settings].
    pub fn set_csm_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CsmSettings>,
    {
        self.csm_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [csm_settings][crate::model::ApplicationSettings::csm_settings].
    pub fn set_or_clear_csm_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CsmSettings>,
    {
        self.csm_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access_denied_page_settings][crate::model::ApplicationSettings::access_denied_page_settings].
    pub fn set_access_denied_page_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessDeniedPageSettings>,
    {
        self.access_denied_page_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_denied_page_settings][crate::model::ApplicationSettings::access_denied_page_settings].
    pub fn set_or_clear_access_denied_page_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessDeniedPageSettings>,
    {
        self.access_denied_page_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cookie_domain][crate::model::ApplicationSettings::cookie_domain].
    pub fn set_cookie_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.cookie_domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cookie_domain][crate::model::ApplicationSettings::cookie_domain].
    pub fn set_or_clear_cookie_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.cookie_domain = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attribute_propagation_settings][crate::model::ApplicationSettings::attribute_propagation_settings].
    pub fn set_attribute_propagation_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributePropagationSettings>,
    {
        self.attribute_propagation_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attribute_propagation_settings][crate::model::ApplicationSettings::attribute_propagation_settings].
    pub fn set_or_clear_attribute_propagation_settings<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AttributePropagationSettings>,
    {
        self.attribute_propagation_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ApplicationSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ApplicationSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApplicationSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __csm_settings,
            __access_denied_page_settings,
            __cookie_domain,
            __attribute_propagation_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApplicationSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "csmSettings" => Ok(__FieldTag::__csm_settings),
                            "csm_settings" => Ok(__FieldTag::__csm_settings),
                            "accessDeniedPageSettings" => {
                                Ok(__FieldTag::__access_denied_page_settings)
                            }
                            "access_denied_page_settings" => {
                                Ok(__FieldTag::__access_denied_page_settings)
                            }
                            "cookieDomain" => Ok(__FieldTag::__cookie_domain),
                            "cookie_domain" => Ok(__FieldTag::__cookie_domain),
                            "attributePropagationSettings" => {
                                Ok(__FieldTag::__attribute_propagation_settings)
                            }
                            "attribute_propagation_settings" => {
                                Ok(__FieldTag::__attribute_propagation_settings)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApplicationSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApplicationSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__csm_settings => {
                            if !fields.insert(__FieldTag::__csm_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csm_settings",
                                ));
                            }
                            result.csm_settings =
                                map.next_value::<std::option::Option<crate::model::CsmSettings>>()?;
                        }
                        __FieldTag::__access_denied_page_settings => {
                            if !fields.insert(__FieldTag::__access_denied_page_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_denied_page_settings",
                                ));
                            }
                            result.access_denied_page_settings = map.next_value::<std::option::Option<crate::model::AccessDeniedPageSettings>>()?
                                ;
                        }
                        __FieldTag::__cookie_domain => {
                            if !fields.insert(__FieldTag::__cookie_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cookie_domain",
                                ));
                            }
                            result.cookie_domain =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__attribute_propagation_settings => {
                            if !fields.insert(__FieldTag::__attribute_propagation_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute_propagation_settings",
                                ));
                            }
                            result.attribute_propagation_settings = map.next_value::<std::option::Option<crate::model::AttributePropagationSettings>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApplicationSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.csm_settings.is_some() {
            state.serialize_entry("csmSettings", &self.csm_settings)?;
        }
        if self.access_denied_page_settings.is_some() {
            state.serialize_entry(
                "accessDeniedPageSettings",
                &self.access_denied_page_settings,
            )?;
        }
        if self.cookie_domain.is_some() {
            state.serialize_entry("cookieDomain", &self.cookie_domain)?;
        }
        if self.attribute_propagation_settings.is_some() {
            state.serialize_entry(
                "attributePropagationSettings",
                &self.attribute_propagation_settings,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for RCToken generated for service mesh workloads protected by
/// IAP. RCToken are IAP generated JWTs that can be verified at the application.
/// The RCToken is primarily used for service mesh deployments, and can be scoped
/// to a single mesh by configuring the audience field accordingly.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CsmSettings {
    /// Audience claim set in the generated RCToken. This value is not validated by
    /// IAP.
    pub rctoken_aud: std::option::Option<wkt::StringValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CsmSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rctoken_aud][crate::model::CsmSettings::rctoken_aud].
    pub fn set_rctoken_aud<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.rctoken_aud = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rctoken_aud][crate::model::CsmSettings::rctoken_aud].
    pub fn set_or_clear_rctoken_aud<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.rctoken_aud = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CsmSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.CsmSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CsmSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rctoken_aud,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CsmSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rctokenAud" => Ok(__FieldTag::__rctoken_aud),
                            "rctoken_aud" => Ok(__FieldTag::__rctoken_aud),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CsmSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CsmSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rctoken_aud => {
                            if !fields.insert(__FieldTag::__rctoken_aud) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rctoken_aud",
                                ));
                            }
                            result.rctoken_aud =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CsmSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rctoken_aud.is_some() {
            state.serialize_entry("rctokenAud", &self.rctoken_aud)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Custom content configuration for access denied page.
/// IAP allows customers to define a custom URI to use as the error page when
/// access is denied to users. If IAP prevents access to this page, the default
/// IAP error page will be displayed instead.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessDeniedPageSettings {
    /// The URI to be redirected to when access is denied.
    pub access_denied_page_uri: std::option::Option<wkt::StringValue>,

    /// Whether to generate a troubleshooting URL on access denied events to this
    /// application.
    pub generate_troubleshooting_uri: std::option::Option<wkt::BoolValue>,

    /// Whether to generate remediation token on access denied events to this
    /// application.
    pub remediation_token_generation_enabled: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessDeniedPageSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_denied_page_uri][crate::model::AccessDeniedPageSettings::access_denied_page_uri].
    pub fn set_access_denied_page_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.access_denied_page_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_denied_page_uri][crate::model::AccessDeniedPageSettings::access_denied_page_uri].
    pub fn set_or_clear_access_denied_page_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.access_denied_page_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [generate_troubleshooting_uri][crate::model::AccessDeniedPageSettings::generate_troubleshooting_uri].
    pub fn set_generate_troubleshooting_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.generate_troubleshooting_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generate_troubleshooting_uri][crate::model::AccessDeniedPageSettings::generate_troubleshooting_uri].
    pub fn set_or_clear_generate_troubleshooting_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.generate_troubleshooting_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [remediation_token_generation_enabled][crate::model::AccessDeniedPageSettings::remediation_token_generation_enabled].
    pub fn set_remediation_token_generation_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.remediation_token_generation_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [remediation_token_generation_enabled][crate::model::AccessDeniedPageSettings::remediation_token_generation_enabled].
    pub fn set_or_clear_remediation_token_generation_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.remediation_token_generation_enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AccessDeniedPageSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.AccessDeniedPageSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessDeniedPageSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_denied_page_uri,
            __generate_troubleshooting_uri,
            __remediation_token_generation_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessDeniedPageSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessDeniedPageUri" => Ok(__FieldTag::__access_denied_page_uri),
                            "access_denied_page_uri" => Ok(__FieldTag::__access_denied_page_uri),
                            "generateTroubleshootingUri" => {
                                Ok(__FieldTag::__generate_troubleshooting_uri)
                            }
                            "generate_troubleshooting_uri" => {
                                Ok(__FieldTag::__generate_troubleshooting_uri)
                            }
                            "remediationTokenGenerationEnabled" => {
                                Ok(__FieldTag::__remediation_token_generation_enabled)
                            }
                            "remediation_token_generation_enabled" => {
                                Ok(__FieldTag::__remediation_token_generation_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessDeniedPageSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessDeniedPageSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_denied_page_uri => {
                            if !fields.insert(__FieldTag::__access_denied_page_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_denied_page_uri",
                                ));
                            }
                            result.access_denied_page_uri =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__generate_troubleshooting_uri => {
                            if !fields.insert(__FieldTag::__generate_troubleshooting_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generate_troubleshooting_uri",
                                ));
                            }
                            result.generate_troubleshooting_uri =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__remediation_token_generation_enabled => {
                            if !fields.insert(__FieldTag::__remediation_token_generation_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation_token_generation_enabled",
                                ));
                            }
                            result.remediation_token_generation_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessDeniedPageSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.access_denied_page_uri.is_some() {
            state.serialize_entry("accessDeniedPageUri", &self.access_denied_page_uri)?;
        }
        if self.generate_troubleshooting_uri.is_some() {
            state.serialize_entry(
                "generateTroubleshootingUri",
                &self.generate_troubleshooting_uri,
            )?;
        }
        if self.remediation_token_generation_enabled.is_some() {
            state.serialize_entry(
                "remediationTokenGenerationEnabled",
                &self.remediation_token_generation_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for propagating attributes to applications protected
/// by IAP.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttributePropagationSettings {
    /// Optional. Raw string CEL expression. Must return a list of attributes. A
    /// maximum of 45 attributes can be selected. Expressions can select different
    /// attribute types from `attributes`: `attributes.saml_attributes`,
    /// `attributes.iap_attributes`. The following functions are supported:
    ///
    /// - filter `<list>.filter(<iter_var>, <predicate>)`: Returns a subset of
    ///   `<list>` where `<predicate>` is true for every item.
    ///
    /// - in `<var> in <list>`: Returns true if `<list>` contains `<var>`.
    ///
    /// - selectByName `<list>.selectByName(<string>)`: Returns the attribute
    ///   in
    ///   `<list>` with the given `<string>` name, otherwise returns empty.
    ///
    /// - emitAs `<attribute>.emitAs(<string>)`: Sets the `<attribute>` name
    ///   field to the given `<string>` for propagation in selected output
    ///   credentials.
    ///
    /// - strict `<attribute>.strict()`: Ignores the `x-goog-iap-attr-` prefix
    ///   for the provided `<attribute>` when propagating with the `HEADER` output
    ///   credential, such as request headers.
    ///
    /// - append `<target_list>.append(<attribute>)` OR
    ///   `<target_list>.append(<list>)`: Appends the provided `<attribute>` or
    ///   `<list>` to the end of `<target_list>`.
    ///
    ///
    /// Example expression: `attributes.saml_attributes.filter(x, x.name in
    /// ['test']).append(attributes.iap_attributes.selectByName('exact').emitAs('custom').strict())`
    pub expression: std::option::Option<std::string::String>,

    /// Optional. Which output credentials attributes selected by the CEL
    /// expression should be propagated in. All attributes will be fully duplicated
    /// in each selected output credential.
    pub output_credentials:
        std::vec::Vec<crate::model::attribute_propagation_settings::OutputCredentials>,

    /// Optional. Whether the provided attribute propagation settings should be
    /// evaluated on user requests. If set to true, attributes returned from the
    /// expression will be propagated in the set output credentials.
    pub enable: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttributePropagationSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expression][crate::model::AttributePropagationSettings::expression].
    pub fn set_expression<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.expression = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expression][crate::model::AttributePropagationSettings::expression].
    pub fn set_or_clear_expression<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.expression = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_credentials][crate::model::AttributePropagationSettings::output_credentials].
    pub fn set_output_credentials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::attribute_propagation_settings::OutputCredentials>,
    {
        use std::iter::Iterator;
        self.output_credentials = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable][crate::model::AttributePropagationSettings::enable].
    pub fn set_enable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable][crate::model::AttributePropagationSettings::enable].
    pub fn set_or_clear_enable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AttributePropagationSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.AttributePropagationSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttributePropagationSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expression,
            __output_credentials,
            __enable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributePropagationSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expression" => Ok(__FieldTag::__expression),
                            "outputCredentials" => Ok(__FieldTag::__output_credentials),
                            "output_credentials" => Ok(__FieldTag::__output_credentials),
                            "enable" => Ok(__FieldTag::__enable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttributePropagationSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributePropagationSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expression => {
                            if !fields.insert(__FieldTag::__expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expression",
                                ));
                            }
                            result.expression =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__output_credentials => {
                            if !fields.insert(__FieldTag::__output_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_credentials",
                                ));
                            }
                            result.output_credentials = map.next_value::<std::option::Option<std::vec::Vec<crate::model::attribute_propagation_settings::OutputCredentials>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enable => {
                            if !fields.insert(__FieldTag::__enable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable",
                                ));
                            }
                            result.enable = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttributePropagationSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.expression.is_some() {
            state.serialize_entry("expression", &self.expression)?;
        }
        if !self.output_credentials.is_empty() {
            state.serialize_entry("outputCredentials", &self.output_credentials)?;
        }
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AttributePropagationSettings].
pub mod attribute_propagation_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Supported output credentials for attribute propagation. Each output
    /// credential maps to a "field" in the response. For example, selecting JWT
    /// will propagate all attributes in the IAP JWT, header in the headers, etc.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputCredentials {
        /// An output credential is required.
        Unspecified,
        /// Propagate attributes in the headers with "x-goog-iap-attr-" prefix.
        Header,
        /// Propagate attributes in the JWT of the form: `"additional_claims": {
        /// "my_attribute": ["value1", "value2"] }`
        Jwt,
        /// Propagate attributes in the RCToken of the form: `"additional_claims": {
        /// "my_attribute": ["value1", "value2"] }`
        Rctoken,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OutputCredentials::value] or
        /// [OutputCredentials::name].
        UnknownValue(output_credentials::UnknownValue),
    }

    #[doc(hidden)]
    pub mod output_credentials {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OutputCredentials {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Header => std::option::Option::Some(1),
                Self::Jwt => std::option::Option::Some(2),
                Self::Rctoken => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OUTPUT_CREDENTIALS_UNSPECIFIED"),
                Self::Header => std::option::Option::Some("HEADER"),
                Self::Jwt => std::option::Option::Some("JWT"),
                Self::Rctoken => std::option::Option::Some("RCTOKEN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OutputCredentials {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OutputCredentials {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OutputCredentials {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Header,
                2 => Self::Jwt,
                3 => Self::Rctoken,
                _ => Self::UnknownValue(output_credentials::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OutputCredentials {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OUTPUT_CREDENTIALS_UNSPECIFIED" => Self::Unspecified,
                "HEADER" => Self::Header,
                "JWT" => Self::Jwt,
                "RCTOKEN" => Self::Rctoken,
                _ => Self::UnknownValue(output_credentials::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OutputCredentials {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Header => serializer.serialize_i32(1),
                Self::Jwt => serializer.serialize_i32(2),
                Self::Rctoken => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OutputCredentials {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OutputCredentials>::new(
                ".google.cloud.iap.v1.AttributePropagationSettings.OutputCredentials",
            ))
        }
    }
}

/// Request sent to IAP Expression Linter endpoint.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateIapAttributeExpressionRequest {
    /// Required. The resource name of the IAP protected resource.
    pub name: std::string::String,

    /// Required. User input string expression. Should be of the form
    /// `attributes.saml_attributes.filter(attribute, attribute.name in
    /// ['{attribute_name}', '{attribute_name}'])`
    pub expression: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateIapAttributeExpressionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateIapAttributeExpressionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expression][crate::model::ValidateIapAttributeExpressionRequest::expression].
    pub fn set_expression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expression = v.into();
        self
    }
}

impl wkt::message::Message for ValidateIapAttributeExpressionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ValidateIapAttributeExpressionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateIapAttributeExpressionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __expression,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ValidateIapAttributeExpressionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "expression" => Ok(__FieldTag::__expression),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateIapAttributeExpressionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateIapAttributeExpressionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expression => {
                            if !fields.insert(__FieldTag::__expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expression",
                                ));
                            }
                            result.expression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateIapAttributeExpressionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.expression.is_empty() {
            state.serialize_entry("expression", &self.expression)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// IAP Expression Linter endpoint returns empty response body.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateIapAttributeExpressionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateIapAttributeExpressionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ValidateIapAttributeExpressionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ValidateIapAttributeExpressionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateIapAttributeExpressionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ValidateIapAttributeExpressionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateIapAttributeExpressionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateIapAttributeExpressionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateIapAttributeExpressionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to ListBrands.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBrandsRequest {
    /// Required. GCP Project number/id.
    /// In the following format: projects/{project_number/id}.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBrandsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBrandsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListBrandsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ListBrandsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBrandsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBrandsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBrandsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBrandsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBrandsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListBrands.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBrandsResponse {
    /// Brands existing in the project.
    pub brands: std::vec::Vec<crate::model::Brand>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBrandsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [brands][crate::model::ListBrandsResponse::brands].
    pub fn set_brands<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Brand>,
    {
        use std::iter::Iterator;
        self.brands = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBrandsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ListBrandsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBrandsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __brands,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBrandsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "brands" => Ok(__FieldTag::__brands),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBrandsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBrandsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__brands => {
                            if !fields.insert(__FieldTag::__brands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for brands",
                                ));
                            }
                            result.brands = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Brand>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBrandsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.brands.is_empty() {
            state.serialize_entry("brands", &self.brands)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to CreateBrand.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBrandRequest {
    /// Required. GCP Project number/id under which the brand is to be created.
    /// In the following format: projects/{project_number/id}.
    pub parent: std::string::String,

    /// Required. The brand to be created.
    pub brand: std::option::Option<crate::model::Brand>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBrandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBrandRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [brand][crate::model::CreateBrandRequest::brand].
    pub fn set_brand<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Brand>,
    {
        self.brand = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [brand][crate::model::CreateBrandRequest::brand].
    pub fn set_or_clear_brand<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Brand>,
    {
        self.brand = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBrandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.CreateBrandRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBrandRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __brand,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBrandRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "brand" => Ok(__FieldTag::__brand),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBrandRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBrandRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__brand => {
                            if !fields.insert(__FieldTag::__brand) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for brand",
                                ));
                            }
                            result.brand =
                                map.next_value::<std::option::Option<crate::model::Brand>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBrandRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.brand.is_some() {
            state.serialize_entry("brand", &self.brand)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to GetBrand.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBrandRequest {
    /// Required. Name of the brand to be fetched.
    /// In the following format: projects/{project_number/id}/brands/{brand}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBrandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBrandRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBrandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.GetBrandRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBrandRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBrandRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBrandRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBrandRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBrandRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to ListIdentityAwareProxyClients.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIdentityAwareProxyClientsRequest {
    /// Required. Full brand path.
    /// In the following format: projects/{project_number/id}/brands/{brand}.
    pub parent: std::string::String,

    /// The maximum number of clients to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 100 clients will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListIdentityAwareProxyClients`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListIdentityAwareProxyClients` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIdentityAwareProxyClientsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIdentityAwareProxyClientsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIdentityAwareProxyClientsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIdentityAwareProxyClientsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIdentityAwareProxyClientsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ListIdentityAwareProxyClientsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIdentityAwareProxyClientsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIdentityAwareProxyClientsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIdentityAwareProxyClientsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIdentityAwareProxyClientsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIdentityAwareProxyClientsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListIdentityAwareProxyClients.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIdentityAwareProxyClientsResponse {
    /// Clients existing in the brand.
    pub identity_aware_proxy_clients: std::vec::Vec<crate::model::IdentityAwareProxyClient>,

    /// A token, which can be send as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIdentityAwareProxyClientsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [identity_aware_proxy_clients][crate::model::ListIdentityAwareProxyClientsResponse::identity_aware_proxy_clients].
    pub fn set_identity_aware_proxy_clients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IdentityAwareProxyClient>,
    {
        use std::iter::Iterator;
        self.identity_aware_proxy_clients = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIdentityAwareProxyClientsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIdentityAwareProxyClientsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ListIdentityAwareProxyClientsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIdentityAwareProxyClientsResponse {
    type PageItem = crate::model::IdentityAwareProxyClient;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.identity_aware_proxy_clients
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIdentityAwareProxyClientsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __identity_aware_proxy_clients,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListIdentityAwareProxyClientsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "identityAwareProxyClients" => {
                                Ok(__FieldTag::__identity_aware_proxy_clients)
                            }
                            "identity_aware_proxy_clients" => {
                                Ok(__FieldTag::__identity_aware_proxy_clients)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIdentityAwareProxyClientsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIdentityAwareProxyClientsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__identity_aware_proxy_clients => {
                            if !fields.insert(__FieldTag::__identity_aware_proxy_clients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_aware_proxy_clients",
                                ));
                            }
                            result.identity_aware_proxy_clients = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::IdentityAwareProxyClient>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIdentityAwareProxyClientsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.identity_aware_proxy_clients.is_empty() {
            state.serialize_entry(
                "identityAwareProxyClients",
                &self.identity_aware_proxy_clients,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to CreateIdentityAwareProxyClient.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIdentityAwareProxyClientRequest {
    /// Required. Path to create the client in.
    /// In the following format:
    /// projects/{project_number/id}/brands/{brand}.
    /// The project must belong to a G Suite account.
    pub parent: std::string::String,

    /// Required. Identity Aware Proxy Client to be created.
    pub identity_aware_proxy_client: std::option::Option<crate::model::IdentityAwareProxyClient>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIdentityAwareProxyClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIdentityAwareProxyClientRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [identity_aware_proxy_client][crate::model::CreateIdentityAwareProxyClientRequest::identity_aware_proxy_client].
    pub fn set_identity_aware_proxy_client<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IdentityAwareProxyClient>,
    {
        self.identity_aware_proxy_client = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity_aware_proxy_client][crate::model::CreateIdentityAwareProxyClientRequest::identity_aware_proxy_client].
    pub fn set_or_clear_identity_aware_proxy_client<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IdentityAwareProxyClient>,
    {
        self.identity_aware_proxy_client = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateIdentityAwareProxyClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.CreateIdentityAwareProxyClientRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIdentityAwareProxyClientRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __identity_aware_proxy_client,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for CreateIdentityAwareProxyClientRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "identityAwareProxyClient" => {
                                Ok(__FieldTag::__identity_aware_proxy_client)
                            }
                            "identity_aware_proxy_client" => {
                                Ok(__FieldTag::__identity_aware_proxy_client)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIdentityAwareProxyClientRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIdentityAwareProxyClientRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__identity_aware_proxy_client => {
                            if !fields.insert(__FieldTag::__identity_aware_proxy_client) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_aware_proxy_client",
                                ));
                            }
                            result.identity_aware_proxy_client = map.next_value::<std::option::Option<crate::model::IdentityAwareProxyClient>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateIdentityAwareProxyClientRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.identity_aware_proxy_client.is_some() {
            state.serialize_entry(
                "identityAwareProxyClient",
                &self.identity_aware_proxy_client,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to GetIdentityAwareProxyClient.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIdentityAwareProxyClientRequest {
    /// Required. Name of the Identity Aware Proxy client to be fetched.
    /// In the following format:
    /// projects/{project_number/id}/brands/{brand}/identityAwareProxyClients/{client_id}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIdentityAwareProxyClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIdentityAwareProxyClientRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIdentityAwareProxyClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.GetIdentityAwareProxyClientRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIdentityAwareProxyClientRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIdentityAwareProxyClientRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIdentityAwareProxyClientRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIdentityAwareProxyClientRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetIdentityAwareProxyClientRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to ResetIdentityAwareProxyClientSecret.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetIdentityAwareProxyClientSecretRequest {
    /// Required. Name of the Identity Aware Proxy client to that will have its
    /// secret reset. In the following format:
    /// projects/{project_number/id}/brands/{brand}/identityAwareProxyClients/{client_id}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetIdentityAwareProxyClientSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetIdentityAwareProxyClientSecretRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetIdentityAwareProxyClientSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.ResetIdentityAwareProxyClientSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetIdentityAwareProxyClientSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ResetIdentityAwareProxyClientSecretRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetIdentityAwareProxyClientSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetIdentityAwareProxyClientSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetIdentityAwareProxyClientSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request sent to DeleteIdentityAwareProxyClient.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIdentityAwareProxyClientRequest {
    /// Required. Name of the Identity Aware Proxy client to be deleted.
    /// In the following format:
    /// projects/{project_number/id}/brands/{brand}/identityAwareProxyClients/{client_id}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIdentityAwareProxyClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIdentityAwareProxyClientRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIdentityAwareProxyClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.DeleteIdentityAwareProxyClientRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIdentityAwareProxyClientRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DeleteIdentityAwareProxyClientRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIdentityAwareProxyClientRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIdentityAwareProxyClientRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteIdentityAwareProxyClientRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// OAuth brand data.
/// NOTE: Only contains a portion of the data that describes a brand.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Brand {
    /// Output only. Identifier of the brand.
    /// NOTE: GCP project number achieves the same brand identification purpose as
    /// only one brand per project can be created.
    pub name: std::string::String,

    /// Support email displayed on the OAuth consent screen.
    pub support_email: std::string::String,

    /// Application name displayed on OAuth consent screen.
    pub application_title: std::string::String,

    /// Output only. Whether the brand is only intended for usage inside the
    /// G Suite organization only.
    pub org_internal_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Brand {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Brand::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [support_email][crate::model::Brand::support_email].
    pub fn set_support_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.support_email = v.into();
        self
    }

    /// Sets the value of [application_title][crate::model::Brand::application_title].
    pub fn set_application_title<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.application_title = v.into();
        self
    }

    /// Sets the value of [org_internal_only][crate::model::Brand::org_internal_only].
    pub fn set_org_internal_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.org_internal_only = v.into();
        self
    }
}

impl wkt::message::Message for Brand {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.Brand"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Brand {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __support_email,
            __application_title,
            __org_internal_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Brand")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "supportEmail" => Ok(__FieldTag::__support_email),
                            "support_email" => Ok(__FieldTag::__support_email),
                            "applicationTitle" => Ok(__FieldTag::__application_title),
                            "application_title" => Ok(__FieldTag::__application_title),
                            "orgInternalOnly" => Ok(__FieldTag::__org_internal_only),
                            "org_internal_only" => Ok(__FieldTag::__org_internal_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Brand;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Brand")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__support_email => {
                            if !fields.insert(__FieldTag::__support_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_email",
                                ));
                            }
                            result.support_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__application_title => {
                            if !fields.insert(__FieldTag::__application_title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_title",
                                ));
                            }
                            result.application_title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__org_internal_only => {
                            if !fields.insert(__FieldTag::__org_internal_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for org_internal_only",
                                ));
                            }
                            result.org_internal_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Brand {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.support_email.is_empty() {
            state.serialize_entry("supportEmail", &self.support_email)?;
        }
        if !self.application_title.is_empty() {
            state.serialize_entry("applicationTitle", &self.application_title)?;
        }
        if !wkt::internal::is_default(&self.org_internal_only) {
            state.serialize_entry("orgInternalOnly", &self.org_internal_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains the data that describes an Identity Aware Proxy owned client.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IdentityAwareProxyClient {
    /// Output only. Unique identifier of the OAuth client.
    pub name: std::string::String,

    /// Output only. Client secret of the OAuth client.
    pub secret: std::string::String,

    /// Human-friendly name given to the OAuth client.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IdentityAwareProxyClient {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IdentityAwareProxyClient::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::IdentityAwareProxyClient::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::IdentityAwareProxyClient::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for IdentityAwareProxyClient {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.iap.v1.IdentityAwareProxyClient"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IdentityAwareProxyClient {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __secret,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IdentityAwareProxyClient")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "secret" => Ok(__FieldTag::__secret),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IdentityAwareProxyClient;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IdentityAwareProxyClient")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            result.secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IdentityAwareProxyClient {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.secret.is_empty() {
            state.serialize_entry("secret", &self.secret)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
