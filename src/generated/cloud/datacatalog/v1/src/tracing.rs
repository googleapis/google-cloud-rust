// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [DataCatalog](super::stub::DataCatalog) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct DataCatalog<T>
where
    T: super::stub::DataCatalog + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> DataCatalog<T>
where
    T: super::stub::DataCatalog + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::DataCatalog for DataCatalog<T>
where
    T: super::stub::DataCatalog + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn search_catalog(
        &self,
        req: crate::model::SearchCatalogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchCatalogResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::search_catalog"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search_catalog",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .search_catalog(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search_catalog(
        &self,
        req: crate::model::SearchCatalogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchCatalogResponse>> {
        self.inner.search_catalog(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_entry_group(
        &self,
        req: crate::model::CreateEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::create_entry_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_entry_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_entry_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_entry_group(
        &self,
        req: crate::model::CreateEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryGroup>> {
        self.inner.create_entry_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_entry_group(
        &self,
        req: crate::model::GetEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::get_entry_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_entry_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_entry_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_entry_group(
        &self,
        req: crate::model::GetEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryGroup>> {
        self.inner.get_entry_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_entry_group(
        &self,
        req: crate::model::UpdateEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::update_entry_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_entry_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_entry_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_entry_group(
        &self,
        req: crate::model::UpdateEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryGroup>> {
        self.inner.update_entry_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_entry_group(
        &self,
        req: crate::model::DeleteEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::delete_entry_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_entry_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_entry_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_entry_group(
        &self,
        req: crate::model::DeleteEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_entry_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_entry_groups(
        &self,
        req: crate::model::ListEntryGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntryGroupsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::list_entry_groups"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_entry_groups",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_entry_groups(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_entry_groups(
        &self,
        req: crate::model::ListEntryGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntryGroupsResponse>> {
        self.inner.list_entry_groups(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_entry(
        &self,
        req: crate::model::CreateEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::create_entry"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_entry",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_entry(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_entry(
        &self,
        req: crate::model::CreateEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        self.inner.create_entry(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_entry(
        &self,
        req: crate::model::UpdateEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::update_entry"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_entry",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_entry(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_entry(
        &self,
        req: crate::model::UpdateEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        self.inner.update_entry(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_entry(
        &self,
        req: crate::model::DeleteEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::delete_entry"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_entry",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_entry(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_entry(
        &self,
        req: crate::model::DeleteEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_entry(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_entry(
        &self,
        req: crate::model::GetEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::get_entry"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_entry",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_entry(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_entry(
        &self,
        req: crate::model::GetEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        self.inner.get_entry(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn lookup_entry(
        &self,
        req: crate::model::LookupEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::lookup_entry"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "lookup_entry",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .lookup_entry(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn lookup_entry(
        &self,
        req: crate::model::LookupEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        self.inner.lookup_entry(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_entries(
        &self,
        req: crate::model::ListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntriesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::list_entries"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_entries",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_entries(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_entries(
        &self,
        req: crate::model::ListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntriesResponse>> {
        self.inner.list_entries(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn modify_entry_overview(
        &self,
        req: crate::model::ModifyEntryOverviewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryOverview>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::modify_entry_overview"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "modify_entry_overview",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .modify_entry_overview(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn modify_entry_overview(
        &self,
        req: crate::model::ModifyEntryOverviewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryOverview>> {
        self.inner.modify_entry_overview(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn modify_entry_contacts(
        &self,
        req: crate::model::ModifyEntryContactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Contacts>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::modify_entry_contacts"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "modify_entry_contacts",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .modify_entry_contacts(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn modify_entry_contacts(
        &self,
        req: crate::model::ModifyEntryContactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Contacts>> {
        self.inner.modify_entry_contacts(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tag_template(
        &self,
        req: crate::model::CreateTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::create_tag_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tag_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tag_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tag_template(
        &self,
        req: crate::model::CreateTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplate>> {
        self.inner.create_tag_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_tag_template(
        &self,
        req: crate::model::GetTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::get_tag_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_tag_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_tag_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_tag_template(
        &self,
        req: crate::model::GetTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplate>> {
        self.inner.get_tag_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_tag_template(
        &self,
        req: crate::model::UpdateTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::update_tag_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_tag_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_tag_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_tag_template(
        &self,
        req: crate::model::UpdateTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplate>> {
        self.inner.update_tag_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_tag_template(
        &self,
        req: crate::model::DeleteTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::delete_tag_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_tag_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_tag_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_tag_template(
        &self,
        req: crate::model::DeleteTagTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_tag_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tag_template_field(
        &self,
        req: crate::model::CreateTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::create_tag_template_field"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tag_template_field",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tag_template_field(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tag_template_field(
        &self,
        req: crate::model::CreateTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        self.inner.create_tag_template_field(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_tag_template_field(
        &self,
        req: crate::model::UpdateTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::update_tag_template_field"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_tag_template_field",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_tag_template_field(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_tag_template_field(
        &self,
        req: crate::model::UpdateTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        self.inner.update_tag_template_field(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn rename_tag_template_field(
        &self,
        req: crate::model::RenameTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::rename_tag_template_field"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "rename_tag_template_field",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .rename_tag_template_field(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn rename_tag_template_field(
        &self,
        req: crate::model::RenameTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        self.inner.rename_tag_template_field(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn rename_tag_template_field_enum_value(
        &self,
        req: crate::model::RenameTagTemplateFieldEnumValueRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::rename_tag_template_field_enum_value"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "rename_tag_template_field_enum_value",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .rename_tag_template_field_enum_value(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn rename_tag_template_field_enum_value(
        &self,
        req: crate::model::RenameTagTemplateFieldEnumValueRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TagTemplateField>> {
        self.inner
            .rename_tag_template_field_enum_value(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_tag_template_field(
        &self,
        req: crate::model::DeleteTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::delete_tag_template_field"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_tag_template_field",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_tag_template_field(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_tag_template_field(
        &self,
        req: crate::model::DeleteTagTemplateFieldRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_tag_template_field(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tag(
        &self,
        req: crate::model::CreateTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Tag>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::create_tag"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tag",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tag(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tag(
        &self,
        req: crate::model::CreateTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Tag>> {
        self.inner.create_tag(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_tag(
        &self,
        req: crate::model::UpdateTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Tag>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::update_tag"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_tag",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_tag(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_tag(
        &self,
        req: crate::model::UpdateTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Tag>> {
        self.inner.update_tag(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_tag(
        &self,
        req: crate::model::DeleteTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::delete_tag"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_tag",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_tag(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_tag(
        &self,
        req: crate::model::DeleteTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_tag(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tags(
        &self,
        req: crate::model::ListTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTagsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::list_tags"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tags",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tags(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tags(
        &self,
        req: crate::model::ListTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTagsResponse>> {
        self.inner.list_tags(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn reconcile_tags(
        &self,
        req: crate::model::ReconcileTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::reconcile_tags"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "reconcile_tags",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .reconcile_tags(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn reconcile_tags(
        &self,
        req: crate::model::ReconcileTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.reconcile_tags(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn star_entry(
        &self,
        req: crate::model::StarEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StarEntryResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::star_entry"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "star_entry",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .star_entry(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn star_entry(
        &self,
        req: crate::model::StarEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StarEntryResponse>> {
        self.inner.star_entry(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn unstar_entry(
        &self,
        req: crate::model::UnstarEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UnstarEntryResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::unstar_entry"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "unstar_entry",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .unstar_entry(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn unstar_entry(
        &self,
        req: crate::model::UnstarEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UnstarEntryResponse>> {
        self.inner.unstar_entry(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_entries(
        &self,
        req: crate::model::ImportEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::import_entries"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_entries",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_entries(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_entries(
        &self,
        req: crate::model::ImportEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_entries(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_config(
        &self,
        req: crate::model::SetConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MigrationConfig>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::set_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_config",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_config(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_config(
        &self,
        req: crate::model::SetConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MigrationConfig>> {
        self.inner.set_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn retrieve_config(
        &self,
        req: crate::model::RetrieveConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OrganizationConfig>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::retrieve_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "retrieve_config",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .retrieve_config(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn retrieve_config(
        &self,
        req: crate::model::RetrieveConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OrganizationConfig>> {
        self.inner.retrieve_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn retrieve_effective_config(
        &self,
        req: crate::model::RetrieveEffectiveConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MigrationConfig>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::retrieve_effective_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "retrieve_effective_config",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .retrieve_effective_config(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn retrieve_effective_config(
        &self,
        req: crate::model::RetrieveEffectiveConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MigrationConfig>> {
        self.inner.retrieve_effective_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataCatalog",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PolicyTagManager](super::stub::PolicyTagManager) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct PolicyTagManager<T>
where
    T: super::stub::PolicyTagManager + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> PolicyTagManager<T>
where
    T: super::stub::PolicyTagManager + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::PolicyTagManager for PolicyTagManager<T>
where
    T: super::stub::PolicyTagManager + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_taxonomy(
        &self,
        req: crate::model::CreateTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::create_taxonomy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_taxonomy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_taxonomy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_taxonomy(
        &self,
        req: crate::model::CreateTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        self.inner.create_taxonomy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_taxonomy(
        &self,
        req: crate::model::DeleteTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::delete_taxonomy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_taxonomy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_taxonomy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_taxonomy(
        &self,
        req: crate::model::DeleteTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_taxonomy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_taxonomy(
        &self,
        req: crate::model::UpdateTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::update_taxonomy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_taxonomy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_taxonomy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_taxonomy(
        &self,
        req: crate::model::UpdateTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        self.inner.update_taxonomy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_taxonomies(
        &self,
        req: crate::model::ListTaxonomiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTaxonomiesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::list_taxonomies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_taxonomies",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_taxonomies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_taxonomies(
        &self,
        req: crate::model::ListTaxonomiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTaxonomiesResponse>> {
        self.inner.list_taxonomies(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_taxonomy(
        &self,
        req: crate::model::GetTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::get_taxonomy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_taxonomy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_taxonomy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_taxonomy(
        &self,
        req: crate::model::GetTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        self.inner.get_taxonomy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_policy_tag(
        &self,
        req: crate::model::CreatePolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PolicyTag>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::create_policy_tag"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_policy_tag",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_policy_tag(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_policy_tag(
        &self,
        req: crate::model::CreatePolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PolicyTag>> {
        self.inner.create_policy_tag(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_policy_tag(
        &self,
        req: crate::model::DeletePolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::delete_policy_tag"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_policy_tag",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_policy_tag(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_policy_tag(
        &self,
        req: crate::model::DeletePolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_policy_tag(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_policy_tag(
        &self,
        req: crate::model::UpdatePolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PolicyTag>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::update_policy_tag"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_policy_tag",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_policy_tag(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_policy_tag(
        &self,
        req: crate::model::UpdatePolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PolicyTag>> {
        self.inner.update_policy_tag(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_policy_tags(
        &self,
        req: crate::model::ListPolicyTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPolicyTagsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::list_policy_tags"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_policy_tags",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_policy_tags(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_policy_tags(
        &self,
        req: crate::model::ListPolicyTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPolicyTagsResponse>> {
        self.inner.list_policy_tags(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_policy_tag(
        &self,
        req: crate::model::GetPolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PolicyTag>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::get_policy_tag"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_policy_tag",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_policy_tag(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_policy_tag(
        &self,
        req: crate::model::GetPolicyTagRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PolicyTag>> {
        self.inner.get_policy_tag(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManager",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [PolicyTagManagerSerialization](super::stub::PolicyTagManagerSerialization) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct PolicyTagManagerSerialization<T>
where
    T: super::stub::PolicyTagManagerSerialization + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> PolicyTagManagerSerialization<T>
where
    T: super::stub::PolicyTagManagerSerialization + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::PolicyTagManagerSerialization for PolicyTagManagerSerialization<T>
where
    T: super::stub::PolicyTagManagerSerialization + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn replace_taxonomy(
        &self,
        req: crate::model::ReplaceTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManagerSerialization",
            "::replace_taxonomy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "replace_taxonomy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .replace_taxonomy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn replace_taxonomy(
        &self,
        req: crate::model::ReplaceTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Taxonomy>> {
        self.inner.replace_taxonomy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_taxonomies(
        &self,
        req: crate::model::ImportTaxonomiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImportTaxonomiesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManagerSerialization",
            "::import_taxonomies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_taxonomies",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_taxonomies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_taxonomies(
        &self,
        req: crate::model::ImportTaxonomiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImportTaxonomiesResponse>> {
        self.inner.import_taxonomies(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_taxonomies(
        &self,
        req: crate::model::ExportTaxonomiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExportTaxonomiesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManagerSerialization",
            "::export_taxonomies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_taxonomies",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_taxonomies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_taxonomies(
        &self,
        req: crate::model::ExportTaxonomiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExportTaxonomiesResponse>> {
        self.inner.export_taxonomies(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManagerSerialization",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManagerSerialization",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManagerSerialization",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PolicyTagManagerSerialization",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}
