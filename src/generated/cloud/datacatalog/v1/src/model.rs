// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Specification for the BigQuery connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryConnectionSpec {
    /// The type of the BigQuery connection.
    pub connection_type: crate::model::big_query_connection_spec::ConnectionType,

    /// True if there are credentials attached to the BigQuery connection; false
    /// otherwise.
    pub has_credential: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connection_spec:
        std::option::Option<crate::model::big_query_connection_spec::ConnectionSpec>,
}

impl BigQueryConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_type][crate::model::BigQueryConnectionSpec::connection_type].
    pub fn set_connection_type<
        T: std::convert::Into<crate::model::big_query_connection_spec::ConnectionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }

    /// Sets the value of [has_credential][crate::model::BigQueryConnectionSpec::has_credential].
    pub fn set_has_credential<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_credential = v.into();
        self
    }

    /// Sets the value of `connection_spec`.
    pub fn set_connection_spec<
        T: std::convert::Into<
            std::option::Option<crate::model::big_query_connection_spec::ConnectionSpec>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_spec = v.into();
        self
    }

    /// The value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_sql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>> {
        #[allow(unreachable_patterns)]
        self.connection_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_connection_spec::ConnectionSpec::CloudSql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `connection_spec` are
    /// mutually exclusive.
    pub fn set_cloud_sql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_spec = std::option::Option::Some(
            crate::model::big_query_connection_spec::ConnectionSpec::CloudSql(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryConnectionSpec"
    }
}

/// Defines additional types related to BigQueryConnectionSpec
pub mod big_query_connection_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the BigQuery connection.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConnectionType(i32);

    impl ConnectionType {
        /// Unspecified type.
        pub const CONNECTION_TYPE_UNSPECIFIED: ConnectionType = ConnectionType::new(0);

        /// Cloud SQL connection.
        pub const CLOUD_SQL: ConnectionType = ConnectionType::new(1);

        /// Creates a new ConnectionType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONNECTION_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLOUD_SQL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONNECTION_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONNECTION_TYPE_UNSPECIFIED)
                }
                "CLOUD_SQL" => std::option::Option::Some(Self::CLOUD_SQL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConnectionType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConnectionType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConnectionSpec {
        /// Specification for the BigQuery connection to a Cloud SQL instance.
        CloudSql(std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>),
    }
}

/// Specification for the BigQuery connection to a Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlBigQueryConnectionSpec {
    /// Cloud SQL instance ID in the format of `project:location:instance`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Database name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Type of the Cloud SQL database.
    #[serde(rename = "type")]
    pub r#type: crate::model::cloud_sql_big_query_connection_spec::DatabaseType,
}

impl CloudSqlBigQueryConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_id][crate::model::CloudSqlBigQueryConnectionSpec::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CloudSqlBigQueryConnectionSpec::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CloudSqlBigQueryConnectionSpec::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::cloud_sql_big_query_connection_spec::DatabaseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlBigQueryConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudSqlBigQueryConnectionSpec"
    }
}

/// Defines additional types related to CloudSqlBigQueryConnectionSpec
pub mod cloud_sql_big_query_connection_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Cloud SQL database types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DatabaseType(i32);

    impl DatabaseType {
        /// Unspecified database type.
        pub const DATABASE_TYPE_UNSPECIFIED: DatabaseType = DatabaseType::new(0);

        /// Cloud SQL for PostgreSQL.
        pub const POSTGRES: DatabaseType = DatabaseType::new(1);

        /// Cloud SQL for MySQL.
        pub const MYSQL: DatabaseType = DatabaseType::new(2);

        /// Creates a new DatabaseType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATABASE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("POSTGRES"),
                2 => std::borrow::Cow::Borrowed("MYSQL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATABASE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATABASE_TYPE_UNSPECIFIED)
                }
                "POSTGRES" => std::option::Option::Some(Self::POSTGRES),
                "MYSQL" => std::option::Option::Some(Self::MYSQL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Fields specific for BigQuery routines.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryRoutineSpec {
    /// Paths of the imported libraries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub imported_libraries: std::vec::Vec<std::string::String>,
}

impl BigQueryRoutineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_libraries][crate::model::BigQueryRoutineSpec::imported_libraries].
    pub fn set_imported_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.imported_libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryRoutineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryRoutineSpec"
    }
}

/// Entry metadata relevant only to the user and private to them.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PersonalDetails {
    /// True if the entry is starred by the user; false otherwise.
    pub starred: bool,

    /// Set if the entry is starred; unset otherwise.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub star_time: std::option::Option<wkt::Timestamp>,
}

impl PersonalDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [starred][crate::model::PersonalDetails::starred].
    pub fn set_starred<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.starred = v.into();
        self
    }

    /// Sets the value of [star_time][crate::model::PersonalDetails::star_time].
    pub fn set_star_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.star_time = v.into();
        self
    }
}

impl wkt::message::Message for PersonalDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PersonalDetails"
    }
}

/// Physical location of an entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSource {
    /// Service that physically stores the data.
    pub service: crate::model::data_source::Service,

    /// Full name of a resource as defined by the service. For example:
    ///
    /// `//bigquery.googleapis.com/projects/{PROJECT_ID}/locations/{LOCATION}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// Output only. Data Catalog entry name, if applicable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_entry: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::data_source::Properties>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::DataSource::service].
    pub fn set_service<T: std::convert::Into<crate::model::data_source::Service>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::DataSource::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [source_entry][crate::model::DataSource::source_entry].
    pub fn set_source_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entry = v.into();
        self
    }

    /// Sets the value of `properties`.
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::data_source::Properties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::DataSource::properties]
    /// if it holds a `StorageProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_storage_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::data_source::Properties::StorageProperties(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::DataSource::properties]
    /// to hold a `StorageProperties`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_storage_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = std::option::Option::Some(
            crate::model::data_source::Properties::StorageProperties(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataSource"
    }
}

/// Defines additional types related to DataSource
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;

    /// Name of a service that stores the data.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Service(i32);

    impl Service {
        /// Default unknown service.
        pub const SERVICE_UNSPECIFIED: Service = Service::new(0);

        /// Google Cloud Storage service.
        pub const CLOUD_STORAGE: Service = Service::new(1);

        /// BigQuery service.
        pub const BIGQUERY: Service = Service::new(2);

        /// Creates a new Service instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SERVICE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLOUD_STORAGE"),
                2 => std::borrow::Cow::Borrowed("BIGQUERY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SERVICE_UNSPECIFIED" => std::option::Option::Some(Self::SERVICE_UNSPECIFIED),
                "CLOUD_STORAGE" => std::option::Option::Some(Self::CLOUD_STORAGE),
                "BIGQUERY" => std::option::Option::Some(Self::BIGQUERY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Service {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Service {
        fn default() -> Self {
            Self::new(0)
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Properties {
        /// Detailed properties of the underlying storage.
        StorageProperties(std::boxed::Box<crate::model::StorageProperties>),
    }
}

/// Details the properties of the underlying storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageProperties {
    /// Patterns to identify a set of files for this fileset.
    ///
    /// Examples of a valid `file_pattern`:
    ///
    /// * `gs://bucket_name/dir/*`: matches all files in the `bucket_name/dir`
    ///   directory
    /// * `gs://bucket_name/dir/**`: matches all files in the `bucket_name/dir`
    ///   and all subdirectories recursively
    /// * `gs://bucket_name/file*`: matches files prefixed by `file` in
    ///   `bucket_name`
    /// * `gs://bucket_name/??.txt`: matches files with two characters followed by
    ///   `.txt` in `bucket_name`
    /// * `gs://bucket_name/[aeiou].txt`: matches files that contain a single
    ///   vowel character followed by `.txt` in
    ///   `bucket_name`
    /// * `gs://bucket_name/[a-m].txt`: matches files that contain `a`, `b`, ...
    ///   or `m` followed by `.txt` in `bucket_name`
    /// * `gs://bucket_name/a/*/b`: matches all files in `bucket_name` that match
    ///   the `a/*/b` pattern, such as `a/c/b`, `a/d/b`
    /// * `gs://another_bucket/a.txt`: matches `gs://another_bucket/a.txt`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_pattern: std::vec::Vec<std::string::String>,

    /// File type in MIME format, for example, `text/plain`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_type: std::string::String,
}

impl StorageProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_type][crate::model::StorageProperties::file_type].
    pub fn set_file_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [file_pattern][crate::model::StorageProperties::file_pattern].
    pub fn set_file_pattern<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_pattern = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StorageProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StorageProperties"
    }
}

/// Request message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchCatalogRequest {
    /// Required. The scope of this search request.
    ///
    /// The `scope` is invalid if `include_org_ids`, `include_project_ids` are
    /// empty AND `include_gcp_public_datasets` is set to `false`. In this case,
    /// the request returns an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scope: std::option::Option<crate::model::search_catalog_request::Scope>,

    /// Optional. The query string with a minimum of 3 characters and specific
    /// syntax. For more information, see [Data Catalog search
    /// syntax](https://cloud.google.com/data-catalog/docs/how-to/search-reference).
    ///
    /// An empty query string returns all data assets (in the specified scope)
    /// that you have access to.
    ///
    /// A query string can be a simple `xyz` or qualified by predicates:
    ///
    /// * `name:x`
    /// * `column:y`
    /// * `description:z`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Upper bound on the number of results you can get in a single response.
    ///
    /// Can't be negative or 0, defaults to 10 in this case.
    /// The maximum number is 1000. If exceeded, throws an "invalid argument"
    /// exception.
    pub page_size: i32,

    /// Optional. Pagination token that, if specified, returns the next page of
    /// search results. If empty, returns the first page.
    ///
    /// This token is returned in the
    /// [SearchCatalogResponse.next_page_token][google.cloud.datacatalog.v1.SearchCatalogResponse.next_page_token]
    /// field of the response to a previous
    /// [SearchCatalogRequest][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]
    /// call.
    ///
    /// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
    /// [google.cloud.datacatalog.v1.SearchCatalogResponse.next_page_token]: crate::model::SearchCatalogResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Specifies the order of results.
    ///
    /// Currently supported case-sensitive values are:
    ///
    /// * `relevance` that can only be descending
    /// * `last_modified_timestamp [asc|desc]` with descending (`desc`) as default
    /// * `default` that can only be descending
    ///
    /// Search queries don't guarantee full recall. Results that match your query
    /// might not be returned, even in subsequent result pages. Additionally,
    /// returned (and not returned) results can vary if you repeat search queries.
    /// If you are experiencing recall issues and you don't have to fetch the
    /// results in any specific order, consider setting this parameter to
    /// `default`.
    ///
    /// If this parameter is omitted, it defaults to the descending `relevance`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. If set, use searchAll permission granted on organizations from
    /// `include_org_ids` and projects from `include_project_ids` instead of the
    /// fine grained per resource permissions when filtering the search results.
    /// The only allowed `order_by` criteria for admin_search mode is `default`.
    /// Using this flags guarantees a full recall of the search results.
    pub admin_search: bool,
}

impl SearchCatalogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::SearchCatalogRequest::scope].
    pub fn set_scope<
        T: std::convert::Into<std::option::Option<crate::model::search_catalog_request::Scope>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchCatalogRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchCatalogRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchCatalogRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchCatalogRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [admin_search][crate::model::SearchCatalogRequest::admin_search].
    pub fn set_admin_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.admin_search = v.into();
        self
    }
}

impl wkt::message::Message for SearchCatalogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogRequest"
    }
}

/// Defines additional types related to SearchCatalogRequest
pub mod search_catalog_request {
    #[allow(unused_imports)]
    use super::*;

    /// The criteria that select the subspace used for query matching.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Scope {
        /// The list of organization IDs to search within.
        ///
        /// To find your organization ID, follow the steps from
        /// [Creating and managing organizations]
        /// (/resource-manager/docs/creating-managing-organization).
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub include_org_ids: std::vec::Vec<std::string::String>,

        /// The list of project IDs to search within.
        ///
        /// For more information on the distinction between project names, IDs, and
        /// numbers, see [Projects](/docs/overview/#projects).
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub include_project_ids: std::vec::Vec<std::string::String>,

        /// If `true`, include Google Cloud public datasets in
        /// search results. By default, they are excluded.
        ///
        /// See [Google Cloud Public Datasets](/public-datasets) for more
        /// information.
        pub include_gcp_public_datasets: bool,

        /// Optional. The list of locations to search within. If empty, all locations
        /// are searched.
        ///
        /// Returns an error if any location in the list isn't one of the [Supported
        /// regions](https://cloud.google.com/data-catalog/docs/concepts/regions#supported_regions).
        ///
        /// If a location is unreachable, its name is returned in the
        /// `SearchCatalogResponse.unreachable` field. To get additional information
        /// on the error, repeat the search request and set the location name as the
        /// value of this parameter.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub restricted_locations: std::vec::Vec<std::string::String>,

        /// Optional. If `true`, search only among starred entries.
        ///
        /// By default, all results are returned, starred or not.
        pub starred_only: bool,

        /// Optional. This field is deprecated. The search mechanism for public and
        /// private tag templates is the same.
        pub include_public_tag_templates: bool,
    }

    impl Scope {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [include_gcp_public_datasets][crate::model::search_catalog_request::Scope::include_gcp_public_datasets].
        pub fn set_include_gcp_public_datasets<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.include_gcp_public_datasets = v.into();
            self
        }

        /// Sets the value of [starred_only][crate::model::search_catalog_request::Scope::starred_only].
        pub fn set_starred_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.starred_only = v.into();
            self
        }

        /// Sets the value of [include_public_tag_templates][crate::model::search_catalog_request::Scope::include_public_tag_templates].
        pub fn set_include_public_tag_templates<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.include_public_tag_templates = v.into();
            self
        }

        /// Sets the value of [include_org_ids][crate::model::search_catalog_request::Scope::include_org_ids].
        pub fn set_include_org_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_org_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [include_project_ids][crate::model::search_catalog_request::Scope::include_project_ids].
        pub fn set_include_project_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_project_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [restricted_locations][crate::model::search_catalog_request::Scope::restricted_locations].
        pub fn set_restricted_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.restricted_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Scope {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogRequest.Scope"
        }
    }
}

/// Response message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchCatalogResponse {
    /// Search results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::SearchCatalogResult>,

    /// The approximate total number of entries matched by the query.
    pub total_size: i32,

    /// Pagination token that can be used in subsequent calls to retrieve the next
    /// page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable locations. Search results don't include data from those
    /// locations.
    ///
    /// To get additional information on an error, repeat the search request and
    /// restrict it to specific locations by setting the
    /// `SearchCatalogRequest.scope.restricted_locations` parameter.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl SearchCatalogResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_size][crate::model::SearchCatalogResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchCatalogResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [results][crate::model::SearchCatalogResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchCatalogResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::SearchCatalogResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchCatalogResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchCatalogResponse {
    type PageItem = crate::model::SearchCatalogResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.results
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [CreateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.CreateEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateEntryGroup]: crate::client::DataCatalog::create_entry_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntryGroupRequest {
    /// Required. The names of the project and location that the new entry group
    /// belongs to.
    ///
    /// Note: The entry group itself and its child resources might not be
    /// stored in the location specified in its name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the entry group to create.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and must start with a letter or underscore.
    /// The maximum size is 64 bytes when encoded in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_group_id: std::string::String,

    /// The entry group to create. Defaults to empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_group: std::option::Option<crate::model::EntryGroup>,
}

impl CreateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_group_id][crate::model::CreateEntryGroupRequest::entry_group_id].
    pub fn set_entry_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_group_id = v.into();
        self
    }

    /// Sets the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T: std::convert::Into<std::option::Option<crate::model::EntryGroup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_group = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateEntryGroupRequest"
    }
}

/// Request message for
/// [UpdateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.UpdateEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateEntryGroup]: crate::client::DataCatalog::update_entry_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntryGroupRequest {
    /// Required. Updates for the entry group. The `name` field must be set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    /// Names of fields whose values to overwrite on an entry group.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T: std::convert::Into<std::option::Option<crate::model::EntryGroup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_group = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateEntryGroupRequest"
    }
}

/// Request message for
/// [GetEntryGroup][google.cloud.datacatalog.v1.DataCatalog.GetEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetEntryGroup]: crate::client::DataCatalog::get_entry_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntryGroupRequest {
    /// Required. The name of the entry group to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The fields to return. If empty or omitted, all fields are returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl GetEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetEntryGroupRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetEntryGroupRequest"
    }
}

/// Request message for
/// [DeleteEntryGroup][google.cloud.datacatalog.v1.DataCatalog.DeleteEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteEntryGroup]: crate::client::DataCatalog::delete_entry_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntryGroupRequest {
    /// Required. The name of the entry group to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If true, deletes all entries in the entry group.
    pub force: bool,
}

impl DeleteEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntryGroupRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteEntryGroupRequest"
    }
}

/// Request message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups]: crate::client::DataCatalog::list_entry_groups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntryGroupsRequest {
    /// Required. The name of the location that contains the entry groups to list.
    ///
    /// Can be provided as a URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// Default is 10. Maximum limit is 1000.
    /// Throws an invalid argument if `page_size` is greater than 1000.
    pub page_size: i32,

    /// Optional. Pagination token that specifies the next page to return.
    /// If empty, returns the first page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListEntryGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntryGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntryGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntryGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntryGroupsRequest"
    }
}

/// Response message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups]: crate::client::DataCatalog::list_entry_groups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntryGroupsResponse {
    /// Entry group details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entry_groups: std::vec::Vec<crate::model::EntryGroup>,

    /// Pagination token to specify in the next call to retrieve the next page of
    /// results. Empty if there are no more items.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListEntryGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEntryGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [entry_groups][crate::model::ListEntryGroupsResponse::entry_groups].
    pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntryGroup>,
    {
        use std::iter::Iterator;
        self.entry_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntryGroupsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEntryGroupsResponse {
    type PageItem = crate::model::EntryGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entry_groups
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [CreateEntry][google.cloud.datacatalog.v1.DataCatalog.CreateEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateEntry]: crate::client::DataCatalog::create_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntryRequest {
    /// Required. The name of the entry group this entry belongs to.
    ///
    /// Note: The entry itself and its child resources might not be stored in
    /// the location specified in its name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the entry to create.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// and underscores (_).
    /// The maximum size is 64 bytes when encoded in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_id: std::string::String,

    /// Required. The entry to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry: std::option::Option<crate::model::Entry>,
}

impl CreateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_id][crate::model::CreateEntryRequest::entry_id].
    pub fn set_entry_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_id = v.into();
        self
    }

    /// Sets the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_entry<T: std::convert::Into<std::option::Option<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateEntryRequest"
    }
}

/// Request message for
/// [UpdateEntry][google.cloud.datacatalog.v1.DataCatalog.UpdateEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateEntry]: crate::client::DataCatalog::update_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntryRequest {
    /// Required. Updates for the entry. The `name` field must be set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry: std::option::Option<crate::model::Entry>,

    /// Names of fields whose values to overwrite on an entry.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    ///
    /// You can modify only the fields listed below.
    ///
    /// For entries with type `DATA_STREAM`:
    ///
    /// * `schema`
    ///
    /// For entries with type `FILESET`:
    ///
    /// * `schema`
    /// * `display_name`
    /// * `description`
    /// * `gcs_fileset_spec`
    /// * `gcs_fileset_spec.file_patterns`
    ///
    /// For entries with `user_specified_type`:
    ///
    /// * `schema`
    /// * `display_name`
    /// * `description`
    /// * `user_specified_type`
    /// * `user_specified_system`
    /// * `linked_resource`
    /// * `source_system_timestamps`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_entry<T: std::convert::Into<std::option::Option<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateEntryRequest"
    }
}

/// Request message for
/// [DeleteEntry][google.cloud.datacatalog.v1.DataCatalog.DeleteEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteEntry]: crate::client::DataCatalog::delete_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntryRequest {
    /// Required. The name of the entry to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteEntryRequest"
    }
}

/// Request message for
/// [GetEntry][google.cloud.datacatalog.v1.DataCatalog.GetEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetEntry]: crate::client::DataCatalog::get_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntryRequest {
    /// Required. The name of the entry to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetEntryRequest"
    }
}

/// Request message for
/// [LookupEntry][google.cloud.datacatalog.v1.DataCatalog.LookupEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.LookupEntry]: crate::client::DataCatalog::lookup_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LookupEntryRequest {
    /// Project where the lookup should be performed. Required to lookup
    /// entry that is not a part of `DPMS` or `DATAPLEX` `integrated_system`
    /// using its `fully_qualified_name`. Ignored in other cases.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Location where the lookup should be performed. Required to lookup
    /// entry that is not a part of `DPMS` or `DATAPLEX` `integrated_system`
    /// using its `fully_qualified_name`. Ignored in other cases.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Required. A full name, SQL name, or a fully qualified name of a
    /// Google Cloud Platform resource.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_name: std::option::Option<crate::model::lookup_entry_request::TargetName>,
}

impl LookupEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::LookupEntryRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::LookupEntryRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of `target_name`.
    pub fn set_target_name<
        T: std::convert::Into<std::option::Option<crate::model::lookup_entry_request::TargetName>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_name = v.into();
        self
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `LinkedResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_linked_resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::LinkedResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `SqlResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sql_resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::SqlResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `FullyQualifiedName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fully_qualified_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::FullyQualifiedName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `LinkedResource`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::LinkedResource(v.into()),
        );
        self
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `SqlResource`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_sql_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::SqlResource(v.into()),
        );
        self
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `FullyQualifiedName`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::FullyQualifiedName(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LookupEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.LookupEntryRequest"
    }
}

/// Defines additional types related to LookupEntryRequest
pub mod lookup_entry_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. A full name, SQL name, or a fully qualified name of a
    /// Google Cloud Platform resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetName {
        /// The full name of the Google Cloud Platform resource the Data Catalog
        /// entry represents. For more information, see [Full Resource Name]
        /// (<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
        ///
        /// Full names are case-sensitive. For example:
        ///
        /// * `//bigquery.googleapis.com/projects/{PROJECT_ID}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
        /// * `//pubsub.googleapis.com/projects/{PROJECT_ID}/topics/{TOPIC_ID}`
        LinkedResource(std::string::String),
        /// The SQL name of the entry. SQL names are case-sensitive.
        ///
        /// Examples:
        ///
        /// * `pubsub.topic.{PROJECT_ID}.{TOPIC_ID}`
        /// * `pubsub.topic.{PROJECT_ID}.`\``{TOPIC.ID.SEPARATED.WITH.DOTS}`\`
        /// * `bigquery.table.{PROJECT_ID}.{DATASET_ID}.{TABLE_ID}`
        /// * `bigquery.dataset.{PROJECT_ID}.{DATASET_ID}`
        /// * `datacatalog.entry.{PROJECT_ID}.{LOCATION_ID}.{ENTRY_GROUP_ID}.{ENTRY_ID}`
        ///
        /// Identifiers (`*_ID`) should comply with the
        /// [Lexical structure in Standard SQL]
        /// (<https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical>).
        SqlResource(std::string::String),
        /// [Fully Qualified Name
        /// (FQN)](https://cloud.google.com//data-catalog/docs/fully-qualified-names)
        /// of the resource.
        ///
        /// FQNs take two forms:
        ///
        /// * For non-regionalized resources:
        ///
        /// * `{SYSTEM}:{PROJECT}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
        ///
        /// * For regionalized resources:
        ///
        /// * `{SYSTEM}:{PROJECT}.{LOCATION_ID}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
        ///
        ///
        /// Example for a DPMS table:
        ///
        /// `dataproc_metastore:{PROJECT_ID}.{LOCATION_ID}.{INSTANCE_ID}.{DATABASE_ID}.{TABLE_ID}`
        FullyQualifiedName(std::string::String),
    }
}

/// Entry metadata.
/// A Data Catalog entry represents another resource in Google
/// Cloud Platform (such as a BigQuery dataset or a Pub/Sub topic) or
/// outside of it. You can use the `linked_resource` field
/// in the entry resource to refer to the original resource ID of the source
/// system.
///
/// An entry resource contains resource details, for example, its schema.
/// Additionally, you can attach flexible metadata to an entry in the form of a
/// [Tag][google.cloud.datacatalog.v1.Tag].
///
/// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entry {
    /// Output only. Identifier. The resource name of an entry in URL format.
    ///
    /// Note: The entry itself and its child resources might not be
    /// stored in the location specified in its name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The resource this metadata entry refers to.
    ///
    /// For Google Cloud Platform resources, `linked_resource` is the
    /// [Full Resource Name]
    /// (<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
    /// For example, the `linked_resource` for a table resource from BigQuery is:
    ///
    /// `//bigquery.googleapis.com/projects/{PROJECT_ID}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
    ///
    /// Output only when the entry is one of the types in the `EntryType` enum.
    ///
    /// For entries with a `user_specified_type`, this field is optional and
    /// defaults to an empty string.
    ///
    /// The resource string must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), periods (.), colons (:), slashes (/), dashes (-),
    /// and hashes (#).
    /// The maximum size is 200 bytes when encoded in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub linked_resource: std::string::String,

    /// [Fully Qualified Name
    /// (FQN)](https://cloud.google.com//data-catalog/docs/fully-qualified-names)
    /// of the resource. Set automatically for entries representing resources from
    /// synced systems. Settable only during creation, and read-only later. Can
    /// be used for search and lookup of the entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fully_qualified_name: std::string::String,

    /// Display name of an entry.
    ///
    /// The maximum size is 500 bytes when encoded in UTF-8.
    /// Default value is an empty string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Entry description that can consist of several sentences or paragraphs
    /// that describe entry contents.
    ///
    /// The description must not contain Unicode non-characters as well as C0
    /// and C1 control codes except tabs (HT), new lines (LF), carriage returns
    /// (CR), and page breaks (FF).
    /// The maximum size is 2000 bytes when encoded in UTF-8.
    /// Default value is an empty string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Business Context of the entry. Not supported for BigQuery datasets
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub business_context: std::option::Option<crate::model::BusinessContext>,

    /// Schema of the entry. An entry might not have any schema attached to it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::Schema>,

    /// Timestamps from the underlying resource, not from the Data Catalog
    /// entry.
    ///
    /// Output only when the entry has a system listed in the `IntegratedSystem`
    /// enum. For entries with `user_specified_system`, this field is optional
    /// and defaults to an empty timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_system_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Resource usage statistics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub usage_signal: std::option::Option<crate::model::UsageSignal>,

    /// Cloud labels attached to the entry.
    ///
    /// In Data Catalog, you can create and modify labels attached only to custom
    /// entries. Synced entries have unmodifiable labels that come from the source
    /// system.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Physical location of the entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::DataSource>,

    /// Output only. Additional information related to the entry. Private to the
    /// current user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub personal_details: std::option::Option<crate::model::PersonalDetails>,

    /// Required. Entry type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub entry_type: std::option::Option<crate::model::entry::EntryType>,

    /// The source system of the entry.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system: std::option::Option<crate::model::entry::System>,

    /// System specification.
    /// Can be used as a complement for `spec`, when some metadata is relevant for
    /// all entries existing within given system
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system_spec: std::option::Option<crate::model::entry::SystemSpec>,

    /// Type specification.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub type_spec: std::option::Option<crate::model::entry::TypeSpec>,

    /// Type- and system-specific information. Specifications for types contain
    /// fields common to all entries of a given type, and sub-specifications with
    /// fields specific to a given source system.
    ///
    /// When extending the API with new types and systems, use this field instead
    /// of the legacy `type_spec`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::entry::Spec>,
}

impl Entry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [linked_resource][crate::model::Entry::linked_resource].
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::Entry::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Entry::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Entry::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [business_context][crate::model::Entry::business_context].
    pub fn set_business_context<
        T: std::convert::Into<std::option::Option<crate::model::BusinessContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.business_context = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::Entry::schema].
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [source_system_timestamps][crate::model::Entry::source_system_timestamps].
    pub fn set_source_system_timestamps<
        T: std::convert::Into<std::option::Option<crate::model::SystemTimestamps>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_system_timestamps = v.into();
        self
    }

    /// Sets the value of [usage_signal][crate::model::Entry::usage_signal].
    pub fn set_usage_signal<
        T: std::convert::Into<std::option::Option<crate::model::UsageSignal>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.usage_signal = v.into();
        self
    }

    /// Sets the value of [data_source][crate::model::Entry::data_source].
    pub fn set_data_source<T: std::convert::Into<std::option::Option<crate::model::DataSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// Sets the value of [personal_details][crate::model::Entry::personal_details].
    pub fn set_personal_details<
        T: std::convert::Into<std::option::Option<crate::model::PersonalDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.personal_details = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Entry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `entry_type`.
    pub fn set_entry_type<
        T: std::convert::Into<std::option::Option<crate::model::entry::EntryType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry_type = v.into();
        self
    }

    /// The value of [entry_type][crate::model::Entry::entry_type]
    /// if it holds a `Type`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_type(&self) -> std::option::Option<&crate::model::EntryType> {
        #[allow(unreachable_patterns)]
        self.entry_type.as_ref().and_then(|v| match v {
            crate::model::entry::EntryType::Type(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entry_type][crate::model::Entry::entry_type]
    /// if it holds a `UserSpecifiedType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_user_specified_type(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.entry_type.as_ref().and_then(|v| match v {
            crate::model::entry::EntryType::UserSpecifiedType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type]
    /// to hold a `Type`.
    ///
    /// Note that all the setters affecting `entry_type` are
    /// mutually exclusive.
    pub fn set_type<T: std::convert::Into<crate::model::EntryType>>(mut self, v: T) -> Self {
        self.entry_type = std::option::Option::Some(crate::model::entry::EntryType::Type(v.into()));
        self
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type]
    /// to hold a `UserSpecifiedType`.
    ///
    /// Note that all the setters affecting `entry_type` are
    /// mutually exclusive.
    pub fn set_user_specified_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_type =
            std::option::Option::Some(crate::model::entry::EntryType::UserSpecifiedType(v.into()));
        self
    }

    /// Sets the value of `system`.
    pub fn set_system<T: std::convert::Into<std::option::Option<crate::model::entry::System>>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = v.into();
        self
    }

    /// The value of [system][crate::model::Entry::system]
    /// if it holds a `IntegratedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_integrated_system(&self) -> std::option::Option<&crate::model::IntegratedSystem> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::entry::System::IntegratedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [system][crate::model::Entry::system]
    /// if it holds a `UserSpecifiedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_user_specified_system(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::entry::System::UserSpecifiedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::Entry::system]
    /// to hold a `IntegratedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_integrated_system<T: std::convert::Into<crate::model::IntegratedSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.system =
            std::option::Option::Some(crate::model::entry::System::IntegratedSystem(v.into()));
        self
    }

    /// Sets the value of [system][crate::model::Entry::system]
    /// to hold a `UserSpecifiedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_user_specified_system<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.system =
            std::option::Option::Some(crate::model::entry::System::UserSpecifiedSystem(v.into()));
        self
    }

    /// Sets the value of `system_spec`.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::entry::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `SqlDatabaseSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sql_database_system_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlDatabaseSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::SqlDatabaseSystemSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `LookerSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_looker_system_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LookerSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::LookerSystemSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `CloudBigtableSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_bigtable_system_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudBigtableSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::CloudBigtableSystemSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `SqlDatabaseSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_sql_database_system_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlDatabaseSystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::entry::SystemSpec::SqlDatabaseSystemSpec(v.into()),
        );
        self
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `LookerSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_looker_system_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::LookerSystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec =
            std::option::Option::Some(crate::model::entry::SystemSpec::LookerSystemSpec(v.into()));
        self
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `CloudBigtableSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_cloud_bigtable_system_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudBigtableSystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::entry::SystemSpec::CloudBigtableSystemSpec(v.into()),
        );
        self
    }

    /// Sets the value of `type_spec`.
    pub fn set_type_spec<
        T: std::convert::Into<std::option::Option<crate::model::entry::TypeSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = v.into();
        self
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `GcsFilesetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_fileset_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsFilesetSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::GcsFilesetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `BigqueryTableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigquery_table_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::BigqueryTableSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `BigqueryDateShardedSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigquery_date_sharded_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDateShardedSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::BigqueryDateShardedSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `GcsFilesetSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_gcs_fileset_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsFilesetSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec =
            std::option::Option::Some(crate::model::entry::TypeSpec::GcsFilesetSpec(v.into()));
        self
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `BigqueryTableSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_table_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec =
            std::option::Option::Some(crate::model::entry::TypeSpec::BigqueryTableSpec(v.into()));
        self
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `BigqueryDateShardedSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_date_sharded_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDateShardedSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::entry::TypeSpec::BigqueryDateShardedSpec(v.into()),
        );
        self
    }

    /// Sets the value of `spec`.
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::entry::Spec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DatabaseTableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_database_table_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseTableSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DatabaseTableSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DataSourceConnectionSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_data_source_connection_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataSourceConnectionSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DataSourceConnectionSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `RoutineSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_routine_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RoutineSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::RoutineSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DatasetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_dataset_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatasetSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DatasetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `FilesetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fileset_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FilesetSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::FilesetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `ServiceSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_service_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ServiceSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::ServiceSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `ModelSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_model_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ModelSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::ModelSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `FeatureOnlineStoreSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_feature_online_store_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureOnlineStoreSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::FeatureOnlineStoreSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DatabaseTableSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_database_table_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseTableSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::entry::Spec::DatabaseTableSpec(v.into()));
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DataSourceConnectionSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_source_connection_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataSourceConnectionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::DataSourceConnectionSpec(
            v.into(),
        ));
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `RoutineSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_routine_spec<T: std::convert::Into<std::boxed::Box<crate::model::RoutineSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::RoutineSpec(v.into()));
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DatasetSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_dataset_spec<T: std::convert::Into<std::boxed::Box<crate::model::DatasetSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::DatasetSpec(v.into()));
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `FilesetSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_fileset_spec<T: std::convert::Into<std::boxed::Box<crate::model::FilesetSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::FilesetSpec(v.into()));
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `ServiceSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_service_spec<T: std::convert::Into<std::boxed::Box<crate::model::ServiceSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::ServiceSpec(v.into()));
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `ModelSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_model_spec<T: std::convert::Into<std::boxed::Box<crate::model::ModelSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::ModelSpec(v.into()));
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `FeatureOnlineStoreSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_feature_online_store_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::FeatureOnlineStoreSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::entry::Spec::FeatureOnlineStoreSpec(v.into()));
        self
    }
}

impl wkt::message::Message for Entry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Entry"
    }
}

/// Defines additional types related to Entry
pub mod entry {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Entry type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EntryType {
        /// The type of the entry.
        ///
        /// For details, see [`EntryType`](#entrytype).
        Type(crate::model::EntryType),
        /// Custom entry type that doesn't match any of the values allowed for input
        /// and listed in the `EntryType` enum.
        ///
        /// When creating an entry, first check the type values in the enum.
        /// If there are no appropriate types for the new entry,
        /// provide a custom value, for example, `my_special_type`.
        ///
        /// The `user_specified_type` string has the following limitations:
        ///
        /// * Is case insensitive.
        /// * Must begin with a letter or underscore.
        /// * Can only contain letters, numbers, and underscores.
        /// * Must be at least 1 character and at most 64 characters long.
        UserSpecifiedType(std::string::String),
    }

    /// The source system of the entry.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum System {
        /// Output only. Indicates the entry's source system that Data Catalog
        /// integrates with, such as BigQuery, Pub/Sub, or Dataproc Metastore.
        IntegratedSystem(crate::model::IntegratedSystem),
        /// Indicates the entry's source system that Data Catalog doesn't
        /// automatically integrate with.
        ///
        /// The `user_specified_system` string has the following limitations:
        ///
        /// * Is case insensitive.
        /// * Must begin with a letter or underscore.
        /// * Can only contain letters, numbers, and underscores.
        /// * Must be at least 1 character and at most 64 characters long.
        UserSpecifiedSystem(std::string::String),
    }

    /// System specification.
    /// Can be used as a complement for `spec`, when some metadata is relevant for
    /// all entries existing within given system
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification that applies to a relational database system. Only settable
        /// when `user_specified_system` is equal to `SQL_DATABASE`
        SqlDatabaseSystemSpec(std::boxed::Box<crate::model::SqlDatabaseSystemSpec>),
        /// Specification that applies to Looker sysstem. Only settable when
        /// `user_specified_system` is equal to `LOOKER`
        LookerSystemSpec(std::boxed::Box<crate::model::LookerSystemSpec>),
        /// Specification that applies to Cloud Bigtable system. Only settable when
        /// `integrated_system` is equal to `CLOUD_BIGTABLE`
        CloudBigtableSystemSpec(std::boxed::Box<crate::model::CloudBigtableSystemSpec>),
    }

    /// Type specification.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TypeSpec {
        /// Specification that applies to a Cloud Storage fileset. Valid only
        /// for entries with the `FILESET` type.
        GcsFilesetSpec(std::boxed::Box<crate::model::GcsFilesetSpec>),
        /// Output only. Specification that applies to a BigQuery table. Valid only
        /// for entries with the `TABLE` type.
        BigqueryTableSpec(std::boxed::Box<crate::model::BigQueryTableSpec>),
        /// Output only. Specification for a group of BigQuery tables with
        /// the `[prefix]YYYYMMDD` name pattern.
        ///
        /// For more information, see [Introduction to partitioned tables]
        /// (<https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding>).
        BigqueryDateShardedSpec(std::boxed::Box<crate::model::BigQueryDateShardedSpec>),
    }

    /// Type- and system-specific information. Specifications for types contain
    /// fields common to all entries of a given type, and sub-specifications with
    /// fields specific to a given source system.
    ///
    /// When extending the API with new types and systems, use this field instead
    /// of the legacy `type_spec`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Spec {
        /// Specification that applies to a table resource. Valid only
        /// for entries with the `TABLE` or `EXPLORE` type.
        DatabaseTableSpec(std::boxed::Box<crate::model::DatabaseTableSpec>),
        /// Specification that applies to a data source connection. Valid only
        /// for entries with the `DATA_SOURCE_CONNECTION` type.
        DataSourceConnectionSpec(std::boxed::Box<crate::model::DataSourceConnectionSpec>),
        /// Specification that applies to a user-defined function or procedure. Valid
        /// only for entries with the `ROUTINE` type.
        RoutineSpec(std::boxed::Box<crate::model::RoutineSpec>),
        /// Specification that applies to a dataset.
        DatasetSpec(std::boxed::Box<crate::model::DatasetSpec>),
        /// Specification that applies to a fileset resource. Valid only
        /// for entries with the `FILESET` type.
        FilesetSpec(std::boxed::Box<crate::model::FilesetSpec>),
        /// Specification that applies to a Service resource.
        ServiceSpec(std::boxed::Box<crate::model::ServiceSpec>),
        /// Model specification.
        ModelSpec(std::boxed::Box<crate::model::ModelSpec>),
        /// FeatureonlineStore spec for Vertex AI Feature Store.
        FeatureOnlineStoreSpec(std::boxed::Box<crate::model::FeatureOnlineStoreSpec>),
    }
}

/// Specification that applies to a table resource. Valid only
/// for entries with the `TABLE` type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseTableSpec {
    /// Type of this table.
    #[serde(rename = "type")]
    pub r#type: crate::model::database_table_spec::TableType,

    /// Output only. Fields specific to a Dataplex table and present only in the
    /// Dataplex table entries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataplex_table: std::option::Option<crate::model::DataplexTableSpec>,

    /// Spec what aplies to tables that are actually views.
    /// Not set for "real" tables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database_view_spec:
        std::option::Option<crate::model::database_table_spec::DatabaseViewSpec>,
}

impl DatabaseTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::DatabaseTableSpec::type].
    pub fn set_type<T: std::convert::Into<crate::model::database_table_spec::TableType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [dataplex_table][crate::model::DatabaseTableSpec::dataplex_table].
    pub fn set_dataplex_table<
        T: std::convert::Into<std::option::Option<crate::model::DataplexTableSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_table = v.into();
        self
    }

    /// Sets the value of [database_view_spec][crate::model::DatabaseTableSpec::database_view_spec].
    pub fn set_database_view_spec<
        T: std::convert::Into<
            std::option::Option<crate::model::database_table_spec::DatabaseViewSpec>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_view_spec = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DatabaseTableSpec"
    }
}

/// Defines additional types related to DatabaseTableSpec
pub mod database_table_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Specification that applies to database view.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DatabaseViewSpec {
        /// Type of this view.
        pub view_type: crate::model::database_table_spec::database_view_spec::ViewType,

        /// Definition of the view.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source_definition: std::option::Option<
            crate::model::database_table_spec::database_view_spec::SourceDefinition,
        >,
    }

    impl DatabaseViewSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [view_type][crate::model::database_table_spec::DatabaseViewSpec::view_type].
        pub fn set_view_type<
            T: std::convert::Into<crate::model::database_table_spec::database_view_spec::ViewType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.view_type = v.into();
            self
        }

        /// Sets the value of `source_definition`.
        pub fn set_source_definition<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::database_table_spec::database_view_spec::SourceDefinition,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_definition = v.into();
            self
        }

        /// The value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// if it holds a `BaseTable`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_base_table(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source_definition.as_ref().and_then(|v| match v {
                crate::model::database_table_spec::database_view_spec::SourceDefinition::BaseTable(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// if it holds a `SqlQuery`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_sql_query(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source_definition.as_ref().and_then(|v| match v {
                crate::model::database_table_spec::database_view_spec::SourceDefinition::SqlQuery(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// to hold a `BaseTable`.
        ///
        /// Note that all the setters affecting `source_definition` are
        /// mutually exclusive.
        pub fn set_base_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_definition = std::option::Option::Some(
                crate::model::database_table_spec::database_view_spec::SourceDefinition::BaseTable(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// to hold a `SqlQuery`.
        ///
        /// Note that all the setters affecting `source_definition` are
        /// mutually exclusive.
        pub fn set_sql_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_definition = std::option::Option::Some(
                crate::model::database_table_spec::database_view_spec::SourceDefinition::SqlQuery(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for DatabaseViewSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.DatabaseTableSpec.DatabaseViewSpec"
        }
    }

    /// Defines additional types related to DatabaseViewSpec
    pub mod database_view_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Concrete type of the view.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ViewType(i32);

        impl ViewType {
            /// Default unknown view type.
            pub const VIEW_TYPE_UNSPECIFIED: ViewType = ViewType::new(0);

            /// Standard view.
            pub const STANDARD_VIEW: ViewType = ViewType::new(1);

            /// Materialized view.
            pub const MATERIALIZED_VIEW: ViewType = ViewType::new(2);

            /// Creates a new ViewType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("VIEW_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("STANDARD_VIEW"),
                    2 => std::borrow::Cow::Borrowed("MATERIALIZED_VIEW"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "VIEW_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::VIEW_TYPE_UNSPECIFIED)
                    }
                    "STANDARD_VIEW" => std::option::Option::Some(Self::STANDARD_VIEW),
                    "MATERIALIZED_VIEW" => std::option::Option::Some(Self::MATERIALIZED_VIEW),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for ViewType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for ViewType {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// Definition of the view.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum SourceDefinition {
            /// Name of a singular table this view reflects one to one.
            BaseTable(std::string::String),
            /// SQL query used to generate this view.
            SqlQuery(std::string::String),
        }
    }

    /// Type of the table.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TableType(i32);

    impl TableType {
        /// Default unknown table type.
        pub const TABLE_TYPE_UNSPECIFIED: TableType = TableType::new(0);

        /// Native table.
        pub const NATIVE: TableType = TableType::new(1);

        /// External table.
        pub const EXTERNAL: TableType = TableType::new(2);

        /// Creates a new TableType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TABLE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NATIVE"),
                2 => std::borrow::Cow::Borrowed("EXTERNAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TABLE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TABLE_TYPE_UNSPECIFIED),
                "NATIVE" => std::option::Option::Some(Self::NATIVE),
                "EXTERNAL" => std::option::Option::Some(Self::EXTERNAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TableType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TableType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Specification that applies to a fileset. Valid only for entries with the
/// 'FILESET' type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilesetSpec {
    /// Fields specific to a Dataplex fileset and present only in the Dataplex
    /// fileset entries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataplex_fileset: std::option::Option<crate::model::DataplexFilesetSpec>,
}

impl FilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataplex_fileset][crate::model::FilesetSpec::dataplex_fileset].
    pub fn set_dataplex_fileset<
        T: std::convert::Into<std::option::Option<crate::model::DataplexFilesetSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_fileset = v.into();
        self
    }
}

impl wkt::message::Message for FilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FilesetSpec"
    }
}

/// Specification that applies to a data source connection. Valid only for
/// entries with the `DATA_SOURCE_CONNECTION` type.
/// Only one of internal specs can be set at the time, and cannot
/// be changed later.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSourceConnectionSpec {
    /// Output only. Fields specific to BigQuery connections.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigquery_connection_spec: std::option::Option<crate::model::BigQueryConnectionSpec>,
}

impl DataSourceConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_connection_spec][crate::model::DataSourceConnectionSpec::bigquery_connection_spec].
    pub fn set_bigquery_connection_spec<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryConnectionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_connection_spec = v.into();
        self
    }
}

impl wkt::message::Message for DataSourceConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataSourceConnectionSpec"
    }
}

/// Specification that applies to a routine. Valid only for
/// entries with the `ROUTINE` type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RoutineSpec {
    /// The type of the routine.
    pub routine_type: crate::model::routine_spec::RoutineType,

    /// The language the routine is written in. The exact value depends on the
    /// source system. For BigQuery routines, possible values are:
    ///
    /// * `SQL`
    /// * `JAVASCRIPT`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language: std::string::String,

    /// Arguments of the routine.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub routine_arguments: std::vec::Vec<crate::model::routine_spec::Argument>,

    /// Return type of the argument. The exact value depends on the source system
    /// and the language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub return_type: std::string::String,

    /// The body of the routine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub definition_body: std::string::String,

    /// Contains fields specific to the source system.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system_spec: std::option::Option<crate::model::routine_spec::SystemSpec>,
}

impl RoutineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [routine_type][crate::model::RoutineSpec::routine_type].
    pub fn set_routine_type<T: std::convert::Into<crate::model::routine_spec::RoutineType>>(
        mut self,
        v: T,
    ) -> Self {
        self.routine_type = v.into();
        self
    }

    /// Sets the value of [language][crate::model::RoutineSpec::language].
    pub fn set_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language = v.into();
        self
    }

    /// Sets the value of [return_type][crate::model::RoutineSpec::return_type].
    pub fn set_return_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.return_type = v.into();
        self
    }

    /// Sets the value of [definition_body][crate::model::RoutineSpec::definition_body].
    pub fn set_definition_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition_body = v.into();
        self
    }

    /// Sets the value of [routine_arguments][crate::model::RoutineSpec::routine_arguments].
    pub fn set_routine_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::routine_spec::Argument>,
    {
        use std::iter::Iterator;
        self.routine_arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `system_spec`.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::routine_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::RoutineSpec::system_spec]
    /// if it holds a `BigqueryRoutineSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigquery_routine_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryRoutineSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::routine_spec::SystemSpec::BigqueryRoutineSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::RoutineSpec::system_spec]
    /// to hold a `BigqueryRoutineSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_routine_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryRoutineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::routine_spec::SystemSpec::BigqueryRoutineSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RoutineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RoutineSpec"
    }
}

/// Defines additional types related to RoutineSpec
pub mod routine_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Input or output argument of a function or stored procedure.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Argument {
        /// The name of the argument. A return argument of a function might not have
        /// a name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Specifies whether the argument is input or output.
        pub mode: crate::model::routine_spec::argument::Mode,

        /// Type of the argument. The exact value depends on the source system and
        /// the language.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,
    }

    impl Argument {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::routine_spec::Argument::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [mode][crate::model::routine_spec::Argument::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::routine_spec::argument::Mode>>(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::routine_spec::Argument::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Argument {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.RoutineSpec.Argument"
        }
    }

    /// Defines additional types related to Argument
    pub mod argument {
        #[allow(unused_imports)]
        use super::*;

        /// The input or output mode of the argument.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Mode(i32);

        impl Mode {
            /// Unspecified mode.
            pub const MODE_UNSPECIFIED: Mode = Mode::new(0);

            /// The argument is input-only.
            pub const IN: Mode = Mode::new(1);

            /// The argument is output-only.
            pub const OUT: Mode = Mode::new(2);

            /// The argument is both an input and an output.
            pub const INOUT: Mode = Mode::new(3);

            /// Creates a new Mode instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("MODE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("IN"),
                    2 => std::borrow::Cow::Borrowed("OUT"),
                    3 => std::borrow::Cow::Borrowed("INOUT"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "MODE_UNSPECIFIED" => std::option::Option::Some(Self::MODE_UNSPECIFIED),
                    "IN" => std::option::Option::Some(Self::IN),
                    "OUT" => std::option::Option::Some(Self::OUT),
                    "INOUT" => std::option::Option::Some(Self::INOUT),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// The fine-grained type of the routine.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RoutineType(i32);

    impl RoutineType {
        /// Unspecified type.
        pub const ROUTINE_TYPE_UNSPECIFIED: RoutineType = RoutineType::new(0);

        /// Non-builtin permanent scalar function.
        pub const SCALAR_FUNCTION: RoutineType = RoutineType::new(1);

        /// Stored procedure.
        pub const PROCEDURE: RoutineType = RoutineType::new(2);

        /// Creates a new RoutineType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ROUTINE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SCALAR_FUNCTION"),
                2 => std::borrow::Cow::Borrowed("PROCEDURE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ROUTINE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ROUTINE_TYPE_UNSPECIFIED)
                }
                "SCALAR_FUNCTION" => std::option::Option::Some(Self::SCALAR_FUNCTION),
                "PROCEDURE" => std::option::Option::Some(Self::PROCEDURE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RoutineType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RoutineType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Contains fields specific to the source system.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Fields specific for BigQuery routines.
        BigqueryRoutineSpec(std::boxed::Box<crate::model::BigQueryRoutineSpec>),
    }
}

/// Specification that applies to a dataset. Valid only for
/// entries with the `DATASET` type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetSpec {
    /// Fields specific to the source system.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system_spec: std::option::Option<crate::model::dataset_spec::SystemSpec>,
}

impl DatasetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `system_spec`.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::dataset_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::DatasetSpec::system_spec]
    /// if it holds a `VertexDatasetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_dataset_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::dataset_spec::SystemSpec::VertexDatasetSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::DatasetSpec::system_spec]
    /// to hold a `VertexDatasetSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::dataset_spec::SystemSpec::VertexDatasetSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatasetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DatasetSpec"
    }
}

/// Defines additional types related to DatasetSpec
pub mod dataset_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Fields specific to the source system.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Vertex AI Dataset specific fields
        VertexDatasetSpec(std::boxed::Box<crate::model::VertexDatasetSpec>),
    }
}

/// Specification that applies to
/// entries that are part `SQL_DATABASE` system
/// (user_specified_type)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabaseSystemSpec {
    /// SQL Database Engine.
    /// enum SqlEngine {
    /// UNDEFINED = 0;
    /// MY_SQL = 1;
    /// POSTGRE_SQL = 2;
    /// SQL_SERVER = 3;
    /// }
    /// Engine of the enclosing database instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_engine: std::string::String,

    /// Version of the database engine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_version: std::string::String,

    /// Host of the SQL database
    /// enum InstanceHost {
    /// UNDEFINED = 0;
    /// SELF_HOSTED = 1;
    /// CLOUD_SQL = 2;
    /// AMAZON_RDS = 3;
    /// AZURE_SQL = 4;
    /// }
    /// Host of the enclousing database instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_host: std::string::String,
}

impl SqlDatabaseSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_engine][crate::model::SqlDatabaseSystemSpec::sql_engine].
    pub fn set_sql_engine<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_engine = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::SqlDatabaseSystemSpec::database_version].
    pub fn set_database_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [instance_host][crate::model::SqlDatabaseSystemSpec::instance_host].
    pub fn set_instance_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_host = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabaseSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SqlDatabaseSystemSpec"
    }
}

/// Specification that applies to
/// entries that are part `LOOKER` system
/// (user_specified_type)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LookerSystemSpec {
    /// ID of the parent Looker Instance. Empty if it does not exist.
    /// Example value: `someinstance.looker.com`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_instance_id: std::string::String,

    /// Name of the parent Looker Instance. Empty if it does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_instance_display_name: std::string::String,

    /// ID of the parent Model. Empty if it does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_model_id: std::string::String,

    /// Name of the parent Model. Empty if it does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_model_display_name: std::string::String,

    /// ID of the parent View. Empty if it does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_view_id: std::string::String,

    /// Name of the parent View. Empty if it does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_view_display_name: std::string::String,
}

impl LookerSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent_instance_id][crate::model::LookerSystemSpec::parent_instance_id].
    pub fn set_parent_instance_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_instance_id = v.into();
        self
    }

    /// Sets the value of [parent_instance_display_name][crate::model::LookerSystemSpec::parent_instance_display_name].
    pub fn set_parent_instance_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_instance_display_name = v.into();
        self
    }

    /// Sets the value of [parent_model_id][crate::model::LookerSystemSpec::parent_model_id].
    pub fn set_parent_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model_id = v.into();
        self
    }

    /// Sets the value of [parent_model_display_name][crate::model::LookerSystemSpec::parent_model_display_name].
    pub fn set_parent_model_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_model_display_name = v.into();
        self
    }

    /// Sets the value of [parent_view_id][crate::model::LookerSystemSpec::parent_view_id].
    pub fn set_parent_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_view_id = v.into();
        self
    }

    /// Sets the value of [parent_view_display_name][crate::model::LookerSystemSpec::parent_view_display_name].
    pub fn set_parent_view_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_view_display_name = v.into();
        self
    }
}

impl wkt::message::Message for LookerSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.LookerSystemSpec"
    }
}

/// Specification that applies to
/// all entries that are part of `CLOUD_BIGTABLE` system
/// (user_specified_type)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudBigtableSystemSpec {
    /// Display name of the Instance. This is user specified and different from
    /// the resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_display_name: std::string::String,
}

impl CloudBigtableSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_display_name][crate::model::CloudBigtableSystemSpec::instance_display_name].
    pub fn set_instance_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_display_name = v.into();
        self
    }
}

impl wkt::message::Message for CloudBigtableSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableSystemSpec"
    }
}

/// Specification that applies to Instance
/// entries that are part of `CLOUD_BIGTABLE` system.
/// (user_specified_type)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudBigtableInstanceSpec {
    /// The list of clusters for the Instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cloud_bigtable_cluster_specs:
        std::vec::Vec<crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec>,
}

impl CloudBigtableInstanceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_bigtable_cluster_specs][crate::model::CloudBigtableInstanceSpec::cloud_bigtable_cluster_specs].
    pub fn set_cloud_bigtable_cluster_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec>,
    {
        use std::iter::Iterator;
        self.cloud_bigtable_cluster_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudBigtableInstanceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableInstanceSpec"
    }
}

/// Defines additional types related to CloudBigtableInstanceSpec
pub mod cloud_bigtable_instance_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Spec that applies to clusters of an Instance of Cloud Bigtable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CloudBigtableClusterSpec {
        /// Name of the cluster.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// Location of the cluster, typically a Cloud zone.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        /// Type of the resource. For a cluster this would be "CLUSTER".
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        /// A link back to the parent resource, in this case Instance.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub linked_resource: std::string::String,
    }

    impl CloudBigtableClusterSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [location][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [linked_resource][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::linked_resource].
        pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.linked_resource = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudBigtableClusterSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableInstanceSpec.CloudBigtableClusterSpec"
        }
    }
}

/// Specification that applies to a Service resource. Valid only
/// for entries with the `SERVICE` type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceSpec {
    /// System spec
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system_spec: std::option::Option<crate::model::service_spec::SystemSpec>,
}

impl ServiceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `system_spec`.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::service_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ServiceSpec::system_spec]
    /// if it holds a `CloudBigtableInstanceSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_bigtable_instance_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudBigtableInstanceSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::service_spec::SystemSpec::CloudBigtableInstanceSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ServiceSpec::system_spec]
    /// to hold a `CloudBigtableInstanceSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_cloud_bigtable_instance_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudBigtableInstanceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::service_spec::SystemSpec::CloudBigtableInstanceSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ServiceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ServiceSpec"
    }
}

/// Defines additional types related to ServiceSpec
pub mod service_spec {
    #[allow(unused_imports)]
    use super::*;

    /// System spec
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification that applies to Instance entries of `CLOUD_BIGTABLE`
        /// system.
        CloudBigtableInstanceSpec(std::boxed::Box<crate::model::CloudBigtableInstanceSpec>),
    }
}

/// Detail description of the source information of a Vertex model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexModelSourceInfo {
    /// Type of the model source.
    pub source_type: crate::model::vertex_model_source_info::ModelSourceType,

    /// If this Model is copy of another Model. If true then
    /// [source_type][google.cloud.datacatalog.v1.VertexModelSourceInfo.source_type]
    /// pertains to the original.
    ///
    /// [google.cloud.datacatalog.v1.VertexModelSourceInfo.source_type]: crate::model::VertexModelSourceInfo::source_type
    pub copy: bool,
}

impl VertexModelSourceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::VertexModelSourceInfo::source_type].
    pub fn set_source_type<
        T: std::convert::Into<crate::model::vertex_model_source_info::ModelSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [copy][crate::model::VertexModelSourceInfo::copy].
    pub fn set_copy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.copy = v.into();
        self
    }
}

impl wkt::message::Message for VertexModelSourceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexModelSourceInfo"
    }
}

/// Defines additional types related to VertexModelSourceInfo
pub mod vertex_model_source_info {
    #[allow(unused_imports)]
    use super::*;

    /// Source of the model.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ModelSourceType(i32);

    impl ModelSourceType {
        /// Should not be used.
        pub const MODEL_SOURCE_TYPE_UNSPECIFIED: ModelSourceType = ModelSourceType::new(0);

        /// The Model is uploaded by automl training pipeline.
        pub const AUTOML: ModelSourceType = ModelSourceType::new(1);

        /// The Model is uploaded by user or custom training pipeline.
        pub const CUSTOM: ModelSourceType = ModelSourceType::new(2);

        /// The Model is registered and sync'ed from BigQuery ML.
        pub const BQML: ModelSourceType = ModelSourceType::new(3);

        /// The Model is saved or tuned from Model Garden.
        pub const MODEL_GARDEN: ModelSourceType = ModelSourceType::new(4);

        /// The Model is saved or tuned from Genie.
        pub const GENIE: ModelSourceType = ModelSourceType::new(5);

        /// The Model is uploaded by text embedding finetuning pipeline.
        pub const CUSTOM_TEXT_EMBEDDING: ModelSourceType = ModelSourceType::new(6);

        /// The Model is saved or tuned from Marketplace.
        pub const MARKETPLACE: ModelSourceType = ModelSourceType::new(7);

        /// Creates a new ModelSourceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MODEL_SOURCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("AUTOML"),
                2 => std::borrow::Cow::Borrowed("CUSTOM"),
                3 => std::borrow::Cow::Borrowed("BQML"),
                4 => std::borrow::Cow::Borrowed("MODEL_GARDEN"),
                5 => std::borrow::Cow::Borrowed("GENIE"),
                6 => std::borrow::Cow::Borrowed("CUSTOM_TEXT_EMBEDDING"),
                7 => std::borrow::Cow::Borrowed("MARKETPLACE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MODEL_SOURCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::MODEL_SOURCE_TYPE_UNSPECIFIED)
                }
                "AUTOML" => std::option::Option::Some(Self::AUTOML),
                "CUSTOM" => std::option::Option::Some(Self::CUSTOM),
                "BQML" => std::option::Option::Some(Self::BQML),
                "MODEL_GARDEN" => std::option::Option::Some(Self::MODEL_GARDEN),
                "GENIE" => std::option::Option::Some(Self::GENIE),
                "CUSTOM_TEXT_EMBEDDING" => std::option::Option::Some(Self::CUSTOM_TEXT_EMBEDDING),
                "MARKETPLACE" => std::option::Option::Some(Self::MARKETPLACE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ModelSourceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ModelSourceType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Specification for vertex model resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexModelSpec {
    /// The version ID of the model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_id: std::string::String,

    /// User provided version aliases so that a model version can be referenced via
    /// alias
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version_aliases: std::vec::Vec<std::string::String>,

    /// The description of this version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_description: std::string::String,

    /// Source of a Vertex model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vertex_model_source_info: std::option::Option<crate::model::VertexModelSourceInfo>,

    /// URI of the Docker image to be used as the custom container for serving
    /// predictions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_image_uri: std::string::String,
}

impl VertexModelSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version_id][crate::model::VertexModelSpec::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [version_description][crate::model::VertexModelSpec::version_description].
    pub fn set_version_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_description = v.into();
        self
    }

    /// Sets the value of [vertex_model_source_info][crate::model::VertexModelSpec::vertex_model_source_info].
    pub fn set_vertex_model_source_info<
        T: std::convert::Into<std::option::Option<crate::model::VertexModelSourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vertex_model_source_info = v.into();
        self
    }

    /// Sets the value of [container_image_uri][crate::model::VertexModelSpec::container_image_uri].
    pub fn set_container_image_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_image_uri = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::VertexModelSpec::version_aliases].
    pub fn set_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VertexModelSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexModelSpec"
    }
}

/// Specification for vertex dataset resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetSpec {
    /// The number of DataItems in this Dataset. Only apply for non-structured
    /// Dataset.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub data_item_count: i64,

    /// Type of the dataset.
    pub data_type: crate::model::vertex_dataset_spec::DataType,
}

impl VertexDatasetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item_count][crate::model::VertexDatasetSpec::data_item_count].
    pub fn set_data_item_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_item_count = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::VertexDatasetSpec::data_type].
    pub fn set_data_type<T: std::convert::Into<crate::model::vertex_dataset_spec::DataType>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_type = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexDatasetSpec"
    }
}

/// Defines additional types related to VertexDatasetSpec
pub mod vertex_dataset_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Type of data stored in the dataset.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataType(i32);

    impl DataType {
        /// Should not be used.
        pub const DATA_TYPE_UNSPECIFIED: DataType = DataType::new(0);

        /// Structured data dataset.
        pub const TABLE: DataType = DataType::new(1);

        /// Image dataset which supports ImageClassification, ImageObjectDetection
        /// and ImageSegmentation problems.
        pub const IMAGE: DataType = DataType::new(2);

        /// Document dataset which supports TextClassification, TextExtraction and
        /// TextSentiment problems.
        pub const TEXT: DataType = DataType::new(3);

        /// Video dataset which supports VideoClassification, VideoObjectTracking and
        /// VideoActionRecognition problems.
        pub const VIDEO: DataType = DataType::new(4);

        /// Conversation dataset which supports conversation problems.
        pub const CONVERSATION: DataType = DataType::new(5);

        /// TimeSeries dataset.
        pub const TIME_SERIES: DataType = DataType::new(6);

        /// Document dataset which supports DocumentAnnotation problems.
        pub const DOCUMENT: DataType = DataType::new(7);

        /// TextToSpeech dataset which supports TextToSpeech problems.
        pub const TEXT_TO_SPEECH: DataType = DataType::new(8);

        /// Translation dataset which supports Translation problems.
        pub const TRANSLATION: DataType = DataType::new(9);

        /// Store Vision dataset which is used for HITL integration.
        pub const STORE_VISION: DataType = DataType::new(10);

        /// Enterprise Knowledge Graph dataset which is used for HITL labeling
        /// integration.
        pub const ENTERPRISE_KNOWLEDGE_GRAPH: DataType = DataType::new(11);

        /// Text prompt dataset which supports Large Language Models.
        pub const TEXT_PROMPT: DataType = DataType::new(12);

        /// Creates a new DataType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATA_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TABLE"),
                2 => std::borrow::Cow::Borrowed("IMAGE"),
                3 => std::borrow::Cow::Borrowed("TEXT"),
                4 => std::borrow::Cow::Borrowed("VIDEO"),
                5 => std::borrow::Cow::Borrowed("CONVERSATION"),
                6 => std::borrow::Cow::Borrowed("TIME_SERIES"),
                7 => std::borrow::Cow::Borrowed("DOCUMENT"),
                8 => std::borrow::Cow::Borrowed("TEXT_TO_SPEECH"),
                9 => std::borrow::Cow::Borrowed("TRANSLATION"),
                10 => std::borrow::Cow::Borrowed("STORE_VISION"),
                11 => std::borrow::Cow::Borrowed("ENTERPRISE_KNOWLEDGE_GRAPH"),
                12 => std::borrow::Cow::Borrowed("TEXT_PROMPT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATA_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::DATA_TYPE_UNSPECIFIED),
                "TABLE" => std::option::Option::Some(Self::TABLE),
                "IMAGE" => std::option::Option::Some(Self::IMAGE),
                "TEXT" => std::option::Option::Some(Self::TEXT),
                "VIDEO" => std::option::Option::Some(Self::VIDEO),
                "CONVERSATION" => std::option::Option::Some(Self::CONVERSATION),
                "TIME_SERIES" => std::option::Option::Some(Self::TIME_SERIES),
                "DOCUMENT" => std::option::Option::Some(Self::DOCUMENT),
                "TEXT_TO_SPEECH" => std::option::Option::Some(Self::TEXT_TO_SPEECH),
                "TRANSLATION" => std::option::Option::Some(Self::TRANSLATION),
                "STORE_VISION" => std::option::Option::Some(Self::STORE_VISION),
                "ENTERPRISE_KNOWLEDGE_GRAPH" => {
                    std::option::Option::Some(Self::ENTERPRISE_KNOWLEDGE_GRAPH)
                }
                "TEXT_PROMPT" => std::option::Option::Some(Self::TEXT_PROMPT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DataType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DataType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Specification that applies to a model. Valid only for
/// entries with the `MODEL` type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelSpec {
    /// System spec
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system_spec: std::option::Option<crate::model::model_spec::SystemSpec>,
}

impl ModelSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `system_spec`.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::model_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ModelSpec::system_spec]
    /// if it holds a `VertexModelSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_model_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexModelSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::model_spec::SystemSpec::VertexModelSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ModelSpec::system_spec]
    /// to hold a `VertexModelSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_vertex_model_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexModelSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::model_spec::SystemSpec::VertexModelSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ModelSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModelSpec"
    }
}

/// Defines additional types related to ModelSpec
pub mod model_spec {
    #[allow(unused_imports)]
    use super::*;

    /// System spec
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification for vertex model resources.
        VertexModelSpec(std::boxed::Box<crate::model::VertexModelSpec>),
    }
}

/// Detail description of the source information of a Vertex Feature Online
/// Store.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureOnlineStoreSpec {
    /// Output only. Type of underelaying storage for the FeatureOnlineStore.
    pub storage_type: crate::model::feature_online_store_spec::StorageType,
}

impl FeatureOnlineStoreSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStoreSpec::storage_type].
    pub fn set_storage_type<
        T: std::convert::Into<crate::model::feature_online_store_spec::StorageType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }
}

impl wkt::message::Message for FeatureOnlineStoreSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FeatureOnlineStoreSpec"
    }
}

/// Defines additional types related to FeatureOnlineStoreSpec
pub mod feature_online_store_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Type of underlaying storage type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StorageType(i32);

    impl StorageType {
        /// Should not be used.
        pub const STORAGE_TYPE_UNSPECIFIED: StorageType = StorageType::new(0);

        /// Underlsying storgae is Bigtable.
        pub const BIGTABLE: StorageType = StorageType::new(1);

        /// Underlaying is optimized online server (Lightning).
        pub const OPTIMIZED: StorageType = StorageType::new(2);

        /// Creates a new StorageType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STORAGE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BIGTABLE"),
                2 => std::borrow::Cow::Borrowed("OPTIMIZED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STORAGE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::STORAGE_TYPE_UNSPECIFIED)
                }
                "BIGTABLE" => std::option::Option::Some(Self::BIGTABLE),
                "OPTIMIZED" => std::option::Option::Some(Self::OPTIMIZED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Business Context of the entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BusinessContext {
    /// Entry overview fields for rich text descriptions of entries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_overview: std::option::Option<crate::model::EntryOverview>,

    /// Contact people for the entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub contacts: std::option::Option<crate::model::Contacts>,
}

impl BusinessContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_overview][crate::model::BusinessContext::entry_overview].
    pub fn set_entry_overview<
        T: std::convert::Into<std::option::Option<crate::model::EntryOverview>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry_overview = v.into();
        self
    }

    /// Sets the value of [contacts][crate::model::BusinessContext::contacts].
    pub fn set_contacts<T: std::convert::Into<std::option::Option<crate::model::Contacts>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contacts = v.into();
        self
    }
}

impl wkt::message::Message for BusinessContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BusinessContext"
    }
}

/// Entry overview fields for rich text descriptions of entries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntryOverview {
    /// Entry overview with support for rich text.
    ///
    /// The overview must only contain Unicode characters, and should be
    /// formatted using HTML.
    /// The maximum length is 10 MiB as this value holds HTML descriptions
    /// including encoded images. The maximum length of the text without images
    /// is 100 KiB.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub overview: std::string::String,
}

impl EntryOverview {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overview][crate::model::EntryOverview::overview].
    pub fn set_overview<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.overview = v.into();
        self
    }
}

impl wkt::message::Message for EntryOverview {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.EntryOverview"
    }
}

/// Contact people for the entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Contacts {
    /// The list of contact people for the entry.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub people: std::vec::Vec<crate::model::contacts::Person>,
}

impl Contacts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [people][crate::model::Contacts::people].
    pub fn set_people<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::contacts::Person>,
    {
        use std::iter::Iterator;
        self.people = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Contacts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Contacts"
    }
}

/// Defines additional types related to Contacts
pub mod contacts {
    #[allow(unused_imports)]
    use super::*;

    /// A contact person for the entry.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Person {
        /// Designation of the person, for example, Data Steward.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub designation: std::string::String,

        /// Email of the person in the format of `john.doe@xyz`,
        /// `<john.doe@xyz>`, or `John Doe<john.doe@xyz>`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub email: std::string::String,
    }

    impl Person {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [designation][crate::model::contacts::Person::designation].
        pub fn set_designation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.designation = v.into();
            self
        }

        /// Sets the value of [email][crate::model::contacts::Person::email].
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }
    }

    impl wkt::message::Message for Person {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.Contacts.Person"
        }
    }
}

/// Entry group metadata.
///
/// An `EntryGroup` resource represents a logical grouping of zero or more
/// Data Catalog [Entry][google.cloud.datacatalog.v1.Entry] resources.
///
/// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntryGroup {
    /// Identifier. The resource name of the entry group in URL format.
    ///
    /// Note: The entry group itself and its child resources might not be
    /// stored in the location specified in its name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A short name to identify the entry group, for example,
    /// "analytics data - jan 2011". Default value is an empty string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Entry group description. Can consist of several sentences or
    /// paragraphs that describe the entry group contents.
    /// Default value is an empty string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamps of the entry group. Default value is empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_catalog_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Optional. When set to [true], it means DataCatalog EntryGroup was
    /// transferred to Dataplex Catalog Service. It makes EntryGroup and its
    /// Entries to be read-only in DataCatalog. However, new Tags on EntryGroup and
    /// its Entries can be created. After setting the flag to [true] it cannot be
    /// unset.
    pub transferred_to_dataplex: bool,
}

impl EntryGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntryGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntryGroup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntryGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [data_catalog_timestamps][crate::model::EntryGroup::data_catalog_timestamps].
    pub fn set_data_catalog_timestamps<
        T: std::convert::Into<std::option::Option<crate::model::SystemTimestamps>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_catalog_timestamps = v.into();
        self
    }

    /// Sets the value of [transferred_to_dataplex][crate::model::EntryGroup::transferred_to_dataplex].
    pub fn set_transferred_to_dataplex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.transferred_to_dataplex = v.into();
        self
    }
}

impl wkt::message::Message for EntryGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.EntryGroup"
    }
}

/// Request message for
/// [CreateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplate]: crate::client::DataCatalog::create_tag_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTagTemplateRequest {
    /// Required. The name of the project and the template location
    /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the tag template to create.
    ///
    /// The ID must contain only lowercase letters (a-z), numbers (0-9),
    /// or underscores (_), and must start with a letter or underscore.
    /// The maximum size is 64 bytes when encoded in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag_template_id: std::string::String,

    /// Required. The tag template to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag_template: std::option::Option<crate::model::TagTemplate>,
}

impl CreateTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template_id][crate::model::CreateTagTemplateRequest::tag_template_id].
    pub fn set_tag_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_template_id = v.into();
        self
    }

    /// Sets the value of [tag_template][crate::model::CreateTagTemplateRequest::tag_template].
    pub fn set_tag_template<
        T: std::convert::Into<std::option::Option<crate::model::TagTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template = v.into();
        self
    }
}

impl wkt::message::Message for CreateTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagTemplateRequest"
    }
}

/// Request message for
/// [GetTagTemplate][google.cloud.datacatalog.v1.DataCatalog.GetTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetTagTemplate]: crate::client::DataCatalog::get_tag_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTagTemplateRequest {
    /// Required. The name of the tag template to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTagTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetTagTemplateRequest"
    }
}

/// Request message for
/// [UpdateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplate]: crate::client::DataCatalog::update_tag_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTagTemplateRequest {
    /// Required. The template to update. The `name` field must be set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag_template: std::option::Option<crate::model::TagTemplate>,

    /// Names of fields whose values to overwrite on a tag template. Currently,
    /// only `display_name` and `is_publicly_readable` can be overwritten.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    ///
    /// Note: Updating the `is_publicly_readable` field may require up to 12
    /// hours to take effect in search results.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_template][crate::model::UpdateTagTemplateRequest::tag_template].
    pub fn set_tag_template<
        T: std::convert::Into<std::option::Option<crate::model::TagTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagTemplateRequest"
    }
}

/// Request message for
/// [DeleteTagTemplate][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplate]: crate::client::DataCatalog::delete_tag_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTagTemplateRequest {
    /// Required. The name of the tag template to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. If true, deletes all tags that use this template.
    ///
    /// Currently, `true` is the only supported value.
    pub force: bool,
}

impl DeleteTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteTagTemplateRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagTemplateRequest"
    }
}

/// Request message for
/// [CreateTag][google.cloud.datacatalog.v1.DataCatalog.CreateTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTag]: crate::client::DataCatalog::create_tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTagRequest {
    /// Required. The name of the resource to attach this tag to.
    ///
    /// Tags can be attached to entries or entry groups. An entry can have up to
    /// 1000 attached tags.
    ///
    /// Note: The tag and its child resources might not be stored in
    /// the location specified in its name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The tag to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag: std::option::Option<crate::model::Tag>,
}

impl CreateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::CreateTagRequest::tag].
    pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::Tag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for CreateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagRequest"
    }
}

/// Request message for
/// [UpdateTag][google.cloud.datacatalog.v1.DataCatalog.UpdateTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTag]: crate::client::DataCatalog::update_tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTagRequest {
    /// Required. The updated tag. The "name" field must be set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag: std::option::Option<crate::model::Tag>,

    /// Names of fields whose values to overwrite on a tag. Currently, a tag has
    /// the only modifiable field with the name `fields`.
    ///
    /// In general, if this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag][crate::model::UpdateTagRequest::tag].
    pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::Tag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagRequest"
    }
}

/// Request message for
/// [DeleteTag][google.cloud.datacatalog.v1.DataCatalog.DeleteTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTag]: crate::client::DataCatalog::delete_tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTagRequest {
    /// Required. The name of the tag to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagRequest"
    }
}

/// Request message for
/// [CreateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplateField]: crate::client::DataCatalog::create_tag_template_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTagTemplateFieldRequest {
    /// Required. The name of the project and the template location
    /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the tag template field to create.
    ///
    /// Note: Adding a required field to an existing template is *not* allowed.
    ///
    /// Field IDs can contain letters (both uppercase and lowercase), numbers
    /// (0-9), underscores (_) and dashes (-). Field IDs must be at least 1
    /// character long and at most 128 characters long. Field IDs must also be
    /// unique within their template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag_template_field_id: std::string::String,

    /// Required. The tag template field to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag_template_field: std::option::Option<crate::model::TagTemplateField>,
}

impl CreateTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagTemplateFieldRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template_field_id][crate::model::CreateTagTemplateFieldRequest::tag_template_field_id].
    pub fn set_tag_template_field_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template_field_id = v.into();
        self
    }

    /// Sets the value of [tag_template_field][crate::model::CreateTagTemplateFieldRequest::tag_template_field].
    pub fn set_tag_template_field<
        T: std::convert::Into<std::option::Option<crate::model::TagTemplateField>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template_field = v.into();
        self
    }
}

impl wkt::message::Message for CreateTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagTemplateFieldRequest"
    }
}

/// Request message for
/// [UpdateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplateField]: crate::client::DataCatalog::update_tag_template_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTagTemplateFieldRequest {
    /// Required. The name of the tag template field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The template to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag_template_field: std::option::Option<crate::model::TagTemplateField>,

    /// Optional. Names of fields whose values to overwrite on an individual field
    /// of a tag template. The following fields are modifiable:
    ///
    /// * `display_name`
    /// * `type.enum_type`
    /// * `is_required`
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the request
    /// body, their values are emptied with one exception: when updating an enum
    /// type, the provided values are merged with the existing values. Therefore,
    /// enum values can only be added, existing enum values cannot be deleted or
    /// renamed.
    ///
    /// Additionally, updating a template field from optional to required is
    /// *not* allowed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tag_template_field][crate::model::UpdateTagTemplateFieldRequest::tag_template_field].
    pub fn set_tag_template_field<
        T: std::convert::Into<std::option::Option<crate::model::TagTemplateField>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template_field = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagTemplateFieldRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagTemplateFieldRequest"
    }
}

/// Request message for
/// [RenameTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateField]: crate::client::DataCatalog::rename_tag_template_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenameTagTemplateFieldRequest {
    /// Required. The name of the tag template field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new ID of this tag template field. For example,
    /// `my_new_field`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_tag_template_field_id: std::string::String,
}

impl RenameTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_tag_template_field_id][crate::model::RenameTagTemplateFieldRequest::new_tag_template_field_id].
    pub fn set_new_tag_template_field_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_tag_template_field_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RenameTagTemplateFieldRequest"
    }
}

/// Request message for
/// [RenameTagTemplateFieldEnumValue][google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateFieldEnumValue].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateFieldEnumValue]: crate::client::DataCatalog::rename_tag_template_field_enum_value
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenameTagTemplateFieldEnumValueRequest {
    /// Required. The name of the enum field value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new display name of the enum value. For example,
    /// `my_new_enum_value`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_enum_value_display_name: std::string::String,
}

impl RenameTagTemplateFieldEnumValueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameTagTemplateFieldEnumValueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_enum_value_display_name][crate::model::RenameTagTemplateFieldEnumValueRequest::new_enum_value_display_name].
    pub fn set_new_enum_value_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_enum_value_display_name = v.into();
        self
    }
}

impl wkt::message::Message for RenameTagTemplateFieldEnumValueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RenameTagTemplateFieldEnumValueRequest"
    }
}

/// Request message for
/// [DeleteTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplateField]: crate::client::DataCatalog::delete_tag_template_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTagTemplateFieldRequest {
    /// Required. The name of the tag template field to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. If true, deletes this field from any tags that use it.
    ///
    /// Currently, `true` is the only supported value.
    pub force: bool,
}

impl DeleteTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteTagTemplateFieldRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagTemplateFieldRequest"
    }
}

/// Request message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTagsRequest {
    /// Required. The name of the Data Catalog resource to list the tags of.
    ///
    /// The resource can be an [Entry][google.cloud.datacatalog.v1.Entry]
    /// or an [EntryGroup][google.cloud.datacatalog.v1.EntryGroup]
    /// (without `/entries/{entries}` at the end).
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    /// [google.cloud.datacatalog.v1.EntryGroup]: crate::model::EntryGroup
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of tags to return. Default is 10. Maximum limit is 1000.
    pub page_size: i32,

    /// Pagination token that specifies the next page to return. If empty, the
    /// first page is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTagsRequest"
    }
}

/// Response message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTagsResponse {
    /// [Tag][google.cloud.datacatalog.v1.Tag] details.
    ///
    /// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// Pagination token of the next results page. Empty if there are
    /// no more items in results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::ListTagsResponse::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTagsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTagsResponse {
    type PageItem = crate::model::Tag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tags
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReconcileTagsRequest {
    /// Required. Name of [Entry][google.cloud.datacatalog.v1.Entry] to be tagged.
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name of the tag template, which is used for reconciliation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag_template: std::string::String,

    /// If set to `true`, deletes entry tags related to a tag template
    /// not listed in the tags source from an entry. If set to `false`,
    /// unlisted tags are retained.
    pub force_delete_missing: bool,

    /// A list of tags to apply to an entry. A tag can specify a
    /// tag template, which must be the template specified in the
    /// `ReconcileTagsRequest`.
    /// The sole entry and each of its columns must be mentioned at most once.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<crate::model::Tag>,
}

impl ReconcileTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReconcileTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template][crate::model::ReconcileTagsRequest::tag_template].
    pub fn set_tag_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_template = v.into();
        self
    }

    /// Sets the value of [force_delete_missing][crate::model::ReconcileTagsRequest::force_delete_missing].
    pub fn set_force_delete_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_delete_missing = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::ReconcileTagsRequest::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReconcileTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsRequest"
    }
}

/// [Long-running operation][google.longrunning.Operation]
/// response message returned by
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReconcileTagsResponse {
    /// Number of tags created in the request.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub created_tags_count: i64,

    /// Number of tags updated in the request.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub updated_tags_count: i64,

    /// Number of tags deleted in the request.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub deleted_tags_count: i64,
}

impl ReconcileTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_tags_count][crate::model::ReconcileTagsResponse::created_tags_count].
    pub fn set_created_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.created_tags_count = v.into();
        self
    }

    /// Sets the value of [updated_tags_count][crate::model::ReconcileTagsResponse::updated_tags_count].
    pub fn set_updated_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.updated_tags_count = v.into();
        self
    }

    /// Sets the value of [deleted_tags_count][crate::model::ReconcileTagsResponse::deleted_tags_count].
    pub fn set_deleted_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.deleted_tags_count = v.into();
        self
    }
}

impl wkt::message::Message for ReconcileTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsResponse"
    }
}

/// [Long-running operation][google.longrunning.Operation]
/// metadata message returned by the
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReconcileTagsMetadata {
    /// State of the reconciliation operation.
    pub state: crate::model::reconcile_tags_metadata::ReconciliationState,

    /// Maps the name of each tagged column (or empty string for a
    /// sole entry) to tagging operation [status][google.rpc.Status].
    ///
    /// [google.rpc.Status]: rpc::model::Status
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub errors: std::collections::HashMap<std::string::String, rpc::model::Status>,
}

impl ReconcileTagsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ReconcileTagsMetadata::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::reconcile_tags_metadata::ReconciliationState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ReconcileTagsMetadata::errors].
    pub fn set_errors<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ReconcileTagsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsMetadata"
    }
}

/// Defines additional types related to ReconcileTagsMetadata
pub mod reconcile_tags_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum holding possible states of the reconciliation operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ReconciliationState(i32);

    impl ReconciliationState {
        /// Default value. This value is unused.
        pub const RECONCILIATION_STATE_UNSPECIFIED: ReconciliationState =
            ReconciliationState::new(0);

        /// The reconciliation has been queued and awaits for execution.
        pub const RECONCILIATION_QUEUED: ReconciliationState = ReconciliationState::new(1);

        /// The reconciliation is in progress.
        pub const RECONCILIATION_IN_PROGRESS: ReconciliationState = ReconciliationState::new(2);

        /// The reconciliation has been finished.
        pub const RECONCILIATION_DONE: ReconciliationState = ReconciliationState::new(3);

        /// Creates a new ReconciliationState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RECONCILIATION_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RECONCILIATION_QUEUED"),
                2 => std::borrow::Cow::Borrowed("RECONCILIATION_IN_PROGRESS"),
                3 => std::borrow::Cow::Borrowed("RECONCILIATION_DONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RECONCILIATION_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RECONCILIATION_STATE_UNSPECIFIED)
                }
                "RECONCILIATION_QUEUED" => std::option::Option::Some(Self::RECONCILIATION_QUEUED),
                "RECONCILIATION_IN_PROGRESS" => {
                    std::option::Option::Some(Self::RECONCILIATION_IN_PROGRESS)
                }
                "RECONCILIATION_DONE" => std::option::Option::Some(Self::RECONCILIATION_DONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ReconciliationState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ReconciliationState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntries]: crate::client::DataCatalog::list_entries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntriesRequest {
    /// Required. The name of the entry group that contains the entries to list.
    ///
    /// Can be provided in URL format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return. Default is 10. Maximum limit is
    /// 1000. Throws an invalid argument if `page_size` is more than 1000.
    pub page_size: i32,

    /// Pagination token that specifies the next page to return. If empty, the
    /// first page is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The fields to return for each entry. If empty or omitted, all
    /// fields are returned.
    ///
    /// For example, to return a list of entries with only the `name` field,
    /// set `read_mask` to only one path with the `name` value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListEntriesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntriesRequest"
    }
}

/// Response message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntries]: crate::client::DataCatalog::list_entries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntriesResponse {
    /// Entry details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::Entry>,

    /// Pagination token of the next results page. Empty if there are no more items
    /// in results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [entries][crate::model::ListEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntriesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEntriesResponse {
    type PageItem = crate::model::Entry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [StarEntry][google.cloud.datacatalog.v1.DataCatalog.StarEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.StarEntry]: crate::client::DataCatalog::star_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StarEntryRequest {
    /// Required. The name of the entry to mark as starred.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StarEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StarEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StarEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StarEntryRequest"
    }
}

/// Response message for
/// [StarEntry][google.cloud.datacatalog.v1.DataCatalog.StarEntry].
/// Empty for now
///
/// [google.cloud.datacatalog.v1.DataCatalog.StarEntry]: crate::client::DataCatalog::star_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StarEntryResponse {}

impl StarEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StarEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StarEntryResponse"
    }
}

/// Request message for
/// [UnstarEntry][google.cloud.datacatalog.v1.DataCatalog.UnstarEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UnstarEntry]: crate::client::DataCatalog::unstar_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnstarEntryRequest {
    /// Required. The name of the entry to mark as **not** starred.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl UnstarEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UnstarEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UnstarEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UnstarEntryRequest"
    }
}

/// Response message for
/// [UnstarEntry][google.cloud.datacatalog.v1.DataCatalog.UnstarEntry].
/// Empty for now
///
/// [google.cloud.datacatalog.v1.DataCatalog.UnstarEntry]: crate::client::DataCatalog::unstar_entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnstarEntryResponse {}

impl UnstarEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UnstarEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UnstarEntryResponse"
    }
}

/// Request message for
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries]
/// method.
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportEntriesRequest {
    /// Required. Target entry group for ingested entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. (Optional) Dataplex task job id, if specified will be used as
    /// part of ImportEntries LRO ID
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Source of imported entries, e.g. dump stored in a Cloud Storage
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_entries_request::Source>,
}

impl ImportEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::ImportEntriesRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_entries_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportEntriesRequest::source]
    /// if it holds a `GcsBucketPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_bucket_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_entries_request::Source::GcsBucketPath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportEntriesRequest::source]
    /// to hold a `GcsBucketPath`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_bucket_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_entries_request::Source::GcsBucketPath(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesRequest"
    }
}

/// Defines additional types related to ImportEntriesRequest
pub mod import_entries_request {
    #[allow(unused_imports)]
    use super::*;

    /// Source of imported entries, e.g. dump stored in a Cloud Storage
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Path to a Cloud Storage bucket that contains a dump ready for ingestion.
        GcsBucketPath(std::string::String),
    }
}

/// Response message for [long-running operation][google.longrunning.Operation]
/// returned by the
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportEntriesResponse {
    /// Cumulative number of entries created and entries updated as a result of
    /// import operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub upserted_entries_count: std::option::Option<i64>,

    /// Number of entries deleted as a result of import operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub deleted_entries_count: std::option::Option<i64>,
}

impl ImportEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upserted_entries_count][crate::model::ImportEntriesResponse::upserted_entries_count].
    pub fn set_upserted_entries_count<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.upserted_entries_count = v.into();
        self
    }

    /// Sets the value of [deleted_entries_count][crate::model::ImportEntriesResponse::deleted_entries_count].
    pub fn set_deleted_entries_count<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deleted_entries_count = v.into();
        self
    }
}

impl wkt::message::Message for ImportEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesResponse"
    }
}

/// Metadata message for [long-running operation][google.longrunning.Operation]
/// returned by the
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportEntriesMetadata {
    /// State of the import operation.
    pub state: crate::model::import_entries_metadata::ImportState,

    /// Partial errors that are encountered during the ImportEntries operation.
    /// There is no guarantee that all the encountered errors are reported.
    /// However, if no errors are reported, it means that no errors were
    /// encountered.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<rpc::model::Status>,
}

impl ImportEntriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ImportEntriesMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_entries_metadata::ImportState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ImportEntriesMetadata::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportEntriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesMetadata"
    }
}

/// Defines additional types related to ImportEntriesMetadata
pub mod import_entries_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum holding possible states of the import operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ImportState(i32);

    impl ImportState {
        /// Default value. This value is unused.
        pub const IMPORT_STATE_UNSPECIFIED: ImportState = ImportState::new(0);

        /// The dump with entries has been queued for import.
        pub const IMPORT_QUEUED: ImportState = ImportState::new(1);

        /// The import of entries is in progress.
        pub const IMPORT_IN_PROGRESS: ImportState = ImportState::new(2);

        /// The import of entries has been finished.
        pub const IMPORT_DONE: ImportState = ImportState::new(3);

        /// The import of entries has been abandoned in favor of a newer request.
        pub const IMPORT_OBSOLETE: ImportState = ImportState::new(4);

        /// Creates a new ImportState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("IMPORT_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IMPORT_QUEUED"),
                2 => std::borrow::Cow::Borrowed("IMPORT_IN_PROGRESS"),
                3 => std::borrow::Cow::Borrowed("IMPORT_DONE"),
                4 => std::borrow::Cow::Borrowed("IMPORT_OBSOLETE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "IMPORT_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::IMPORT_STATE_UNSPECIFIED)
                }
                "IMPORT_QUEUED" => std::option::Option::Some(Self::IMPORT_QUEUED),
                "IMPORT_IN_PROGRESS" => std::option::Option::Some(Self::IMPORT_IN_PROGRESS),
                "IMPORT_DONE" => std::option::Option::Some(Self::IMPORT_DONE),
                "IMPORT_OBSOLETE" => std::option::Option::Some(Self::IMPORT_OBSOLETE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ImportState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ImportState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request message for
/// [ModifyEntryOverview][google.cloud.datacatalog.v1.DataCatalog.ModifyEntryOverview].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ModifyEntryOverview]: crate::client::DataCatalog::modify_entry_overview
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModifyEntryOverviewRequest {
    /// Required. The full resource name of the entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new value for the Entry Overview.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_overview: std::option::Option<crate::model::EntryOverview>,
}

impl ModifyEntryOverviewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyEntryOverviewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [entry_overview][crate::model::ModifyEntryOverviewRequest::entry_overview].
    pub fn set_entry_overview<
        T: std::convert::Into<std::option::Option<crate::model::EntryOverview>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry_overview = v.into();
        self
    }
}

impl wkt::message::Message for ModifyEntryOverviewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModifyEntryOverviewRequest"
    }
}

/// Request message for
/// [ModifyEntryContacts][google.cloud.datacatalog.v1.DataCatalog.ModifyEntryContacts].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ModifyEntryContacts]: crate::client::DataCatalog::modify_entry_contacts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModifyEntryContactsRequest {
    /// Required. The full resource name of the entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new value for the Contacts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub contacts: std::option::Option<crate::model::Contacts>,
}

impl ModifyEntryContactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyEntryContactsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [contacts][crate::model::ModifyEntryContactsRequest::contacts].
    pub fn set_contacts<T: std::convert::Into<std::option::Option<crate::model::Contacts>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contacts = v.into();
        self
    }
}

impl wkt::message::Message for ModifyEntryContactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModifyEntryContactsRequest"
    }
}

/// Request message for
/// [SetConfig][google.cloud.datacatalog.v1.DataCatalog.SetConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SetConfig]: crate::client::DataCatalog::set_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetConfigRequest {
    /// Required. The organization or project whose config is being specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The configuration field to set.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub configuration: std::option::Option<crate::model::set_config_request::Configuration>,
}

impl SetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `configuration`.
    pub fn set_configuration<
        T: std::convert::Into<std::option::Option<crate::model::set_config_request::Configuration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = v.into();
        self
    }

    /// The value of [configuration][crate::model::SetConfigRequest::configuration]
    /// if it holds a `TagTemplateMigration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tag_template_migration(
        &self,
    ) -> std::option::Option<&crate::model::TagTemplateMigration> {
        #[allow(unreachable_patterns)]
        self.configuration.as_ref().and_then(|v| match v {
            crate::model::set_config_request::Configuration::TagTemplateMigration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [configuration][crate::model::SetConfigRequest::configuration]
    /// if it holds a `CatalogUiExperience`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_catalog_ui_experience(
        &self,
    ) -> std::option::Option<&crate::model::CatalogUIExperience> {
        #[allow(unreachable_patterns)]
        self.configuration.as_ref().and_then(|v| match v {
            crate::model::set_config_request::Configuration::CatalogUiExperience(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration]
    /// to hold a `TagTemplateMigration`.
    ///
    /// Note that all the setters affecting `configuration` are
    /// mutually exclusive.
    pub fn set_tag_template_migration<T: std::convert::Into<crate::model::TagTemplateMigration>>(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = std::option::Option::Some(
            crate::model::set_config_request::Configuration::TagTemplateMigration(v.into()),
        );
        self
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration]
    /// to hold a `CatalogUiExperience`.
    ///
    /// Note that all the setters affecting `configuration` are
    /// mutually exclusive.
    pub fn set_catalog_ui_experience<T: std::convert::Into<crate::model::CatalogUIExperience>>(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = std::option::Option::Some(
            crate::model::set_config_request::Configuration::CatalogUiExperience(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SetConfigRequest"
    }
}

/// Defines additional types related to SetConfigRequest
pub mod set_config_request {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration field to set.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Configuration {
        /// Opt-in status for the migration of Tag Templates to Dataplex.
        TagTemplateMigration(crate::model::TagTemplateMigration),
        /// Opt-in status for the UI switch to Dataplex.
        CatalogUiExperience(crate::model::CatalogUIExperience),
    }
}

/// Request message for
/// [RetrieveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig]: crate::client::DataCatalog::retrieve_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveConfigRequest {
    /// Required. The organization whose config is being retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RetrieveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetrieveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RetrieveConfigRequest"
    }
}

/// Request message for
/// [RetrieveEffectiveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig]: crate::client::DataCatalog::retrieve_effective_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveEffectiveConfigRequest {
    /// Required. The resource whose effective config is being retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RetrieveEffectiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetrieveEffectiveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveEffectiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RetrieveEffectiveConfigRequest"
    }
}

/// The configuration related to the migration from Data Catalog to Dataplex that
/// has been applied to an organization and any projects under it. It is the
/// response message for
/// [RetrieveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig]: crate::client::DataCatalog::retrieve_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OrganizationConfig {
    /// Map of organizations and project resource names and their configuration.
    /// The format for the map keys is `organizations/{organizationId}` or
    /// `projects/{projectId}`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub config: std::collections::HashMap<std::string::String, crate::model::MigrationConfig>,
}

impl OrganizationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::OrganizationConfig::config].
    pub fn set_config<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::MigrationConfig>,
    {
        use std::iter::Iterator;
        self.config = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for OrganizationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.OrganizationConfig"
    }
}

/// The configuration related to the migration to Dataplex applied to an
/// organization or project.
/// It is the response message for
/// [SetConfig][google.cloud.datacatalog.v1.DataCatalog.SetConfig] and
/// [RetrieveEffectiveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig]: crate::client::DataCatalog::retrieve_effective_config
/// [google.cloud.datacatalog.v1.DataCatalog.SetConfig]: crate::client::DataCatalog::set_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationConfig {
    /// Opt-in status for the migration of Tag Templates to Dataplex.
    pub tag_template_migration: crate::model::TagTemplateMigration,

    /// Opt-in status for the UI switch to Dataplex.
    pub catalog_ui_experience: crate::model::CatalogUIExperience,
}

impl MigrationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_template_migration][crate::model::MigrationConfig::tag_template_migration].
    pub fn set_tag_template_migration<T: std::convert::Into<crate::model::TagTemplateMigration>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template_migration = v.into();
        self
    }

    /// Sets the value of [catalog_ui_experience][crate::model::MigrationConfig::catalog_ui_experience].
    pub fn set_catalog_ui_experience<T: std::convert::Into<crate::model::CatalogUIExperience>>(
        mut self,
        v: T,
    ) -> Self {
        self.catalog_ui_experience = v.into();
        self
    }
}

impl wkt::message::Message for MigrationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.MigrationConfig"
    }
}

/// Common Dataplex fields.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataplexSpec {
    /// Fully qualified resource name of an asset in Dataplex, to which the
    /// underlying data source (Cloud Storage bucket or BigQuery dataset) of the
    /// entity is attached.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset: std::string::String,

    /// Format of the data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_format: std::option::Option<crate::model::PhysicalSchema>,

    /// Compression format of the data, e.g., zip, gzip etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub compression_format: std::string::String,

    /// Project ID of the underlying Cloud Storage or BigQuery data. Note that
    /// this may not be the same project as the correspondingly Dataplex lake /
    /// zone / asset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,
}

impl DataplexSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset][crate::model::DataplexSpec::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::DataplexSpec::data_format].
    pub fn set_data_format<
        T: std::convert::Into<std::option::Option<crate::model::PhysicalSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }

    /// Sets the value of [compression_format][crate::model::DataplexSpec::compression_format].
    pub fn set_compression_format<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.compression_format = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DataplexSpec::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for DataplexSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexSpec"
    }
}

/// Entry specyfication for a Dataplex fileset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataplexFilesetSpec {
    /// Common Dataplex fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataplex_spec: std::option::Option<crate::model::DataplexSpec>,
}

impl DataplexFilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataplex_spec][crate::model::DataplexFilesetSpec::dataplex_spec].
    pub fn set_dataplex_spec<
        T: std::convert::Into<std::option::Option<crate::model::DataplexSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_spec = v.into();
        self
    }
}

impl wkt::message::Message for DataplexFilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexFilesetSpec"
    }
}

/// Entry specification for a Dataplex table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataplexTableSpec {
    /// List of external tables registered by Dataplex in other systems based on
    /// the same underlying data.
    ///
    /// External tables allow to query this data in those systems.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub external_tables: std::vec::Vec<crate::model::DataplexExternalTable>,

    /// Common Dataplex fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataplex_spec: std::option::Option<crate::model::DataplexSpec>,

    /// Indicates if the table schema is managed by the user or not.
    pub user_managed: bool,
}

impl DataplexTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataplex_spec][crate::model::DataplexTableSpec::dataplex_spec].
    pub fn set_dataplex_spec<
        T: std::convert::Into<std::option::Option<crate::model::DataplexSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_spec = v.into();
        self
    }

    /// Sets the value of [user_managed][crate::model::DataplexTableSpec::user_managed].
    pub fn set_user_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.user_managed = v.into();
        self
    }

    /// Sets the value of [external_tables][crate::model::DataplexTableSpec::external_tables].
    pub fn set_external_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataplexExternalTable>,
    {
        use std::iter::Iterator;
        self.external_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataplexTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexTableSpec"
    }
}

/// External table registered by Dataplex.
/// Dataplex publishes data discovered from an asset into multiple other systems
/// (BigQuery, DPMS) in form of tables. We call them "external tables". External
/// tables are also synced into the Data Catalog.
/// This message contains pointers to
/// those external tables (fully qualified name, resource name et cetera) within
/// the Data Catalog.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataplexExternalTable {
    /// Service in which the external table is registered.
    pub system: crate::model::IntegratedSystem,

    /// Fully qualified name (FQN) of the external table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fully_qualified_name: std::string::String,

    /// Google Cloud resource name of the external table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub google_cloud_resource: std::string::String,

    /// Name of the Data Catalog entry representing the external table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_catalog_entry: std::string::String,
}

impl DataplexExternalTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system][crate::model::DataplexExternalTable::system].
    pub fn set_system<T: std::convert::Into<crate::model::IntegratedSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::DataplexExternalTable::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [google_cloud_resource][crate::model::DataplexExternalTable::google_cloud_resource].
    pub fn set_google_cloud_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_cloud_resource = v.into();
        self
    }

    /// Sets the value of [data_catalog_entry][crate::model::DataplexExternalTable::data_catalog_entry].
    pub fn set_data_catalog_entry<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_catalog_entry = v.into();
        self
    }
}

impl wkt::message::Message for DataplexExternalTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexExternalTable"
    }
}

/// Wrapper containing Entry and information about Tags
/// that should and should not be attached to it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TaggedEntry {
    /// Optional. Tags that should be ingested into the Data Catalog.
    /// Caller should populate template name, column and fields.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub present_tags: std::vec::Vec<crate::model::Tag>,

    /// Optional. Tags that should be deleted from the Data Catalog.
    /// Caller should populate template name and column only.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub absent_tags: std::vec::Vec<crate::model::Tag>,

    /// Required. Entry to be ingested.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub entry: std::option::Option<crate::model::tagged_entry::Entry>,
}

impl TaggedEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [present_tags][crate::model::TaggedEntry::present_tags].
    pub fn set_present_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.present_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [absent_tags][crate::model::TaggedEntry::absent_tags].
    pub fn set_absent_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.absent_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `entry`.
    pub fn set_entry<
        T: std::convert::Into<std::option::Option<crate::model::tagged_entry::Entry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }

    /// The value of [entry][crate::model::TaggedEntry::entry]
    /// if it holds a `V1Entry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_v1_entry(&self) -> std::option::Option<&std::boxed::Box<crate::model::Entry>> {
        #[allow(unreachable_patterns)]
        self.entry.as_ref().and_then(|v| match v {
            crate::model::tagged_entry::Entry::V1Entry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry][crate::model::TaggedEntry::entry]
    /// to hold a `V1Entry`.
    ///
    /// Note that all the setters affecting `entry` are
    /// mutually exclusive.
    pub fn set_v1_entry<T: std::convert::Into<std::boxed::Box<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry =
            std::option::Option::Some(crate::model::tagged_entry::Entry::V1Entry(v.into()));
        self
    }
}

impl wkt::message::Message for TaggedEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TaggedEntry"
    }
}

/// Defines additional types related to TaggedEntry
pub mod tagged_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Entry to be ingested.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Entry {
        /// Non-encrypted Data Catalog v1 Entry.
        V1Entry(std::boxed::Box<crate::model::Entry>),
    }
}

/// Wrapper for any item that can be contained in the dump.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DumpItem {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::dump_item::Item>,
}

impl DumpItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `item`.
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::dump_item::Item>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// The value of [item][crate::model::DumpItem::item]
    /// if it holds a `TaggedEntry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tagged_entry(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TaggedEntry>> {
        #[allow(unreachable_patterns)]
        self.item.as_ref().and_then(|v| match v {
            crate::model::dump_item::Item::TaggedEntry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [item][crate::model::DumpItem::item]
    /// to hold a `TaggedEntry`.
    ///
    /// Note that all the setters affecting `item` are
    /// mutually exclusive.
    pub fn set_tagged_entry<T: std::convert::Into<std::boxed::Box<crate::model::TaggedEntry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = std::option::Option::Some(crate::model::dump_item::Item::TaggedEntry(v.into()));
        self
    }
}

impl wkt::message::Message for DumpItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DumpItem"
    }
}

/// Defines additional types related to DumpItem
pub mod dump_item {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Item {
        /// Entry and its tags.
        TaggedEntry(std::boxed::Box<crate::model::TaggedEntry>),
    }
}

/// Describes a Cloud Storage fileset entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsFilesetSpec {
    /// Required. Patterns to identify a set of files in Google Cloud Storage.
    ///
    /// For more information, see [Wildcard Names]
    /// (<https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames>).
    ///
    /// Note: Currently, bucket wildcards are not supported.
    ///
    /// Examples of valid `file_patterns`:
    ///
    /// * `gs://bucket_name/dir/*`: matches all files in `bucket_name/dir`
    ///   directory
    /// * `gs://bucket_name/dir/**`: matches all files in `bucket_name/dir`
    ///   and all subdirectories
    /// * `gs://bucket_name/file*`: matches files prefixed by `file` in
    ///   `bucket_name`
    /// * `gs://bucket_name/??.txt`: matches files with two characters followed by
    ///   `.txt` in `bucket_name`
    /// * `gs://bucket_name/[aeiou].txt`: matches files that contain a single
    ///   vowel character followed by `.txt` in
    ///   `bucket_name`
    /// * `gs://bucket_name/[a-m].txt`: matches files that contain `a`, `b`, ...
    ///   or `m` followed by `.txt` in `bucket_name`
    /// * `gs://bucket_name/a/*/b`: matches all files in `bucket_name` that match
    ///   the `a/*/b` pattern, such as `a/c/b`, `a/d/b`
    /// * `gs://another_bucket/a.txt`: matches `gs://another_bucket/a.txt`
    ///
    /// You can combine wildcards to match complex sets of files, for example:
    ///
    /// `gs://bucket_name/[a-m]??.j*g`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_patterns: std::vec::Vec<std::string::String>,

    /// Output only. Sample files contained in this fileset, not all files
    /// contained in this fileset are represented here.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sample_gcs_file_specs: std::vec::Vec<crate::model::GcsFileSpec>,
}

impl GcsFilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_patterns][crate::model::GcsFilesetSpec::file_patterns].
    pub fn set_file_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_gcs_file_specs][crate::model::GcsFilesetSpec::sample_gcs_file_specs].
    pub fn set_sample_gcs_file_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcsFileSpec>,
    {
        use std::iter::Iterator;
        self.sample_gcs_file_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcsFilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GcsFilesetSpec"
    }
}

/// Specification of a single file in Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsFileSpec {
    /// Required. Full file path. Example: `gs://bucket_name/a/b.txt`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_path: std::string::String,

    /// Output only. Creation, modification, and expiration timestamps of a Cloud
    /// Storage file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Output only. File size in bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_bytes: i64,
}

impl GcsFileSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::GcsFileSpec::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [gcs_timestamps][crate::model::GcsFileSpec::gcs_timestamps].
    pub fn set_gcs_timestamps<
        T: std::convert::Into<std::option::Option<crate::model::SystemTimestamps>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_timestamps = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::GcsFileSpec::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }
}

impl wkt::message::Message for GcsFileSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GcsFileSpec"
    }
}

/// Native schema used by a resource represented as an entry. Used by query
/// engines for deserializing and parsing source data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhysicalSchema {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::physical_schema::Schema>,
}

impl PhysicalSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `schema`.
    pub fn set_schema<
        T: std::convert::Into<std::option::Option<crate::model::physical_schema::Schema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Avro`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_avro(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::AvroSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Avro(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Thrift`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_thrift(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ThriftSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Thrift(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Protobuf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_protobuf(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ProtobufSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Protobuf(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Parquet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_parquet(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ParquetSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Parquet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Orc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_orc(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::OrcSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Orc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Csv`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_csv(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::CsvSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Csv(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Avro`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_avro<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::AvroSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Avro(v.into()));
        self
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Thrift`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_thrift<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ThriftSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Thrift(v.into()));
        self
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Protobuf`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_protobuf<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ProtobufSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Protobuf(v.into()));
        self
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Parquet`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_parquet<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ParquetSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Parquet(v.into()));
        self
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Orc`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_orc<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::OrcSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Orc(v.into()));
        self
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Csv`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_csv<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::CsvSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Csv(v.into()));
        self
    }
}

impl wkt::message::Message for PhysicalSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema"
    }
}

/// Defines additional types related to PhysicalSchema
pub mod physical_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Schema in Avro JSON format.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AvroSchema {
        /// JSON source of the Avro schema.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text: std::string::String,
    }

    impl AvroSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::AvroSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for AvroSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.AvroSchema"
        }
    }

    /// Schema in Thrift format.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThriftSchema {
        /// Thrift IDL source of the schema.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text: std::string::String,
    }

    impl ThriftSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::ThriftSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for ThriftSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ThriftSchema"
        }
    }

    /// Schema in protocol buffer format.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ProtobufSchema {
        /// Protocol buffer source of the schema.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text: std::string::String,
    }

    impl ProtobufSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::ProtobufSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for ProtobufSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ProtobufSchema"
        }
    }

    /// Marks a Parquet-encoded data source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ParquetSchema {}

    impl ParquetSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ParquetSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ParquetSchema"
        }
    }

    /// Marks an ORC-encoded data source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OrcSchema {}

    impl OrcSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for OrcSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.OrcSchema"
        }
    }

    /// Marks a CSV-encoded data source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CsvSchema {}

    impl CsvSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for CsvSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.CsvSchema"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Schema {
        /// Schema in Avro JSON format.
        Avro(std::boxed::Box<crate::model::physical_schema::AvroSchema>),
        /// Schema in Thrift format.
        Thrift(std::boxed::Box<crate::model::physical_schema::ThriftSchema>),
        /// Schema in protocol buffer format.
        Protobuf(std::boxed::Box<crate::model::physical_schema::ProtobufSchema>),
        /// Marks a Parquet-encoded data source.
        Parquet(std::boxed::Box<crate::model::physical_schema::ParquetSchema>),
        /// Marks an ORC-encoded data source.
        Orc(std::boxed::Box<crate::model::physical_schema::OrcSchema>),
        /// Marks a CSV-encoded data source.
        Csv(std::boxed::Box<crate::model::physical_schema::CsvSchema>),
    }
}

/// A taxonomy is a collection of hierarchical policy tags that classify data
/// along a common axis.
///
/// For example, a "data sensitivity" taxonomy might contain the following policy
/// tags:
///
/// ```norust
/// + PII
///   + Account number
///   + Age
///   + SSN
///   + Zipcode
/// + Financials
///   + Revenue
/// ```
///
/// A "data origin" taxonomy might contain the following policy tags:
///
/// ```norust
/// + User data
/// + Employee data
/// + Partner data
/// + Public data
/// ```
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Taxonomy {
    /// Identifier. Resource name of this taxonomy in URL format.
    ///
    /// Note: Policy tag manager generates unique taxonomy IDs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User-defined name of this taxonomy.
    ///
    /// The name can't start or end with spaces, must contain only Unicode letters,
    /// numbers, underscores, dashes, and spaces, and be at most 200 bytes long
    /// when encoded in UTF-8.
    ///
    /// The taxonomy display name must be unique within an organization.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Description of this taxonomy. If not set, defaults to empty.
    ///
    /// The description must contain only Unicode characters, tabs, newlines,
    /// carriage returns, and page breaks, and be at most 2000 bytes long when
    /// encoded in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Number of policy tags in this taxonomy.
    pub policy_tag_count: i32,

    /// Output only. Creation and modification timestamps of this taxonomy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub taxonomy_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Optional. A list of policy types that are activated for this taxonomy. If
    /// not set, defaults to an empty list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub activated_policy_types: std::vec::Vec<crate::model::taxonomy::PolicyType>,

    /// Output only. Identity of the service which owns the Taxonomy. This field is
    /// only populated when the taxonomy is created by a Google Cloud service.
    /// Currently only 'DATAPLEX' is supported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::taxonomy::Service>,
}

impl Taxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Taxonomy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Taxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Taxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy_tag_count][crate::model::Taxonomy::policy_tag_count].
    pub fn set_policy_tag_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.policy_tag_count = v.into();
        self
    }

    /// Sets the value of [taxonomy_timestamps][crate::model::Taxonomy::taxonomy_timestamps].
    pub fn set_taxonomy_timestamps<
        T: std::convert::Into<std::option::Option<crate::model::SystemTimestamps>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.taxonomy_timestamps = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Taxonomy::service].
    pub fn set_service<
        T: std::convert::Into<std::option::Option<crate::model::taxonomy::Service>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [activated_policy_types][crate::model::Taxonomy::activated_policy_types].
    pub fn set_activated_policy_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::taxonomy::PolicyType>,
    {
        use std::iter::Iterator;
        self.activated_policy_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Taxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Taxonomy"
    }
}

/// Defines additional types related to Taxonomy
pub mod taxonomy {
    #[allow(unused_imports)]
    use super::*;

    /// The source system of the Taxonomy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Service {
        /// The Google Cloud service name.
        pub name: crate::model::ManagingSystem,

        /// The service agent for the service.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub identity: std::string::String,
    }

    impl Service {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::taxonomy::Service::name].
        pub fn set_name<T: std::convert::Into<crate::model::ManagingSystem>>(
            mut self,
            v: T,
        ) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [identity][crate::model::taxonomy::Service::identity].
        pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.identity = v.into();
            self
        }
    }

    impl wkt::message::Message for Service {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.Taxonomy.Service"
        }
    }

    /// Defines policy types where the policy tags can be used for.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PolicyType(i32);

    impl PolicyType {
        /// Unspecified policy type.
        pub const POLICY_TYPE_UNSPECIFIED: PolicyType = PolicyType::new(0);

        /// Fine-grained access control policy that enables access control on
        /// tagged sub-resources.
        pub const FINE_GRAINED_ACCESS_CONTROL: PolicyType = PolicyType::new(1);

        /// Creates a new PolicyType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("POLICY_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FINE_GRAINED_ACCESS_CONTROL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "POLICY_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::POLICY_TYPE_UNSPECIFIED)
                }
                "FINE_GRAINED_ACCESS_CONTROL" => {
                    std::option::Option::Some(Self::FINE_GRAINED_ACCESS_CONTROL)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for PolicyType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for PolicyType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Denotes one policy tag in a taxonomy, for example, SSN.
///
/// Policy tags can be defined in a hierarchy. For example:
///
/// ```norust
/// + Geolocation
///   + LatLong
///   + City
///   + ZipCode
/// ```
///
/// Where the "Geolocation" policy tag contains three children.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicyTag {
    /// Identifier. Resource name of this policy tag in the URL format.
    ///
    /// The policy tag manager generates unique taxonomy IDs and policy tag IDs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User-defined name of this policy tag.
    ///
    /// The name can't start or end with spaces and must be unique within the
    /// parent taxonomy, contain only Unicode letters, numbers, underscores, dashes
    /// and spaces, and be at most 200 bytes long when encoded in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this policy tag. If not set, defaults to empty.
    ///
    /// The description must contain only Unicode characters,
    /// tabs, newlines, carriage returns and page breaks, and be at most 2000 bytes
    /// long when encoded in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Resource name of this policy tag's parent policy tag. If empty, this is a
    /// top level tag. If not set, defaults to an empty string.
    ///
    /// For example, for the "LatLong" policy tag in the example above, this field
    /// contains the resource name of the "Geolocation" policy tag, and, for
    /// "Geolocation", this field is empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_policy_tag: std::string::String,

    /// Output only. Resource names of child policy tags of this policy tag.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub child_policy_tags: std::vec::Vec<std::string::String>,
}

impl PolicyTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PolicyTag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PolicyTag::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PolicyTag::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parent_policy_tag][crate::model::PolicyTag::parent_policy_tag].
    pub fn set_parent_policy_tag<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_policy_tag = v.into();
        self
    }

    /// Sets the value of [child_policy_tags][crate::model::PolicyTag::child_policy_tags].
    pub fn set_child_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PolicyTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PolicyTag"
    }
}

/// Request message for
/// [CreateTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.CreateTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.CreateTaxonomy]: crate::client::PolicyTagManager::create_taxonomy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTaxonomyRequest {
    /// Required. Resource name of the project that the taxonomy will belong to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The taxonomy to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub taxonomy: std::option::Option<crate::model::Taxonomy>,
}

impl CreateTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTaxonomyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [taxonomy][crate::model::CreateTaxonomyRequest::taxonomy].
    pub fn set_taxonomy<T: std::convert::Into<std::option::Option<crate::model::Taxonomy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.taxonomy = v.into();
        self
    }
}

impl wkt::message::Message for CreateTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTaxonomyRequest"
    }
}

/// Request message for
/// [DeleteTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.DeleteTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.DeleteTaxonomy]: crate::client::PolicyTagManager::delete_taxonomy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTaxonomyRequest {
    /// Required. Resource name of the taxonomy to delete.
    ///
    /// Note: All policy tags in this taxonomy are also deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTaxonomyRequest"
    }
}

/// Request message for
/// [UpdateTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.UpdateTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.UpdateTaxonomy]: crate::client::PolicyTagManager::update_taxonomy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTaxonomyRequest {
    /// The taxonomy to update. You can update only its description, display name,
    /// and activated policy types.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub taxonomy: std::option::Option<crate::model::Taxonomy>,

    /// Specifies fields to update. If not set, defaults to all fields you can
    /// update.
    ///
    /// For more information, see [FieldMask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomy][crate::model::UpdateTaxonomyRequest::taxonomy].
    pub fn set_taxonomy<T: std::convert::Into<std::option::Option<crate::model::Taxonomy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.taxonomy = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTaxonomyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTaxonomyRequest"
    }
}

/// Request message for
/// [ListTaxonomies][google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies]: crate::client::PolicyTagManager::list_taxonomies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTaxonomiesRequest {
    /// Required. Resource name of the project to list the taxonomies of.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return. Must be a value between 1 and 1000
    /// inclusively. If not set, defaults to 50.
    pub page_size: i32,

    /// The pagination token of the next results page. If not set,
    /// the first page is returned.
    ///
    /// The token is returned in the response to a previous list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Supported field for filter is 'service' and value is 'dataplex'.
    /// Eg: service=dataplex.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTaxonomiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTaxonomiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTaxonomiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTaxonomiesRequest"
    }
}

/// Response message for
/// [ListTaxonomies][google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies]: crate::client::PolicyTagManager::list_taxonomies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTaxonomiesResponse {
    /// Taxonomies that the project contains.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taxonomies: std::vec::Vec<crate::model::Taxonomy>,

    /// Pagination token of the next results page. Empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTaxonomiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [taxonomies][crate::model::ListTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Taxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTaxonomiesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTaxonomiesResponse {
    type PageItem = crate::model::Taxonomy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.taxonomies
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [GetTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.GetTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.GetTaxonomy]: crate::client::PolicyTagManager::get_taxonomy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTaxonomyRequest {
    /// Required. Resource name of the taxonomy to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetTaxonomyRequest"
    }
}

/// Request message for
/// [CreatePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.CreatePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.CreatePolicyTag]: crate::client::PolicyTagManager::create_policy_tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePolicyTagRequest {
    /// Required. Resource name of the taxonomy that the policy tag will belong to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The policy tag to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy_tag: std::option::Option<crate::model::PolicyTag>,
}

impl CreatePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePolicyTagRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy_tag][crate::model::CreatePolicyTagRequest::policy_tag].
    pub fn set_policy_tag<T: std::convert::Into<std::option::Option<crate::model::PolicyTag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy_tag = v.into();
        self
    }
}

impl wkt::message::Message for CreatePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreatePolicyTagRequest"
    }
}

/// Request message for
/// [DeletePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.DeletePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.DeletePolicyTag]: crate::client::PolicyTagManager::delete_policy_tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePolicyTagRequest {
    /// Required. Resource name of the policy tag to delete.
    ///
    /// Note: All of its descendant policy tags are also deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeletePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePolicyTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeletePolicyTagRequest"
    }
}

/// Request message for
/// [UpdatePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.UpdatePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.UpdatePolicyTag]: crate::client::PolicyTagManager::update_policy_tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePolicyTagRequest {
    /// The policy tag to update. You can update only its description, display
    /// name, and parent policy tag fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy_tag: std::option::Option<crate::model::PolicyTag>,

    /// Specifies the fields to update.
    ///
    /// You can update only display name, description, and parent policy tag.
    /// If not set, defaults to all updatable fields.
    /// For more information, see [FieldMask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdatePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tag][crate::model::UpdatePolicyTagRequest::policy_tag].
    pub fn set_policy_tag<T: std::convert::Into<std::option::Option<crate::model::PolicyTag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy_tag = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePolicyTagRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdatePolicyTagRequest"
    }
}

/// Request message for
/// [ListPolicyTags][google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags]: crate::client::PolicyTagManager::list_policy_tags
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPolicyTagsRequest {
    /// Required. Resource name of the taxonomy to list the policy tags of.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return. Must be a value between 1 and 1000
    /// inclusively.
    /// If not set, defaults to 50.
    pub page_size: i32,

    /// The pagination token of the next results page. If not set, returns the
    /// first page.
    ///
    /// The token is returned in the response to a previous list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListPolicyTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPolicyTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPolicyTagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPolicyTagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPolicyTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListPolicyTagsRequest"
    }
}

/// Response message for
/// [ListPolicyTags][google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags]: crate::client::PolicyTagManager::list_policy_tags
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPolicyTagsResponse {
    /// The policy tags that belong to the taxonomy.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policy_tags: std::vec::Vec<crate::model::PolicyTag>,

    /// Pagination token of the next results page. Empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListPolicyTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPolicyTagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [policy_tags][crate::model::ListPolicyTagsResponse::policy_tags].
    pub fn set_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PolicyTag>,
    {
        use std::iter::Iterator;
        self.policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPolicyTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListPolicyTagsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListPolicyTagsResponse {
    type PageItem = crate::model::PolicyTag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policy_tags
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [GetPolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.GetPolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.GetPolicyTag]: crate::client::PolicyTagManager::get_policy_tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPolicyTagRequest {
    /// Required. Resource name of the policy tag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPolicyTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetPolicyTagRequest"
    }
}

/// A nested protocol buffer that represents a taxonomy and the hierarchy of its
/// policy tags. Used for taxonomy replacement, import, and
/// export.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SerializedTaxonomy {
    /// Required. Display name of the taxonomy. At most 200 bytes when encoded in
    /// UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of the serialized taxonomy. At most 2000 bytes when
    /// encoded in UTF-8. If not set, defaults to an empty description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Top level policy tags associated with the taxonomy, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policy_tags: std::vec::Vec<crate::model::SerializedPolicyTag>,

    /// A list of policy types that are activated per taxonomy.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub activated_policy_types: std::vec::Vec<crate::model::taxonomy::PolicyType>,
}

impl SerializedTaxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::SerializedTaxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SerializedTaxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy_tags][crate::model::SerializedTaxonomy::policy_tags].
    pub fn set_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedPolicyTag>,
    {
        use std::iter::Iterator;
        self.policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [activated_policy_types][crate::model::SerializedTaxonomy::activated_policy_types].
    pub fn set_activated_policy_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::taxonomy::PolicyType>,
    {
        use std::iter::Iterator;
        self.activated_policy_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerializedTaxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SerializedTaxonomy"
    }
}

/// A nested protocol buffer that represents a policy tag and all its
/// descendants.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SerializedPolicyTag {
    /// Resource name of the policy tag.
    ///
    /// This field is ignored when calling `ImportTaxonomies`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_tag: std::string::String,

    /// Required. Display name of the policy tag. At most 200 bytes when encoded
    /// in UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of the serialized policy tag. At most
    /// 2000 bytes when encoded in UTF-8. If not set, defaults to an
    /// empty description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Children of the policy tag, if any.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub child_policy_tags: std::vec::Vec<crate::model::SerializedPolicyTag>,
}

impl SerializedPolicyTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tag][crate::model::SerializedPolicyTag::policy_tag].
    pub fn set_policy_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_tag = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SerializedPolicyTag::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SerializedPolicyTag::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [child_policy_tags][crate::model::SerializedPolicyTag::child_policy_tags].
    pub fn set_child_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedPolicyTag>,
    {
        use std::iter::Iterator;
        self.child_policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerializedPolicyTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SerializedPolicyTag"
    }
}

/// Request message for
/// [ReplaceTaxonomy][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ReplaceTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ReplaceTaxonomy]: crate::client::PolicyTagManagerSerialization::replace_taxonomy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplaceTaxonomyRequest {
    /// Required. Resource name of the taxonomy to update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Taxonomy to update along with its child policy tags.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub serialized_taxonomy: std::option::Option<crate::model::SerializedTaxonomy>,
}

impl ReplaceTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReplaceTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [serialized_taxonomy][crate::model::ReplaceTaxonomyRequest::serialized_taxonomy].
    pub fn set_serialized_taxonomy<
        T: std::convert::Into<std::option::Option<crate::model::SerializedTaxonomy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.serialized_taxonomy = v.into();
        self
    }
}

impl wkt::message::Message for ReplaceTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReplaceTaxonomyRequest"
    }
}

/// Request message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies]: crate::client::PolicyTagManagerSerialization::import_taxonomies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportTaxonomiesRequest {
    /// Required. Resource name of project that the imported taxonomies will belong
    /// to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Source taxonomies to import.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_taxonomies_request::Source>,
}

impl ImportTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_taxonomies_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_inline_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_taxonomies_request::Source::InlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// if it holds a `CrossRegionalSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cross_regional_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CrossRegionalSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_taxonomies_request::Source::CrossRegionalSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<T: std::convert::Into<std::boxed::Box<crate::model::InlineSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_taxonomies_request::Source::InlineSource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// to hold a `CrossRegionalSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cross_regional_source<
        T: std::convert::Into<std::boxed::Box<crate::model::CrossRegionalSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_taxonomies_request::Source::CrossRegionalSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportTaxonomiesRequest"
    }
}

/// Defines additional types related to ImportTaxonomiesRequest
pub mod import_taxonomies_request {
    #[allow(unused_imports)]
    use super::*;

    /// Source taxonomies to import.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Inline source taxonomy to import.
        InlineSource(std::boxed::Box<crate::model::InlineSource>),
        /// Cross-regional source taxonomy to import.
        CrossRegionalSource(std::boxed::Box<crate::model::CrossRegionalSource>),
    }
}

/// Inline source containing taxonomies to import.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InlineSource {
    /// Required. Taxonomies to import.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taxonomies: std::vec::Vec<crate::model::SerializedTaxonomy>,
}

impl InlineSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::InlineSource::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedTaxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InlineSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.InlineSource"
    }
}

/// Cross-regional source used to import an existing taxonomy into a different
/// region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CrossRegionalSource {
    /// Required. The resource name of the source taxonomy to import.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub taxonomy: std::string::String,
}

impl CrossRegionalSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomy][crate::model::CrossRegionalSource::taxonomy].
    pub fn set_taxonomy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.taxonomy = v.into();
        self
    }
}

impl wkt::message::Message for CrossRegionalSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CrossRegionalSource"
    }
}

/// Response message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies]: crate::client::PolicyTagManagerSerialization::import_taxonomies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportTaxonomiesResponse {
    /// Imported taxonomies.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taxonomies: std::vec::Vec<crate::model::Taxonomy>,
}

impl ImportTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ImportTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Taxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportTaxonomiesResponse"
    }
}

/// Request message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies]: crate::client::PolicyTagManagerSerialization::export_taxonomies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportTaxonomiesRequest {
    /// Required. Resource name of the project that the exported taxonomies belong
    /// to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Resource names of the taxonomies to export.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taxonomies: std::vec::Vec<std::string::String>,

    /// Required. Export destination for taxonomies.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::export_taxonomies_request::Destination>,
}

impl ExportTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [taxonomies][crate::model::ExportTaxonomiesRequest::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<
            std::option::Option<crate::model::export_taxonomies_request::Destination>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportTaxonomiesRequest::destination]
    /// if it holds a `SerializedTaxonomies`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_serialized_taxonomies(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_taxonomies_request::Destination::SerializedTaxonomies(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportTaxonomiesRequest::destination]
    /// to hold a `SerializedTaxonomies`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_serialized_taxonomies<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_taxonomies_request::Destination::SerializedTaxonomies(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ExportTaxonomiesRequest"
    }
}

/// Defines additional types related to ExportTaxonomiesRequest
pub mod export_taxonomies_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Export destination for taxonomies.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Serialized export taxonomies that contain all the policy
        /// tags as nested protocol buffers.
        SerializedTaxonomies(bool),
    }
}

/// Response message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies]: crate::client::PolicyTagManagerSerialization::export_taxonomies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportTaxonomiesResponse {
    /// List of taxonomies and policy tags as nested protocol buffers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taxonomies: std::vec::Vec<crate::model::SerializedTaxonomy>,
}

impl ExportTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ExportTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedTaxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ExportTaxonomiesResponse"
    }
}

/// Represents a schema, for example, a BigQuery, GoogleSQL, or Avro schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schema {
    /// The unified GoogleSQL-like schema of columns.
    ///
    /// The overall maximum number of columns and nested columns is 10,000.
    /// The maximum nested depth is 15 levels.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::ColumnSchema>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::Schema::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnSchema>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Schema"
    }
}

/// A column within a schema. Columns can be nested inside
/// other columns.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnSchema {
    /// Required. Name of the column.
    ///
    /// Must be a UTF-8 string without dots (.).
    /// The maximum size is 64 bytes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// Required. Type of the column.
    ///
    /// Must be a UTF-8 string with the maximum size of 128 bytes.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. Description of the column. Default value is an empty string.
    ///
    /// The description must be a UTF-8 string with the maximum size of 2000
    /// bytes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. A column's mode indicates whether values in this column are
    /// required, nullable, or repeated.
    ///
    /// Only `NULLABLE`, `REQUIRED`, and `REPEATED` values are supported.
    /// Default mode is `NULLABLE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mode: std::string::String,

    /// Optional. Default value for the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_value: std::string::String,

    /// Optional. Ordinal position
    pub ordinal_position: i32,

    /// Optional. Most important inclusion of this column.
    pub highest_indexing_type: crate::model::column_schema::IndexingType,

    /// Optional. Schema of sub-columns. A column can have zero or more
    /// sub-columns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subcolumns: std::vec::Vec<crate::model::ColumnSchema>,

    /// Optional. The subtype of the RANGE, if the type of this field is RANGE. If
    /// the type is RANGE, this field is required. Possible values for the field
    /// element type of a RANGE include:
    ///
    /// * DATE
    /// * DATETIME
    /// * TIMESTAMP
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_element_type: std::option::Option<crate::model::column_schema::FieldElementType>,

    /// Optional. Garbage collection policy for the column or column family.
    /// Applies to systems like Cloud Bigtable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gc_rule: std::string::String,

    /// Information only applying for columns in Entries from a specific system.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system_spec: std::option::Option<crate::model::column_schema::SystemSpec>,
}

impl ColumnSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::ColumnSchema::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ColumnSchema::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ColumnSchema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::ColumnSchema::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::ColumnSchema::default_value].
    pub fn set_default_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::ColumnSchema::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [highest_indexing_type][crate::model::ColumnSchema::highest_indexing_type].
    pub fn set_highest_indexing_type<
        T: std::convert::Into<crate::model::column_schema::IndexingType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.highest_indexing_type = v.into();
        self
    }

    /// Sets the value of [range_element_type][crate::model::ColumnSchema::range_element_type].
    pub fn set_range_element_type<
        T: std::convert::Into<std::option::Option<crate::model::column_schema::FieldElementType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_element_type = v.into();
        self
    }

    /// Sets the value of [gc_rule][crate::model::ColumnSchema::gc_rule].
    pub fn set_gc_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gc_rule = v.into();
        self
    }

    /// Sets the value of [subcolumns][crate::model::ColumnSchema::subcolumns].
    pub fn set_subcolumns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnSchema>,
    {
        use std::iter::Iterator;
        self.subcolumns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `system_spec`.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::column_schema::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ColumnSchema::system_spec]
    /// if it holds a `LookerColumnSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_looker_column_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::column_schema::LookerColumnSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::column_schema::SystemSpec::LookerColumnSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ColumnSchema::system_spec]
    /// to hold a `LookerColumnSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_looker_column_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::column_schema::LookerColumnSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::column_schema::SystemSpec::LookerColumnSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ColumnSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema"
    }
}

/// Defines additional types related to ColumnSchema
pub mod column_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Column info specific to Looker System.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LookerColumnSpec {
        /// Looker specific column type of this column.
        #[serde(rename = "type")]
        pub r#type: crate::model::column_schema::looker_column_spec::LookerColumnType,
    }

    impl LookerColumnSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::column_schema::LookerColumnSpec::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::column_schema::looker_column_spec::LookerColumnType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for LookerColumnSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema.LookerColumnSpec"
        }
    }

    /// Defines additional types related to LookerColumnSpec
    pub mod looker_column_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Column type in Looker.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct LookerColumnType(i32);

        impl LookerColumnType {
            /// Unspecified.
            pub const LOOKER_COLUMN_TYPE_UNSPECIFIED: LookerColumnType = LookerColumnType::new(0);

            /// Dimension.
            pub const DIMENSION: LookerColumnType = LookerColumnType::new(1);

            /// Dimension group - parent for Dimension.
            pub const DIMENSION_GROUP: LookerColumnType = LookerColumnType::new(2);

            /// Filter.
            pub const FILTER: LookerColumnType = LookerColumnType::new(3);

            /// Measure.
            pub const MEASURE: LookerColumnType = LookerColumnType::new(4);

            /// Parameter.
            pub const PARAMETER: LookerColumnType = LookerColumnType::new(5);

            /// Creates a new LookerColumnType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("LOOKER_COLUMN_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("DIMENSION"),
                    2 => std::borrow::Cow::Borrowed("DIMENSION_GROUP"),
                    3 => std::borrow::Cow::Borrowed("FILTER"),
                    4 => std::borrow::Cow::Borrowed("MEASURE"),
                    5 => std::borrow::Cow::Borrowed("PARAMETER"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "LOOKER_COLUMN_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::LOOKER_COLUMN_TYPE_UNSPECIFIED)
                    }
                    "DIMENSION" => std::option::Option::Some(Self::DIMENSION),
                    "DIMENSION_GROUP" => std::option::Option::Some(Self::DIMENSION_GROUP),
                    "FILTER" => std::option::Option::Some(Self::FILTER),
                    "MEASURE" => std::option::Option::Some(Self::MEASURE),
                    "PARAMETER" => std::option::Option::Some(Self::PARAMETER),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for LookerColumnType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for LookerColumnType {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Represents the type of a field element.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FieldElementType {
        /// Required. The type of a field element. See
        /// [ColumnSchema.type][google.cloud.datacatalog.v1.ColumnSchema.type].
        ///
        /// [google.cloud.datacatalog.v1.ColumnSchema.type]: crate::model::ColumnSchema::type
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,
    }

    impl FieldElementType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::column_schema::FieldElementType::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for FieldElementType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema.FieldElementType"
        }
    }

    /// Specifies inclusion of the column in an index
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IndexingType(i32);

    impl IndexingType {
        /// Unspecified.
        pub const INDEXING_TYPE_UNSPECIFIED: IndexingType = IndexingType::new(0);

        /// Column not a part of an index.
        pub const INDEXING_TYPE_NONE: IndexingType = IndexingType::new(1);

        /// Column Part of non unique index.
        pub const INDEXING_TYPE_NON_UNIQUE: IndexingType = IndexingType::new(2);

        /// Column part of unique index.
        pub const INDEXING_TYPE_UNIQUE: IndexingType = IndexingType::new(3);

        /// Column part of the primary key.
        pub const INDEXING_TYPE_PRIMARY_KEY: IndexingType = IndexingType::new(4);

        /// Creates a new IndexingType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INDEXING_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INDEXING_TYPE_NONE"),
                2 => std::borrow::Cow::Borrowed("INDEXING_TYPE_NON_UNIQUE"),
                3 => std::borrow::Cow::Borrowed("INDEXING_TYPE_UNIQUE"),
                4 => std::borrow::Cow::Borrowed("INDEXING_TYPE_PRIMARY_KEY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INDEXING_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::INDEXING_TYPE_UNSPECIFIED)
                }
                "INDEXING_TYPE_NONE" => std::option::Option::Some(Self::INDEXING_TYPE_NONE),
                "INDEXING_TYPE_NON_UNIQUE" => {
                    std::option::Option::Some(Self::INDEXING_TYPE_NON_UNIQUE)
                }
                "INDEXING_TYPE_UNIQUE" => std::option::Option::Some(Self::INDEXING_TYPE_UNIQUE),
                "INDEXING_TYPE_PRIMARY_KEY" => {
                    std::option::Option::Some(Self::INDEXING_TYPE_PRIMARY_KEY)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for IndexingType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for IndexingType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Information only applying for columns in Entries from a specific system.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Looker specific column info of this column.
        LookerColumnSpec(std::boxed::Box<crate::model::column_schema::LookerColumnSpec>),
    }
}

/// Result in the response to a search request.
///
/// Each result captures details of one entry that matches the search.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchCatalogResult {
    /// Type of the search result.
    ///
    /// You can use this field to determine which get method to call to fetch the
    /// full resource.
    pub search_result_type: crate::model::SearchResultType,

    /// Sub-type of the search result.
    ///
    /// A dot-delimited full type of the resource. The same type you
    /// specify in the `type` search predicate.
    ///
    /// Examples: `entry.table`, `entry.dataStream`, `tagTemplate`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub search_result_subtype: std::string::String,

    /// The relative name of the resource in URL format.
    ///
    /// Examples:
    ///
    /// * `projects/{PROJECT_ID}/locations/{LOCATION_ID}/entryGroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`
    /// * `projects/{PROJECT_ID}/tagTemplates/{TAG_TEMPLATE_ID}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relative_resource_name: std::string::String,

    /// The full name of the Google Cloud resource the entry belongs to.
    ///
    /// For more information, see [Full Resource Name]
    /// (/apis/design/resource_names#full_resource_name).
    ///
    /// Example:
    ///
    /// `//bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub linked_resource: std::string::String,

    /// The last modification timestamp of the entry in the source system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub modify_time: std::option::Option<wkt::Timestamp>,

    /// Fully qualified name (FQN) of the resource.
    ///
    /// FQNs take two forms:
    ///
    /// * For non-regionalized resources:
    ///
    /// * `{SYSTEM}:{PROJECT}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
    ///
    /// * For regionalized resources:
    ///
    /// * `{SYSTEM}:{PROJECT}.{LOCATION_ID}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
    ///
    ///
    /// Example for a DPMS table:
    ///
    /// `dataproc_metastore:PROJECT_ID.LOCATION_ID.INSTANCE_ID.DATABASE_ID.TABLE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fully_qualified_name: std::string::String,

    /// The display name of the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Entry description that can consist of several sentences or paragraphs that
    /// describe entry contents.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The source system of the entry. Applicable only when the
    /// `search_result_type` is `ENTRY`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub system: std::option::Option<crate::model::search_catalog_result::System>,
}

impl SearchCatalogResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_result_type][crate::model::SearchCatalogResult::search_result_type].
    pub fn set_search_result_type<T: std::convert::Into<crate::model::SearchResultType>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_result_type = v.into();
        self
    }

    /// Sets the value of [search_result_subtype][crate::model::SearchCatalogResult::search_result_subtype].
    pub fn set_search_result_subtype<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_result_subtype = v.into();
        self
    }

    /// Sets the value of [relative_resource_name][crate::model::SearchCatalogResult::relative_resource_name].
    pub fn set_relative_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.relative_resource_name = v.into();
        self
    }

    /// Sets the value of [linked_resource][crate::model::SearchCatalogResult::linked_resource].
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [modify_time][crate::model::SearchCatalogResult::modify_time].
    pub fn set_modify_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.modify_time = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::SearchCatalogResult::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SearchCatalogResult::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SearchCatalogResult::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of `system`.
    pub fn set_system<
        T: std::convert::Into<std::option::Option<crate::model::search_catalog_result::System>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system = v.into();
        self
    }

    /// The value of [system][crate::model::SearchCatalogResult::system]
    /// if it holds a `IntegratedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_integrated_system(&self) -> std::option::Option<&crate::model::IntegratedSystem> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::search_catalog_result::System::IntegratedSystem(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [system][crate::model::SearchCatalogResult::system]
    /// if it holds a `UserSpecifiedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_user_specified_system(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::search_catalog_result::System::UserSpecifiedSystem(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system]
    /// to hold a `IntegratedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_integrated_system<T: std::convert::Into<crate::model::IntegratedSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = std::option::Option::Some(
            crate::model::search_catalog_result::System::IntegratedSystem(v.into()),
        );
        self
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system]
    /// to hold a `UserSpecifiedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_user_specified_system<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = std::option::Option::Some(
            crate::model::search_catalog_result::System::UserSpecifiedSystem(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SearchCatalogResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogResult"
    }
}

/// Defines additional types related to SearchCatalogResult
pub mod search_catalog_result {
    #[allow(unused_imports)]
    use super::*;

    /// The source system of the entry. Applicable only when the
    /// `search_result_type` is `ENTRY`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum System {
        /// Output only. The source system that Data Catalog automatically integrates
        /// with, such as BigQuery, Cloud Pub/Sub, or Dataproc Metastore.
        IntegratedSystem(crate::model::IntegratedSystem),
        /// Custom source system that you can manually integrate Data Catalog with.
        UserSpecifiedSystem(std::string::String),
    }
}

/// Describes a BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryTableSpec {
    /// Output only. The table source type.
    pub table_source_type: crate::model::TableSourceType,

    /// Output only.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub type_spec: std::option::Option<crate::model::big_query_table_spec::TypeSpec>,
}

impl BigQueryTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_source_type][crate::model::BigQueryTableSpec::table_source_type].
    pub fn set_table_source_type<T: std::convert::Into<crate::model::TableSourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_source_type = v.into();
        self
    }

    /// Sets the value of `type_spec`.
    pub fn set_type_spec<
        T: std::convert::Into<std::option::Option<crate::model::big_query_table_spec::TypeSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = v.into();
        self
    }

    /// The value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// if it holds a `ViewSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_view_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ViewSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_table_spec::TypeSpec::ViewSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// if it holds a `TableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_table_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::TableSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_table_spec::TypeSpec::TableSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// to hold a `ViewSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_view_spec<T: std::convert::Into<std::boxed::Box<crate::model::ViewSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::big_query_table_spec::TypeSpec::ViewSpec(v.into()),
        );
        self
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// to hold a `TableSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_table_spec<T: std::convert::Into<std::boxed::Box<crate::model::TableSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::big_query_table_spec::TypeSpec::TableSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryTableSpec"
    }
}

/// Defines additional types related to BigQueryTableSpec
pub mod big_query_table_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TypeSpec {
        /// Table view specification. Populated only if
        /// the `table_source_type` is `BIGQUERY_VIEW`.
        ViewSpec(std::boxed::Box<crate::model::ViewSpec>),
        /// Specification of a BigQuery table. Populated only if
        /// the `table_source_type` is `BIGQUERY_TABLE`.
        TableSpec(std::boxed::Box<crate::model::TableSpec>),
    }
}

/// Table view specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ViewSpec {
    /// Output only. The query that defines the table view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub view_query: std::string::String,
}

impl ViewSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view_query][crate::model::ViewSpec::view_query].
    pub fn set_view_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.view_query = v.into();
        self
    }
}

impl wkt::message::Message for ViewSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ViewSpec"
    }
}

/// Normal BigQuery table specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableSpec {
    /// Output only. If the table is date-sharded, that is, it matches the
    /// `[prefix]YYYYMMDD` name pattern, this field is the Data Catalog resource
    /// name of the date-sharded grouped entry. For example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/entrygroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`.
    ///
    /// Otherwise, `grouped_entry` is empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub grouped_entry: std::string::String,
}

impl TableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [grouped_entry][crate::model::TableSpec::grouped_entry].
    pub fn set_grouped_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grouped_entry = v.into();
        self
    }
}

impl wkt::message::Message for TableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TableSpec"
    }
}

/// Specification for a group of BigQuery tables with the `[prefix]YYYYMMDD` name
/// pattern.
///
/// For more information, see [Introduction to partitioned tables]
/// (<https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding>).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDateShardedSpec {
    /// Output only. The Data Catalog resource name of the dataset entry the
    /// current table belongs to. For example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/entrygroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Output only. The table name prefix of the shards.
    ///
    /// The name of any given shard is `[table_prefix]YYYYMMDD`.
    /// For example, for the `MyTable20180101` shard, the
    /// `table_prefix` is `MyTable`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_prefix: std::string::String,

    /// Output only. Total number of shards.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub shard_count: i64,

    /// Output only. BigQuery resource name of the latest shard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latest_shard_resource: std::string::String,
}

impl BigQueryDateShardedSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::BigQueryDateShardedSpec::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [table_prefix][crate::model::BigQueryDateShardedSpec::table_prefix].
    pub fn set_table_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_prefix = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::BigQueryDateShardedSpec::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [latest_shard_resource][crate::model::BigQueryDateShardedSpec::latest_shard_resource].
    pub fn set_latest_shard_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_shard_resource = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDateShardedSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryDateShardedSpec"
    }
}

/// Tags contain custom metadata and are attached to Data Catalog resources. Tags
/// conform with the specification of their tag template.
///
/// See [Data Catalog
/// IAM](https://cloud.google.com/data-catalog/docs/concepts/iam) for information
/// on the permissions needed to create or view tags.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tag {
    /// Identifier. The resource name of the tag in URL format where tag ID is a
    /// system-generated identifier.
    ///
    /// Note: The tag itself might not be stored in the location specified in its
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The resource name of the tag template this tag uses. Example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE_ID}`
    ///
    /// This field cannot be modified after creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template: std::string::String,

    /// Output only. The display name of the tag template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_display_name: std::string::String,

    /// Required. Maps the ID of a tag field to its value and additional
    /// information about that field.
    ///
    /// Tag template defines valid field IDs. A tag
    /// must have at least 1 field and at most 500 fields.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub fields: std::collections::HashMap<std::string::String, crate::model::TagField>,

    /// Output only. Denotes the transfer status of the Tag Template.
    pub dataplex_transfer_status: crate::model::tag_template::DataplexTransferStatus,

    /// The scope within the parent resource that this tag is attached to. If not
    /// provided, the tag is attached to the parent resource itself.
    ///
    /// Deleting the scope from the parent resource deletes all tags attached
    /// to that scope.
    ///
    /// These fields cannot be updated after creation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub scope: std::option::Option<crate::model::tag::Scope>,
}

impl Tag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Tag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [template][crate::model::Tag::template].
    pub fn set_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [template_display_name][crate::model::Tag::template_display_name].
    pub fn set_template_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.template_display_name = v.into();
        self
    }

    /// Sets the value of [dataplex_transfer_status][crate::model::Tag::dataplex_transfer_status].
    pub fn set_dataplex_transfer_status<
        T: std::convert::Into<crate::model::tag_template::DataplexTransferStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_transfer_status = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Tag::fields].
    pub fn set_fields<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TagField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `scope`.
    pub fn set_scope<T: std::convert::Into<std::option::Option<crate::model::tag::Scope>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// The value of [scope][crate::model::Tag::scope]
    /// if it holds a `Column`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_column(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.scope.as_ref().and_then(|v| match v {
            crate::model::tag::Scope::Column(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scope][crate::model::Tag::scope]
    /// to hold a `Column`.
    ///
    /// Note that all the setters affecting `scope` are
    /// mutually exclusive.
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = std::option::Option::Some(crate::model::tag::Scope::Column(v.into()));
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Tag"
    }
}

/// Defines additional types related to Tag
pub mod tag {
    #[allow(unused_imports)]
    use super::*;

    /// The scope within the parent resource that this tag is attached to. If not
    /// provided, the tag is attached to the parent resource itself.
    ///
    /// Deleting the scope from the parent resource deletes all tags attached
    /// to that scope.
    ///
    /// These fields cannot be updated after creation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Scope {
        /// Resources like entry can have schemas associated with them. This scope
        /// allows you to attach tags to an individual column based on that schema.
        ///
        /// To attach a tag to a nested column, separate column names with a dot
        /// (`.`). Example: `column.nested_column`.
        Column(std::string::String),
    }
}

/// Contains the value and additional information on a field within
/// a [Tag][google.cloud.datacatalog.v1.Tag].
///
/// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TagField {
    /// Output only. The display name of this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The order of this field with respect to other fields in this
    /// tag. Can be set by
    /// [Tag][google.cloud.datacatalog.v1.TagTemplateField.order].
    ///
    /// For example, a higher value can indicate a more important field.
    /// The value can be negative. Multiple fields can have the same order, and
    /// field orders within a tag don't have to be sequential.
    ///
    /// [google.cloud.datacatalog.v1.TagTemplateField.order]: crate::model::TagTemplateField::order
    pub order: i32,

    /// Required. The value of this field.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub kind: std::option::Option<crate::model::tag_field::Kind>,
}

impl TagField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::TagField::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [order][crate::model::TagField::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }

    /// Sets the value of `kind`.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::tag_field::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `TimestampValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_timestamp_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::TimestampValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `EnumValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_enum_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::tag_field::EnumValue>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::EnumValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `RichtextValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_richtext_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::RichtextValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::DoubleValue(v.into()));
        self
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::StringValue(v.into()));
        self
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::BoolValue(v.into()));
        self
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `TimestampValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_timestamp_value<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::tag_field::Kind::TimestampValue(v.into()));
        self
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `EnumValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_enum_value<
        T: std::convert::Into<std::boxed::Box<crate::model::tag_field::EnumValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::EnumValue(v.into()));
        self
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `RichtextValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_richtext_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::tag_field::Kind::RichtextValue(v.into()));
        self
    }
}

impl wkt::message::Message for TagField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagField"
    }
}

/// Defines additional types related to TagField
pub mod tag_field {
    #[allow(unused_imports)]
    use super::*;

    /// An enum value.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EnumValue {
        /// The display name of the enum value.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,
    }

    impl EnumValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::tag_field::EnumValue::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EnumValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.TagField.EnumValue"
        }
    }

    /// Required. The value of this field.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Kind {
        /// The value of a tag field with a double type.
        DoubleValue(f64),
        /// The value of a tag field with a string type.
        ///
        /// The maximum length is 2000 UTF-8 characters.
        StringValue(std::string::String),
        /// The value of a tag field with a boolean type.
        BoolValue(bool),
        /// The value of a tag field with a timestamp type.
        TimestampValue(std::boxed::Box<wkt::Timestamp>),
        /// The value of a tag field with an enum type.
        ///
        /// This value must be one of the allowed values listed in this enum.
        EnumValue(std::boxed::Box<crate::model::tag_field::EnumValue>),
        /// The value of a tag field with a rich text type.
        ///
        /// The maximum length is 10 MiB as this value holds HTML descriptions
        /// including encoded images. The maximum length of the text without images
        /// is 100 KiB.
        RichtextValue(std::string::String),
    }
}

/// A tag template defines a tag that can have one or more typed fields.
///
/// The template is used to create tags that are attached to Google Cloud
/// resources. [Tag template roles]
/// (<https://cloud.google.com/iam/docs/understanding-roles#data-catalog-roles>)
/// provide permissions to create, edit, and use the template. For example,
/// see the [TagTemplate User]
/// (<https://cloud.google.com/data-catalog/docs/how-to/template-user>) role
/// that includes a permission to use the tag template to tag resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TagTemplate {
    /// Identifier. The resource name of the tag template in URL format.
    ///
    /// Note: The tag template itself and its child resources might not be
    /// stored in the location specified in its name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name for this template. Defaults to an empty string.
    ///
    /// The name must contain only Unicode letters, numbers (0-9), underscores (_),
    /// dashes (-), spaces ( ), and can't start or end with spaces.
    /// The maximum length is 200 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Indicates whether tags created with this template are public. Public tags
    /// do not require tag template access to appear in
    /// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags] API response.
    ///
    /// Additionally, you can search for a public tag by value with a
    /// simple search query in addition to using a ``tag:`` predicate.
    ///
    /// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
    pub is_publicly_readable: bool,

    /// Required. Map of tag template field IDs to the settings for the field.
    /// This map is an exhaustive list of the allowed fields. The map must contain
    /// at least one field and at most 500 fields.
    ///
    /// The keys to this map are tag template field IDs. The IDs have the
    /// following limitations:
    ///
    /// * Can contain uppercase and lowercase letters, numbers (0-9) and
    ///   underscores (_).
    /// * Must be at least 1 character and at most 64 characters long.
    /// * Must start with a letter or underscore.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub fields: std::collections::HashMap<std::string::String, crate::model::TagTemplateField>,

    /// Optional. Transfer status of the TagTemplate
    pub dataplex_transfer_status: crate::model::tag_template::DataplexTransferStatus,
}

impl TagTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TagTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TagTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [is_publicly_readable][crate::model::TagTemplate::is_publicly_readable].
    pub fn set_is_publicly_readable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_publicly_readable = v.into();
        self
    }

    /// Sets the value of [dataplex_transfer_status][crate::model::TagTemplate::dataplex_transfer_status].
    pub fn set_dataplex_transfer_status<
        T: std::convert::Into<crate::model::tag_template::DataplexTransferStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_transfer_status = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TagTemplate::fields].
    pub fn set_fields<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TagTemplateField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TagTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagTemplate"
    }
}

/// Defines additional types related to TagTemplate
pub mod tag_template {
    #[allow(unused_imports)]
    use super::*;

    /// This enum describes TagTemplate transfer status to Dataplex service.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataplexTransferStatus(i32);

    impl DataplexTransferStatus {
        /// Default value. TagTemplate and its tags are only visible and editable in
        /// DataCatalog.
        pub const DATAPLEX_TRANSFER_STATUS_UNSPECIFIED: DataplexTransferStatus =
            DataplexTransferStatus::new(0);

        /// TagTemplate and its tags are auto-copied to Dataplex service.
        /// Visible in both services. Editable in DataCatalog, read-only in Dataplex.
        /// Deprecated: Individual TagTemplate migration is deprecated in favor of
        /// organization or project wide TagTemplate migration opt-in.
        pub const MIGRATED: DataplexTransferStatus = DataplexTransferStatus::new(1);

        /// TagTemplate and its tags are auto-copied to Dataplex service.
        /// Visible in both services. Editable in Dataplex, read-only in DataCatalog.
        pub const TRANSFERRED: DataplexTransferStatus = DataplexTransferStatus::new(2);

        /// Creates a new DataplexTransferStatus instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATAPLEX_TRANSFER_STATUS_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("MIGRATED"),
                2 => std::borrow::Cow::Borrowed("TRANSFERRED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATAPLEX_TRANSFER_STATUS_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATAPLEX_TRANSFER_STATUS_UNSPECIFIED)
                }
                "MIGRATED" => std::option::Option::Some(Self::MIGRATED),
                "TRANSFERRED" => std::option::Option::Some(Self::TRANSFERRED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DataplexTransferStatus {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DataplexTransferStatus {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The template for an individual field within a tag template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TagTemplateField {
    /// Identifier. The resource name of the tag template field in URL format.
    /// Example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE}/fields/{FIELD}`
    ///
    /// Note: The tag template field itself might not be stored in the location
    /// specified in its name.
    ///
    /// The name must contain only letters (a-z, A-Z), numbers (0-9),
    /// or underscores (_), and must start with a letter or underscore.
    /// The maximum length is 64 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name for this field. Defaults to an empty string.
    ///
    /// The name must contain only Unicode letters, numbers (0-9), underscores (_),
    /// dashes (-), spaces ( ), and can't start or end with spaces.
    /// The maximum length is 200 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. The type of value this tag field can contain.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::FieldType>,

    /// If true, this field is required. Defaults to false.
    pub is_required: bool,

    /// The description for this field. Defaults to an empty string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The order of this field with respect to other fields in this tag
    /// template.
    ///
    /// For example, a higher value can indicate a more important field.
    /// The value can be negative. Multiple fields can have the same order and
    /// field orders within a tag don't have to be sequential.
    pub order: i32,
}

impl TagTemplateField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TagTemplateField::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TagTemplateField::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TagTemplateField::type].
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::FieldType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [is_required][crate::model::TagTemplateField::is_required].
    pub fn set_is_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_required = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TagTemplateField::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [order][crate::model::TagTemplateField::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }
}

impl wkt::message::Message for TagTemplateField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagTemplateField"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FieldType {
    /// Required.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub type_decl: std::option::Option<crate::model::field_type::TypeDecl>,
}

impl FieldType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `type_decl`.
    pub fn set_type_decl<
        T: std::convert::Into<std::option::Option<crate::model::field_type::TypeDecl>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_decl = v.into();
        self
    }

    /// The value of [type_decl][crate::model::FieldType::type_decl]
    /// if it holds a `PrimitiveType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_primitive_type(
        &self,
    ) -> std::option::Option<&crate::model::field_type::PrimitiveType> {
        #[allow(unreachable_patterns)]
        self.type_decl.as_ref().and_then(|v| match v {
            crate::model::field_type::TypeDecl::PrimitiveType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [type_decl][crate::model::FieldType::type_decl]
    /// if it holds a `EnumType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_enum_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::field_type::EnumType>> {
        #[allow(unreachable_patterns)]
        self.type_decl.as_ref().and_then(|v| match v {
            crate::model::field_type::TypeDecl::EnumType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl]
    /// to hold a `PrimitiveType`.
    ///
    /// Note that all the setters affecting `type_decl` are
    /// mutually exclusive.
    pub fn set_primitive_type<T: std::convert::Into<crate::model::field_type::PrimitiveType>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_decl =
            std::option::Option::Some(crate::model::field_type::TypeDecl::PrimitiveType(v.into()));
        self
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl]
    /// to hold a `EnumType`.
    ///
    /// Note that all the setters affecting `type_decl` are
    /// mutually exclusive.
    pub fn set_enum_type<
        T: std::convert::Into<std::boxed::Box<crate::model::field_type::EnumType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_decl =
            std::option::Option::Some(crate::model::field_type::TypeDecl::EnumType(v.into()));
        self
    }
}

impl wkt::message::Message for FieldType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FieldType"
    }
}

/// Defines additional types related to FieldType
pub mod field_type {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EnumType {
        /// The set of allowed values for this enum.
        ///
        /// This set must not be empty and can include up to 100 allowed values.
        /// The display names of the values in this set must not be empty and must
        /// be case-insensitively unique within this set.
        ///
        /// The order of items in this set is preserved. This field can be used to
        /// create, remove, and reorder enum values. To rename enum values, use the
        /// `RenameTagTemplateFieldEnumValue` method.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allowed_values: std::vec::Vec<crate::model::field_type::enum_type::EnumValue>,
    }

    impl EnumType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_values][crate::model::field_type::EnumType::allowed_values].
        pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::field_type::enum_type::EnumValue>,
        {
            use std::iter::Iterator;
            self.allowed_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EnumType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.FieldType.EnumType"
        }
    }

    /// Defines additional types related to EnumType
    pub mod enum_type {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct EnumValue {
            /// Required. The display name of the enum value. Must not be an empty
            /// string.
            ///
            /// The name must contain only Unicode letters, numbers (0-9), underscores
            /// (_), dashes (-), spaces ( ), and can't start or end with spaces. The
            /// maximum length is 200 characters.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub display_name: std::string::String,
        }

        impl EnumValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [display_name][crate::model::field_type::enum_type::EnumValue::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }
        }

        impl wkt::message::Message for EnumValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datacatalog.v1.FieldType.EnumType.EnumValue"
            }
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PrimitiveType(i32);

    impl PrimitiveType {
        /// The default invalid value for a type.
        pub const PRIMITIVE_TYPE_UNSPECIFIED: PrimitiveType = PrimitiveType::new(0);

        /// A double precision number.
        pub const DOUBLE: PrimitiveType = PrimitiveType::new(1);

        /// An UTF-8 string.
        pub const STRING: PrimitiveType = PrimitiveType::new(2);

        /// A boolean value.
        pub const BOOL: PrimitiveType = PrimitiveType::new(3);

        /// A timestamp.
        pub const TIMESTAMP: PrimitiveType = PrimitiveType::new(4);

        /// A Richtext description.
        pub const RICHTEXT: PrimitiveType = PrimitiveType::new(5);

        /// Creates a new PrimitiveType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PRIMITIVE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DOUBLE"),
                2 => std::borrow::Cow::Borrowed("STRING"),
                3 => std::borrow::Cow::Borrowed("BOOL"),
                4 => std::borrow::Cow::Borrowed("TIMESTAMP"),
                5 => std::borrow::Cow::Borrowed("RICHTEXT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PRIMITIVE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PRIMITIVE_TYPE_UNSPECIFIED)
                }
                "DOUBLE" => std::option::Option::Some(Self::DOUBLE),
                "STRING" => std::option::Option::Some(Self::STRING),
                "BOOL" => std::option::Option::Some(Self::BOOL),
                "TIMESTAMP" => std::option::Option::Some(Self::TIMESTAMP),
                "RICHTEXT" => std::option::Option::Some(Self::RICHTEXT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for PrimitiveType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for PrimitiveType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Required.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TypeDecl {
        /// Primitive types, such as string, boolean, etc.
        PrimitiveType(crate::model::field_type::PrimitiveType),
        /// An enum type.
        EnumType(std::boxed::Box<crate::model::field_type::EnumType>),
    }
}

/// Timestamps associated with this resource in a particular system.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SystemTimestamps {
    /// Creation timestamp of the resource within the given system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Timestamp of the last modification of the resource or its metadata within
    /// a given system.
    ///
    /// Note: Depending on the source system, not every modification updates this
    /// timestamp.
    /// For example, BigQuery timestamps every metadata modification but not data
    /// or permission changes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Expiration timestamp of the resource within the given system.
    ///
    /// Currently only applicable to BigQuery resources.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,
}

impl SystemTimestamps {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::SystemTimestamps::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SystemTimestamps::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::SystemTimestamps::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for SystemTimestamps {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SystemTimestamps"
    }
}

/// Detailed statistics on the entry's usage.
///
/// Usage statistics have the following limitations:
///
/// - Only BigQuery tables have them.
/// - They only include BigQuery query jobs.
/// - They might be underestimated because wildcard table references
///   are not yet counted. For more information, see
///   [Querying multiple tables using a wildcard table]
///   (<https://cloud.google.com/bigquery/docs/querying-wildcard-tables>)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsageStats {
    /// The number of successful uses of the underlying entry.
    pub total_completions: f32,

    /// The number of failed attempts to use the underlying entry.
    pub total_failures: f32,

    /// The number of cancelled attempts to use the underlying entry.
    pub total_cancellations: f32,

    /// Total time spent only on successful uses, in milliseconds.
    pub total_execution_time_for_completions_millis: f32,
}

impl UsageStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_completions][crate::model::UsageStats::total_completions].
    pub fn set_total_completions<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_completions = v.into();
        self
    }

    /// Sets the value of [total_failures][crate::model::UsageStats::total_failures].
    pub fn set_total_failures<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_failures = v.into();
        self
    }

    /// Sets the value of [total_cancellations][crate::model::UsageStats::total_cancellations].
    pub fn set_total_cancellations<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_cancellations = v.into();
        self
    }

    /// Sets the value of [total_execution_time_for_completions_millis][crate::model::UsageStats::total_execution_time_for_completions_millis].
    pub fn set_total_execution_time_for_completions_millis<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_execution_time_for_completions_millis = v.into();
        self
    }
}

impl wkt::message::Message for UsageStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UsageStats"
    }
}

/// Common statistics on the entry's usage.
///
/// They can be set on any system.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CommonUsageStats {
    /// View count in source system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub view_count: std::option::Option<i64>,
}

impl CommonUsageStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view_count][crate::model::CommonUsageStats::view_count].
    pub fn set_view_count<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.view_count = v.into();
        self
    }
}

impl wkt::message::Message for CommonUsageStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CommonUsageStats"
    }
}

/// The set of all usage signals that Data Catalog stores.
///
/// Note: Usually, these signals are updated daily. In rare cases, an update may
/// fail but will be performed again on the next day.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsageSignal {
    /// The end timestamp of the duration of usage statistics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. BigQuery usage statistics over each of the predefined time
    /// ranges.
    ///
    /// Supported time ranges are `{"24H", "7D", "30D"}`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub usage_within_time_range:
        std::collections::HashMap<std::string::String, crate::model::UsageStats>,

    /// Common usage statistics over each of the predefined time ranges.
    ///
    /// Supported time ranges are `{"24H", "7D", "30D", "Lifetime"}`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub common_usage_within_time_range:
        std::collections::HashMap<std::string::String, crate::model::CommonUsageStats>,

    /// Favorite count in the source system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub favorite_count: std::option::Option<i64>,
}

impl UsageSignal {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::UsageSignal::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [favorite_count][crate::model::UsageSignal::favorite_count].
    pub fn set_favorite_count<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.favorite_count = v.into();
        self
    }

    /// Sets the value of [usage_within_time_range][crate::model::UsageSignal::usage_within_time_range].
    pub fn set_usage_within_time_range<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::UsageStats>,
    {
        use std::iter::Iterator;
        self.usage_within_time_range = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [common_usage_within_time_range][crate::model::UsageSignal::common_usage_within_time_range].
    pub fn set_common_usage_within_time_range<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CommonUsageStats>,
    {
        use std::iter::Iterator;
        self.common_usage_within_time_range =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for UsageSignal {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UsageSignal"
    }
}

/// This enum lists all the systems that Data Catalog integrates with.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct IntegratedSystem(i32);

impl IntegratedSystem {
    /// Default unknown system.
    pub const INTEGRATED_SYSTEM_UNSPECIFIED: IntegratedSystem = IntegratedSystem::new(0);

    /// BigQuery.
    pub const BIGQUERY: IntegratedSystem = IntegratedSystem::new(1);

    /// Cloud Pub/Sub.
    pub const CLOUD_PUBSUB: IntegratedSystem = IntegratedSystem::new(2);

    /// Dataproc Metastore.
    pub const DATAPROC_METASTORE: IntegratedSystem = IntegratedSystem::new(3);

    /// Dataplex.
    pub const DATAPLEX: IntegratedSystem = IntegratedSystem::new(4);

    /// Cloud Spanner
    pub const CLOUD_SPANNER: IntegratedSystem = IntegratedSystem::new(6);

    /// Cloud Bigtable
    pub const CLOUD_BIGTABLE: IntegratedSystem = IntegratedSystem::new(7);

    /// Cloud Sql
    pub const CLOUD_SQL: IntegratedSystem = IntegratedSystem::new(8);

    /// Looker
    pub const LOOKER: IntegratedSystem = IntegratedSystem::new(9);

    /// Vertex AI
    pub const VERTEX_AI: IntegratedSystem = IntegratedSystem::new(10);

    /// Creates a new IntegratedSystem instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("INTEGRATED_SYSTEM_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("BIGQUERY"),
            2 => std::borrow::Cow::Borrowed("CLOUD_PUBSUB"),
            3 => std::borrow::Cow::Borrowed("DATAPROC_METASTORE"),
            4 => std::borrow::Cow::Borrowed("DATAPLEX"),
            6 => std::borrow::Cow::Borrowed("CLOUD_SPANNER"),
            7 => std::borrow::Cow::Borrowed("CLOUD_BIGTABLE"),
            8 => std::borrow::Cow::Borrowed("CLOUD_SQL"),
            9 => std::borrow::Cow::Borrowed("LOOKER"),
            10 => std::borrow::Cow::Borrowed("VERTEX_AI"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "INTEGRATED_SYSTEM_UNSPECIFIED" => {
                std::option::Option::Some(Self::INTEGRATED_SYSTEM_UNSPECIFIED)
            }
            "BIGQUERY" => std::option::Option::Some(Self::BIGQUERY),
            "CLOUD_PUBSUB" => std::option::Option::Some(Self::CLOUD_PUBSUB),
            "DATAPROC_METASTORE" => std::option::Option::Some(Self::DATAPROC_METASTORE),
            "DATAPLEX" => std::option::Option::Some(Self::DATAPLEX),
            "CLOUD_SPANNER" => std::option::Option::Some(Self::CLOUD_SPANNER),
            "CLOUD_BIGTABLE" => std::option::Option::Some(Self::CLOUD_BIGTABLE),
            "CLOUD_SQL" => std::option::Option::Some(Self::CLOUD_SQL),
            "LOOKER" => std::option::Option::Some(Self::LOOKER),
            "VERTEX_AI" => std::option::Option::Some(Self::VERTEX_AI),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for IntegratedSystem {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for IntegratedSystem {
    fn default() -> Self {
        Self::new(0)
    }
}

/// This enum describes all the systems that manage
/// Taxonomy and PolicyTag resources in DataCatalog.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ManagingSystem(i32);

impl ManagingSystem {
    /// Default value
    pub const MANAGING_SYSTEM_UNSPECIFIED: ManagingSystem = ManagingSystem::new(0);

    /// Dataplex.
    pub const MANAGING_SYSTEM_DATAPLEX: ManagingSystem = ManagingSystem::new(1);

    /// Other
    pub const MANAGING_SYSTEM_OTHER: ManagingSystem = ManagingSystem::new(2);

    /// Creates a new ManagingSystem instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MANAGING_SYSTEM_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("MANAGING_SYSTEM_DATAPLEX"),
            2 => std::borrow::Cow::Borrowed("MANAGING_SYSTEM_OTHER"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MANAGING_SYSTEM_UNSPECIFIED" => {
                std::option::Option::Some(Self::MANAGING_SYSTEM_UNSPECIFIED)
            }
            "MANAGING_SYSTEM_DATAPLEX" => std::option::Option::Some(Self::MANAGING_SYSTEM_DATAPLEX),
            "MANAGING_SYSTEM_OTHER" => std::option::Option::Some(Self::MANAGING_SYSTEM_OTHER),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ManagingSystem {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ManagingSystem {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Metadata automatically ingested from Google Cloud resources like BigQuery
/// tables or Pub/Sub topics always uses enum values from `EntryType` as the type
/// of entry.
///
/// Other sources of metadata like Hive or Oracle databases can identify the type
/// by either using one of the enum values from `EntryType` (for example,
/// `FILESET` for a Cloud Storage fileset) or specifying a custom value using
/// the [`Entry`](#resource:-entry) field `user_specified_type`. For more
/// information, see
/// [Surface files from Cloud Storage with fileset
/// entries](/data-catalog/docs/how-to/filesets) or [Create custom entries for
/// your data sources](/data-catalog/docs/how-to/custom-entries).
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct EntryType(i32);

impl EntryType {
    /// Default unknown type.
    pub const ENTRY_TYPE_UNSPECIFIED: EntryType = EntryType::new(0);

    /// The entry type that has a GoogleSQL schema, including
    /// logical views.
    pub const TABLE: EntryType = EntryType::new(2);

    /// The type of models.
    ///
    /// For more information, see [Supported models in BigQuery
    /// ML](/bigquery/docs/bqml-introduction#supported_models).
    pub const MODEL: EntryType = EntryType::new(5);

    /// An entry type for streaming entries. For example, a Pub/Sub topic.
    pub const DATA_STREAM: EntryType = EntryType::new(3);

    /// An entry type for a set of files or objects. For example, a
    /// Cloud Storage fileset.
    pub const FILESET: EntryType = EntryType::new(4);

    /// A group of servers that work together. For example, a Kafka cluster.
    pub const CLUSTER: EntryType = EntryType::new(6);

    /// A database.
    pub const DATABASE: EntryType = EntryType::new(7);

    /// Connection to a data source. For example, a BigQuery
    /// connection.
    pub const DATA_SOURCE_CONNECTION: EntryType = EntryType::new(8);

    /// Routine, for example, a BigQuery routine.
    pub const ROUTINE: EntryType = EntryType::new(9);

    /// A Dataplex lake.
    pub const LAKE: EntryType = EntryType::new(10);

    /// A Dataplex zone.
    pub const ZONE: EntryType = EntryType::new(11);

    /// A service, for example, a Dataproc Metastore service.
    pub const SERVICE: EntryType = EntryType::new(14);

    /// Schema within a relational database.
    pub const DATABASE_SCHEMA: EntryType = EntryType::new(15);

    /// A Dashboard, for example from Looker.
    pub const DASHBOARD: EntryType = EntryType::new(16);

    /// A Looker Explore.
    ///
    /// For more information, see [Looker Explore API]
    /// (<https://developers.looker.com/api/explorer/4.0/methods/LookmlModel/lookml_model_explore>).
    pub const EXPLORE: EntryType = EntryType::new(17);

    /// A Looker Look.
    ///
    /// For more information, see [Looker Look API]
    /// (<https://developers.looker.com/api/explorer/4.0/methods/Look>).
    pub const LOOK: EntryType = EntryType::new(18);

    /// Feature Online Store resource in Vertex AI Feature Store.
    pub const FEATURE_ONLINE_STORE: EntryType = EntryType::new(19);

    /// Feature View resource in Vertex AI Feature Store.
    pub const FEATURE_VIEW: EntryType = EntryType::new(20);

    /// Feature Group resource in Vertex AI Feature Store.
    pub const FEATURE_GROUP: EntryType = EntryType::new(21);

    /// Creates a new EntryType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("ENTRY_TYPE_UNSPECIFIED"),
            2 => std::borrow::Cow::Borrowed("TABLE"),
            3 => std::borrow::Cow::Borrowed("DATA_STREAM"),
            4 => std::borrow::Cow::Borrowed("FILESET"),
            5 => std::borrow::Cow::Borrowed("MODEL"),
            6 => std::borrow::Cow::Borrowed("CLUSTER"),
            7 => std::borrow::Cow::Borrowed("DATABASE"),
            8 => std::borrow::Cow::Borrowed("DATA_SOURCE_CONNECTION"),
            9 => std::borrow::Cow::Borrowed("ROUTINE"),
            10 => std::borrow::Cow::Borrowed("LAKE"),
            11 => std::borrow::Cow::Borrowed("ZONE"),
            14 => std::borrow::Cow::Borrowed("SERVICE"),
            15 => std::borrow::Cow::Borrowed("DATABASE_SCHEMA"),
            16 => std::borrow::Cow::Borrowed("DASHBOARD"),
            17 => std::borrow::Cow::Borrowed("EXPLORE"),
            18 => std::borrow::Cow::Borrowed("LOOK"),
            19 => std::borrow::Cow::Borrowed("FEATURE_ONLINE_STORE"),
            20 => std::borrow::Cow::Borrowed("FEATURE_VIEW"),
            21 => std::borrow::Cow::Borrowed("FEATURE_GROUP"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "ENTRY_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::ENTRY_TYPE_UNSPECIFIED),
            "TABLE" => std::option::Option::Some(Self::TABLE),
            "MODEL" => std::option::Option::Some(Self::MODEL),
            "DATA_STREAM" => std::option::Option::Some(Self::DATA_STREAM),
            "FILESET" => std::option::Option::Some(Self::FILESET),
            "CLUSTER" => std::option::Option::Some(Self::CLUSTER),
            "DATABASE" => std::option::Option::Some(Self::DATABASE),
            "DATA_SOURCE_CONNECTION" => std::option::Option::Some(Self::DATA_SOURCE_CONNECTION),
            "ROUTINE" => std::option::Option::Some(Self::ROUTINE),
            "LAKE" => std::option::Option::Some(Self::LAKE),
            "ZONE" => std::option::Option::Some(Self::ZONE),
            "SERVICE" => std::option::Option::Some(Self::SERVICE),
            "DATABASE_SCHEMA" => std::option::Option::Some(Self::DATABASE_SCHEMA),
            "DASHBOARD" => std::option::Option::Some(Self::DASHBOARD),
            "EXPLORE" => std::option::Option::Some(Self::EXPLORE),
            "LOOK" => std::option::Option::Some(Self::LOOK),
            "FEATURE_ONLINE_STORE" => std::option::Option::Some(Self::FEATURE_ONLINE_STORE),
            "FEATURE_VIEW" => std::option::Option::Some(Self::FEATURE_VIEW),
            "FEATURE_GROUP" => std::option::Option::Some(Self::FEATURE_GROUP),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for EntryType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for EntryType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Configuration related to the opt-in status for the migration of TagTemplates
/// to Dataplex.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TagTemplateMigration(i32);

impl TagTemplateMigration {
    /// Default value. Migration of Tag Templates from Data Catalog to Dataplex is
    /// not performed.
    pub const TAG_TEMPLATE_MIGRATION_UNSPECIFIED: TagTemplateMigration =
        TagTemplateMigration::new(0);

    /// Migration of Tag Templates from Data Catalog to Dataplex is enabled.
    pub const TAG_TEMPLATE_MIGRATION_ENABLED: TagTemplateMigration = TagTemplateMigration::new(1);

    /// Migration of Tag Templates from Data Catalog to Dataplex is disabled.
    pub const TAG_TEMPLATE_MIGRATION_DISABLED: TagTemplateMigration = TagTemplateMigration::new(2);

    /// Creates a new TagTemplateMigration instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("TAG_TEMPLATE_MIGRATION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("TAG_TEMPLATE_MIGRATION_ENABLED"),
            2 => std::borrow::Cow::Borrowed("TAG_TEMPLATE_MIGRATION_DISABLED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "TAG_TEMPLATE_MIGRATION_UNSPECIFIED" => {
                std::option::Option::Some(Self::TAG_TEMPLATE_MIGRATION_UNSPECIFIED)
            }
            "TAG_TEMPLATE_MIGRATION_ENABLED" => {
                std::option::Option::Some(Self::TAG_TEMPLATE_MIGRATION_ENABLED)
            }
            "TAG_TEMPLATE_MIGRATION_DISABLED" => {
                std::option::Option::Some(Self::TAG_TEMPLATE_MIGRATION_DISABLED)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for TagTemplateMigration {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for TagTemplateMigration {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Configuration related to the opt-in status for the UI switch to Dataplex.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct CatalogUIExperience(i32);

impl CatalogUIExperience {
    /// Default value. The default UI is Dataplex.
    pub const CATALOG_UI_EXPERIENCE_UNSPECIFIED: CatalogUIExperience = CatalogUIExperience::new(0);

    /// The UI is Dataplex.
    pub const CATALOG_UI_EXPERIENCE_ENABLED: CatalogUIExperience = CatalogUIExperience::new(1);

    /// The UI is Data Catalog.
    pub const CATALOG_UI_EXPERIENCE_DISABLED: CatalogUIExperience = CatalogUIExperience::new(2);

    /// Creates a new CatalogUIExperience instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("CATALOG_UI_EXPERIENCE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("CATALOG_UI_EXPERIENCE_ENABLED"),
            2 => std::borrow::Cow::Borrowed("CATALOG_UI_EXPERIENCE_DISABLED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "CATALOG_UI_EXPERIENCE_UNSPECIFIED" => {
                std::option::Option::Some(Self::CATALOG_UI_EXPERIENCE_UNSPECIFIED)
            }
            "CATALOG_UI_EXPERIENCE_ENABLED" => {
                std::option::Option::Some(Self::CATALOG_UI_EXPERIENCE_ENABLED)
            }
            "CATALOG_UI_EXPERIENCE_DISABLED" => {
                std::option::Option::Some(Self::CATALOG_UI_EXPERIENCE_DISABLED)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for CatalogUIExperience {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for CatalogUIExperience {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The resource types that can be returned in search results.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct SearchResultType(i32);

impl SearchResultType {
    /// Default unknown type.
    pub const SEARCH_RESULT_TYPE_UNSPECIFIED: SearchResultType = SearchResultType::new(0);

    /// An [Entry][google.cloud.datacatalog.v1.Entry].
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    pub const ENTRY: SearchResultType = SearchResultType::new(1);

    /// A [TagTemplate][google.cloud.datacatalog.v1.TagTemplate].
    ///
    /// [google.cloud.datacatalog.v1.TagTemplate]: crate::model::TagTemplate
    pub const TAG_TEMPLATE: SearchResultType = SearchResultType::new(2);

    /// An [EntryGroup][google.cloud.datacatalog.v1.EntryGroup].
    ///
    /// [google.cloud.datacatalog.v1.EntryGroup]: crate::model::EntryGroup
    pub const ENTRY_GROUP: SearchResultType = SearchResultType::new(3);

    /// Creates a new SearchResultType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SEARCH_RESULT_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("ENTRY"),
            2 => std::borrow::Cow::Borrowed("TAG_TEMPLATE"),
            3 => std::borrow::Cow::Borrowed("ENTRY_GROUP"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SEARCH_RESULT_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::SEARCH_RESULT_TYPE_UNSPECIFIED)
            }
            "ENTRY" => std::option::Option::Some(Self::ENTRY),
            "TAG_TEMPLATE" => std::option::Option::Some(Self::TAG_TEMPLATE),
            "ENTRY_GROUP" => std::option::Option::Some(Self::ENTRY_GROUP),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for SearchResultType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for SearchResultType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Table source type.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TableSourceType(i32);

impl TableSourceType {
    /// Default unknown type.
    pub const TABLE_SOURCE_TYPE_UNSPECIFIED: TableSourceType = TableSourceType::new(0);

    /// Table view.
    pub const BIGQUERY_VIEW: TableSourceType = TableSourceType::new(2);

    /// BigQuery native table.
    pub const BIGQUERY_TABLE: TableSourceType = TableSourceType::new(5);

    /// BigQuery materialized view.
    pub const BIGQUERY_MATERIALIZED_VIEW: TableSourceType = TableSourceType::new(7);

    /// Creates a new TableSourceType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("TABLE_SOURCE_TYPE_UNSPECIFIED"),
            2 => std::borrow::Cow::Borrowed("BIGQUERY_VIEW"),
            5 => std::borrow::Cow::Borrowed("BIGQUERY_TABLE"),
            7 => std::borrow::Cow::Borrowed("BIGQUERY_MATERIALIZED_VIEW"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "TABLE_SOURCE_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::TABLE_SOURCE_TYPE_UNSPECIFIED)
            }
            "BIGQUERY_VIEW" => std::option::Option::Some(Self::BIGQUERY_VIEW),
            "BIGQUERY_TABLE" => std::option::Option::Some(Self::BIGQUERY_TABLE),
            "BIGQUERY_MATERIALIZED_VIEW" => {
                std::option::Option::Some(Self::BIGQUERY_MATERIALIZED_VIEW)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for TableSourceType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for TableSourceType {
    fn default() -> Self {
        Self::new(0)
    }
}
