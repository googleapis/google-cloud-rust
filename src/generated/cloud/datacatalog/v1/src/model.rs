// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Specification for the BigQuery connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryConnectionSpec {

    /// The type of the BigQuery connection.
    pub connection_type: crate::model::big_query_connection_spec::ConnectionType,

    /// True if there are credentials attached to the BigQuery connection; false
    /// otherwise.
    pub has_credential: bool,

    pub connection_spec: std::option::Option<crate::model::big_query_connection_spec::ConnectionSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_type][crate::model::BigQueryConnectionSpec::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::big_query_connection_spec::ConnectionType>>(mut self, v: T) -> Self {
        self.connection_type = v.into();
        self
    }

    /// Sets the value of [has_credential][crate::model::BigQueryConnectionSpec::has_credential].
    pub fn set_has_credential<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_credential = v.into();
        self
    }

    /// Sets the value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec].
    ///
    /// Note that all the setters affecting `connection_spec` are mutually
    /// exclusive.
    pub fn set_connection_spec<T: std::convert::Into<std::option::Option<crate::model::big_query_connection_spec::ConnectionSpec>>>(mut self, v: T) -> Self
    {
        self.connection_spec = v.into();
        self
    }

    /// The value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>> {
        #[allow(unreachable_patterns)]
        self.connection_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_connection_spec::ConnectionSpec::CloudSql(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `connection_spec` are
    /// mutually exclusive.
    pub fn set_cloud_sql<T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>>>(mut self, v: T) -> Self {
        self.connection_spec = std::option::Option::Some(
            crate::model::big_query_connection_spec::ConnectionSpec::CloudSql(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for BigQueryConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryConnectionSpec"
    }
}

/// Defines additional types related to [BigQueryConnectionSpec].
pub mod big_query_connection_spec {
    #[allow(unused_imports)]
    use super::*;


    /// The type of the BigQuery connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionType {
        /// Unspecified type.
        Unspecified,
        /// Cloud SQL connection.
        CloudSql,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectionType::value] or
        /// [ConnectionType::name].
        UnknownValue(connection_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connection_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudSql => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTION_TYPE_UNSPECIFIED"),
                Self::CloudSql => std::option::Option::Some("CLOUD_SQL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudSql,
                _ => Self::UnknownValue(connection_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ConnectionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_SQL" => Self::CloudSql,
                _ => Self::UnknownValue(connection_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ConnectionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudSql => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionType>::new(
                ".google.cloud.datacatalog.v1.BigQueryConnectionSpec.ConnectionType"))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionSpec {
        /// Specification for the BigQuery connection to a Cloud SQL instance.
        CloudSql(std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>),
    }
}

/// Specification for the BigQuery connection to a Cloud SQL instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlBigQueryConnectionSpec {

    /// Cloud SQL instance ID in the format of `project:location:instance`.
    pub instance_id: std::string::String,

    /// Database name.
    pub database: std::string::String,

    /// Type of the Cloud SQL database.
    pub r#type: crate::model::cloud_sql_big_query_connection_spec::DatabaseType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlBigQueryConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_id][crate::model::CloudSqlBigQueryConnectionSpec::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CloudSqlBigQueryConnectionSpec::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CloudSqlBigQueryConnectionSpec::type].
    pub fn set_type<T: std::convert::Into<crate::model::cloud_sql_big_query_connection_spec::DatabaseType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlBigQueryConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudSqlBigQueryConnectionSpec"
    }
}

/// Defines additional types related to [CloudSqlBigQueryConnectionSpec].
pub mod cloud_sql_big_query_connection_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Supported Cloud SQL database types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Unspecified database type.
        Unspecified,
        /// Cloud SQL for PostgreSQL.
        Postgres,
        /// Cloud SQL for MySQL.
        Mysql,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Postgres => std::option::Option::Some(1),
                Self::Mysql => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::Postgres => std::option::Option::Some("POSTGRES"),
                Self::Mysql => std::option::Option::Some("MYSQL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Postgres,
                2 => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "POSTGRES" => Self::Postgres,
                "MYSQL" => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Postgres => serializer.serialize_i32(1),
                Self::Mysql => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.cloud.datacatalog.v1.CloudSqlBigQueryConnectionSpec.DatabaseType"))
        }
    }
}

/// Fields specific for BigQuery routines.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryRoutineSpec {

    /// Paths of the imported libraries.
    pub imported_libraries: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryRoutineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_libraries][crate::model::BigQueryRoutineSpec::imported_libraries].
    pub fn set_imported_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.imported_libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryRoutineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryRoutineSpec"
    }
}

/// Entry metadata relevant only to the user and private to them.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PersonalDetails {

    /// True if the entry is starred by the user; false otherwise.
    pub starred: bool,

    /// Set if the entry is starred; unset otherwise.
    pub star_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PersonalDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [starred][crate::model::PersonalDetails::starred].
    pub fn set_starred<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.starred = v.into();
        self
    }

    /// Sets the value of [star_time][crate::model::PersonalDetails::star_time].
    pub fn set_star_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.star_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [star_time][crate::model::PersonalDetails::star_time].
    pub fn set_or_clear_star_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.star_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PersonalDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PersonalDetails"
    }
}

/// Physical location of an entry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSource {

    /// Service that physically stores the data.
    pub service: crate::model::data_source::Service,

    /// Full name of a resource as defined by the service. For example:
    ///
    /// `//bigquery.googleapis.com/projects/{PROJECT_ID}/locations/{LOCATION}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
    pub resource: std::string::String,

    /// Output only. Data Catalog entry name, if applicable.
    pub source_entry: std::string::String,

    pub properties: std::option::Option<crate::model::data_source::Properties>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::DataSource::service].
    pub fn set_service<T: std::convert::Into<crate::model::data_source::Service>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::DataSource::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [source_entry][crate::model::DataSource::source_entry].
    pub fn set_source_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entry = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DataSource::properties].
    ///
    /// Note that all the setters affecting `properties` are mutually
    /// exclusive.
    pub fn set_properties<T: std::convert::Into<std::option::Option<crate::model::data_source::Properties>>>(mut self, v: T) -> Self
    {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::DataSource::properties]
    /// if it holds a `StorageProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_properties(&self) -> std::option::Option<&std::boxed::Box<crate::model::StorageProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::data_source::Properties::StorageProperties(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::DataSource::properties]
    /// to hold a `StorageProperties`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_storage_properties<T: std::convert::Into<std::boxed::Box<crate::model::StorageProperties>>>(mut self, v: T) -> Self {
        self.properties = std::option::Option::Some(
            crate::model::data_source::Properties::StorageProperties(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataSource"
    }
}

/// Defines additional types related to [DataSource].
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;


    /// Name of a service that stores the data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Service {
        /// Default unknown service.
        Unspecified,
        /// Google Cloud Storage service.
        CloudStorage,
        /// BigQuery service.
        Bigquery,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Service::value] or
        /// [Service::name].
        UnknownValue(service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Service {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudStorage => std::option::Option::Some(1),
                Self::Bigquery => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_UNSPECIFIED"),
                Self::CloudStorage => std::option::Option::Some("CLOUD_STORAGE"),
                Self::Bigquery => std::option::Option::Some("BIGQUERY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Service {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Service {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Service {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudStorage,
                2 => Self::Bigquery,
                _ => Self::UnknownValue(service::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Service {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_STORAGE" => Self::CloudStorage,
                "BIGQUERY" => Self::Bigquery,
                _ => Self::UnknownValue(service::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Service {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudStorage => serializer.serialize_i32(1),
                Self::Bigquery => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Service {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Service>::new(
                ".google.cloud.datacatalog.v1.DataSource.Service"))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Properties {
        /// Detailed properties of the underlying storage.
        StorageProperties(std::boxed::Box<crate::model::StorageProperties>),
    }
}

/// Details the properties of the underlying storage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageProperties {

    /// Patterns to identify a set of files for this fileset.
    ///
    /// Examples of a valid `file_pattern`:
    ///
    /// * `gs://bucket_name/dir/*`: matches all files in the `bucket_name/dir`
    ///   directory
    /// * `gs://bucket_name/dir/**`: matches all files in the `bucket_name/dir`
    ///   and all subdirectories recursively
    /// * `gs://bucket_name/file*`: matches files prefixed by `file` in
    ///   `bucket_name`
    /// * `gs://bucket_name/??.txt`: matches files with two characters followed by
    ///   `.txt` in `bucket_name`
    /// * `gs://bucket_name/[aeiou].txt`: matches files that contain a single
    ///   vowel character followed by `.txt` in
    ///   `bucket_name`
    /// * `gs://bucket_name/[a-m].txt`: matches files that contain `a`, `b`, ...
    ///   or `m` followed by `.txt` in `bucket_name`
    /// * `gs://bucket_name/a/*/b`: matches all files in `bucket_name` that match
    ///   the `a/*/b` pattern, such as `a/c/b`, `a/d/b`
    /// * `gs://another_bucket/a.txt`: matches `gs://another_bucket/a.txt`
    pub file_pattern: std::vec::Vec<std::string::String>,

    /// File type in MIME format, for example, `text/plain`.
    pub file_type: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_pattern][crate::model::StorageProperties::file_pattern].
    pub fn set_file_pattern<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.file_pattern = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_type][crate::model::StorageProperties::file_type].
    pub fn set_file_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }
}

impl wkt::message::Message for StorageProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StorageProperties"
    }
}

/// Request message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCatalogRequest {

    /// Required. The scope of this search request.
    ///
    /// The `scope` is invalid if `include_org_ids`, `include_project_ids` are
    /// empty AND `include_gcp_public_datasets` is set to `false`. In this case,
    /// the request returns an error.
    pub scope: std::option::Option<crate::model::search_catalog_request::Scope>,

    /// Optional. The query string with a minimum of 3 characters and specific
    /// syntax. For more information, see [Data Catalog search
    /// syntax](https://cloud.google.com/data-catalog/docs/how-to/search-reference).
    ///
    /// An empty query string returns all data assets (in the specified scope)
    /// that you have access to.
    ///
    /// A query string can be a simple `xyz` or qualified by predicates:
    ///
    /// * `name:x`
    /// * `column:y`
    /// * `description:z`
    pub query: std::string::String,

    /// Upper bound on the number of results you can get in a single response.
    ///
    /// Can't be negative or 0, defaults to 10 in this case.
    /// The maximum number is 1000. If exceeded, throws an "invalid argument"
    /// exception.
    pub page_size: i32,

    /// Optional. Pagination token that, if specified, returns the next page of
    /// search results. If empty, returns the first page.
    ///
    /// This token is returned in the
    /// [SearchCatalogResponse.next_page_token][google.cloud.datacatalog.v1.SearchCatalogResponse.next_page_token]
    /// field of the response to a previous
    /// [SearchCatalogRequest][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]
    /// call.
    ///
    /// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
    /// [google.cloud.datacatalog.v1.SearchCatalogResponse.next_page_token]: crate::model::SearchCatalogResponse::next_page_token
    pub page_token: std::string::String,

    /// Specifies the order of results.
    ///
    /// Currently supported case-sensitive values are:
    ///
    /// * `relevance` that can only be descending
    /// * `last_modified_timestamp [asc|desc]` with descending (`desc`) as default
    /// * `default` that can only be descending
    ///
    /// Search queries don't guarantee full recall. Results that match your query
    /// might not be returned, even in subsequent result pages. Additionally,
    /// returned (and not returned) results can vary if you repeat search queries.
    /// If you are experiencing recall issues and you don't have to fetch the
    /// results in any specific order, consider setting this parameter to
    /// `default`.
    ///
    /// If this parameter is omitted, it defaults to the descending `relevance`.
    pub order_by: std::string::String,

    /// Optional. If set, use searchAll permission granted on organizations from
    /// `include_org_ids` and projects from `include_project_ids` instead of the
    /// fine grained per resource permissions when filtering the search results.
    /// The only allowed `order_by` criteria for admin_search mode is `default`.
    /// Using this flags guarantees a full recall of the search results.
    pub admin_search: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCatalogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::SearchCatalogRequest::scope].
    pub fn set_scope<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::search_catalog_request::Scope>
    {
        self.scope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scope][crate::model::SearchCatalogRequest::scope].
    pub fn set_or_clear_scope<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::search_catalog_request::Scope>
    {
        self.scope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query][crate::model::SearchCatalogRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchCatalogRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchCatalogRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchCatalogRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [admin_search][crate::model::SearchCatalogRequest::admin_search].
    pub fn set_admin_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.admin_search = v.into();
        self
    }
}

impl wkt::message::Message for SearchCatalogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogRequest"
    }
}

/// Defines additional types related to [SearchCatalogRequest].
pub mod search_catalog_request {
    #[allow(unused_imports)]
    use super::*;


    /// The criteria that select the subspace used for query matching.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Scope {

        /// The list of organization IDs to search within.
        ///
        /// To find your organization ID, follow the steps from
        /// [Creating and managing organizations]
        /// (/resource-manager/docs/creating-managing-organization).
        pub include_org_ids: std::vec::Vec<std::string::String>,

        /// The list of project IDs to search within.
        ///
        /// For more information on the distinction between project names, IDs, and
        /// numbers, see [Projects](/docs/overview/#projects).
        pub include_project_ids: std::vec::Vec<std::string::String>,

        /// If `true`, include Google Cloud public datasets in
        /// search results. By default, they are excluded.
        ///
        /// See [Google Cloud Public Datasets](/public-datasets) for more
        /// information.
        pub include_gcp_public_datasets: bool,

        /// Optional. The list of locations to search within. If empty, all locations
        /// are searched.
        ///
        /// Returns an error if any location in the list isn't one of the [Supported
        /// regions](https://cloud.google.com/data-catalog/docs/concepts/regions#supported_regions).
        ///
        /// If a location is unreachable, its name is returned in the
        /// `SearchCatalogResponse.unreachable` field. To get additional information
        /// on the error, repeat the search request and set the location name as the
        /// value of this parameter.
        pub restricted_locations: std::vec::Vec<std::string::String>,

        /// Optional. If `true`, search only among starred entries.
        ///
        /// By default, all results are returned, starred or not.
        pub starred_only: bool,

        /// Optional. This field is deprecated. The search mechanism for public and
        /// private tag templates is the same.
        #[deprecated]
        pub include_public_tag_templates: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Scope {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [include_org_ids][crate::model::search_catalog_request::Scope::include_org_ids].
        pub fn set_include_org_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.include_org_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [include_project_ids][crate::model::search_catalog_request::Scope::include_project_ids].
        pub fn set_include_project_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.include_project_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [include_gcp_public_datasets][crate::model::search_catalog_request::Scope::include_gcp_public_datasets].
        pub fn set_include_gcp_public_datasets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.include_gcp_public_datasets = v.into();
            self
        }

        /// Sets the value of [restricted_locations][crate::model::search_catalog_request::Scope::restricted_locations].
        pub fn set_restricted_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.restricted_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [starred_only][crate::model::search_catalog_request::Scope::starred_only].
        pub fn set_starred_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.starred_only = v.into();
            self
        }

        /// Sets the value of [include_public_tag_templates][crate::model::search_catalog_request::Scope::include_public_tag_templates].
        #[deprecated]
        pub fn set_include_public_tag_templates<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.include_public_tag_templates = v.into();
            self
        }
    }

    impl wkt::message::Message for Scope {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogRequest.Scope"
        }
    }
}

/// Response message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCatalogResponse {

    /// Search results.
    pub results: std::vec::Vec<crate::model::SearchCatalogResult>,

    /// The approximate total number of entries matched by the query.
    pub total_size: i32,

    /// Pagination token that can be used in subsequent calls to retrieve the next
    /// page of results.
    pub next_page_token: std::string::String,

    /// Unreachable locations. Search results don't include data from those
    /// locations.
    ///
    /// To get additional information on an error, repeat the search request and
    /// restrict it to specific locations by setting the
    /// `SearchCatalogRequest.scope.restricted_locations` parameter.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCatalogResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchCatalogResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchCatalogResult>
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_size][crate::model::SearchCatalogResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchCatalogResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::SearchCatalogResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchCatalogResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchCatalogResponse {
    type PageItem = crate::model::SearchCatalogResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [CreateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.CreateEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateEntryGroup]: crate::client::DataCatalog::create_entry_group
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntryGroupRequest {

    /// Required. The names of the project and location that the new entry group
    /// belongs to.
    ///
    /// Note: The entry group itself and its child resources might not be
    /// stored in the location specified in its name.
    pub parent: std::string::String,

    /// Required. The ID of the entry group to create.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and must start with a letter or underscore.
    /// The maximum size is 64 bytes when encoded in UTF-8.
    pub entry_group_id: std::string::String,

    /// The entry group to create. Defaults to empty.
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_group_id][crate::model::CreateEntryGroupRequest::entry_group_id].
    pub fn set_entry_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_group_id = v.into();
        self
    }

    /// Sets the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::EntryGroup>
    {
        self.entry_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_or_clear_entry_group<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::EntryGroup>
    {
        self.entry_group = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateEntryGroupRequest"
    }
}

/// Request message for
/// [UpdateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.UpdateEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateEntryGroup]: crate::client::DataCatalog::update_entry_group
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntryGroupRequest {

    /// Required. Updates for the entry group. The `name` field must be set.
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    /// Names of fields whose values to overwrite on an entry group.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::EntryGroup>
    {
        self.entry_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_or_clear_entry_group<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::EntryGroup>
    {
        self.entry_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateEntryGroupRequest"
    }
}

/// Request message for
/// [GetEntryGroup][google.cloud.datacatalog.v1.DataCatalog.GetEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetEntryGroup]: crate::client::DataCatalog::get_entry_group
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntryGroupRequest {

    /// Required. The name of the entry group to get.
    pub name: std::string::String,

    /// The fields to return. If empty or omitted, all fields are returned.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetEntryGroupRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetEntryGroupRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetEntryGroupRequest"
    }
}

/// Request message for
/// [DeleteEntryGroup][google.cloud.datacatalog.v1.DataCatalog.DeleteEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteEntryGroup]: crate::client::DataCatalog::delete_entry_group
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntryGroupRequest {

    /// Required. The name of the entry group to delete.
    pub name: std::string::String,

    /// Optional. If true, deletes all entries in the entry group.
    pub force: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntryGroupRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteEntryGroupRequest"
    }
}

/// Request message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups]: crate::client::DataCatalog::list_entry_groups
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryGroupsRequest {

    /// Required. The name of the location that contains the entry groups to list.
    ///
    /// Can be provided as a URL.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// Default is 10. Maximum limit is 1000.
    /// Throws an invalid argument if `page_size` is greater than 1000.
    pub page_size: i32,

    /// Optional. Pagination token that specifies the next page to return.
    /// If empty, returns the first page.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntryGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntryGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntryGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntryGroupsRequest"
    }
}

/// Response message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups]: crate::client::DataCatalog::list_entry_groups
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryGroupsResponse {

    /// Entry group details.
    pub entry_groups: std::vec::Vec<crate::model::EntryGroup>,

    /// Pagination token to specify in the next call to retrieve the next page of
    /// results. Empty if there are no more items.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_groups][crate::model::ListEntryGroupsResponse::entry_groups].
    pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntryGroup>
    {
        use std::iter::Iterator;
        self.entry_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntryGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntryGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntryGroupsResponse {
    type PageItem = crate::model::EntryGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entry_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [CreateEntry][google.cloud.datacatalog.v1.DataCatalog.CreateEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateEntry]: crate::client::DataCatalog::create_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntryRequest {

    /// Required. The name of the entry group this entry belongs to.
    ///
    /// Note: The entry itself and its child resources might not be stored in
    /// the location specified in its name.
    pub parent: std::string::String,

    /// Required. The ID of the entry to create.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// and underscores (_).
    /// The maximum size is 64 bytes when encoded in UTF-8.
    pub entry_id: std::string::String,

    /// Required. The entry to create.
    pub entry: std::option::Option<crate::model::Entry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_id][crate::model::CreateEntryRequest::entry_id].
    pub fn set_entry_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_id = v.into();
        self
    }

    /// Sets the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_entry<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Entry>
    {
        self.entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_or_clear_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Entry>
    {
        self.entry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateEntryRequest"
    }
}

/// Request message for
/// [UpdateEntry][google.cloud.datacatalog.v1.DataCatalog.UpdateEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateEntry]: crate::client::DataCatalog::update_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntryRequest {

    /// Required. Updates for the entry. The `name` field must be set.
    pub entry: std::option::Option<crate::model::Entry>,

    /// Names of fields whose values to overwrite on an entry.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    ///
    /// You can modify only the fields listed below.
    ///
    /// For entries with type `DATA_STREAM`:
    ///
    /// * `schema`
    ///
    /// For entries with type `FILESET`:
    ///
    /// * `schema`
    /// * `display_name`
    /// * `description`
    /// * `gcs_fileset_spec`
    /// * `gcs_fileset_spec.file_patterns`
    ///
    /// For entries with `user_specified_type`:
    ///
    /// * `schema`
    /// * `display_name`
    /// * `description`
    /// * `user_specified_type`
    /// * `user_specified_system`
    /// * `linked_resource`
    /// * `source_system_timestamps`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_entry<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Entry>
    {
        self.entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_or_clear_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Entry>
    {
        self.entry = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateEntryRequest"
    }
}

/// Request message for
/// [DeleteEntry][google.cloud.datacatalog.v1.DataCatalog.DeleteEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteEntry]: crate::client::DataCatalog::delete_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntryRequest {

    /// Required. The name of the entry to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteEntryRequest"
    }
}

/// Request message for
/// [GetEntry][google.cloud.datacatalog.v1.DataCatalog.GetEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetEntry]: crate::client::DataCatalog::get_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntryRequest {

    /// Required. The name of the entry to get.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetEntryRequest"
    }
}

/// Request message for
/// [LookupEntry][google.cloud.datacatalog.v1.DataCatalog.LookupEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.LookupEntry]: crate::client::DataCatalog::lookup_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupEntryRequest {

    /// Project where the lookup should be performed. Required to lookup
    /// entry that is not a part of `DPMS` or `DATAPLEX` `integrated_system`
    /// using its `fully_qualified_name`. Ignored in other cases.
    pub project: std::string::String,

    /// Location where the lookup should be performed. Required to lookup
    /// entry that is not a part of `DPMS` or `DATAPLEX` `integrated_system`
    /// using its `fully_qualified_name`. Ignored in other cases.
    pub location: std::string::String,

    /// Required. A full name, SQL name, or a fully qualified name of a
    /// Google Cloud Platform resource.
    pub target_name: std::option::Option<crate::model::lookup_entry_request::TargetName>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::LookupEntryRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::LookupEntryRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name].
    ///
    /// Note that all the setters affecting `target_name` are mutually
    /// exclusive.
    pub fn set_target_name<T: std::convert::Into<std::option::Option<crate::model::lookup_entry_request::TargetName>>>(mut self, v: T) -> Self
    {
        self.target_name = v.into();
        self
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `LinkedResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn linked_resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::LinkedResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `LinkedResource`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::LinkedResource(
                v.into()
            )
        );
        self
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `SqlResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::SqlResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `SqlResource`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_sql_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::SqlResource(
                v.into()
            )
        );
        self
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `FullyQualifiedName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fully_qualified_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::FullyQualifiedName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `FullyQualifiedName`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::FullyQualifiedName(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for LookupEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.LookupEntryRequest"
    }
}

/// Defines additional types related to [LookupEntryRequest].
pub mod lookup_entry_request {
    #[allow(unused_imports)]
    use super::*;


    /// Required. A full name, SQL name, or a fully qualified name of a
    /// Google Cloud Platform resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetName {
        /// The full name of the Google Cloud Platform resource the Data Catalog
        /// entry represents. For more information, see [Full Resource Name]
        /// (<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
        ///
        /// Full names are case-sensitive. For example:
        ///
        /// * `//bigquery.googleapis.com/projects/{PROJECT_ID}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
        /// * `//pubsub.googleapis.com/projects/{PROJECT_ID}/topics/{TOPIC_ID}`
        LinkedResource(std::string::String),
        /// The SQL name of the entry. SQL names are case-sensitive.
        ///
        /// Examples:
        ///
        /// * `pubsub.topic.{PROJECT_ID}.{TOPIC_ID}`
        /// * `pubsub.topic.{PROJECT_ID}.`\``{TOPIC.ID.SEPARATED.WITH.DOTS}`\`
        /// * `bigquery.table.{PROJECT_ID}.{DATASET_ID}.{TABLE_ID}`
        /// * `bigquery.dataset.{PROJECT_ID}.{DATASET_ID}`
        /// * `datacatalog.entry.{PROJECT_ID}.{LOCATION_ID}.{ENTRY_GROUP_ID}.{ENTRY_ID}`
        ///
        /// Identifiers (`*_ID`) should comply with the
        /// [Lexical structure in GoogleSQL]
        /// (<https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical>).
        SqlResource(std::string::String),
        /// [Fully Qualified Name
        /// (FQN)](https://cloud.google.com//data-catalog/docs/fully-qualified-names)
        /// of the resource.
        ///
        /// FQNs take two forms:
        ///
        /// * For non-regionalized resources:
        ///
        ///   `{SYSTEM}:{PROJECT}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
        ///
        /// * For regionalized resources:
        ///
        ///   `{SYSTEM}:{PROJECT}.{LOCATION_ID}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
        ///
        ///
        /// Example for a DPMS table:
        ///
        /// `dataproc_metastore:{PROJECT_ID}.{LOCATION_ID}.{INSTANCE_ID}.{DATABASE_ID}.{TABLE_ID}`
        FullyQualifiedName(std::string::String),
    }
}

/// Entry metadata.
/// A Data Catalog entry represents another resource in Google
/// Cloud Platform (such as a BigQuery dataset or a Pub/Sub topic) or
/// outside of it. You can use the `linked_resource` field
/// in the entry resource to refer to the original resource ID of the source
/// system.
///
/// An entry resource contains resource details, for example, its schema.
/// Additionally, you can attach flexible metadata to an entry in the form of a
/// [Tag][google.cloud.datacatalog.v1.Tag].
///
/// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Entry {

    /// Output only. Identifier. The resource name of an entry in URL format.
    ///
    /// Note: The entry itself and its child resources might not be
    /// stored in the location specified in its name.
    pub name: std::string::String,

    /// The resource this metadata entry refers to.
    ///
    /// For Google Cloud Platform resources, `linked_resource` is the
    /// [Full Resource Name]
    /// (<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
    /// For example, the `linked_resource` for a table resource from BigQuery is:
    ///
    /// `//bigquery.googleapis.com/projects/{PROJECT_ID}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
    ///
    /// Output only when the entry is one of the types in the `EntryType` enum.
    ///
    /// For entries with a `user_specified_type`, this field is optional and
    /// defaults to an empty string.
    ///
    /// The resource string must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), periods (.), colons (:), slashes (/), dashes (-),
    /// and hashes (#).
    /// The maximum size is 200 bytes when encoded in UTF-8.
    pub linked_resource: std::string::String,

    /// [Fully Qualified Name
    /// (FQN)](https://cloud.google.com//data-catalog/docs/fully-qualified-names)
    /// of the resource. Set automatically for entries representing resources from
    /// synced systems. Settable only during creation, and read-only later. Can
    /// be used for search and lookup of the entries.
    pub fully_qualified_name: std::string::String,

    /// Display name of an entry.
    ///
    /// The maximum size is 500 bytes when encoded in UTF-8.
    /// Default value is an empty string.
    pub display_name: std::string::String,

    /// Entry description that can consist of several sentences or paragraphs
    /// that describe entry contents.
    ///
    /// The description must not contain Unicode non-characters as well as C0
    /// and C1 control codes except tabs (HT), new lines (LF), carriage returns
    /// (CR), and page breaks (FF).
    /// The maximum size is 2000 bytes when encoded in UTF-8.
    /// Default value is an empty string.
    pub description: std::string::String,

    /// Business Context of the entry. Not supported for BigQuery datasets
    pub business_context: std::option::Option<crate::model::BusinessContext>,

    /// Schema of the entry. An entry might not have any schema attached to it.
    pub schema: std::option::Option<crate::model::Schema>,

    /// Timestamps from the underlying resource, not from the Data Catalog
    /// entry.
    ///
    /// Output only when the entry has a system listed in the `IntegratedSystem`
    /// enum. For entries with `user_specified_system`, this field is optional
    /// and defaults to an empty timestamp.
    pub source_system_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Resource usage statistics.
    pub usage_signal: std::option::Option<crate::model::UsageSignal>,

    /// Cloud labels attached to the entry.
    ///
    /// In Data Catalog, you can create and modify labels attached only to custom
    /// entries. Synced entries have unmodifiable labels that come from the source
    /// system.
    pub labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// Output only. Physical location of the entry.
    pub data_source: std::option::Option<crate::model::DataSource>,

    /// Output only. Additional information related to the entry. Private to the
    /// current user.
    pub personal_details: std::option::Option<crate::model::PersonalDetails>,

    /// Required. Entry type.
    pub entry_type: std::option::Option<crate::model::entry::EntryType>,

    /// The source system of the entry.
    pub system: std::option::Option<crate::model::entry::System>,

    /// System specification.
    /// Can be used as a complement for `spec`, when some metadata is relevant for
    /// all entries existing within given system
    pub system_spec: std::option::Option<crate::model::entry::SystemSpec>,

    /// Type specification.
    pub type_spec: std::option::Option<crate::model::entry::TypeSpec>,

    /// Type- and system-specific information. Specifications for types contain
    /// fields common to all entries of a given type, and sub-specifications with
    /// fields specific to a given source system.
    ///
    /// When extending the API with new types and systems, use this field instead
    /// of the legacy `type_spec`.
    pub spec: std::option::Option<crate::model::entry::Spec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [linked_resource][crate::model::Entry::linked_resource].
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::Entry::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Entry::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Entry::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [business_context][crate::model::Entry::business_context].
    pub fn set_business_context<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::BusinessContext>
    {
        self.business_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [business_context][crate::model::Entry::business_context].
    pub fn set_or_clear_business_context<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::BusinessContext>
    {
        self.business_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::Entry::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Schema>
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::Entry::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Schema>
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_system_timestamps][crate::model::Entry::source_system_timestamps].
    pub fn set_source_system_timestamps<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.source_system_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_system_timestamps][crate::model::Entry::source_system_timestamps].
    pub fn set_or_clear_source_system_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.source_system_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [usage_signal][crate::model::Entry::usage_signal].
    pub fn set_usage_signal<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::UsageSignal>
    {
        self.usage_signal = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [usage_signal][crate::model::Entry::usage_signal].
    pub fn set_or_clear_usage_signal<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::UsageSignal>
    {
        self.usage_signal = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Entry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [data_source][crate::model::Entry::data_source].
    pub fn set_data_source<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::DataSource>
    {
        self.data_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source][crate::model::Entry::data_source].
    pub fn set_or_clear_data_source<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::DataSource>
    {
        self.data_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [personal_details][crate::model::Entry::personal_details].
    pub fn set_personal_details<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::PersonalDetails>
    {
        self.personal_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [personal_details][crate::model::Entry::personal_details].
    pub fn set_or_clear_personal_details<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::PersonalDetails>
    {
        self.personal_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type].
    ///
    /// Note that all the setters affecting `entry_type` are mutually
    /// exclusive.
    pub fn set_entry_type<T: std::convert::Into<std::option::Option<crate::model::entry::EntryType>>>(mut self, v: T) -> Self
    {
        self.entry_type = v.into();
        self
    }

    /// The value of [entry_type][crate::model::Entry::entry_type]
    /// if it holds a `Type`, `None` if the field is not set or
    /// holds a different branch.
    pub fn r#type(&self) -> std::option::Option<&crate::model::EntryType> {
        #[allow(unreachable_patterns)]
        self.entry_type.as_ref().and_then(|v| match v {
            crate::model::entry::EntryType::Type(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type]
    /// to hold a `Type`.
    ///
    /// Note that all the setters affecting `entry_type` are
    /// mutually exclusive.
    pub fn set_type<T: std::convert::Into<crate::model::EntryType>>(mut self, v: T) -> Self {
        self.entry_type = std::option::Option::Some(
            crate::model::entry::EntryType::Type(
                v.into()
            )
        );
        self
    }

    /// The value of [entry_type][crate::model::Entry::entry_type]
    /// if it holds a `UserSpecifiedType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_specified_type(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.entry_type.as_ref().and_then(|v| match v {
            crate::model::entry::EntryType::UserSpecifiedType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type]
    /// to hold a `UserSpecifiedType`.
    ///
    /// Note that all the setters affecting `entry_type` are
    /// mutually exclusive.
    pub fn set_user_specified_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_type = std::option::Option::Some(
            crate::model::entry::EntryType::UserSpecifiedType(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [system][crate::model::Entry::system].
    ///
    /// Note that all the setters affecting `system` are mutually
    /// exclusive.
    pub fn set_system<T: std::convert::Into<std::option::Option<crate::model::entry::System>>>(mut self, v: T) -> Self
    {
        self.system = v.into();
        self
    }

    /// The value of [system][crate::model::Entry::system]
    /// if it holds a `IntegratedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integrated_system(&self) -> std::option::Option<&crate::model::IntegratedSystem> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::entry::System::IntegratedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::Entry::system]
    /// to hold a `IntegratedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_integrated_system<T: std::convert::Into<crate::model::IntegratedSystem>>(mut self, v: T) -> Self {
        self.system = std::option::Option::Some(
            crate::model::entry::System::IntegratedSystem(
                v.into()
            )
        );
        self
    }

    /// The value of [system][crate::model::Entry::system]
    /// if it holds a `UserSpecifiedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_specified_system(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::entry::System::UserSpecifiedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::Entry::system]
    /// to hold a `UserSpecifiedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_user_specified_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system = std::option::Option::Some(
            crate::model::entry::System::UserSpecifiedSystem(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<T: std::convert::Into<std::option::Option<crate::model::entry::SystemSpec>>>(mut self, v: T) -> Self
    {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `SqlDatabaseSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_database_system_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::SqlDatabaseSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::SqlDatabaseSystemSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `SqlDatabaseSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_sql_database_system_spec<T: std::convert::Into<std::boxed::Box<crate::model::SqlDatabaseSystemSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::entry::SystemSpec::SqlDatabaseSystemSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `LookerSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn looker_system_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::LookerSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::LookerSystemSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `LookerSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_looker_system_spec<T: std::convert::Into<std::boxed::Box<crate::model::LookerSystemSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::entry::SystemSpec::LookerSystemSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `CloudBigtableSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_bigtable_system_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudBigtableSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::CloudBigtableSystemSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `CloudBigtableSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_cloud_bigtable_system_spec<T: std::convert::Into<std::boxed::Box<crate::model::CloudBigtableSystemSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::entry::SystemSpec::CloudBigtableSystemSpec(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec].
    ///
    /// Note that all the setters affecting `type_spec` are mutually
    /// exclusive.
    pub fn set_type_spec<T: std::convert::Into<std::option::Option<crate::model::entry::TypeSpec>>>(mut self, v: T) -> Self
    {
        self.type_spec = v.into();
        self
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `GcsFilesetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_fileset_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsFilesetSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::GcsFilesetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `GcsFilesetSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_gcs_fileset_spec<T: std::convert::Into<std::boxed::Box<crate::model::GcsFilesetSpec>>>(mut self, v: T) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::entry::TypeSpec::GcsFilesetSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `BigqueryTableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_table_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::BigqueryTableSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `BigqueryTableSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_table_spec<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableSpec>>>(mut self, v: T) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::entry::TypeSpec::BigqueryTableSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `BigqueryDateShardedSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_date_sharded_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDateShardedSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::BigqueryDateShardedSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `BigqueryDateShardedSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_date_sharded_spec<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDateShardedSpec>>>(mut self, v: T) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::entry::TypeSpec::BigqueryDateShardedSpec(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::entry::Spec>>>(mut self, v: T) -> Self
    {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DatabaseTableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_table_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseTableSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DatabaseTableSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DatabaseTableSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_database_table_spec<T: std::convert::Into<std::boxed::Box<crate::model::DatabaseTableSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::DatabaseTableSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DataSourceConnectionSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_source_connection_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::DataSourceConnectionSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DataSourceConnectionSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DataSourceConnectionSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_source_connection_spec<T: std::convert::Into<std::boxed::Box<crate::model::DataSourceConnectionSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::DataSourceConnectionSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `RoutineSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn routine_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::RoutineSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::RoutineSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `RoutineSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_routine_spec<T: std::convert::Into<std::boxed::Box<crate::model::RoutineSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::RoutineSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DatasetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dataset_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::DatasetSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DatasetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DatasetSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_dataset_spec<T: std::convert::Into<std::boxed::Box<crate::model::DatasetSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::DatasetSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `FilesetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fileset_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::FilesetSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::FilesetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `FilesetSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_fileset_spec<T: std::convert::Into<std::boxed::Box<crate::model::FilesetSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::FilesetSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `ServiceSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ServiceSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::ServiceSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `ServiceSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_service_spec<T: std::convert::Into<std::boxed::Box<crate::model::ServiceSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::ServiceSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `ModelSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn model_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ModelSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::ModelSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `ModelSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_model_spec<T: std::convert::Into<std::boxed::Box<crate::model::ModelSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::ModelSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `FeatureOnlineStoreSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn feature_online_store_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::FeatureOnlineStoreSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::FeatureOnlineStoreSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `FeatureOnlineStoreSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_feature_online_store_spec<T: std::convert::Into<std::boxed::Box<crate::model::FeatureOnlineStoreSpec>>>(mut self, v: T) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::entry::Spec::FeatureOnlineStoreSpec(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for Entry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Entry"
    }
}

/// Defines additional types related to [Entry].
pub mod entry {
    #[allow(unused_imports)]
    use super::*;


    /// Required. Entry type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntryType {
        /// The type of the entry.
        ///
        /// For details, see [`EntryType`](#entrytype).
        Type(crate::model::EntryType),
        /// Custom entry type that doesn't match any of the values allowed for input
        /// and listed in the `EntryType` enum.
        ///
        /// When creating an entry, first check the type values in the enum.
        /// If there are no appropriate types for the new entry,
        /// provide a custom value, for example, `my_special_type`.
        ///
        /// The `user_specified_type` string has the following limitations:
        ///
        /// * Is case insensitive.
        /// * Must begin with a letter or underscore.
        /// * Can only contain letters, numbers, and underscores.
        /// * Must be at least 1 character and at most 64 characters long.
        UserSpecifiedType(std::string::String),
    }

    /// The source system of the entry.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum System {
        /// Output only. Indicates the entry's source system that Data Catalog
        /// integrates with, such as BigQuery, Pub/Sub, or Dataproc Metastore.
        IntegratedSystem(crate::model::IntegratedSystem),
        /// Indicates the entry's source system that Data Catalog doesn't
        /// automatically integrate with.
        ///
        /// The `user_specified_system` string has the following limitations:
        ///
        /// * Is case insensitive.
        /// * Must begin with a letter or underscore.
        /// * Can only contain letters, numbers, and underscores.
        /// * Must be at least 1 character and at most 64 characters long.
        UserSpecifiedSystem(std::string::String),
    }

    /// System specification.
    /// Can be used as a complement for `spec`, when some metadata is relevant for
    /// all entries existing within given system
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification that applies to a relational database system. Only settable
        /// when `user_specified_system` is equal to `SQL_DATABASE`
        SqlDatabaseSystemSpec(std::boxed::Box<crate::model::SqlDatabaseSystemSpec>),
        /// Specification that applies to Looker sysstem. Only settable when
        /// `user_specified_system` is equal to `LOOKER`
        LookerSystemSpec(std::boxed::Box<crate::model::LookerSystemSpec>),
        /// Specification that applies to Cloud Bigtable system. Only settable when
        /// `integrated_system` is equal to `CLOUD_BIGTABLE`
        CloudBigtableSystemSpec(std::boxed::Box<crate::model::CloudBigtableSystemSpec>),
    }

    /// Type specification.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeSpec {
        /// Specification that applies to a Cloud Storage fileset. Valid only
        /// for entries with the `FILESET` type.
        GcsFilesetSpec(std::boxed::Box<crate::model::GcsFilesetSpec>),
        /// Output only. Specification that applies to a BigQuery table. Valid only
        /// for entries with the `TABLE` type.
        BigqueryTableSpec(std::boxed::Box<crate::model::BigQueryTableSpec>),
        /// Output only. Specification for a group of BigQuery tables with
        /// the `[prefix]YYYYMMDD` name pattern.
        ///
        /// For more information, see [Introduction to partitioned tables]
        /// (<https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding>).
        BigqueryDateShardedSpec(std::boxed::Box<crate::model::BigQueryDateShardedSpec>),
    }

    /// Type- and system-specific information. Specifications for types contain
    /// fields common to all entries of a given type, and sub-specifications with
    /// fields specific to a given source system.
    ///
    /// When extending the API with new types and systems, use this field instead
    /// of the legacy `type_spec`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Spec {
        /// Specification that applies to a table resource. Valid only
        /// for entries with the `TABLE` or `EXPLORE` type.
        DatabaseTableSpec(std::boxed::Box<crate::model::DatabaseTableSpec>),
        /// Specification that applies to a data source connection. Valid only
        /// for entries with the `DATA_SOURCE_CONNECTION` type.
        DataSourceConnectionSpec(std::boxed::Box<crate::model::DataSourceConnectionSpec>),
        /// Specification that applies to a user-defined function or procedure. Valid
        /// only for entries with the `ROUTINE` type.
        RoutineSpec(std::boxed::Box<crate::model::RoutineSpec>),
        /// Specification that applies to a dataset.
        DatasetSpec(std::boxed::Box<crate::model::DatasetSpec>),
        /// Specification that applies to a fileset resource. Valid only
        /// for entries with the `FILESET` type.
        FilesetSpec(std::boxed::Box<crate::model::FilesetSpec>),
        /// Specification that applies to a Service resource.
        ServiceSpec(std::boxed::Box<crate::model::ServiceSpec>),
        /// Model specification.
        ModelSpec(std::boxed::Box<crate::model::ModelSpec>),
        /// FeatureonlineStore spec for Vertex AI Feature Store.
        FeatureOnlineStoreSpec(std::boxed::Box<crate::model::FeatureOnlineStoreSpec>),
    }
}

/// Specification that applies to a table resource. Valid only
/// for entries with the `TABLE` type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseTableSpec {

    /// Type of this table.
    pub r#type: crate::model::database_table_spec::TableType,

    /// Output only. Fields specific to a Dataplex table and present only in the
    /// Dataplex table entries.
    pub dataplex_table: std::option::Option<crate::model::DataplexTableSpec>,

    /// Spec what applies to tables that are actually views.
    /// Not set for "real" tables.
    pub database_view_spec: std::option::Option<crate::model::database_table_spec::DatabaseViewSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::DatabaseTableSpec::type].
    pub fn set_type<T: std::convert::Into<crate::model::database_table_spec::TableType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [dataplex_table][crate::model::DatabaseTableSpec::dataplex_table].
    pub fn set_dataplex_table<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::DataplexTableSpec>
    {
        self.dataplex_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_table][crate::model::DatabaseTableSpec::dataplex_table].
    pub fn set_or_clear_dataplex_table<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::DataplexTableSpec>
    {
        self.dataplex_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_view_spec][crate::model::DatabaseTableSpec::database_view_spec].
    pub fn set_database_view_spec<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::database_table_spec::DatabaseViewSpec>
    {
        self.database_view_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_view_spec][crate::model::DatabaseTableSpec::database_view_spec].
    pub fn set_or_clear_database_view_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::database_table_spec::DatabaseViewSpec>
    {
        self.database_view_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatabaseTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DatabaseTableSpec"
    }
}

/// Defines additional types related to [DatabaseTableSpec].
pub mod database_table_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Specification that applies to database view.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DatabaseViewSpec {

        /// Type of this view.
        pub view_type: crate::model::database_table_spec::database_view_spec::ViewType,

        /// Definition of the view.
        pub source_definition: std::option::Option<crate::model::database_table_spec::database_view_spec::SourceDefinition>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DatabaseViewSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [view_type][crate::model::database_table_spec::DatabaseViewSpec::view_type].
        pub fn set_view_type<T: std::convert::Into<crate::model::database_table_spec::database_view_spec::ViewType>>(mut self, v: T) -> Self {
            self.view_type = v.into();
            self
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition].
        ///
        /// Note that all the setters affecting `source_definition` are mutually
        /// exclusive.
        pub fn set_source_definition<T: std::convert::Into<std::option::Option<crate::model::database_table_spec::database_view_spec::SourceDefinition>>>(mut self, v: T) -> Self
        {
            self.source_definition = v.into();
            self
        }

        /// The value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// if it holds a `BaseTable`, `None` if the field is not set or
        /// holds a different branch.
        pub fn base_table(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source_definition.as_ref().and_then(|v| match v {
                crate::model::database_table_spec::database_view_spec::SourceDefinition::BaseTable(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// to hold a `BaseTable`.
        ///
        /// Note that all the setters affecting `source_definition` are
        /// mutually exclusive.
        pub fn set_base_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_definition = std::option::Option::Some(
                crate::model::database_table_spec::database_view_spec::SourceDefinition::BaseTable(
                    v.into()
                )
            );
            self
        }

        /// The value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// if it holds a `SqlQuery`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_query(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source_definition.as_ref().and_then(|v| match v {
                crate::model::database_table_spec::database_view_spec::SourceDefinition::SqlQuery(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// to hold a `SqlQuery`.
        ///
        /// Note that all the setters affecting `source_definition` are
        /// mutually exclusive.
        pub fn set_sql_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_definition = std::option::Option::Some(
                crate::model::database_table_spec::database_view_spec::SourceDefinition::SqlQuery(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for DatabaseViewSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.DatabaseTableSpec.DatabaseViewSpec"
        }
    }

    /// Defines additional types related to [DatabaseViewSpec].
    pub mod database_view_spec {
        #[allow(unused_imports)]
        use super::*;


        /// Concrete type of the view.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ViewType {
            /// Default unknown view type.
            Unspecified,
            /// Standard view.
            StandardView,
            /// Materialized view.
            MaterializedView,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ViewType::value] or
            /// [ViewType::name].
            UnknownValue(view_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod view_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ViewType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::StandardView => std::option::Option::Some(1),
                    Self::MaterializedView => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("VIEW_TYPE_UNSPECIFIED"),
                    Self::StandardView => std::option::Option::Some("STANDARD_VIEW"),
                    Self::MaterializedView => std::option::Option::Some("MATERIALIZED_VIEW"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ViewType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ViewType {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ViewType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::StandardView,
                    2 => Self::MaterializedView,
                    _ => Self::UnknownValue(view_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for ViewType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VIEW_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "STANDARD_VIEW" => Self::StandardView,
                    "MATERIALIZED_VIEW" => Self::MaterializedView,
                    _ => Self::UnknownValue(view_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for ViewType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::StandardView => serializer.serialize_i32(1),
                    Self::MaterializedView => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ViewType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ViewType>::new(
                    ".google.cloud.datacatalog.v1.DatabaseTableSpec.DatabaseViewSpec.ViewType"))
            }
        }

        /// Definition of the view.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SourceDefinition {
            /// Name of a singular table this view reflects one to one.
            BaseTable(std::string::String),
            /// SQL query used to generate this view.
            SqlQuery(std::string::String),
        }
    }

    /// Type of the table.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TableType {
        /// Default unknown table type.
        Unspecified,
        /// Native table.
        Native,
        /// External table.
        External,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TableType::value] or
        /// [TableType::name].
        UnknownValue(table_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod table_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TableType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Native => std::option::Option::Some(1),
                Self::External => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TABLE_TYPE_UNSPECIFIED"),
                Self::Native => std::option::Option::Some("NATIVE"),
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TableType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TableType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TableType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Native,
                2 => Self::External,
                _ => Self::UnknownValue(table_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for TableType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NATIVE" => Self::Native,
                "EXTERNAL" => Self::External,
                _ => Self::UnknownValue(table_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for TableType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Native => serializer.serialize_i32(1),
                Self::External => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TableType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableType>::new(
                ".google.cloud.datacatalog.v1.DatabaseTableSpec.TableType"))
        }
    }
}

/// Specification that applies to a fileset. Valid only for entries with the
/// 'FILESET' type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FilesetSpec {

    /// Fields specific to a Dataplex fileset and present only in the Dataplex
    /// fileset entries.
    pub dataplex_fileset: std::option::Option<crate::model::DataplexFilesetSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataplex_fileset][crate::model::FilesetSpec::dataplex_fileset].
    pub fn set_dataplex_fileset<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::DataplexFilesetSpec>
    {
        self.dataplex_fileset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_fileset][crate::model::FilesetSpec::dataplex_fileset].
    pub fn set_or_clear_dataplex_fileset<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::DataplexFilesetSpec>
    {
        self.dataplex_fileset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FilesetSpec"
    }
}

/// Specification that applies to a data source connection. Valid only for
/// entries with the `DATA_SOURCE_CONNECTION` type.
/// Only one of internal specs can be set at the time, and cannot
/// be changed later.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSourceConnectionSpec {

    /// Output only. Fields specific to BigQuery connections.
    pub bigquery_connection_spec: std::option::Option<crate::model::BigQueryConnectionSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_connection_spec][crate::model::DataSourceConnectionSpec::bigquery_connection_spec].
    pub fn set_bigquery_connection_spec<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::BigQueryConnectionSpec>
    {
        self.bigquery_connection_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_connection_spec][crate::model::DataSourceConnectionSpec::bigquery_connection_spec].
    pub fn set_or_clear_bigquery_connection_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::BigQueryConnectionSpec>
    {
        self.bigquery_connection_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataSourceConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataSourceConnectionSpec"
    }
}

/// Specification that applies to a routine. Valid only for
/// entries with the `ROUTINE` type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RoutineSpec {

    /// The type of the routine.
    pub routine_type: crate::model::routine_spec::RoutineType,

    /// The language the routine is written in. The exact value depends on the
    /// source system. For BigQuery routines, possible values are:
    ///
    /// * `SQL`
    /// * `JAVASCRIPT`
    pub language: std::string::String,

    /// Arguments of the routine.
    pub routine_arguments: std::vec::Vec<crate::model::routine_spec::Argument>,

    /// Return type of the argument. The exact value depends on the source system
    /// and the language.
    pub return_type: std::string::String,

    /// The body of the routine.
    pub definition_body: std::string::String,

    /// Contains fields specific to the source system.
    pub system_spec: std::option::Option<crate::model::routine_spec::SystemSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RoutineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [routine_type][crate::model::RoutineSpec::routine_type].
    pub fn set_routine_type<T: std::convert::Into<crate::model::routine_spec::RoutineType>>(mut self, v: T) -> Self {
        self.routine_type = v.into();
        self
    }

    /// Sets the value of [language][crate::model::RoutineSpec::language].
    pub fn set_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language = v.into();
        self
    }

    /// Sets the value of [routine_arguments][crate::model::RoutineSpec::routine_arguments].
    pub fn set_routine_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::routine_spec::Argument>
    {
        use std::iter::Iterator;
        self.routine_arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [return_type][crate::model::RoutineSpec::return_type].
    pub fn set_return_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.return_type = v.into();
        self
    }

    /// Sets the value of [definition_body][crate::model::RoutineSpec::definition_body].
    pub fn set_definition_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition_body = v.into();
        self
    }

    /// Sets the value of [system_spec][crate::model::RoutineSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<T: std::convert::Into<std::option::Option<crate::model::routine_spec::SystemSpec>>>(mut self, v: T) -> Self
    {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::RoutineSpec::system_spec]
    /// if it holds a `BigqueryRoutineSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_routine_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryRoutineSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::routine_spec::SystemSpec::BigqueryRoutineSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::RoutineSpec::system_spec]
    /// to hold a `BigqueryRoutineSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_routine_spec<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryRoutineSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::routine_spec::SystemSpec::BigqueryRoutineSpec(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for RoutineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RoutineSpec"
    }
}

/// Defines additional types related to [RoutineSpec].
pub mod routine_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Input or output argument of a function or stored procedure.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Argument {

        /// The name of the argument. A return argument of a function might not have
        /// a name.
        pub name: std::string::String,

        /// Specifies whether the argument is input or output.
        pub mode: crate::model::routine_spec::argument::Mode,

        /// Type of the argument. The exact value depends on the source system and
        /// the language.
        pub r#type: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Argument {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::routine_spec::Argument::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [mode][crate::model::routine_spec::Argument::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::routine_spec::argument::Mode>>(mut self, v: T) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::routine_spec::Argument::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Argument {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.RoutineSpec.Argument"
        }
    }

    /// Defines additional types related to [Argument].
    pub mod argument {
        #[allow(unused_imports)]
        use super::*;


        /// The input or output mode of the argument.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Unspecified mode.
            Unspecified,
            /// The argument is input-only.
            In,
            /// The argument is output-only.
            Out,
            /// The argument is both an input and an output.
            Inout,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::In => std::option::Option::Some(1),
                    Self::Out => std::option::Option::Some(2),
                    Self::Inout => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::In => std::option::Option::Some("IN"),
                    Self::Out => std::option::Option::Some("OUT"),
                    Self::Inout => std::option::Option::Some("INOUT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::In,
                    2 => Self::Out,
                    3 => Self::Inout,
                    _ => Self::UnknownValue(mode::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "IN" => Self::In,
                    "OUT" => Self::Out,
                    "INOUT" => Self::Inout,
                    _ => Self::UnknownValue(mode::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::In => serializer.serialize_i32(1),
                    Self::Out => serializer.serialize_i32(2),
                    Self::Inout => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.cloud.datacatalog.v1.RoutineSpec.Argument.Mode"))
            }
        }
    }

    /// The fine-grained type of the routine.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoutineType {
        /// Unspecified type.
        Unspecified,
        /// Non-builtin permanent scalar function.
        ScalarFunction,
        /// Stored procedure.
        Procedure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RoutineType::value] or
        /// [RoutineType::name].
        UnknownValue(routine_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod routine_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RoutineType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ScalarFunction => std::option::Option::Some(1),
                Self::Procedure => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUTINE_TYPE_UNSPECIFIED"),
                Self::ScalarFunction => std::option::Option::Some("SCALAR_FUNCTION"),
                Self::Procedure => std::option::Option::Some("PROCEDURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RoutineType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RoutineType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RoutineType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ScalarFunction,
                2 => Self::Procedure,
                _ => Self::UnknownValue(routine_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for RoutineType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUTINE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCALAR_FUNCTION" => Self::ScalarFunction,
                "PROCEDURE" => Self::Procedure,
                _ => Self::UnknownValue(routine_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for RoutineType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ScalarFunction => serializer.serialize_i32(1),
                Self::Procedure => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RoutineType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RoutineType>::new(
                ".google.cloud.datacatalog.v1.RoutineSpec.RoutineType"))
        }
    }

    /// Contains fields specific to the source system.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Fields specific for BigQuery routines.
        BigqueryRoutineSpec(std::boxed::Box<crate::model::BigQueryRoutineSpec>),
    }
}

/// Specification that applies to a dataset. Valid only for
/// entries with the `DATASET` type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetSpec {

    /// Fields specific to the source system.
    pub system_spec: std::option::Option<crate::model::dataset_spec::SystemSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system_spec][crate::model::DatasetSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<T: std::convert::Into<std::option::Option<crate::model::dataset_spec::SystemSpec>>>(mut self, v: T) -> Self
    {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::DatasetSpec::system_spec]
    /// if it holds a `VertexDatasetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::dataset_spec::SystemSpec::VertexDatasetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::DatasetSpec::system_spec]
    /// to hold a `VertexDatasetSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_spec<T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::dataset_spec::SystemSpec::VertexDatasetSpec(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DatasetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DatasetSpec"
    }
}

/// Defines additional types related to [DatasetSpec].
pub mod dataset_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Fields specific to the source system.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Vertex AI Dataset specific fields
        VertexDatasetSpec(std::boxed::Box<crate::model::VertexDatasetSpec>),
    }
}

/// Specification that applies to
/// entries that are part `SQL_DATABASE` system
/// (user_specified_type)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlDatabaseSystemSpec {

    /// SQL Database Engine.
    /// enum SqlEngine {
    /// UNDEFINED = 0;
    /// MY_SQL = 1;
    /// POSTGRE_SQL = 2;
    /// SQL_SERVER = 3;
    /// }
    /// Engine of the enclosing database instance.
    pub sql_engine: std::string::String,

    /// Version of the database engine.
    pub database_version: std::string::String,

    /// Host of the SQL database
    /// enum InstanceHost {
    /// UNDEFINED = 0;
    /// SELF_HOSTED = 1;
    /// CLOUD_SQL = 2;
    /// AMAZON_RDS = 3;
    /// AZURE_SQL = 4;
    /// }
    /// Host of the enclousing database instance.
    pub instance_host: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabaseSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_engine][crate::model::SqlDatabaseSystemSpec::sql_engine].
    pub fn set_sql_engine<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_engine = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::SqlDatabaseSystemSpec::database_version].
    pub fn set_database_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [instance_host][crate::model::SqlDatabaseSystemSpec::instance_host].
    pub fn set_instance_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_host = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabaseSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SqlDatabaseSystemSpec"
    }
}

/// Specification that applies to
/// entries that are part `LOOKER` system
/// (user_specified_type)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookerSystemSpec {

    /// ID of the parent Looker Instance. Empty if it does not exist.
    /// Example value: `someinstance.looker.com`
    pub parent_instance_id: std::string::String,

    /// Name of the parent Looker Instance. Empty if it does not exist.
    pub parent_instance_display_name: std::string::String,

    /// ID of the parent Model. Empty if it does not exist.
    pub parent_model_id: std::string::String,

    /// Name of the parent Model. Empty if it does not exist.
    pub parent_model_display_name: std::string::String,

    /// ID of the parent View. Empty if it does not exist.
    pub parent_view_id: std::string::String,

    /// Name of the parent View. Empty if it does not exist.
    pub parent_view_display_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookerSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent_instance_id][crate::model::LookerSystemSpec::parent_instance_id].
    pub fn set_parent_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_instance_id = v.into();
        self
    }

    /// Sets the value of [parent_instance_display_name][crate::model::LookerSystemSpec::parent_instance_display_name].
    pub fn set_parent_instance_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_instance_display_name = v.into();
        self
    }

    /// Sets the value of [parent_model_id][crate::model::LookerSystemSpec::parent_model_id].
    pub fn set_parent_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model_id = v.into();
        self
    }

    /// Sets the value of [parent_model_display_name][crate::model::LookerSystemSpec::parent_model_display_name].
    pub fn set_parent_model_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model_display_name = v.into();
        self
    }

    /// Sets the value of [parent_view_id][crate::model::LookerSystemSpec::parent_view_id].
    pub fn set_parent_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_view_id = v.into();
        self
    }

    /// Sets the value of [parent_view_display_name][crate::model::LookerSystemSpec::parent_view_display_name].
    pub fn set_parent_view_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_view_display_name = v.into();
        self
    }
}

impl wkt::message::Message for LookerSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.LookerSystemSpec"
    }
}

/// Specification that applies to
/// all entries that are part of `CLOUD_BIGTABLE` system
/// (user_specified_type)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudBigtableSystemSpec {

    /// Display name of the Instance. This is user specified and different from
    /// the resource name.
    pub instance_display_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudBigtableSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_display_name][crate::model::CloudBigtableSystemSpec::instance_display_name].
    pub fn set_instance_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_display_name = v.into();
        self
    }
}

impl wkt::message::Message for CloudBigtableSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableSystemSpec"
    }
}

/// Specification that applies to Instance
/// entries that are part of `CLOUD_BIGTABLE` system.
/// (user_specified_type)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudBigtableInstanceSpec {

    /// The list of clusters for the Instance.
    pub cloud_bigtable_cluster_specs: std::vec::Vec<crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudBigtableInstanceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_bigtable_cluster_specs][crate::model::CloudBigtableInstanceSpec::cloud_bigtable_cluster_specs].
    pub fn set_cloud_bigtable_cluster_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec>
    {
        use std::iter::Iterator;
        self.cloud_bigtable_cluster_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudBigtableInstanceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableInstanceSpec"
    }
}

/// Defines additional types related to [CloudBigtableInstanceSpec].
pub mod cloud_bigtable_instance_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Spec that applies to clusters of an Instance of Cloud Bigtable.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudBigtableClusterSpec {

        /// Name of the cluster.
        pub display_name: std::string::String,

        /// Location of the cluster, typically a Cloud zone.
        pub location: std::string::String,

        /// Type of the resource. For a cluster this would be "CLUSTER".
        pub r#type: std::string::String,

        /// A link back to the parent resource, in this case Instance.
        pub linked_resource: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudBigtableClusterSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [location][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [linked_resource][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::linked_resource].
        pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.linked_resource = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudBigtableClusterSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableInstanceSpec.CloudBigtableClusterSpec"
        }
    }
}

/// Specification that applies to a Service resource. Valid only
/// for entries with the `SERVICE` type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceSpec {

    /// System spec
    pub system_spec: std::option::Option<crate::model::service_spec::SystemSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system_spec][crate::model::ServiceSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<T: std::convert::Into<std::option::Option<crate::model::service_spec::SystemSpec>>>(mut self, v: T) -> Self
    {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ServiceSpec::system_spec]
    /// if it holds a `CloudBigtableInstanceSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_bigtable_instance_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudBigtableInstanceSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::service_spec::SystemSpec::CloudBigtableInstanceSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ServiceSpec::system_spec]
    /// to hold a `CloudBigtableInstanceSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_cloud_bigtable_instance_spec<T: std::convert::Into<std::boxed::Box<crate::model::CloudBigtableInstanceSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::service_spec::SystemSpec::CloudBigtableInstanceSpec(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ServiceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ServiceSpec"
    }
}

/// Defines additional types related to [ServiceSpec].
pub mod service_spec {
    #[allow(unused_imports)]
    use super::*;


    /// System spec
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification that applies to Instance entries of `CLOUD_BIGTABLE`
        /// system.
        CloudBigtableInstanceSpec(std::boxed::Box<crate::model::CloudBigtableInstanceSpec>),
    }
}

/// Detail description of the source information of a Vertex model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexModelSourceInfo {

    /// Type of the model source.
    pub source_type: crate::model::vertex_model_source_info::ModelSourceType,

    /// If this Model is copy of another Model. If true then
    /// [source_type][google.cloud.datacatalog.v1.VertexModelSourceInfo.source_type]
    /// pertains to the original.
    ///
    /// [google.cloud.datacatalog.v1.VertexModelSourceInfo.source_type]: crate::model::VertexModelSourceInfo::source_type
    pub copy: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexModelSourceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::VertexModelSourceInfo::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::vertex_model_source_info::ModelSourceType>>(mut self, v: T) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [copy][crate::model::VertexModelSourceInfo::copy].
    pub fn set_copy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.copy = v.into();
        self
    }
}

impl wkt::message::Message for VertexModelSourceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexModelSourceInfo"
    }
}

/// Defines additional types related to [VertexModelSourceInfo].
pub mod vertex_model_source_info {
    #[allow(unused_imports)]
    use super::*;


    /// Source of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelSourceType {
        /// Should not be used.
        Unspecified,
        /// The Model is uploaded by automl training pipeline.
        Automl,
        /// The Model is uploaded by user or custom training pipeline.
        Custom,
        /// The Model is registered and sync'ed from BigQuery ML.
        Bqml,
        /// The Model is saved or tuned from Model Garden.
        ModelGarden,
        /// The Model is saved or tuned from Genie.
        Genie,
        /// The Model is uploaded by text embedding finetuning pipeline.
        CustomTextEmbedding,
        /// The Model is saved or tuned from Marketplace.
        Marketplace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelSourceType::value] or
        /// [ModelSourceType::name].
        UnknownValue(model_source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelSourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automl => std::option::Option::Some(1),
                Self::Custom => std::option::Option::Some(2),
                Self::Bqml => std::option::Option::Some(3),
                Self::ModelGarden => std::option::Option::Some(4),
                Self::Genie => std::option::Option::Some(5),
                Self::CustomTextEmbedding => std::option::Option::Some(6),
                Self::Marketplace => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_SOURCE_TYPE_UNSPECIFIED"),
                Self::Automl => std::option::Option::Some("AUTOML"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::Bqml => std::option::Option::Some("BQML"),
                Self::ModelGarden => std::option::Option::Some("MODEL_GARDEN"),
                Self::Genie => std::option::Option::Some("GENIE"),
                Self::CustomTextEmbedding => std::option::Option::Some("CUSTOM_TEXT_EMBEDDING"),
                Self::Marketplace => std::option::Option::Some("MARKETPLACE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelSourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelSourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelSourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automl,
                2 => Self::Custom,
                3 => Self::Bqml,
                4 => Self::ModelGarden,
                5 => Self::Genie,
                6 => Self::CustomTextEmbedding,
                7 => Self::Marketplace,
                _ => Self::UnknownValue(model_source_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ModelSourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOML" => Self::Automl,
                "CUSTOM" => Self::Custom,
                "BQML" => Self::Bqml,
                "MODEL_GARDEN" => Self::ModelGarden,
                "GENIE" => Self::Genie,
                "CUSTOM_TEXT_EMBEDDING" => Self::CustomTextEmbedding,
                "MARKETPLACE" => Self::Marketplace,
                _ => Self::UnknownValue(model_source_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ModelSourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automl => serializer.serialize_i32(1),
                Self::Custom => serializer.serialize_i32(2),
                Self::Bqml => serializer.serialize_i32(3),
                Self::ModelGarden => serializer.serialize_i32(4),
                Self::Genie => serializer.serialize_i32(5),
                Self::CustomTextEmbedding => serializer.serialize_i32(6),
                Self::Marketplace => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelSourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelSourceType>::new(
                ".google.cloud.datacatalog.v1.VertexModelSourceInfo.ModelSourceType"))
        }
    }
}

/// Specification for vertex model resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexModelSpec {

    /// The version ID of the model.
    pub version_id: std::string::String,

    /// User provided version aliases so that a model version can be referenced via
    /// alias
    pub version_aliases: std::vec::Vec<std::string::String>,

    /// The description of this version.
    pub version_description: std::string::String,

    /// Source of a Vertex model.
    pub vertex_model_source_info: std::option::Option<crate::model::VertexModelSourceInfo>,

    /// URI of the Docker image to be used as the custom container for serving
    /// predictions.
    pub container_image_uri: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexModelSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version_id][crate::model::VertexModelSpec::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::VertexModelSpec::version_aliases].
    pub fn set_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version_description][crate::model::VertexModelSpec::version_description].
    pub fn set_version_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_description = v.into();
        self
    }

    /// Sets the value of [vertex_model_source_info][crate::model::VertexModelSpec::vertex_model_source_info].
    pub fn set_vertex_model_source_info<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::VertexModelSourceInfo>
    {
        self.vertex_model_source_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vertex_model_source_info][crate::model::VertexModelSpec::vertex_model_source_info].
    pub fn set_or_clear_vertex_model_source_info<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::VertexModelSourceInfo>
    {
        self.vertex_model_source_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container_image_uri][crate::model::VertexModelSpec::container_image_uri].
    pub fn set_container_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_image_uri = v.into();
        self
    }
}

impl wkt::message::Message for VertexModelSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexModelSpec"
    }
}

/// Specification for vertex dataset resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexDatasetSpec {

    /// The number of DataItems in this Dataset. Only apply for non-structured
    /// Dataset.
    pub data_item_count: i64,

    /// Type of the dataset.
    pub data_type: crate::model::vertex_dataset_spec::DataType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item_count][crate::model::VertexDatasetSpec::data_item_count].
    pub fn set_data_item_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_item_count = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::VertexDatasetSpec::data_type].
    pub fn set_data_type<T: std::convert::Into<crate::model::vertex_dataset_spec::DataType>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexDatasetSpec"
    }
}

/// Defines additional types related to [VertexDatasetSpec].
pub mod vertex_dataset_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Type of data stored in the dataset.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataType {
        /// Should not be used.
        Unspecified,
        /// Structured data dataset.
        Table,
        /// Image dataset which supports ImageClassification, ImageObjectDetection
        /// and ImageSegmentation problems.
        Image,
        /// Document dataset which supports TextClassification, TextExtraction and
        /// TextSentiment problems.
        Text,
        /// Video dataset which supports VideoClassification, VideoObjectTracking and
        /// VideoActionRecognition problems.
        Video,
        /// Conversation dataset which supports conversation problems.
        Conversation,
        /// TimeSeries dataset.
        TimeSeries,
        /// Document dataset which supports DocumentAnnotation problems.
        Document,
        /// TextToSpeech dataset which supports TextToSpeech problems.
        TextToSpeech,
        /// Translation dataset which supports Translation problems.
        Translation,
        /// Store Vision dataset which is used for HITL integration.
        StoreVision,
        /// Enterprise Knowledge Graph dataset which is used for HITL labeling
        /// integration.
        EnterpriseKnowledgeGraph,
        /// Text prompt dataset which supports Large Language Models.
        TextPrompt,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataType::value] or
        /// [DataType::name].
        UnknownValue(data_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Table => std::option::Option::Some(1),
                Self::Image => std::option::Option::Some(2),
                Self::Text => std::option::Option::Some(3),
                Self::Video => std::option::Option::Some(4),
                Self::Conversation => std::option::Option::Some(5),
                Self::TimeSeries => std::option::Option::Some(6),
                Self::Document => std::option::Option::Some(7),
                Self::TextToSpeech => std::option::Option::Some(8),
                Self::Translation => std::option::Option::Some(9),
                Self::StoreVision => std::option::Option::Some(10),
                Self::EnterpriseKnowledgeGraph => std::option::Option::Some(11),
                Self::TextPrompt => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_TYPE_UNSPECIFIED"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Image => std::option::Option::Some("IMAGE"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Video => std::option::Option::Some("VIDEO"),
                Self::Conversation => std::option::Option::Some("CONVERSATION"),
                Self::TimeSeries => std::option::Option::Some("TIME_SERIES"),
                Self::Document => std::option::Option::Some("DOCUMENT"),
                Self::TextToSpeech => std::option::Option::Some("TEXT_TO_SPEECH"),
                Self::Translation => std::option::Option::Some("TRANSLATION"),
                Self::StoreVision => std::option::Option::Some("STORE_VISION"),
                Self::EnterpriseKnowledgeGraph => std::option::Option::Some("ENTERPRISE_KNOWLEDGE_GRAPH"),
                Self::TextPrompt => std::option::Option::Some("TEXT_PROMPT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Table,
                2 => Self::Image,
                3 => Self::Text,
                4 => Self::Video,
                5 => Self::Conversation,
                6 => Self::TimeSeries,
                7 => Self::Document,
                8 => Self::TextToSpeech,
                9 => Self::Translation,
                10 => Self::StoreVision,
                11 => Self::EnterpriseKnowledgeGraph,
                12 => Self::TextPrompt,
                _ => Self::UnknownValue(data_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for DataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TABLE" => Self::Table,
                "IMAGE" => Self::Image,
                "TEXT" => Self::Text,
                "VIDEO" => Self::Video,
                "CONVERSATION" => Self::Conversation,
                "TIME_SERIES" => Self::TimeSeries,
                "DOCUMENT" => Self::Document,
                "TEXT_TO_SPEECH" => Self::TextToSpeech,
                "TRANSLATION" => Self::Translation,
                "STORE_VISION" => Self::StoreVision,
                "ENTERPRISE_KNOWLEDGE_GRAPH" => Self::EnterpriseKnowledgeGraph,
                "TEXT_PROMPT" => Self::TextPrompt,
                _ => Self::UnknownValue(data_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for DataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Table => serializer.serialize_i32(1),
                Self::Image => serializer.serialize_i32(2),
                Self::Text => serializer.serialize_i32(3),
                Self::Video => serializer.serialize_i32(4),
                Self::Conversation => serializer.serialize_i32(5),
                Self::TimeSeries => serializer.serialize_i32(6),
                Self::Document => serializer.serialize_i32(7),
                Self::TextToSpeech => serializer.serialize_i32(8),
                Self::Translation => serializer.serialize_i32(9),
                Self::StoreVision => serializer.serialize_i32(10),
                Self::EnterpriseKnowledgeGraph => serializer.serialize_i32(11),
                Self::TextPrompt => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataType>::new(
                ".google.cloud.datacatalog.v1.VertexDatasetSpec.DataType"))
        }
    }
}

/// Specification that applies to a model. Valid only for
/// entries with the `MODEL` type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModelSpec {

    /// System spec
    pub system_spec: std::option::Option<crate::model::model_spec::SystemSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system_spec][crate::model::ModelSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<T: std::convert::Into<std::option::Option<crate::model::model_spec::SystemSpec>>>(mut self, v: T) -> Self
    {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ModelSpec::system_spec]
    /// if it holds a `VertexModelSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_model_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::VertexModelSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::model_spec::SystemSpec::VertexModelSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ModelSpec::system_spec]
    /// to hold a `VertexModelSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_vertex_model_spec<T: std::convert::Into<std::boxed::Box<crate::model::VertexModelSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::model_spec::SystemSpec::VertexModelSpec(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ModelSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModelSpec"
    }
}

/// Defines additional types related to [ModelSpec].
pub mod model_spec {
    #[allow(unused_imports)]
    use super::*;


    /// System spec
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification for vertex model resources.
        VertexModelSpec(std::boxed::Box<crate::model::VertexModelSpec>),
    }
}

/// Detail description of the source information of a Vertex Feature Online
/// Store.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FeatureOnlineStoreSpec {

    /// Output only. Type of underlying storage for the FeatureOnlineStore.
    pub storage_type: crate::model::feature_online_store_spec::StorageType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FeatureOnlineStoreSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStoreSpec::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::feature_online_store_spec::StorageType>>(mut self, v: T) -> Self {
        self.storage_type = v.into();
        self
    }
}

impl wkt::message::Message for FeatureOnlineStoreSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FeatureOnlineStoreSpec"
    }
}

/// Defines additional types related to [FeatureOnlineStoreSpec].
pub mod feature_online_store_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Type of underlying storage type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// Should not be used.
        Unspecified,
        /// Underlsying storgae is Bigtable.
        Bigtable,
        /// Underlying is optimized online server (Lightning).
        Optimized,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bigtable => std::option::Option::Some(1),
                Self::Optimized => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Bigtable => std::option::Option::Some("BIGTABLE"),
                Self::Optimized => std::option::Option::Some("OPTIMIZED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bigtable,
                2 => Self::Optimized,
                _ => Self::UnknownValue(storage_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BIGTABLE" => Self::Bigtable,
                "OPTIMIZED" => Self::Optimized,
                _ => Self::UnknownValue(storage_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bigtable => serializer.serialize_i32(1),
                Self::Optimized => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.datacatalog.v1.FeatureOnlineStoreSpec.StorageType"))
        }
    }
}

/// Business Context of the entry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BusinessContext {

    /// Entry overview fields for rich text descriptions of entries.
    pub entry_overview: std::option::Option<crate::model::EntryOverview>,

    /// Contact people for the entry.
    pub contacts: std::option::Option<crate::model::Contacts>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BusinessContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_overview][crate::model::BusinessContext::entry_overview].
    pub fn set_entry_overview<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::EntryOverview>
    {
        self.entry_overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_overview][crate::model::BusinessContext::entry_overview].
    pub fn set_or_clear_entry_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::EntryOverview>
    {
        self.entry_overview = v.map(|x| x.into());
        self
    }

    /// Sets the value of [contacts][crate::model::BusinessContext::contacts].
    pub fn set_contacts<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Contacts>
    {
        self.contacts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contacts][crate::model::BusinessContext::contacts].
    pub fn set_or_clear_contacts<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Contacts>
    {
        self.contacts = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BusinessContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BusinessContext"
    }
}

/// Entry overview fields for rich text descriptions of entries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntryOverview {

    /// Entry overview with support for rich text.
    ///
    /// The overview must only contain Unicode characters, and should be
    /// formatted using HTML.
    /// The maximum length is 10 MiB as this value holds HTML descriptions
    /// including encoded images. The maximum length of the text without images
    /// is 100 KiB.
    pub overview: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryOverview {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overview][crate::model::EntryOverview::overview].
    pub fn set_overview<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.overview = v.into();
        self
    }
}

impl wkt::message::Message for EntryOverview {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.EntryOverview"
    }
}

/// Contact people for the entry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Contacts {

    /// The list of contact people for the entry.
    pub people: std::vec::Vec<crate::model::contacts::Person>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Contacts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [people][crate::model::Contacts::people].
    pub fn set_people<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::contacts::Person>
    {
        use std::iter::Iterator;
        self.people = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Contacts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Contacts"
    }
}

/// Defines additional types related to [Contacts].
pub mod contacts {
    #[allow(unused_imports)]
    use super::*;


    /// A contact person for the entry.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Person {

        /// Designation of the person, for example, Data Steward.
        pub designation: std::string::String,

        /// Email of the person in the format of `john.doe@xyz`,
        /// `<john.doe@xyz>`, or `John Doe<john.doe@xyz>`.
        pub email: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Person {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [designation][crate::model::contacts::Person::designation].
        pub fn set_designation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.designation = v.into();
            self
        }

        /// Sets the value of [email][crate::model::contacts::Person::email].
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }
    }

    impl wkt::message::Message for Person {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.Contacts.Person"
        }
    }
}

/// Entry group metadata.
///
/// An `EntryGroup` resource represents a logical grouping of zero or more
/// Data Catalog [Entry][google.cloud.datacatalog.v1.Entry] resources.
///
/// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntryGroup {

    /// Identifier. The resource name of the entry group in URL format.
    ///
    /// Note: The entry group itself and its child resources might not be
    /// stored in the location specified in its name.
    pub name: std::string::String,

    /// A short name to identify the entry group, for example,
    /// "analytics data - jan 2011". Default value is an empty string.
    pub display_name: std::string::String,

    /// Entry group description. Can consist of several sentences or
    /// paragraphs that describe the entry group contents.
    /// Default value is an empty string.
    pub description: std::string::String,

    /// Output only. Timestamps of the entry group. Default value is empty.
    pub data_catalog_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Optional. When set to [true], it means DataCatalog EntryGroup was
    /// transferred to Dataplex Catalog Service. It makes EntryGroup and its
    /// Entries to be read-only in DataCatalog. However, new Tags on EntryGroup and
    /// its Entries can be created. After setting the flag to [true] it cannot be
    /// unset.
    pub transferred_to_dataplex: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntryGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntryGroup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntryGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [data_catalog_timestamps][crate::model::EntryGroup::data_catalog_timestamps].
    pub fn set_data_catalog_timestamps<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.data_catalog_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_catalog_timestamps][crate::model::EntryGroup::data_catalog_timestamps].
    pub fn set_or_clear_data_catalog_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.data_catalog_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transferred_to_dataplex][crate::model::EntryGroup::transferred_to_dataplex].
    pub fn set_transferred_to_dataplex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.transferred_to_dataplex = v.into();
        self
    }
}

impl wkt::message::Message for EntryGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.EntryGroup"
    }
}

/// Request message for
/// [CreateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplate]: crate::client::DataCatalog::create_tag_template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTagTemplateRequest {

    /// Required. The name of the project and the template location
    /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
    pub parent: std::string::String,

    /// Required. The ID of the tag template to create.
    ///
    /// The ID must contain only lowercase letters (a-z), numbers (0-9),
    /// or underscores (_), and must start with a letter or underscore.
    /// The maximum size is 64 bytes when encoded in UTF-8.
    pub tag_template_id: std::string::String,

    /// Required. The tag template to create.
    pub tag_template: std::option::Option<crate::model::TagTemplate>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template_id][crate::model::CreateTagTemplateRequest::tag_template_id].
    pub fn set_tag_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_template_id = v.into();
        self
    }

    /// Sets the value of [tag_template][crate::model::CreateTagTemplateRequest::tag_template].
    pub fn set_tag_template<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::TagTemplate>
    {
        self.tag_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template][crate::model::CreateTagTemplateRequest::tag_template].
    pub fn set_or_clear_tag_template<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::TagTemplate>
    {
        self.tag_template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagTemplateRequest"
    }
}

/// Request message for
/// [GetTagTemplate][google.cloud.datacatalog.v1.DataCatalog.GetTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetTagTemplate]: crate::client::DataCatalog::get_tag_template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTagTemplateRequest {

    /// Required. The name of the tag template to get.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTagTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetTagTemplateRequest"
    }
}

/// Request message for
/// [UpdateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplate]: crate::client::DataCatalog::update_tag_template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTagTemplateRequest {

    /// Required. The template to update. The `name` field must be set.
    pub tag_template: std::option::Option<crate::model::TagTemplate>,

    /// Names of fields whose values to overwrite on a tag template. Currently,
    /// only `display_name` and `is_publicly_readable` can be overwritten.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    ///
    /// Note: Updating the `is_publicly_readable` field may require up to 12
    /// hours to take effect in search results.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_template][crate::model::UpdateTagTemplateRequest::tag_template].
    pub fn set_tag_template<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::TagTemplate>
    {
        self.tag_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template][crate::model::UpdateTagTemplateRequest::tag_template].
    pub fn set_or_clear_tag_template<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::TagTemplate>
    {
        self.tag_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagTemplateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTagTemplateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagTemplateRequest"
    }
}

/// Request message for
/// [DeleteTagTemplate][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplate]: crate::client::DataCatalog::delete_tag_template
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTagTemplateRequest {

    /// Required. The name of the tag template to delete.
    pub name: std::string::String,

    /// Required. If true, deletes all tags that use this template.
    ///
    /// Currently, `true` is the only supported value.
    pub force: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteTagTemplateRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagTemplateRequest"
    }
}

/// Request message for
/// [CreateTag][google.cloud.datacatalog.v1.DataCatalog.CreateTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTag]: crate::client::DataCatalog::create_tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTagRequest {

    /// Required. The name of the resource to attach this tag to.
    ///
    /// Tags can be attached to entries or entry groups. An entry can have up to
    /// 1000 attached tags.
    ///
    /// Note: The tag and its child resources might not be stored in
    /// the location specified in its name.
    pub parent: std::string::String,

    /// Required. The tag to create.
    pub tag: std::option::Option<crate::model::Tag>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::CreateTagRequest::tag].
    pub fn set_tag<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Tag>
    {
        self.tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag][crate::model::CreateTagRequest::tag].
    pub fn set_or_clear_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Tag>
    {
        self.tag = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagRequest"
    }
}

/// Request message for
/// [UpdateTag][google.cloud.datacatalog.v1.DataCatalog.UpdateTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTag]: crate::client::DataCatalog::update_tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTagRequest {

    /// Required. The updated tag. The "name" field must be set.
    pub tag: std::option::Option<crate::model::Tag>,

    /// Names of fields whose values to overwrite on a tag. Currently, a tag has
    /// the only modifiable field with the name `fields`.
    ///
    /// In general, if this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag][crate::model::UpdateTagRequest::tag].
    pub fn set_tag<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Tag>
    {
        self.tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag][crate::model::UpdateTagRequest::tag].
    pub fn set_or_clear_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Tag>
    {
        self.tag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagRequest"
    }
}

/// Request message for
/// [DeleteTag][google.cloud.datacatalog.v1.DataCatalog.DeleteTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTag]: crate::client::DataCatalog::delete_tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTagRequest {

    /// Required. The name of the tag to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagRequest"
    }
}

/// Request message for
/// [CreateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplateField]: crate::client::DataCatalog::create_tag_template_field
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTagTemplateFieldRequest {

    /// Required. The name of the project and the template location
    /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
    pub parent: std::string::String,

    /// Required. The ID of the tag template field to create.
    ///
    /// Note: Adding a required field to an existing template is *not* allowed.
    ///
    /// Field IDs can contain letters (both uppercase and lowercase), numbers
    /// (0-9), underscores (_) and dashes (-). Field IDs must be at least 1
    /// character long and at most 128 characters long. Field IDs must also be
    /// unique within their template.
    pub tag_template_field_id: std::string::String,

    /// Required. The tag template field to create.
    pub tag_template_field: std::option::Option<crate::model::TagTemplateField>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagTemplateFieldRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template_field_id][crate::model::CreateTagTemplateFieldRequest::tag_template_field_id].
    pub fn set_tag_template_field_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_template_field_id = v.into();
        self
    }

    /// Sets the value of [tag_template_field][crate::model::CreateTagTemplateFieldRequest::tag_template_field].
    pub fn set_tag_template_field<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::TagTemplateField>
    {
        self.tag_template_field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template_field][crate::model::CreateTagTemplateFieldRequest::tag_template_field].
    pub fn set_or_clear_tag_template_field<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::TagTemplateField>
    {
        self.tag_template_field = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagTemplateFieldRequest"
    }
}

/// Request message for
/// [UpdateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplateField]: crate::client::DataCatalog::update_tag_template_field
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTagTemplateFieldRequest {

    /// Required. The name of the tag template field.
    pub name: std::string::String,

    /// Required. The template to update.
    pub tag_template_field: std::option::Option<crate::model::TagTemplateField>,

    /// Optional. Names of fields whose values to overwrite on an individual field
    /// of a tag template. The following fields are modifiable:
    ///
    /// * `display_name`
    /// * `type.enum_type`
    /// * `is_required`
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the request
    /// body, their values are emptied with one exception: when updating an enum
    /// type, the provided values are merged with the existing values. Therefore,
    /// enum values can only be added, existing enum values cannot be deleted or
    /// renamed.
    ///
    /// Additionally, updating a template field from optional to required is
    /// *not* allowed.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tag_template_field][crate::model::UpdateTagTemplateFieldRequest::tag_template_field].
    pub fn set_tag_template_field<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::TagTemplateField>
    {
        self.tag_template_field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template_field][crate::model::UpdateTagTemplateFieldRequest::tag_template_field].
    pub fn set_or_clear_tag_template_field<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::TagTemplateField>
    {
        self.tag_template_field = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagTemplateFieldRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTagTemplateFieldRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagTemplateFieldRequest"
    }
}

/// Request message for
/// [RenameTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateField]: crate::client::DataCatalog::rename_tag_template_field
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameTagTemplateFieldRequest {

    /// Required. The name of the tag template field.
    pub name: std::string::String,

    /// Required. The new ID of this tag template field. For example,
    /// `my_new_field`.
    pub new_tag_template_field_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_tag_template_field_id][crate::model::RenameTagTemplateFieldRequest::new_tag_template_field_id].
    pub fn set_new_tag_template_field_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_tag_template_field_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RenameTagTemplateFieldRequest"
    }
}

/// Request message for
/// [RenameTagTemplateFieldEnumValue][google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateFieldEnumValue].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateFieldEnumValue]: crate::client::DataCatalog::rename_tag_template_field_enum_value
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameTagTemplateFieldEnumValueRequest {

    /// Required. The name of the enum field value.
    pub name: std::string::String,

    /// Required. The new display name of the enum value. For example,
    /// `my_new_enum_value`.
    pub new_enum_value_display_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameTagTemplateFieldEnumValueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameTagTemplateFieldEnumValueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_enum_value_display_name][crate::model::RenameTagTemplateFieldEnumValueRequest::new_enum_value_display_name].
    pub fn set_new_enum_value_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_enum_value_display_name = v.into();
        self
    }
}

impl wkt::message::Message for RenameTagTemplateFieldEnumValueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RenameTagTemplateFieldEnumValueRequest"
    }
}

/// Request message for
/// [DeleteTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplateField]: crate::client::DataCatalog::delete_tag_template_field
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTagTemplateFieldRequest {

    /// Required. The name of the tag template field to delete.
    pub name: std::string::String,

    /// Required. If true, deletes this field from any tags that use it.
    ///
    /// Currently, `true` is the only supported value.
    pub force: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteTagTemplateFieldRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagTemplateFieldRequest"
    }
}

/// Request message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTagsRequest {

    /// Required. The name of the Data Catalog resource to list the tags of.
    ///
    /// The resource can be an [Entry][google.cloud.datacatalog.v1.Entry]
    /// or an [EntryGroup][google.cloud.datacatalog.v1.EntryGroup]
    /// (without `/entries/{entries}` at the end).
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    /// [google.cloud.datacatalog.v1.EntryGroup]: crate::model::EntryGroup
    pub parent: std::string::String,

    /// The maximum number of tags to return. Default is 10. Maximum limit is 1000.
    pub page_size: i32,

    /// Pagination token that specifies the next page to return. If empty, the
    /// first page is returned.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTagsRequest"
    }
}

/// Response message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTagsResponse {

    /// [Tag][google.cloud.datacatalog.v1.Tag] details.
    ///
    /// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// Pagination token of the next results page. Empty if there are
    /// no more items in results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tags][crate::model::ListTagsResponse::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTagsResponse {
    type PageItem = crate::model::Tag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReconcileTagsRequest {

    /// Required. Name of [Entry][google.cloud.datacatalog.v1.Entry] to be tagged.
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    pub parent: std::string::String,

    /// Required. The name of the tag template, which is used for reconciliation.
    pub tag_template: std::string::String,

    /// If set to `true`, deletes entry tags related to a tag template
    /// not listed in the tags source from an entry. If set to `false`,
    /// unlisted tags are retained.
    pub force_delete_missing: bool,

    /// A list of tags to apply to an entry. A tag can specify a
    /// tag template, which must be the template specified in the
    /// `ReconcileTagsRequest`.
    /// The sole entry and each of its columns must be mentioned at most once.
    pub tags: std::vec::Vec<crate::model::Tag>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconcileTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReconcileTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template][crate::model::ReconcileTagsRequest::tag_template].
    pub fn set_tag_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_template = v.into();
        self
    }

    /// Sets the value of [force_delete_missing][crate::model::ReconcileTagsRequest::force_delete_missing].
    pub fn set_force_delete_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_delete_missing = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::ReconcileTagsRequest::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReconcileTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsRequest"
    }
}

/// [Long-running operation][google.longrunning.Operation]
/// response message returned by
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReconcileTagsResponse {

    /// Number of tags created in the request.
    pub created_tags_count: i64,

    /// Number of tags updated in the request.
    pub updated_tags_count: i64,

    /// Number of tags deleted in the request.
    pub deleted_tags_count: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconcileTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_tags_count][crate::model::ReconcileTagsResponse::created_tags_count].
    pub fn set_created_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.created_tags_count = v.into();
        self
    }

    /// Sets the value of [updated_tags_count][crate::model::ReconcileTagsResponse::updated_tags_count].
    pub fn set_updated_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.updated_tags_count = v.into();
        self
    }

    /// Sets the value of [deleted_tags_count][crate::model::ReconcileTagsResponse::deleted_tags_count].
    pub fn set_deleted_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.deleted_tags_count = v.into();
        self
    }
}

impl wkt::message::Message for ReconcileTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsResponse"
    }
}

/// [Long-running operation][google.longrunning.Operation]
/// metadata message returned by the
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReconcileTagsMetadata {

    /// State of the reconciliation operation.
    pub state: crate::model::reconcile_tags_metadata::ReconciliationState,

    /// Maps the name of each tagged column (or empty string for a
    /// sole entry) to tagging operation [status][google.rpc.Status].
    ///
    /// [google.rpc.Status]: rpc::model::Status
    pub errors: std::collections::HashMap<std::string::String,rpc::model::Status>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconcileTagsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ReconcileTagsMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::reconcile_tags_metadata::ReconciliationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ReconcileTagsMetadata::errors].
    pub fn set_errors<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ReconcileTagsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsMetadata"
    }
}

/// Defines additional types related to [ReconcileTagsMetadata].
pub mod reconcile_tags_metadata {
    #[allow(unused_imports)]
    use super::*;


    /// Enum holding possible states of the reconciliation operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReconciliationState {
        /// Default value. This value is unused.
        Unspecified,
        /// The reconciliation has been queued and awaits for execution.
        ReconciliationQueued,
        /// The reconciliation is in progress.
        ReconciliationInProgress,
        /// The reconciliation has been finished.
        ReconciliationDone,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReconciliationState::value] or
        /// [ReconciliationState::name].
        UnknownValue(reconciliation_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reconciliation_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReconciliationState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReconciliationQueued => std::option::Option::Some(1),
                Self::ReconciliationInProgress => std::option::Option::Some(2),
                Self::ReconciliationDone => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECONCILIATION_STATE_UNSPECIFIED"),
                Self::ReconciliationQueued => std::option::Option::Some("RECONCILIATION_QUEUED"),
                Self::ReconciliationInProgress => std::option::Option::Some("RECONCILIATION_IN_PROGRESS"),
                Self::ReconciliationDone => std::option::Option::Some("RECONCILIATION_DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReconciliationState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReconciliationState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReconciliationState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReconciliationQueued,
                2 => Self::ReconciliationInProgress,
                3 => Self::ReconciliationDone,
                _ => Self::UnknownValue(reconciliation_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ReconciliationState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECONCILIATION_STATE_UNSPECIFIED" => Self::Unspecified,
                "RECONCILIATION_QUEUED" => Self::ReconciliationQueued,
                "RECONCILIATION_IN_PROGRESS" => Self::ReconciliationInProgress,
                "RECONCILIATION_DONE" => Self::ReconciliationDone,
                _ => Self::UnknownValue(reconciliation_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ReconciliationState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReconciliationQueued => serializer.serialize_i32(1),
                Self::ReconciliationInProgress => serializer.serialize_i32(2),
                Self::ReconciliationDone => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReconciliationState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReconciliationState>::new(
                ".google.cloud.datacatalog.v1.ReconcileTagsMetadata.ReconciliationState"))
        }
    }
}

/// Request message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntries]: crate::client::DataCatalog::list_entries
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntriesRequest {

    /// Required. The name of the entry group that contains the entries to list.
    ///
    /// Can be provided in URL format.
    pub parent: std::string::String,

    /// The maximum number of items to return. Default is 10. Maximum limit is
    /// 1000. Throws an invalid argument if `page_size` is more than 1000.
    pub page_size: i32,

    /// Pagination token that specifies the next page to return. If empty, the
    /// first page is returned.
    pub page_token: std::string::String,

    /// The fields to return for each entry. If empty or omitted, all
    /// fields are returned.
    ///
    /// For example, to return a list of entries with only the `name` field,
    /// set `read_mask` to only one path with the `name` value.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListEntriesRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListEntriesRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntriesRequest"
    }
}

/// Response message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntries]: crate::client::DataCatalog::list_entries
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntriesResponse {

    /// Entry details.
    pub entries: std::vec::Vec<crate::model::Entry>,

    /// Pagination token of the next results page. Empty if there are no more items
    /// in results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::ListEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entry>
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntriesResponse {
    type PageItem = crate::model::Entry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [StarEntry][google.cloud.datacatalog.v1.DataCatalog.StarEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.StarEntry]: crate::client::DataCatalog::star_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StarEntryRequest {

    /// Required. The name of the entry to mark as starred.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StarEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StarEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StarEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StarEntryRequest"
    }
}

/// Response message for
/// [StarEntry][google.cloud.datacatalog.v1.DataCatalog.StarEntry].
/// Empty for now
///
/// [google.cloud.datacatalog.v1.DataCatalog.StarEntry]: crate::client::DataCatalog::star_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StarEntryResponse {

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StarEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StarEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StarEntryResponse"
    }
}

/// Request message for
/// [UnstarEntry][google.cloud.datacatalog.v1.DataCatalog.UnstarEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UnstarEntry]: crate::client::DataCatalog::unstar_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UnstarEntryRequest {

    /// Required. The name of the entry to mark as **not** starred.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnstarEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UnstarEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UnstarEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UnstarEntryRequest"
    }
}

/// Response message for
/// [UnstarEntry][google.cloud.datacatalog.v1.DataCatalog.UnstarEntry].
/// Empty for now
///
/// [google.cloud.datacatalog.v1.DataCatalog.UnstarEntry]: crate::client::DataCatalog::unstar_entry
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UnstarEntryResponse {

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnstarEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UnstarEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UnstarEntryResponse"
    }
}

/// Request message for
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries]
/// method.
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntriesRequest {

    /// Required. Target entry group for ingested entries.
    pub parent: std::string::String,

    /// Optional. (Optional) Dataplex task job id, if specified will be used as
    /// part of ImportEntries LRO ID
    pub job_id: std::string::String,

    /// Source of imported entries, e.g. dump stored in a Cloud Storage
    pub source: std::option::Option<crate::model::import_entries_request::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::ImportEntriesRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportEntriesRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::import_entries_request::Source>>>(mut self, v: T) -> Self
    {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportEntriesRequest::source]
    /// if it holds a `GcsBucketPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_bucket_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_entries_request::Source::GcsBucketPath(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportEntriesRequest::source]
    /// to hold a `GcsBucketPath`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_bucket_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_entries_request::Source::GcsBucketPath(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ImportEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesRequest"
    }
}

/// Defines additional types related to [ImportEntriesRequest].
pub mod import_entries_request {
    #[allow(unused_imports)]
    use super::*;


    /// Source of imported entries, e.g. dump stored in a Cloud Storage
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Path to a Cloud Storage bucket that contains a dump ready for ingestion.
        GcsBucketPath(std::string::String),
    }
}

/// Response message for [long-running operation][google.longrunning.Operation]
/// returned by the
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntriesResponse {

    /// Cumulative number of entries created and entries updated as a result of
    /// import operation.
    pub upserted_entries_count: std::option::Option<i64>,

    /// Number of entries deleted as a result of import operation.
    pub deleted_entries_count: std::option::Option<i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upserted_entries_count][crate::model::ImportEntriesResponse::upserted_entries_count].
    pub fn set_upserted_entries_count<T>(mut self, v: T) -> Self
    where T: std::convert::Into<i64>
    {
        self.upserted_entries_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upserted_entries_count][crate::model::ImportEntriesResponse::upserted_entries_count].
    pub fn set_or_clear_upserted_entries_count<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<i64>
    {
        self.upserted_entries_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted_entries_count][crate::model::ImportEntriesResponse::deleted_entries_count].
    pub fn set_deleted_entries_count<T>(mut self, v: T) -> Self
    where T: std::convert::Into<i64>
    {
        self.deleted_entries_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted_entries_count][crate::model::ImportEntriesResponse::deleted_entries_count].
    pub fn set_or_clear_deleted_entries_count<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<i64>
    {
        self.deleted_entries_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesResponse"
    }
}

/// Metadata message for [long-running operation][google.longrunning.Operation]
/// returned by the
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntriesMetadata {

    /// State of the import operation.
    pub state: crate::model::import_entries_metadata::ImportState,

    /// Partial errors that are encountered during the ImportEntries operation.
    /// There is no guarantee that all the encountered errors are reported.
    /// However, if no errors are reported, it means that no errors were
    /// encountered.
    pub errors: std::vec::Vec<rpc::model::Status>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ImportEntriesMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_entries_metadata::ImportState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ImportEntriesMetadata::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportEntriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesMetadata"
    }
}

/// Defines additional types related to [ImportEntriesMetadata].
pub mod import_entries_metadata {
    #[allow(unused_imports)]
    use super::*;


    /// Enum holding possible states of the import operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportState {
        /// Default value. This value is unused.
        Unspecified,
        /// The dump with entries has been queued for import.
        ImportQueued,
        /// The import of entries is in progress.
        ImportInProgress,
        /// The import of entries has been finished.
        ImportDone,
        /// The import of entries has been abandoned in favor of a newer request.
        ImportObsolete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ImportState::value] or
        /// [ImportState::name].
        UnknownValue(import_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod import_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ImportState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ImportQueued => std::option::Option::Some(1),
                Self::ImportInProgress => std::option::Option::Some(2),
                Self::ImportDone => std::option::Option::Some(3),
                Self::ImportObsolete => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPORT_STATE_UNSPECIFIED"),
                Self::ImportQueued => std::option::Option::Some("IMPORT_QUEUED"),
                Self::ImportInProgress => std::option::Option::Some("IMPORT_IN_PROGRESS"),
                Self::ImportDone => std::option::Option::Some("IMPORT_DONE"),
                Self::ImportObsolete => std::option::Option::Some("IMPORT_OBSOLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ImportState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ImportState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ImportState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ImportQueued,
                2 => Self::ImportInProgress,
                3 => Self::ImportDone,
                4 => Self::ImportObsolete,
                _ => Self::UnknownValue(import_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ImportState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPORT_STATE_UNSPECIFIED" => Self::Unspecified,
                "IMPORT_QUEUED" => Self::ImportQueued,
                "IMPORT_IN_PROGRESS" => Self::ImportInProgress,
                "IMPORT_DONE" => Self::ImportDone,
                "IMPORT_OBSOLETE" => Self::ImportObsolete,
                _ => Self::UnknownValue(import_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ImportState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ImportQueued => serializer.serialize_i32(1),
                Self::ImportInProgress => serializer.serialize_i32(2),
                Self::ImportDone => serializer.serialize_i32(3),
                Self::ImportObsolete => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ImportState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportState>::new(
                ".google.cloud.datacatalog.v1.ImportEntriesMetadata.ImportState"))
        }
    }
}

/// Request message for
/// [ModifyEntryOverview][google.cloud.datacatalog.v1.DataCatalog.ModifyEntryOverview].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ModifyEntryOverview]: crate::client::DataCatalog::modify_entry_overview
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyEntryOverviewRequest {

    /// Required. The full resource name of the entry.
    pub name: std::string::String,

    /// Required. The new value for the Entry Overview.
    pub entry_overview: std::option::Option<crate::model::EntryOverview>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyEntryOverviewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyEntryOverviewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [entry_overview][crate::model::ModifyEntryOverviewRequest::entry_overview].
    pub fn set_entry_overview<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::EntryOverview>
    {
        self.entry_overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_overview][crate::model::ModifyEntryOverviewRequest::entry_overview].
    pub fn set_or_clear_entry_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::EntryOverview>
    {
        self.entry_overview = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ModifyEntryOverviewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModifyEntryOverviewRequest"
    }
}

/// Request message for
/// [ModifyEntryContacts][google.cloud.datacatalog.v1.DataCatalog.ModifyEntryContacts].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ModifyEntryContacts]: crate::client::DataCatalog::modify_entry_contacts
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyEntryContactsRequest {

    /// Required. The full resource name of the entry.
    pub name: std::string::String,

    /// Required. The new value for the Contacts.
    pub contacts: std::option::Option<crate::model::Contacts>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyEntryContactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyEntryContactsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [contacts][crate::model::ModifyEntryContactsRequest::contacts].
    pub fn set_contacts<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Contacts>
    {
        self.contacts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contacts][crate::model::ModifyEntryContactsRequest::contacts].
    pub fn set_or_clear_contacts<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Contacts>
    {
        self.contacts = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ModifyEntryContactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModifyEntryContactsRequest"
    }
}

/// Request message for
/// [SetConfig][google.cloud.datacatalog.v1.DataCatalog.SetConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SetConfig]: crate::client::DataCatalog::set_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetConfigRequest {

    /// Required. The organization or project whose config is being specified.
    pub name: std::string::String,

    /// The configuration field to set.
    pub configuration: std::option::Option<crate::model::set_config_request::Configuration>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration].
    ///
    /// Note that all the setters affecting `configuration` are mutually
    /// exclusive.
    pub fn set_configuration<T: std::convert::Into<std::option::Option<crate::model::set_config_request::Configuration>>>(mut self, v: T) -> Self
    {
        self.configuration = v.into();
        self
    }

    /// The value of [configuration][crate::model::SetConfigRequest::configuration]
    /// if it holds a `TagTemplateMigration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag_template_migration(&self) -> std::option::Option<&crate::model::TagTemplateMigration> {
        #[allow(unreachable_patterns)]
        self.configuration.as_ref().and_then(|v| match v {
            crate::model::set_config_request::Configuration::TagTemplateMigration(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration]
    /// to hold a `TagTemplateMigration`.
    ///
    /// Note that all the setters affecting `configuration` are
    /// mutually exclusive.
    pub fn set_tag_template_migration<T: std::convert::Into<crate::model::TagTemplateMigration>>(mut self, v: T) -> Self {
        self.configuration = std::option::Option::Some(
            crate::model::set_config_request::Configuration::TagTemplateMigration(
                v.into()
            )
        );
        self
    }

    /// The value of [configuration][crate::model::SetConfigRequest::configuration]
    /// if it holds a `CatalogUiExperience`, `None` if the field is not set or
    /// holds a different branch.
    pub fn catalog_ui_experience(&self) -> std::option::Option<&crate::model::CatalogUIExperience> {
        #[allow(unreachable_patterns)]
        self.configuration.as_ref().and_then(|v| match v {
            crate::model::set_config_request::Configuration::CatalogUiExperience(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration]
    /// to hold a `CatalogUiExperience`.
    ///
    /// Note that all the setters affecting `configuration` are
    /// mutually exclusive.
    pub fn set_catalog_ui_experience<T: std::convert::Into<crate::model::CatalogUIExperience>>(mut self, v: T) -> Self {
        self.configuration = std::option::Option::Some(
            crate::model::set_config_request::Configuration::CatalogUiExperience(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SetConfigRequest"
    }
}

/// Defines additional types related to [SetConfigRequest].
pub mod set_config_request {
    #[allow(unused_imports)]
    use super::*;


    /// The configuration field to set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Configuration {
        /// Opt-in status for the migration of Tag Templates to Dataplex.
        TagTemplateMigration(crate::model::TagTemplateMigration),
        /// Opt-in status for the UI switch to Dataplex.
        CatalogUiExperience(crate::model::CatalogUIExperience),
    }
}

/// Request message for
/// [RetrieveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig]: crate::client::DataCatalog::retrieve_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveConfigRequest {

    /// Required. The organization whose config is being retrieved.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetrieveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RetrieveConfigRequest"
    }
}

/// Request message for
/// [RetrieveEffectiveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig]: crate::client::DataCatalog::retrieve_effective_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveEffectiveConfigRequest {

    /// Required. The resource whose effective config is being retrieved.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveEffectiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetrieveEffectiveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveEffectiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RetrieveEffectiveConfigRequest"
    }
}

/// The configuration related to the migration from Data Catalog to Dataplex that
/// has been applied to an organization and any projects under it. It is the
/// response message for
/// [RetrieveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig]: crate::client::DataCatalog::retrieve_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OrganizationConfig {

    /// Map of organizations and project resource names and their configuration.
    /// The format for the map keys is `organizations/{organizationId}` or
    /// `projects/{projectId}`.
    pub config: std::collections::HashMap<std::string::String,crate::model::MigrationConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrganizationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::OrganizationConfig::config].
    pub fn set_config<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::MigrationConfig>,
    {
        use std::iter::Iterator;
        self.config = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for OrganizationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.OrganizationConfig"
    }
}

/// The configuration related to the migration to Dataplex applied to an
/// organization or project.
/// It is the response message for
/// [SetConfig][google.cloud.datacatalog.v1.DataCatalog.SetConfig] and
/// [RetrieveEffectiveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig]: crate::client::DataCatalog::retrieve_effective_config
/// [google.cloud.datacatalog.v1.DataCatalog.SetConfig]: crate::client::DataCatalog::set_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationConfig {

    /// Opt-in status for the migration of Tag Templates to Dataplex.
    pub tag_template_migration: crate::model::TagTemplateMigration,

    /// Opt-in status for the UI switch to Dataplex.
    pub catalog_ui_experience: crate::model::CatalogUIExperience,

    /// The time when the Tag Template migration was enabled.
    /// If the Tag Template migration is not enabled, this field is not set.
    pub template_migration_enabled_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_template_migration][crate::model::MigrationConfig::tag_template_migration].
    pub fn set_tag_template_migration<T: std::convert::Into<crate::model::TagTemplateMigration>>(mut self, v: T) -> Self {
        self.tag_template_migration = v.into();
        self
    }

    /// Sets the value of [catalog_ui_experience][crate::model::MigrationConfig::catalog_ui_experience].
    pub fn set_catalog_ui_experience<T: std::convert::Into<crate::model::CatalogUIExperience>>(mut self, v: T) -> Self {
        self.catalog_ui_experience = v.into();
        self
    }

    /// Sets the value of [template_migration_enabled_time][crate::model::MigrationConfig::template_migration_enabled_time].
    pub fn set_template_migration_enabled_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.template_migration_enabled_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template_migration_enabled_time][crate::model::MigrationConfig::template_migration_enabled_time].
    pub fn set_or_clear_template_migration_enabled_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.template_migration_enabled_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.MigrationConfig"
    }
}

/// Common Dataplex fields.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexSpec {

    /// Fully qualified resource name of an asset in Dataplex, to which the
    /// underlying data source (Cloud Storage bucket or BigQuery dataset) of the
    /// entity is attached.
    pub asset: std::string::String,

    /// Format of the data.
    pub data_format: std::option::Option<crate::model::PhysicalSchema>,

    /// Compression format of the data, e.g., zip, gzip etc.
    pub compression_format: std::string::String,

    /// Project ID of the underlying Cloud Storage or BigQuery data. Note that
    /// this may not be the same project as the correspondingly Dataplex lake /
    /// zone / asset.
    pub project_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset][crate::model::DataplexSpec::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::DataplexSpec::data_format].
    pub fn set_data_format<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::PhysicalSchema>
    {
        self.data_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_format][crate::model::DataplexSpec::data_format].
    pub fn set_or_clear_data_format<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::PhysicalSchema>
    {
        self.data_format = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compression_format][crate::model::DataplexSpec::compression_format].
    pub fn set_compression_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compression_format = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DataplexSpec::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for DataplexSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexSpec"
    }
}

/// Entry specyfication for a Dataplex fileset.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexFilesetSpec {

    /// Common Dataplex fields.
    pub dataplex_spec: std::option::Option<crate::model::DataplexSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexFilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataplex_spec][crate::model::DataplexFilesetSpec::dataplex_spec].
    pub fn set_dataplex_spec<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::DataplexSpec>
    {
        self.dataplex_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_spec][crate::model::DataplexFilesetSpec::dataplex_spec].
    pub fn set_or_clear_dataplex_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::DataplexSpec>
    {
        self.dataplex_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataplexFilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexFilesetSpec"
    }
}

/// Entry specification for a Dataplex table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexTableSpec {

    /// List of external tables registered by Dataplex in other systems based on
    /// the same underlying data.
    ///
    /// External tables allow to query this data in those systems.
    pub external_tables: std::vec::Vec<crate::model::DataplexExternalTable>,

    /// Common Dataplex fields.
    pub dataplex_spec: std::option::Option<crate::model::DataplexSpec>,

    /// Indicates if the table schema is managed by the user or not.
    pub user_managed: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_tables][crate::model::DataplexTableSpec::external_tables].
    pub fn set_external_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataplexExternalTable>
    {
        use std::iter::Iterator;
        self.external_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dataplex_spec][crate::model::DataplexTableSpec::dataplex_spec].
    pub fn set_dataplex_spec<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::DataplexSpec>
    {
        self.dataplex_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_spec][crate::model::DataplexTableSpec::dataplex_spec].
    pub fn set_or_clear_dataplex_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::DataplexSpec>
    {
        self.dataplex_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_managed][crate::model::DataplexTableSpec::user_managed].
    pub fn set_user_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.user_managed = v.into();
        self
    }
}

impl wkt::message::Message for DataplexTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexTableSpec"
    }
}

/// External table registered by Dataplex.
/// Dataplex publishes data discovered from an asset into multiple other systems
/// (BigQuery, DPMS) in form of tables. We call them "external tables". External
/// tables are also synced into the Data Catalog.
/// This message contains pointers to
/// those external tables (fully qualified name, resource name et cetera) within
/// the Data Catalog.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexExternalTable {

    /// Service in which the external table is registered.
    pub system: crate::model::IntegratedSystem,

    /// Fully qualified name (FQN) of the external table.
    pub fully_qualified_name: std::string::String,

    /// Google Cloud resource name of the external table.
    pub google_cloud_resource: std::string::String,

    /// Name of the Data Catalog entry representing the external table.
    pub data_catalog_entry: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexExternalTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system][crate::model::DataplexExternalTable::system].
    pub fn set_system<T: std::convert::Into<crate::model::IntegratedSystem>>(mut self, v: T) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::DataplexExternalTable::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [google_cloud_resource][crate::model::DataplexExternalTable::google_cloud_resource].
    pub fn set_google_cloud_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.google_cloud_resource = v.into();
        self
    }

    /// Sets the value of [data_catalog_entry][crate::model::DataplexExternalTable::data_catalog_entry].
    pub fn set_data_catalog_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_catalog_entry = v.into();
        self
    }
}

impl wkt::message::Message for DataplexExternalTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexExternalTable"
    }
}

/// Wrapper containing Entry and information about Tags
/// that should and should not be attached to it.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TaggedEntry {

    /// Optional. Tags that should be ingested into the Data Catalog.
    /// Caller should populate template name, column and fields.
    pub present_tags: std::vec::Vec<crate::model::Tag>,

    /// Optional. Tags that should be deleted from the Data Catalog.
    /// Caller should populate template name and column only.
    pub absent_tags: std::vec::Vec<crate::model::Tag>,

    /// Required. Entry to be ingested.
    pub entry: std::option::Option<crate::model::tagged_entry::Entry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaggedEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [present_tags][crate::model::TaggedEntry::present_tags].
    pub fn set_present_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>
    {
        use std::iter::Iterator;
        self.present_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [absent_tags][crate::model::TaggedEntry::absent_tags].
    pub fn set_absent_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>
    {
        use std::iter::Iterator;
        self.absent_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entry][crate::model::TaggedEntry::entry].
    ///
    /// Note that all the setters affecting `entry` are mutually
    /// exclusive.
    pub fn set_entry<T: std::convert::Into<std::option::Option<crate::model::tagged_entry::Entry>>>(mut self, v: T) -> Self
    {
        self.entry = v.into();
        self
    }

    /// The value of [entry][crate::model::TaggedEntry::entry]
    /// if it holds a `V1Entry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn v1_entry(&self) -> std::option::Option<&std::boxed::Box<crate::model::Entry>> {
        #[allow(unreachable_patterns)]
        self.entry.as_ref().and_then(|v| match v {
            crate::model::tagged_entry::Entry::V1Entry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry][crate::model::TaggedEntry::entry]
    /// to hold a `V1Entry`.
    ///
    /// Note that all the setters affecting `entry` are
    /// mutually exclusive.
    pub fn set_v1_entry<T: std::convert::Into<std::boxed::Box<crate::model::Entry>>>(mut self, v: T) -> Self {
        self.entry = std::option::Option::Some(
            crate::model::tagged_entry::Entry::V1Entry(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for TaggedEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TaggedEntry"
    }
}

/// Defines additional types related to [TaggedEntry].
pub mod tagged_entry {
    #[allow(unused_imports)]
    use super::*;


    /// Required. Entry to be ingested.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Entry {
        /// Non-encrypted Data Catalog v1 Entry.
        V1Entry(std::boxed::Box<crate::model::Entry>),
    }
}

/// Wrapper for any item that can be contained in the dump.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DumpItem {

    pub item: std::option::Option<crate::model::dump_item::Item>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DumpItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::DumpItem::item].
    ///
    /// Note that all the setters affecting `item` are mutually
    /// exclusive.
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::dump_item::Item>>>(mut self, v: T) -> Self
    {
        self.item = v.into();
        self
    }

    /// The value of [item][crate::model::DumpItem::item]
    /// if it holds a `TaggedEntry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tagged_entry(&self) -> std::option::Option<&std::boxed::Box<crate::model::TaggedEntry>> {
        #[allow(unreachable_patterns)]
        self.item.as_ref().and_then(|v| match v {
            crate::model::dump_item::Item::TaggedEntry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [item][crate::model::DumpItem::item]
    /// to hold a `TaggedEntry`.
    ///
    /// Note that all the setters affecting `item` are
    /// mutually exclusive.
    pub fn set_tagged_entry<T: std::convert::Into<std::boxed::Box<crate::model::TaggedEntry>>>(mut self, v: T) -> Self {
        self.item = std::option::Option::Some(
            crate::model::dump_item::Item::TaggedEntry(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DumpItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DumpItem"
    }
}

/// Defines additional types related to [DumpItem].
pub mod dump_item {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Item {
        /// Entry and its tags.
        TaggedEntry(std::boxed::Box<crate::model::TaggedEntry>),
    }
}

/// Describes a Cloud Storage fileset entry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsFilesetSpec {

    /// Required. Patterns to identify a set of files in Google Cloud Storage.
    ///
    /// For more information, see [Wildcard Names]
    /// (<https://cloud.google.com/storage/docs/wildcards>).
    ///
    /// Note: Currently, bucket wildcards are not supported.
    ///
    /// Examples of valid `file_patterns`:
    ///
    /// * `gs://bucket_name/dir/*`: matches all files in `bucket_name/dir`
    ///   directory
    /// * `gs://bucket_name/dir/**`: matches all files in `bucket_name/dir`
    ///   and all subdirectories
    /// * `gs://bucket_name/file*`: matches files prefixed by `file` in
    ///   `bucket_name`
    /// * `gs://bucket_name/??.txt`: matches files with two characters followed by
    ///   `.txt` in `bucket_name`
    /// * `gs://bucket_name/[aeiou].txt`: matches files that contain a single
    ///   vowel character followed by `.txt` in
    ///   `bucket_name`
    /// * `gs://bucket_name/[a-m].txt`: matches files that contain `a`, `b`, ...
    ///   or `m` followed by `.txt` in `bucket_name`
    /// * `gs://bucket_name/a/*/b`: matches all files in `bucket_name` that match
    ///   the `a/*/b` pattern, such as `a/c/b`, `a/d/b`
    /// * `gs://another_bucket/a.txt`: matches `gs://another_bucket/a.txt`
    ///
    /// You can combine wildcards to match complex sets of files, for example:
    ///
    /// `gs://bucket_name/[a-m]??.j*g`
    pub file_patterns: std::vec::Vec<std::string::String>,

    /// Output only. Sample files contained in this fileset, not all files
    /// contained in this fileset are represented here.
    pub sample_gcs_file_specs: std::vec::Vec<crate::model::GcsFileSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsFilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_patterns][crate::model::GcsFilesetSpec::file_patterns].
    pub fn set_file_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.file_patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_gcs_file_specs][crate::model::GcsFilesetSpec::sample_gcs_file_specs].
    pub fn set_sample_gcs_file_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcsFileSpec>
    {
        use std::iter::Iterator;
        self.sample_gcs_file_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcsFilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GcsFilesetSpec"
    }
}

/// Specification of a single file in Cloud Storage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsFileSpec {

    /// Required. Full file path. Example: `gs://bucket_name/a/b.txt`.
    pub file_path: std::string::String,

    /// Output only. Creation, modification, and expiration timestamps of a Cloud
    /// Storage file.
    pub gcs_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Output only. File size in bytes.
    pub size_bytes: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsFileSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::GcsFileSpec::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [gcs_timestamps][crate::model::GcsFileSpec::gcs_timestamps].
    pub fn set_gcs_timestamps<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.gcs_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcs_timestamps][crate::model::GcsFileSpec::gcs_timestamps].
    pub fn set_or_clear_gcs_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.gcs_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [size_bytes][crate::model::GcsFileSpec::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }
}

impl wkt::message::Message for GcsFileSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GcsFileSpec"
    }
}

/// Native schema used by a resource represented as an entry. Used by query
/// engines for deserializing and parsing source data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhysicalSchema {

    pub schema: std::option::Option<crate::model::physical_schema::Schema>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhysicalSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema].
    ///
    /// Note that all the setters affecting `schema` are mutually
    /// exclusive.
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::physical_schema::Schema>>>(mut self, v: T) -> Self
    {
        self.schema = v.into();
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Avro`, `None` if the field is not set or
    /// holds a different branch.
    pub fn avro(&self) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::AvroSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Avro(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Avro`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_avro<T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::AvroSchema>>>(mut self, v: T) -> Self {
        self.schema = std::option::Option::Some(
            crate::model::physical_schema::Schema::Avro(
                v.into()
            )
        );
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Thrift`, `None` if the field is not set or
    /// holds a different branch.
    pub fn thrift(&self) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ThriftSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Thrift(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Thrift`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_thrift<T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ThriftSchema>>>(mut self, v: T) -> Self {
        self.schema = std::option::Option::Some(
            crate::model::physical_schema::Schema::Thrift(
                v.into()
            )
        );
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Protobuf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn protobuf(&self) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ProtobufSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Protobuf(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Protobuf`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_protobuf<T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ProtobufSchema>>>(mut self, v: T) -> Self {
        self.schema = std::option::Option::Some(
            crate::model::physical_schema::Schema::Protobuf(
                v.into()
            )
        );
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Parquet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn parquet(&self) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ParquetSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Parquet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Parquet`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_parquet<T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ParquetSchema>>>(mut self, v: T) -> Self {
        self.schema = std::option::Option::Some(
            crate::model::physical_schema::Schema::Parquet(
                v.into()
            )
        );
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Orc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn orc(&self) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::OrcSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Orc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Orc`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_orc<T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::OrcSchema>>>(mut self, v: T) -> Self {
        self.schema = std::option::Option::Some(
            crate::model::physical_schema::Schema::Orc(
                v.into()
            )
        );
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Csv`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv(&self) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::CsvSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Csv(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Csv`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_csv<T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::CsvSchema>>>(mut self, v: T) -> Self {
        self.schema = std::option::Option::Some(
            crate::model::physical_schema::Schema::Csv(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for PhysicalSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema"
    }
}

/// Defines additional types related to [PhysicalSchema].
pub mod physical_schema {
    #[allow(unused_imports)]
    use super::*;


    /// Schema in Avro JSON format.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AvroSchema {

        /// JSON source of the Avro schema.
        pub text: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AvroSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::AvroSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for AvroSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.AvroSchema"
        }
    }

    /// Schema in Thrift format.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThriftSchema {

        /// Thrift IDL source of the schema.
        pub text: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThriftSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::ThriftSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for ThriftSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ThriftSchema"
        }
    }

    /// Schema in protocol buffer format.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProtobufSchema {

        /// Protocol buffer source of the schema.
        pub text: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProtobufSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::ProtobufSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for ProtobufSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ProtobufSchema"
        }
    }

    /// Marks a Parquet-encoded data source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ParquetSchema {

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ParquetSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ParquetSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ParquetSchema"
        }
    }

    /// Marks an ORC-encoded data source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OrcSchema {

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OrcSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for OrcSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.OrcSchema"
        }
    }

    /// Marks a CSV-encoded data source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CsvSchema {

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for CsvSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.CsvSchema"
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schema {
        /// Schema in Avro JSON format.
        Avro(std::boxed::Box<crate::model::physical_schema::AvroSchema>),
        /// Schema in Thrift format.
        Thrift(std::boxed::Box<crate::model::physical_schema::ThriftSchema>),
        /// Schema in protocol buffer format.
        Protobuf(std::boxed::Box<crate::model::physical_schema::ProtobufSchema>),
        /// Marks a Parquet-encoded data source.
        Parquet(std::boxed::Box<crate::model::physical_schema::ParquetSchema>),
        /// Marks an ORC-encoded data source.
        Orc(std::boxed::Box<crate::model::physical_schema::OrcSchema>),
        /// Marks a CSV-encoded data source.
        Csv(std::boxed::Box<crate::model::physical_schema::CsvSchema>),
    }
}

/// A taxonomy is a collection of hierarchical policy tags that classify data
/// along a common axis.
///
/// For example, a "data sensitivity" taxonomy might contain the following policy
/// tags:
///
/// ```norust
/// + PII
///   + Account number
///   + Age
///   + SSN
///   + Zipcode
/// + Financials
///   + Revenue
/// ```
///
/// A "data origin" taxonomy might contain the following policy tags:
///
/// ```norust
/// + User data
/// + Employee data
/// + Partner data
/// + Public data
/// ```
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Taxonomy {

    /// Identifier. Resource name of this taxonomy in URL format.
    ///
    /// Note: Policy tag manager generates unique taxonomy IDs.
    pub name: std::string::String,

    /// Required. User-defined name of this taxonomy.
    ///
    /// The name can't start or end with spaces, must contain only Unicode letters,
    /// numbers, underscores, dashes, and spaces, and be at most 200 bytes long
    /// when encoded in UTF-8.
    ///
    /// The taxonomy display name must be unique within an organization.
    pub display_name: std::string::String,

    /// Optional. Description of this taxonomy. If not set, defaults to empty.
    ///
    /// The description must contain only Unicode characters, tabs, newlines,
    /// carriage returns, and page breaks, and be at most 2000 bytes long when
    /// encoded in UTF-8.
    pub description: std::string::String,

    /// Output only. Number of policy tags in this taxonomy.
    pub policy_tag_count: i32,

    /// Output only. Creation and modification timestamps of this taxonomy.
    pub taxonomy_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Optional. A list of policy types that are activated for this taxonomy. If
    /// not set, defaults to an empty list.
    pub activated_policy_types: std::vec::Vec<crate::model::taxonomy::PolicyType>,

    /// Output only. Identity of the service which owns the Taxonomy. This field is
    /// only populated when the taxonomy is created by a Google Cloud service.
    /// Currently only 'DATAPLEX' is supported.
    pub service: std::option::Option<crate::model::taxonomy::Service>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Taxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Taxonomy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Taxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Taxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy_tag_count][crate::model::Taxonomy::policy_tag_count].
    pub fn set_policy_tag_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.policy_tag_count = v.into();
        self
    }

    /// Sets the value of [taxonomy_timestamps][crate::model::Taxonomy::taxonomy_timestamps].
    pub fn set_taxonomy_timestamps<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.taxonomy_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [taxonomy_timestamps][crate::model::Taxonomy::taxonomy_timestamps].
    pub fn set_or_clear_taxonomy_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SystemTimestamps>
    {
        self.taxonomy_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activated_policy_types][crate::model::Taxonomy::activated_policy_types].
    pub fn set_activated_policy_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::taxonomy::PolicyType>
    {
        use std::iter::Iterator;
        self.activated_policy_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service][crate::model::Taxonomy::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::taxonomy::Service>
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::Taxonomy::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::taxonomy::Service>
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Taxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Taxonomy"
    }
}

/// Defines additional types related to [Taxonomy].
pub mod taxonomy {
    #[allow(unused_imports)]
    use super::*;


    /// The source system of the Taxonomy.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Service {

        /// The Google Cloud service name.
        pub name: crate::model::ManagingSystem,

        /// The service agent for the service.
        pub identity: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Service {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::taxonomy::Service::name].
        pub fn set_name<T: std::convert::Into<crate::model::ManagingSystem>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [identity][crate::model::taxonomy::Service::identity].
        pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.identity = v.into();
            self
        }
    }

    impl wkt::message::Message for Service {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.Taxonomy.Service"
        }
    }

    /// Defines policy types where the policy tags can be used for.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PolicyType {
        /// Unspecified policy type.
        Unspecified,
        /// Fine-grained access control policy that enables access control on
        /// tagged sub-resources.
        FineGrainedAccessControl,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PolicyType::value] or
        /// [PolicyType::name].
        UnknownValue(policy_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod policy_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PolicyType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FineGrainedAccessControl => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POLICY_TYPE_UNSPECIFIED"),
                Self::FineGrainedAccessControl => std::option::Option::Some("FINE_GRAINED_ACCESS_CONTROL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PolicyType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PolicyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PolicyType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FineGrainedAccessControl,
                _ => Self::UnknownValue(policy_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for PolicyType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POLICY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FINE_GRAINED_ACCESS_CONTROL" => Self::FineGrainedAccessControl,
                _ => Self::UnknownValue(policy_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for PolicyType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FineGrainedAccessControl => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PolicyType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PolicyType>::new(
                ".google.cloud.datacatalog.v1.Taxonomy.PolicyType"))
        }
    }
}

/// Denotes one policy tag in a taxonomy, for example, SSN.
///
/// Policy tags can be defined in a hierarchy. For example:
///
/// ```norust
/// + Geolocation
///   + LatLong
///   + City
///   + ZipCode
/// ```
///
/// Where the "Geolocation" policy tag contains three children.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PolicyTag {

    /// Identifier. Resource name of this policy tag in the URL format.
    ///
    /// The policy tag manager generates unique taxonomy IDs and policy tag IDs.
    pub name: std::string::String,

    /// Required. User-defined name of this policy tag.
    ///
    /// The name can't start or end with spaces and must be unique within the
    /// parent taxonomy, contain only Unicode letters, numbers, underscores, dashes
    /// and spaces, and be at most 200 bytes long when encoded in UTF-8.
    pub display_name: std::string::String,

    /// Description of this policy tag. If not set, defaults to empty.
    ///
    /// The description must contain only Unicode characters,
    /// tabs, newlines, carriage returns and page breaks, and be at most 2000 bytes
    /// long when encoded in UTF-8.
    pub description: std::string::String,

    /// Resource name of this policy tag's parent policy tag. If empty, this is a
    /// top level tag. If not set, defaults to an empty string.
    ///
    /// For example, for the "LatLong" policy tag in the example above, this field
    /// contains the resource name of the "Geolocation" policy tag, and, for
    /// "Geolocation", this field is empty.
    pub parent_policy_tag: std::string::String,

    /// Output only. Resource names of child policy tags of this policy tag.
    pub child_policy_tags: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PolicyTag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PolicyTag::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PolicyTag::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parent_policy_tag][crate::model::PolicyTag::parent_policy_tag].
    pub fn set_parent_policy_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_policy_tag = v.into();
        self
    }

    /// Sets the value of [child_policy_tags][crate::model::PolicyTag::child_policy_tags].
    pub fn set_child_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.child_policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PolicyTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PolicyTag"
    }
}

/// Request message for
/// [CreateTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.CreateTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.CreateTaxonomy]: crate::client::PolicyTagManager::create_taxonomy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTaxonomyRequest {

    /// Required. Resource name of the project that the taxonomy will belong to.
    pub parent: std::string::String,

    /// The taxonomy to create.
    pub taxonomy: std::option::Option<crate::model::Taxonomy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTaxonomyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [taxonomy][crate::model::CreateTaxonomyRequest::taxonomy].
    pub fn set_taxonomy<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Taxonomy>
    {
        self.taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [taxonomy][crate::model::CreateTaxonomyRequest::taxonomy].
    pub fn set_or_clear_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Taxonomy>
    {
        self.taxonomy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTaxonomyRequest"
    }
}

/// Request message for
/// [DeleteTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.DeleteTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.DeleteTaxonomy]: crate::client::PolicyTagManager::delete_taxonomy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTaxonomyRequest {

    /// Required. Resource name of the taxonomy to delete.
    ///
    /// Note: All policy tags in this taxonomy are also deleted.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTaxonomyRequest"
    }
}

/// Request message for
/// [UpdateTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.UpdateTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.UpdateTaxonomy]: crate::client::PolicyTagManager::update_taxonomy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTaxonomyRequest {

    /// The taxonomy to update. You can update only its description, display name,
    /// and activated policy types.
    pub taxonomy: std::option::Option<crate::model::Taxonomy>,

    /// Specifies fields to update. If not set, defaults to all fields you can
    /// update.
    ///
    /// For more information, see [FieldMask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>).
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomy][crate::model::UpdateTaxonomyRequest::taxonomy].
    pub fn set_taxonomy<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Taxonomy>
    {
        self.taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [taxonomy][crate::model::UpdateTaxonomyRequest::taxonomy].
    pub fn set_or_clear_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Taxonomy>
    {
        self.taxonomy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTaxonomyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTaxonomyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTaxonomyRequest"
    }
}

/// Request message for
/// [ListTaxonomies][google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies]: crate::client::PolicyTagManager::list_taxonomies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTaxonomiesRequest {

    /// Required. Resource name of the project to list the taxonomies of.
    pub parent: std::string::String,

    /// The maximum number of items to return. Must be a value between 1 and 1000
    /// inclusively. If not set, defaults to 50.
    pub page_size: i32,

    /// The pagination token of the next results page. If not set,
    /// the first page is returned.
    ///
    /// The token is returned in the response to a previous list request.
    pub page_token: std::string::String,

    /// Supported field for filter is 'service' and value is 'dataplex'.
    /// Eg: service=dataplex.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTaxonomiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTaxonomiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTaxonomiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTaxonomiesRequest"
    }
}

/// Response message for
/// [ListTaxonomies][google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies]: crate::client::PolicyTagManager::list_taxonomies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTaxonomiesResponse {

    /// Taxonomies that the project contains.
    pub taxonomies: std::vec::Vec<crate::model::Taxonomy>,

    /// Pagination token of the next results page. Empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ListTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Taxonomy>
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTaxonomiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTaxonomiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTaxonomiesResponse {
    type PageItem = crate::model::Taxonomy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.taxonomies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [GetTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.GetTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.GetTaxonomy]: crate::client::PolicyTagManager::get_taxonomy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTaxonomyRequest {

    /// Required. Resource name of the taxonomy to get.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetTaxonomyRequest"
    }
}

/// Request message for
/// [CreatePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.CreatePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.CreatePolicyTag]: crate::client::PolicyTagManager::create_policy_tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePolicyTagRequest {

    /// Required. Resource name of the taxonomy that the policy tag will belong to.
    pub parent: std::string::String,

    /// The policy tag to create.
    pub policy_tag: std::option::Option<crate::model::PolicyTag>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePolicyTagRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy_tag][crate::model::CreatePolicyTagRequest::policy_tag].
    pub fn set_policy_tag<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::PolicyTag>
    {
        self.policy_tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy_tag][crate::model::CreatePolicyTagRequest::policy_tag].
    pub fn set_or_clear_policy_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::PolicyTag>
    {
        self.policy_tag = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreatePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreatePolicyTagRequest"
    }
}

/// Request message for
/// [DeletePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.DeletePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.DeletePolicyTag]: crate::client::PolicyTagManager::delete_policy_tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePolicyTagRequest {

    /// Required. Resource name of the policy tag to delete.
    ///
    /// Note: All of its descendant policy tags are also deleted.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePolicyTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeletePolicyTagRequest"
    }
}

/// Request message for
/// [UpdatePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.UpdatePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.UpdatePolicyTag]: crate::client::PolicyTagManager::update_policy_tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePolicyTagRequest {

    /// The policy tag to update. You can update only its description, display
    /// name, and parent policy tag fields.
    pub policy_tag: std::option::Option<crate::model::PolicyTag>,

    /// Specifies the fields to update.
    ///
    /// You can update only display name, description, and parent policy tag.
    /// If not set, defaults to all updatable fields.
    /// For more information, see [FieldMask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>).
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tag][crate::model::UpdatePolicyTagRequest::policy_tag].
    pub fn set_policy_tag<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::PolicyTag>
    {
        self.policy_tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy_tag][crate::model::UpdatePolicyTagRequest::policy_tag].
    pub fn set_or_clear_policy_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::PolicyTag>
    {
        self.policy_tag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePolicyTagRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePolicyTagRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdatePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdatePolicyTagRequest"
    }
}

/// Request message for
/// [ListPolicyTags][google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags]: crate::client::PolicyTagManager::list_policy_tags
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPolicyTagsRequest {

    /// Required. Resource name of the taxonomy to list the policy tags of.
    pub parent: std::string::String,

    /// The maximum number of items to return. Must be a value between 1 and 1000
    /// inclusively.
    /// If not set, defaults to 50.
    pub page_size: i32,

    /// The pagination token of the next results page. If not set, returns the
    /// first page.
    ///
    /// The token is returned in the response to a previous list request.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPolicyTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPolicyTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPolicyTagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPolicyTagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPolicyTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListPolicyTagsRequest"
    }
}

/// Response message for
/// [ListPolicyTags][google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags]: crate::client::PolicyTagManager::list_policy_tags
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPolicyTagsResponse {

    /// The policy tags that belong to the taxonomy.
    pub policy_tags: std::vec::Vec<crate::model::PolicyTag>,

    /// Pagination token of the next results page. Empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPolicyTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tags][crate::model::ListPolicyTagsResponse::policy_tags].
    pub fn set_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PolicyTag>
    {
        use std::iter::Iterator;
        self.policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPolicyTagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPolicyTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListPolicyTagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPolicyTagsResponse {
    type PageItem = crate::model::PolicyTag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policy_tags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [GetPolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.GetPolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.GetPolicyTag]: crate::client::PolicyTagManager::get_policy_tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPolicyTagRequest {

    /// Required. Resource name of the policy tag.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPolicyTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetPolicyTagRequest"
    }
}

/// A nested protocol buffer that represents a taxonomy and the hierarchy of its
/// policy tags. Used for taxonomy replacement, import, and
/// export.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SerializedTaxonomy {

    /// Required. Display name of the taxonomy. At most 200 bytes when encoded in
    /// UTF-8.
    pub display_name: std::string::String,

    /// Description of the serialized taxonomy. At most 2000 bytes when
    /// encoded in UTF-8. If not set, defaults to an empty description.
    pub description: std::string::String,

    /// Top level policy tags associated with the taxonomy, if any.
    pub policy_tags: std::vec::Vec<crate::model::SerializedPolicyTag>,

    /// A list of policy types that are activated per taxonomy.
    pub activated_policy_types: std::vec::Vec<crate::model::taxonomy::PolicyType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SerializedTaxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::SerializedTaxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SerializedTaxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy_tags][crate::model::SerializedTaxonomy::policy_tags].
    pub fn set_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedPolicyTag>
    {
        use std::iter::Iterator;
        self.policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [activated_policy_types][crate::model::SerializedTaxonomy::activated_policy_types].
    pub fn set_activated_policy_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::taxonomy::PolicyType>
    {
        use std::iter::Iterator;
        self.activated_policy_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerializedTaxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SerializedTaxonomy"
    }
}

/// A nested protocol buffer that represents a policy tag and all its
/// descendants.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SerializedPolicyTag {

    /// Resource name of the policy tag.
    ///
    /// This field is ignored when calling `ImportTaxonomies`.
    pub policy_tag: std::string::String,

    /// Required. Display name of the policy tag. At most 200 bytes when encoded
    /// in UTF-8.
    pub display_name: std::string::String,

    /// Description of the serialized policy tag. At most
    /// 2000 bytes when encoded in UTF-8. If not set, defaults to an
    /// empty description.
    pub description: std::string::String,

    /// Children of the policy tag, if any.
    pub child_policy_tags: std::vec::Vec<crate::model::SerializedPolicyTag>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SerializedPolicyTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tag][crate::model::SerializedPolicyTag::policy_tag].
    pub fn set_policy_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_tag = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SerializedPolicyTag::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SerializedPolicyTag::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [child_policy_tags][crate::model::SerializedPolicyTag::child_policy_tags].
    pub fn set_child_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedPolicyTag>
    {
        use std::iter::Iterator;
        self.child_policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerializedPolicyTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SerializedPolicyTag"
    }
}

/// Request message for
/// [ReplaceTaxonomy][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ReplaceTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ReplaceTaxonomy]: crate::client::PolicyTagManagerSerialization::replace_taxonomy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplaceTaxonomyRequest {

    /// Required. Resource name of the taxonomy to update.
    pub name: std::string::String,

    /// Required. Taxonomy to update along with its child policy tags.
    pub serialized_taxonomy: std::option::Option<crate::model::SerializedTaxonomy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReplaceTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [serialized_taxonomy][crate::model::ReplaceTaxonomyRequest::serialized_taxonomy].
    pub fn set_serialized_taxonomy<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SerializedTaxonomy>
    {
        self.serialized_taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serialized_taxonomy][crate::model::ReplaceTaxonomyRequest::serialized_taxonomy].
    pub fn set_or_clear_serialized_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SerializedTaxonomy>
    {
        self.serialized_taxonomy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplaceTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReplaceTaxonomyRequest"
    }
}

/// Request message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies]: crate::client::PolicyTagManagerSerialization::import_taxonomies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportTaxonomiesRequest {

    /// Required. Resource name of project that the imported taxonomies will belong
    /// to.
    pub parent: std::string::String,

    /// Source taxonomies to import.
    pub source: std::option::Option<crate::model::import_taxonomies_request::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::import_taxonomies_request::Source>>>(mut self, v: T) -> Self
    {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::InlineSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_taxonomies_request::Source::InlineSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<T: std::convert::Into<std::boxed::Box<crate::model::InlineSource>>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_taxonomies_request::Source::InlineSource(
                v.into()
            )
        );
        self
    }

    /// The value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// if it holds a `CrossRegionalSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cross_regional_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::CrossRegionalSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_taxonomies_request::Source::CrossRegionalSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// to hold a `CrossRegionalSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cross_regional_source<T: std::convert::Into<std::boxed::Box<crate::model::CrossRegionalSource>>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_taxonomies_request::Source::CrossRegionalSource(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ImportTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportTaxonomiesRequest"
    }
}

/// Defines additional types related to [ImportTaxonomiesRequest].
pub mod import_taxonomies_request {
    #[allow(unused_imports)]
    use super::*;


    /// Source taxonomies to import.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Inline source taxonomy to import.
        InlineSource(std::boxed::Box<crate::model::InlineSource>),
        /// Cross-regional source taxonomy to import.
        CrossRegionalSource(std::boxed::Box<crate::model::CrossRegionalSource>),
    }
}

/// Inline source containing taxonomies to import.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InlineSource {

    /// Required. Taxonomies to import.
    pub taxonomies: std::vec::Vec<crate::model::SerializedTaxonomy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::InlineSource::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedTaxonomy>
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InlineSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.InlineSource"
    }
}

/// Cross-regional source used to import an existing taxonomy into a different
/// region.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CrossRegionalSource {

    /// Required. The resource name of the source taxonomy to import.
    pub taxonomy: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CrossRegionalSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomy][crate::model::CrossRegionalSource::taxonomy].
    pub fn set_taxonomy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.taxonomy = v.into();
        self
    }
}

impl wkt::message::Message for CrossRegionalSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CrossRegionalSource"
    }
}

/// Response message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies]: crate::client::PolicyTagManagerSerialization::import_taxonomies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportTaxonomiesResponse {

    /// Imported taxonomies.
    pub taxonomies: std::vec::Vec<crate::model::Taxonomy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ImportTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Taxonomy>
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportTaxonomiesResponse"
    }
}

/// Request message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies]: crate::client::PolicyTagManagerSerialization::export_taxonomies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportTaxonomiesRequest {

    /// Required. Resource name of the project that the exported taxonomies belong
    /// to.
    pub parent: std::string::String,

    /// Required. Resource names of the taxonomies to export.
    pub taxonomies: std::vec::Vec<std::string::String>,

    /// Required. Export destination for taxonomies.
    pub destination: std::option::Option<crate::model::export_taxonomies_request::Destination>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [taxonomies][crate::model::ExportTaxonomiesRequest::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination][crate::model::ExportTaxonomiesRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<T: std::convert::Into<std::option::Option<crate::model::export_taxonomies_request::Destination>>>(mut self, v: T) -> Self
    {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportTaxonomiesRequest::destination]
    /// if it holds a `SerializedTaxonomies`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serialized_taxonomies(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_taxonomies_request::Destination::SerializedTaxonomies(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportTaxonomiesRequest::destination]
    /// to hold a `SerializedTaxonomies`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_serialized_taxonomies<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_taxonomies_request::Destination::SerializedTaxonomies(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ExportTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ExportTaxonomiesRequest"
    }
}

/// Defines additional types related to [ExportTaxonomiesRequest].
pub mod export_taxonomies_request {
    #[allow(unused_imports)]
    use super::*;


    /// Required. Export destination for taxonomies.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Serialized export taxonomies that contain all the policy
        /// tags as nested protocol buffers.
        SerializedTaxonomies(bool),
    }
}

/// Response message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies]: crate::client::PolicyTagManagerSerialization::export_taxonomies
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportTaxonomiesResponse {

    /// List of taxonomies and policy tags as nested protocol buffers.
    pub taxonomies: std::vec::Vec<crate::model::SerializedTaxonomy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ExportTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedTaxonomy>
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ExportTaxonomiesResponse"
    }
}

/// Represents a schema, for example, a BigQuery, GoogleSQL, or Avro schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {

    /// The unified GoogleSQL-like schema of columns.
    ///
    /// The overall maximum number of columns and nested columns is 10,000.
    /// The maximum nested depth is 15 levels.
    pub columns: std::vec::Vec<crate::model::ColumnSchema>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::Schema::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnSchema>
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Schema"
    }
}

/// A column within a schema. Columns can be nested inside
/// other columns.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ColumnSchema {

    /// Required. Name of the column.
    ///
    /// Must be a UTF-8 string without dots (.).
    /// The maximum size is 64 bytes.
    pub column: std::string::String,

    /// Required. Type of the column.
    ///
    /// Must be a UTF-8 string with the maximum size of 128 bytes.
    pub r#type: std::string::String,

    /// Optional. Description of the column. Default value is an empty string.
    ///
    /// The description must be a UTF-8 string with the maximum size of 2000
    /// bytes.
    pub description: std::string::String,

    /// Optional. A column's mode indicates whether values in this column are
    /// required, nullable, or repeated.
    ///
    /// Only `NULLABLE`, `REQUIRED`, and `REPEATED` values are supported.
    /// Default mode is `NULLABLE`.
    pub mode: std::string::String,

    /// Optional. Default value for the column.
    pub default_value: std::string::String,

    /// Optional. Ordinal position
    pub ordinal_position: i32,

    /// Optional. Most important inclusion of this column.
    pub highest_indexing_type: crate::model::column_schema::IndexingType,

    /// Optional. Schema of sub-columns. A column can have zero or more
    /// sub-columns.
    pub subcolumns: std::vec::Vec<crate::model::ColumnSchema>,

    /// Optional. The subtype of the RANGE, if the type of this field is RANGE. If
    /// the type is RANGE, this field is required. Possible values for the field
    /// element type of a RANGE include:
    ///
    /// * DATE
    /// * DATETIME
    /// * TIMESTAMP
    pub range_element_type: std::option::Option<crate::model::column_schema::FieldElementType>,

    /// Optional. Garbage collection policy for the column or column family.
    /// Applies to systems like Cloud Bigtable.
    pub gc_rule: std::string::String,

    /// Information only applying for columns in Entries from a specific system.
    pub system_spec: std::option::Option<crate::model::column_schema::SystemSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::ColumnSchema::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ColumnSchema::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ColumnSchema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::ColumnSchema::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::ColumnSchema::default_value].
    pub fn set_default_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::ColumnSchema::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [highest_indexing_type][crate::model::ColumnSchema::highest_indexing_type].
    pub fn set_highest_indexing_type<T: std::convert::Into<crate::model::column_schema::IndexingType>>(mut self, v: T) -> Self {
        self.highest_indexing_type = v.into();
        self
    }

    /// Sets the value of [subcolumns][crate::model::ColumnSchema::subcolumns].
    pub fn set_subcolumns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnSchema>
    {
        use std::iter::Iterator;
        self.subcolumns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [range_element_type][crate::model::ColumnSchema::range_element_type].
    pub fn set_range_element_type<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::column_schema::FieldElementType>
    {
        self.range_element_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range_element_type][crate::model::ColumnSchema::range_element_type].
    pub fn set_or_clear_range_element_type<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::column_schema::FieldElementType>
    {
        self.range_element_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gc_rule][crate::model::ColumnSchema::gc_rule].
    pub fn set_gc_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gc_rule = v.into();
        self
    }

    /// Sets the value of [system_spec][crate::model::ColumnSchema::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<T: std::convert::Into<std::option::Option<crate::model::column_schema::SystemSpec>>>(mut self, v: T) -> Self
    {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ColumnSchema::system_spec]
    /// if it holds a `LookerColumnSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn looker_column_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::column_schema::LookerColumnSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::column_schema::SystemSpec::LookerColumnSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ColumnSchema::system_spec]
    /// to hold a `LookerColumnSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_looker_column_spec<T: std::convert::Into<std::boxed::Box<crate::model::column_schema::LookerColumnSpec>>>(mut self, v: T) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::column_schema::SystemSpec::LookerColumnSpec(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ColumnSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema"
    }
}

/// Defines additional types related to [ColumnSchema].
pub mod column_schema {
    #[allow(unused_imports)]
    use super::*;


    /// Column info specific to Looker System.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LookerColumnSpec {

        /// Looker specific column type of this column.
        pub r#type: crate::model::column_schema::looker_column_spec::LookerColumnType,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LookerColumnSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::column_schema::LookerColumnSpec::type].
        pub fn set_type<T: std::convert::Into<crate::model::column_schema::looker_column_spec::LookerColumnType>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for LookerColumnSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema.LookerColumnSpec"
        }
    }

    /// Defines additional types related to [LookerColumnSpec].
    pub mod looker_column_spec {
        #[allow(unused_imports)]
        use super::*;


        /// Column type in Looker.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LookerColumnType {
            /// Unspecified.
            Unspecified,
            /// Dimension.
            Dimension,
            /// Dimension group - parent for Dimension.
            DimensionGroup,
            /// Filter.
            Filter,
            /// Measure.
            Measure,
            /// Parameter.
            Parameter,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LookerColumnType::value] or
            /// [LookerColumnType::name].
            UnknownValue(looker_column_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod looker_column_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LookerColumnType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Dimension => std::option::Option::Some(1),
                    Self::DimensionGroup => std::option::Option::Some(2),
                    Self::Filter => std::option::Option::Some(3),
                    Self::Measure => std::option::Option::Some(4),
                    Self::Parameter => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LOOKER_COLUMN_TYPE_UNSPECIFIED"),
                    Self::Dimension => std::option::Option::Some("DIMENSION"),
                    Self::DimensionGroup => std::option::Option::Some("DIMENSION_GROUP"),
                    Self::Filter => std::option::Option::Some("FILTER"),
                    Self::Measure => std::option::Option::Some("MEASURE"),
                    Self::Parameter => std::option::Option::Some("PARAMETER"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LookerColumnType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LookerColumnType {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LookerColumnType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Dimension,
                    2 => Self::DimensionGroup,
                    3 => Self::Filter,
                    4 => Self::Measure,
                    5 => Self::Parameter,
                    _ => Self::UnknownValue(looker_column_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for LookerColumnType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOOKER_COLUMN_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "DIMENSION" => Self::Dimension,
                    "DIMENSION_GROUP" => Self::DimensionGroup,
                    "FILTER" => Self::Filter,
                    "MEASURE" => Self::Measure,
                    "PARAMETER" => Self::Parameter,
                    _ => Self::UnknownValue(looker_column_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for LookerColumnType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Dimension => serializer.serialize_i32(1),
                    Self::DimensionGroup => serializer.serialize_i32(2),
                    Self::Filter => serializer.serialize_i32(3),
                    Self::Measure => serializer.serialize_i32(4),
                    Self::Parameter => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LookerColumnType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LookerColumnType>::new(
                    ".google.cloud.datacatalog.v1.ColumnSchema.LookerColumnSpec.LookerColumnType"))
            }
        }
    }

    /// Represents the type of a field element.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FieldElementType {

        /// Required. The type of a field element. See
        /// [ColumnSchema.type][google.cloud.datacatalog.v1.ColumnSchema.type].
        ///
        /// [google.cloud.datacatalog.v1.ColumnSchema.type]: crate::model::ColumnSchema::type
        pub r#type: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FieldElementType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::column_schema::FieldElementType::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for FieldElementType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema.FieldElementType"
        }
    }

    /// Specifies inclusion of the column in an index
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IndexingType {
        /// Unspecified.
        Unspecified,
        /// Column not a part of an index.
        None,
        /// Column Part of non unique index.
        NonUnique,
        /// Column part of unique index.
        Unique,
        /// Column part of the primary key.
        PrimaryKey,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IndexingType::value] or
        /// [IndexingType::name].
        UnknownValue(indexing_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod indexing_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IndexingType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::NonUnique => std::option::Option::Some(2),
                Self::Unique => std::option::Option::Some(3),
                Self::PrimaryKey => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INDEXING_TYPE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("INDEXING_TYPE_NONE"),
                Self::NonUnique => std::option::Option::Some("INDEXING_TYPE_NON_UNIQUE"),
                Self::Unique => std::option::Option::Some("INDEXING_TYPE_UNIQUE"),
                Self::PrimaryKey => std::option::Option::Some("INDEXING_TYPE_PRIMARY_KEY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IndexingType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IndexingType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IndexingType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::NonUnique,
                3 => Self::Unique,
                4 => Self::PrimaryKey,
                _ => Self::UnknownValue(indexing_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for IndexingType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INDEXING_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INDEXING_TYPE_NONE" => Self::None,
                "INDEXING_TYPE_NON_UNIQUE" => Self::NonUnique,
                "INDEXING_TYPE_UNIQUE" => Self::Unique,
                "INDEXING_TYPE_PRIMARY_KEY" => Self::PrimaryKey,
                _ => Self::UnknownValue(indexing_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for IndexingType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::NonUnique => serializer.serialize_i32(2),
                Self::Unique => serializer.serialize_i32(3),
                Self::PrimaryKey => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IndexingType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndexingType>::new(
                ".google.cloud.datacatalog.v1.ColumnSchema.IndexingType"))
        }
    }

    /// Information only applying for columns in Entries from a specific system.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Looker specific column info of this column.
        LookerColumnSpec(std::boxed::Box<crate::model::column_schema::LookerColumnSpec>),
    }
}

/// Result in the response to a search request.
///
/// Each result captures details of one entry that matches the search.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCatalogResult {

    /// Type of the search result.
    ///
    /// You can use this field to determine which get method to call to fetch the
    /// full resource.
    pub search_result_type: crate::model::SearchResultType,

    /// Sub-type of the search result.
    ///
    /// A dot-delimited full type of the resource. The same type you
    /// specify in the `type` search predicate.
    ///
    /// Examples: `entry.table`, `entry.dataStream`, `tagTemplate`.
    pub search_result_subtype: std::string::String,

    /// The relative name of the resource in URL format.
    ///
    /// Examples:
    ///
    /// * `projects/{PROJECT_ID}/locations/{LOCATION_ID}/entryGroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`
    /// * `projects/{PROJECT_ID}/tagTemplates/{TAG_TEMPLATE_ID}`
    pub relative_resource_name: std::string::String,

    /// The full name of the Google Cloud resource the entry belongs to.
    ///
    /// For more information, see [Full Resource Name]
    /// (/apis/design/resource_names#full_resource_name).
    ///
    /// Example:
    ///
    /// `//bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID`
    pub linked_resource: std::string::String,

    /// The last modification timestamp of the entry in the source system.
    pub modify_time: std::option::Option<wkt::Timestamp>,

    /// Fully qualified name (FQN) of the resource.
    ///
    /// FQNs take two forms:
    ///
    /// * For non-regionalized resources:
    ///
    ///   `{SYSTEM}:{PROJECT}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
    ///
    /// * For regionalized resources:
    ///
    ///   `{SYSTEM}:{PROJECT}.{LOCATION_ID}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
    ///
    ///
    /// Example for a DPMS table:
    ///
    /// `dataproc_metastore:PROJECT_ID.LOCATION_ID.INSTANCE_ID.DATABASE_ID.TABLE_ID`
    pub fully_qualified_name: std::string::String,

    /// The display name of the result.
    pub display_name: std::string::String,

    /// Entry description that can consist of several sentences or paragraphs that
    /// describe entry contents.
    pub description: std::string::String,

    /// The source system of the entry. Applicable only when the
    /// `search_result_type` is `ENTRY`.
    pub system: std::option::Option<crate::model::search_catalog_result::System>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCatalogResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_result_type][crate::model::SearchCatalogResult::search_result_type].
    pub fn set_search_result_type<T: std::convert::Into<crate::model::SearchResultType>>(mut self, v: T) -> Self {
        self.search_result_type = v.into();
        self
    }

    /// Sets the value of [search_result_subtype][crate::model::SearchCatalogResult::search_result_subtype].
    pub fn set_search_result_subtype<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.search_result_subtype = v.into();
        self
    }

    /// Sets the value of [relative_resource_name][crate::model::SearchCatalogResult::relative_resource_name].
    pub fn set_relative_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_resource_name = v.into();
        self
    }

    /// Sets the value of [linked_resource][crate::model::SearchCatalogResult::linked_resource].
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [modify_time][crate::model::SearchCatalogResult::modify_time].
    pub fn set_modify_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.modify_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [modify_time][crate::model::SearchCatalogResult::modify_time].
    pub fn set_or_clear_modify_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.modify_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::SearchCatalogResult::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SearchCatalogResult::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SearchCatalogResult::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system].
    ///
    /// Note that all the setters affecting `system` are mutually
    /// exclusive.
    pub fn set_system<T: std::convert::Into<std::option::Option<crate::model::search_catalog_result::System>>>(mut self, v: T) -> Self
    {
        self.system = v.into();
        self
    }

    /// The value of [system][crate::model::SearchCatalogResult::system]
    /// if it holds a `IntegratedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integrated_system(&self) -> std::option::Option<&crate::model::IntegratedSystem> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::search_catalog_result::System::IntegratedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system]
    /// to hold a `IntegratedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_integrated_system<T: std::convert::Into<crate::model::IntegratedSystem>>(mut self, v: T) -> Self {
        self.system = std::option::Option::Some(
            crate::model::search_catalog_result::System::IntegratedSystem(
                v.into()
            )
        );
        self
    }

    /// The value of [system][crate::model::SearchCatalogResult::system]
    /// if it holds a `UserSpecifiedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_specified_system(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::search_catalog_result::System::UserSpecifiedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system]
    /// to hold a `UserSpecifiedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_user_specified_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system = std::option::Option::Some(
            crate::model::search_catalog_result::System::UserSpecifiedSystem(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SearchCatalogResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogResult"
    }
}

/// Defines additional types related to [SearchCatalogResult].
pub mod search_catalog_result {
    #[allow(unused_imports)]
    use super::*;


    /// The source system of the entry. Applicable only when the
    /// `search_result_type` is `ENTRY`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum System {
        /// Output only. The source system that Data Catalog automatically integrates
        /// with, such as BigQuery, Cloud Pub/Sub, or Dataproc Metastore.
        IntegratedSystem(crate::model::IntegratedSystem),
        /// Custom source system that you can manually integrate Data Catalog with.
        UserSpecifiedSystem(std::string::String),
    }
}

/// Describes a BigQuery table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryTableSpec {

    /// Output only. The table source type.
    pub table_source_type: crate::model::TableSourceType,

    /// Output only.
    pub type_spec: std::option::Option<crate::model::big_query_table_spec::TypeSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_source_type][crate::model::BigQueryTableSpec::table_source_type].
    pub fn set_table_source_type<T: std::convert::Into<crate::model::TableSourceType>>(mut self, v: T) -> Self {
        self.table_source_type = v.into();
        self
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec].
    ///
    /// Note that all the setters affecting `type_spec` are mutually
    /// exclusive.
    pub fn set_type_spec<T: std::convert::Into<std::option::Option<crate::model::big_query_table_spec::TypeSpec>>>(mut self, v: T) -> Self
    {
        self.type_spec = v.into();
        self
    }

    /// The value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// if it holds a `ViewSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn view_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ViewSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_table_spec::TypeSpec::ViewSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// to hold a `ViewSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_view_spec<T: std::convert::Into<std::boxed::Box<crate::model::ViewSpec>>>(mut self, v: T) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::big_query_table_spec::TypeSpec::ViewSpec(
                v.into()
            )
        );
        self
    }

    /// The value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// if it holds a `TableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::TableSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_table_spec::TypeSpec::TableSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// to hold a `TableSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_table_spec<T: std::convert::Into<std::boxed::Box<crate::model::TableSpec>>>(mut self, v: T) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::big_query_table_spec::TypeSpec::TableSpec(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for BigQueryTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryTableSpec"
    }
}

/// Defines additional types related to [BigQueryTableSpec].
pub mod big_query_table_spec {
    #[allow(unused_imports)]
    use super::*;


    /// Output only.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeSpec {
        /// Table view specification. Populated only if
        /// the `table_source_type` is `BIGQUERY_VIEW`.
        ViewSpec(std::boxed::Box<crate::model::ViewSpec>),
        /// Specification of a BigQuery table. Populated only if
        /// the `table_source_type` is `BIGQUERY_TABLE`.
        TableSpec(std::boxed::Box<crate::model::TableSpec>),
    }
}

/// Table view specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ViewSpec {

    /// Output only. The query that defines the table view.
    pub view_query: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViewSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view_query][crate::model::ViewSpec::view_query].
    pub fn set_view_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.view_query = v.into();
        self
    }
}

impl wkt::message::Message for ViewSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ViewSpec"
    }
}

/// Normal BigQuery table specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TableSpec {

    /// Output only. If the table is date-sharded, that is, it matches the
    /// `[prefix]YYYYMMDD` name pattern, this field is the Data Catalog resource
    /// name of the date-sharded grouped entry. For example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/entrygroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`.
    ///
    /// Otherwise, `grouped_entry` is empty.
    pub grouped_entry: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [grouped_entry][crate::model::TableSpec::grouped_entry].
    pub fn set_grouped_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grouped_entry = v.into();
        self
    }
}

impl wkt::message::Message for TableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TableSpec"
    }
}

/// Specification for a group of BigQuery tables with the `[prefix]YYYYMMDD` name
/// pattern.
///
/// For more information, see [Introduction to partitioned tables]
/// (<https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding>).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDateShardedSpec {

    /// Output only. The Data Catalog resource name of the dataset entry the
    /// current table belongs to. For example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/entrygroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`.
    pub dataset: std::string::String,

    /// Output only. The table name prefix of the shards.
    ///
    /// The name of any given shard is `[table_prefix]YYYYMMDD`.
    /// For example, for the `MyTable20180101` shard, the
    /// `table_prefix` is `MyTable`.
    pub table_prefix: std::string::String,

    /// Output only. Total number of shards.
    pub shard_count: i64,

    /// Output only. BigQuery resource name of the latest shard.
    pub latest_shard_resource: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDateShardedSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::BigQueryDateShardedSpec::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [table_prefix][crate::model::BigQueryDateShardedSpec::table_prefix].
    pub fn set_table_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_prefix = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::BigQueryDateShardedSpec::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [latest_shard_resource][crate::model::BigQueryDateShardedSpec::latest_shard_resource].
    pub fn set_latest_shard_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_shard_resource = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDateShardedSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryDateShardedSpec"
    }
}

/// Tags contain custom metadata and are attached to Data Catalog resources. Tags
/// conform with the specification of their tag template.
///
/// See [Data Catalog
/// IAM](https://cloud.google.com/data-catalog/docs/concepts/iam) for information
/// on the permissions needed to create or view tags.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Tag {

    /// Identifier. The resource name of the tag in URL format where tag ID is a
    /// system-generated identifier.
    ///
    /// Note: The tag itself might not be stored in the location specified in its
    /// name.
    pub name: std::string::String,

    /// Required. The resource name of the tag template this tag uses. Example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE_ID}`
    ///
    /// This field cannot be modified after creation.
    pub template: std::string::String,

    /// Output only. The display name of the tag template.
    pub template_display_name: std::string::String,

    /// Required. Maps the ID of a tag field to its value and additional
    /// information about that field.
    ///
    /// Tag template defines valid field IDs. A tag
    /// must have at least 1 field and at most 500 fields.
    pub fields: std::collections::HashMap<std::string::String,crate::model::TagField>,

    /// Output only. Denotes the transfer status of the Tag Template.
    pub dataplex_transfer_status: crate::model::tag_template::DataplexTransferStatus,

    /// The scope within the parent resource that this tag is attached to. If not
    /// provided, the tag is attached to the parent resource itself.
    ///
    /// Deleting the scope from the parent resource deletes all tags attached
    /// to that scope.
    ///
    /// These fields cannot be updated after creation.
    pub scope: std::option::Option<crate::model::tag::Scope>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Tag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [template][crate::model::Tag::template].
    pub fn set_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [template_display_name][crate::model::Tag::template_display_name].
    pub fn set_template_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_display_name = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Tag::fields].
    pub fn set_fields<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TagField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [dataplex_transfer_status][crate::model::Tag::dataplex_transfer_status].
    pub fn set_dataplex_transfer_status<T: std::convert::Into<crate::model::tag_template::DataplexTransferStatus>>(mut self, v: T) -> Self {
        self.dataplex_transfer_status = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Tag::scope].
    ///
    /// Note that all the setters affecting `scope` are mutually
    /// exclusive.
    pub fn set_scope<T: std::convert::Into<std::option::Option<crate::model::tag::Scope>>>(mut self, v: T) -> Self
    {
        self.scope = v.into();
        self
    }

    /// The value of [scope][crate::model::Tag::scope]
    /// if it holds a `Column`, `None` if the field is not set or
    /// holds a different branch.
    pub fn column(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.scope.as_ref().and_then(|v| match v {
            crate::model::tag::Scope::Column(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scope][crate::model::Tag::scope]
    /// to hold a `Column`.
    ///
    /// Note that all the setters affecting `scope` are
    /// mutually exclusive.
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = std::option::Option::Some(
            crate::model::tag::Scope::Column(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Tag"
    }
}

/// Defines additional types related to [Tag].
pub mod tag {
    #[allow(unused_imports)]
    use super::*;


    /// The scope within the parent resource that this tag is attached to. If not
    /// provided, the tag is attached to the parent resource itself.
    ///
    /// Deleting the scope from the parent resource deletes all tags attached
    /// to that scope.
    ///
    /// These fields cannot be updated after creation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Resources like entry can have schemas associated with them. This scope
        /// allows you to attach tags to an individual column based on that schema.
        ///
        /// To attach a tag to a nested column, separate column names with a dot
        /// (`.`). Example: `column.nested_column`.
        Column(std::string::String),
    }
}

/// Contains the value and additional information on a field within
/// a [Tag][google.cloud.datacatalog.v1.Tag].
///
/// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TagField {

    /// Output only. The display name of this field.
    pub display_name: std::string::String,

    /// Output only. The order of this field with respect to other fields in this
    /// tag. Can be set by
    /// [Tag][google.cloud.datacatalog.v1.TagTemplateField.order].
    ///
    /// For example, a higher value can indicate a more important field.
    /// The value can be negative. Multiple fields can have the same order, and
    /// field orders within a tag don't have to be sequential.
    ///
    /// [google.cloud.datacatalog.v1.TagTemplateField.order]: crate::model::TagTemplateField::order
    pub order: i32,

    /// Required. The value of this field.
    pub kind: std::option::Option<crate::model::tag_field::Kind>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TagField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::TagField::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [order][crate::model::TagField::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::TagField::kind].
    ///
    /// Note that all the setters affecting `kind` are mutually
    /// exclusive.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::tag_field::Kind>>>(mut self, v: T) -> Self
    {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(
            crate::model::tag_field::Kind::DoubleValue(
                v.into()
            )
        );
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(
            crate::model::tag_field::Kind::StringValue(
                v.into()
            )
        );
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(
            crate::model::tag_field::Kind::BoolValue(
                v.into()
            )
        );
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `TimestampValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timestamp_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::TimestampValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `TimestampValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_timestamp_value<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(
            crate::model::tag_field::Kind::TimestampValue(
                v.into()
            )
        );
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `EnumValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn enum_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::tag_field::EnumValue>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::EnumValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `EnumValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_enum_value<T: std::convert::Into<std::boxed::Box<crate::model::tag_field::EnumValue>>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(
            crate::model::tag_field::Kind::EnumValue(
                v.into()
            )
        );
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `RichtextValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn richtext_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::RichtextValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `RichtextValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_richtext_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(
            crate::model::tag_field::Kind::RichtextValue(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for TagField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagField"
    }
}

/// Defines additional types related to [TagField].
pub mod tag_field {
    #[allow(unused_imports)]
    use super::*;


    /// An enum value.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EnumValue {

        /// The display name of the enum value.
        pub display_name: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EnumValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::tag_field::EnumValue::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EnumValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.TagField.EnumValue"
        }
    }

    /// Required. The value of this field.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// The value of a tag field with a double type.
        DoubleValue(f64),
        /// The value of a tag field with a string type.
        ///
        /// The maximum length is 2000 UTF-8 characters.
        StringValue(std::string::String),
        /// The value of a tag field with a boolean type.
        BoolValue(bool),
        /// The value of a tag field with a timestamp type.
        TimestampValue(std::boxed::Box<wkt::Timestamp>),
        /// The value of a tag field with an enum type.
        ///
        /// This value must be one of the allowed values listed in this enum.
        EnumValue(std::boxed::Box<crate::model::tag_field::EnumValue>),
        /// The value of a tag field with a rich text type.
        ///
        /// The maximum length is 10 MiB as this value holds HTML descriptions
        /// including encoded images. The maximum length of the text without images
        /// is 100 KiB.
        RichtextValue(std::string::String),
    }
}

/// A tag template defines a tag that can have one or more typed fields.
///
/// The template is used to create tags that are attached to Google Cloud
/// resources. [Tag template roles]
/// (<https://cloud.google.com/iam/docs/understanding-roles#data-catalog-roles>)
/// provide permissions to create, edit, and use the template. For example,
/// see the [TagTemplate User]
/// (<https://cloud.google.com/data-catalog/docs/how-to/template-user>) role
/// that includes a permission to use the tag template to tag resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TagTemplate {

    /// Identifier. The resource name of the tag template in URL format.
    ///
    /// Note: The tag template itself and its child resources might not be
    /// stored in the location specified in its name.
    pub name: std::string::String,

    /// Display name for this template. Defaults to an empty string.
    ///
    /// The name must contain only Unicode letters, numbers (0-9), underscores (_),
    /// dashes (-), spaces ( ), and can't start or end with spaces.
    /// The maximum length is 200 characters.
    pub display_name: std::string::String,

    /// Indicates whether tags created with this template are public. Public tags
    /// do not require tag template access to appear in
    /// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags] API response.
    ///
    /// Additionally, you can search for a public tag by value with a
    /// simple search query in addition to using a ``tag:`` predicate.
    ///
    /// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
    pub is_publicly_readable: bool,

    /// Required. Map of tag template field IDs to the settings for the field.
    /// This map is an exhaustive list of the allowed fields. The map must contain
    /// at least one field and at most 500 fields.
    ///
    /// The keys to this map are tag template field IDs. The IDs have the
    /// following limitations:
    ///
    /// * Can contain uppercase and lowercase letters, numbers (0-9) and
    ///   underscores (_).
    /// * Must be at least 1 character and at most 64 characters long.
    /// * Must start with a letter or underscore.
    pub fields: std::collections::HashMap<std::string::String,crate::model::TagTemplateField>,

    /// Optional. Transfer status of the TagTemplate
    pub dataplex_transfer_status: crate::model::tag_template::DataplexTransferStatus,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TagTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TagTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TagTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [is_publicly_readable][crate::model::TagTemplate::is_publicly_readable].
    pub fn set_is_publicly_readable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_publicly_readable = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TagTemplate::fields].
    pub fn set_fields<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TagTemplateField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [dataplex_transfer_status][crate::model::TagTemplate::dataplex_transfer_status].
    pub fn set_dataplex_transfer_status<T: std::convert::Into<crate::model::tag_template::DataplexTransferStatus>>(mut self, v: T) -> Self {
        self.dataplex_transfer_status = v.into();
        self
    }
}

impl wkt::message::Message for TagTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagTemplate"
    }
}

/// Defines additional types related to [TagTemplate].
pub mod tag_template {
    #[allow(unused_imports)]
    use super::*;


    /// This enum describes TagTemplate transfer status to Dataplex service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataplexTransferStatus {
        /// Default value. TagTemplate and its tags are only visible and editable in
        /// DataCatalog.
        Unspecified,
        /// TagTemplate and its tags are auto-copied to Dataplex service.
        /// Visible in both services. Editable in DataCatalog, read-only in Dataplex.
        /// Deprecated: Individual TagTemplate migration is deprecated in favor of
        /// organization or project wide TagTemplate migration opt-in.
        #[deprecated]
        Migrated,
        /// TagTemplate and its tags are auto-copied to Dataplex service.
        /// Visible in both services. Editable in Dataplex, read-only in DataCatalog.
        Transferred,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataplexTransferStatus::value] or
        /// [DataplexTransferStatus::name].
        UnknownValue(dataplex_transfer_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dataplex_transfer_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataplexTransferStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Migrated => std::option::Option::Some(1),
                Self::Transferred => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATAPLEX_TRANSFER_STATUS_UNSPECIFIED"),
                Self::Migrated => std::option::Option::Some("MIGRATED"),
                Self::Transferred => std::option::Option::Some("TRANSFERRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataplexTransferStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataplexTransferStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataplexTransferStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Migrated,
                2 => Self::Transferred,
                _ => Self::UnknownValue(dataplex_transfer_status::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for DataplexTransferStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATAPLEX_TRANSFER_STATUS_UNSPECIFIED" => Self::Unspecified,
                "MIGRATED" => Self::Migrated,
                "TRANSFERRED" => Self::Transferred,
                _ => Self::UnknownValue(dataplex_transfer_status::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for DataplexTransferStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Migrated => serializer.serialize_i32(1),
                Self::Transferred => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataplexTransferStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataplexTransferStatus>::new(
                ".google.cloud.datacatalog.v1.TagTemplate.DataplexTransferStatus"))
        }
    }
}

/// The template for an individual field within a tag template.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TagTemplateField {

    /// Identifier. The resource name of the tag template field in URL format.
    /// Example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE}/fields/{FIELD}`
    ///
    /// Note: The tag template field itself might not be stored in the location
    /// specified in its name.
    ///
    /// The name must contain only letters (a-z, A-Z), numbers (0-9),
    /// or underscores (_), and must start with a letter or underscore.
    /// The maximum length is 64 characters.
    pub name: std::string::String,

    /// The display name for this field. Defaults to an empty string.
    ///
    /// The name must contain only Unicode letters, numbers (0-9), underscores (_),
    /// dashes (-), spaces ( ), and can't start or end with spaces.
    /// The maximum length is 200 characters.
    pub display_name: std::string::String,

    /// Required. The type of value this tag field can contain.
    pub r#type: std::option::Option<crate::model::FieldType>,

    /// If true, this field is required. Defaults to false.
    pub is_required: bool,

    /// The description for this field. Defaults to an empty string.
    pub description: std::string::String,

    /// The order of this field with respect to other fields in this tag
    /// template.
    ///
    /// For example, a higher value can indicate a more important field.
    /// The value can be negative. Multiple fields can have the same order and
    /// field orders within a tag don't have to be sequential.
    pub order: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TagTemplateField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TagTemplateField::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TagTemplateField::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TagTemplateField::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::FieldType>
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::TagTemplateField::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::FieldType>
    {
        self.r#type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_required][crate::model::TagTemplateField::is_required].
    pub fn set_is_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_required = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TagTemplateField::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [order][crate::model::TagTemplateField::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }
}

impl wkt::message::Message for TagTemplateField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagTemplateField"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FieldType {

    /// Required.
    pub type_decl: std::option::Option<crate::model::field_type::TypeDecl>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl].
    ///
    /// Note that all the setters affecting `type_decl` are mutually
    /// exclusive.
    pub fn set_type_decl<T: std::convert::Into<std::option::Option<crate::model::field_type::TypeDecl>>>(mut self, v: T) -> Self
    {
        self.type_decl = v.into();
        self
    }

    /// The value of [type_decl][crate::model::FieldType::type_decl]
    /// if it holds a `PrimitiveType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn primitive_type(&self) -> std::option::Option<&crate::model::field_type::PrimitiveType> {
        #[allow(unreachable_patterns)]
        self.type_decl.as_ref().and_then(|v| match v {
            crate::model::field_type::TypeDecl::PrimitiveType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl]
    /// to hold a `PrimitiveType`.
    ///
    /// Note that all the setters affecting `type_decl` are
    /// mutually exclusive.
    pub fn set_primitive_type<T: std::convert::Into<crate::model::field_type::PrimitiveType>>(mut self, v: T) -> Self {
        self.type_decl = std::option::Option::Some(
            crate::model::field_type::TypeDecl::PrimitiveType(
                v.into()
            )
        );
        self
    }

    /// The value of [type_decl][crate::model::FieldType::type_decl]
    /// if it holds a `EnumType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn enum_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::field_type::EnumType>> {
        #[allow(unreachable_patterns)]
        self.type_decl.as_ref().and_then(|v| match v {
            crate::model::field_type::TypeDecl::EnumType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl]
    /// to hold a `EnumType`.
    ///
    /// Note that all the setters affecting `type_decl` are
    /// mutually exclusive.
    pub fn set_enum_type<T: std::convert::Into<std::boxed::Box<crate::model::field_type::EnumType>>>(mut self, v: T) -> Self {
        self.type_decl = std::option::Option::Some(
            crate::model::field_type::TypeDecl::EnumType(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for FieldType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FieldType"
    }
}

/// Defines additional types related to [FieldType].
pub mod field_type {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EnumType {

        /// The set of allowed values for this enum.
        ///
        /// This set must not be empty and can include up to 100 allowed values.
        /// The display names of the values in this set must not be empty and must
        /// be case-insensitively unique within this set.
        ///
        /// The order of items in this set is preserved. This field can be used to
        /// create, remove, and reorder enum values. To rename enum values, use the
        /// `RenameTagTemplateFieldEnumValue` method.
        pub allowed_values: std::vec::Vec<crate::model::field_type::enum_type::EnumValue>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EnumType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_values][crate::model::field_type::EnumType::allowed_values].
        pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::field_type::enum_type::EnumValue>
        {
            use std::iter::Iterator;
            self.allowed_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EnumType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.FieldType.EnumType"
        }
    }

    /// Defines additional types related to [EnumType].
    pub mod enum_type {
        #[allow(unused_imports)]
        use super::*;


        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct EnumValue {

            /// Required. The display name of the enum value. Must not be an empty
            /// string.
            ///
            /// The name must contain only Unicode letters, numbers (0-9), underscores
            /// (_), dashes (-), spaces ( ), and can't start or end with spaces. The
            /// maximum length is 200 characters.
            pub display_name: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EnumValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [display_name][crate::model::field_type::enum_type::EnumValue::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.display_name = v.into();
                self
            }
        }

        impl wkt::message::Message for EnumValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datacatalog.v1.FieldType.EnumType.EnumValue"
            }
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrimitiveType {
        /// The default invalid value for a type.
        Unspecified,
        /// A double precision number.
        Double,
        /// An UTF-8 string.
        String,
        /// A boolean value.
        Bool,
        /// A timestamp.
        Timestamp,
        /// A Richtext description.
        Richtext,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrimitiveType::value] or
        /// [PrimitiveType::name].
        UnknownValue(primitive_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod primitive_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrimitiveType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Double => std::option::Option::Some(1),
                Self::String => std::option::Option::Some(2),
                Self::Bool => std::option::Option::Some(3),
                Self::Timestamp => std::option::Option::Some(4),
                Self::Richtext => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIMITIVE_TYPE_UNSPECIFIED"),
                Self::Double => std::option::Option::Some("DOUBLE"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::Timestamp => std::option::Option::Some("TIMESTAMP"),
                Self::Richtext => std::option::Option::Some("RICHTEXT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrimitiveType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrimitiveType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrimitiveType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Double,
                2 => Self::String,
                3 => Self::Bool,
                4 => Self::Timestamp,
                5 => Self::Richtext,
                _ => Self::UnknownValue(primitive_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for PrimitiveType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIMITIVE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DOUBLE" => Self::Double,
                "STRING" => Self::String,
                "BOOL" => Self::Bool,
                "TIMESTAMP" => Self::Timestamp,
                "RICHTEXT" => Self::Richtext,
                _ => Self::UnknownValue(primitive_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for PrimitiveType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Double => serializer.serialize_i32(1),
                Self::String => serializer.serialize_i32(2),
                Self::Bool => serializer.serialize_i32(3),
                Self::Timestamp => serializer.serialize_i32(4),
                Self::Richtext => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrimitiveType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrimitiveType>::new(
                ".google.cloud.datacatalog.v1.FieldType.PrimitiveType"))
        }
    }

    /// Required.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeDecl {
        /// Primitive types, such as string, boolean, etc.
        PrimitiveType(crate::model::field_type::PrimitiveType),
        /// An enum type.
        EnumType(std::boxed::Box<crate::model::field_type::EnumType>),
    }
}

/// Timestamps associated with this resource in a particular system.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SystemTimestamps {

    /// Creation timestamp of the resource within the given system.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Timestamp of the last modification of the resource or its metadata within
    /// a given system.
    ///
    /// Note: Depending on the source system, not every modification updates this
    /// timestamp.
    /// For example, BigQuery timestamps every metadata modification but not data
    /// or permission changes.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Expiration timestamp of the resource within the given system.
    ///
    /// Currently only applicable to BigQuery resources.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SystemTimestamps {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::SystemTimestamps::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SystemTimestamps::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::SystemTimestamps::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SystemTimestamps::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::SystemTimestamps::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::SystemTimestamps::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SystemTimestamps {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SystemTimestamps"
    }
}

/// Detailed statistics on the entry's usage.
///
/// Usage statistics have the following limitations:
///
/// - Only BigQuery tables have them.
/// - They only include BigQuery query jobs.
/// - They might be underestimated because wildcard table references
///   are not yet counted. For more information, see
///   [Querying multiple tables using a wildcard table]
///   (<https://cloud.google.com/bigquery/docs/querying-wildcard-tables>)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UsageStats {

    /// The number of successful uses of the underlying entry.
    pub total_completions: f32,

    /// The number of failed attempts to use the underlying entry.
    pub total_failures: f32,

    /// The number of cancelled attempts to use the underlying entry.
    pub total_cancellations: f32,

    /// Total time spent only on successful uses, in milliseconds.
    pub total_execution_time_for_completions_millis: f32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_completions][crate::model::UsageStats::total_completions].
    pub fn set_total_completions<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_completions = v.into();
        self
    }

    /// Sets the value of [total_failures][crate::model::UsageStats::total_failures].
    pub fn set_total_failures<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_failures = v.into();
        self
    }

    /// Sets the value of [total_cancellations][crate::model::UsageStats::total_cancellations].
    pub fn set_total_cancellations<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_cancellations = v.into();
        self
    }

    /// Sets the value of [total_execution_time_for_completions_millis][crate::model::UsageStats::total_execution_time_for_completions_millis].
    pub fn set_total_execution_time_for_completions_millis<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_execution_time_for_completions_millis = v.into();
        self
    }
}

impl wkt::message::Message for UsageStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UsageStats"
    }
}

/// Common statistics on the entry's usage.
///
/// They can be set on any system.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CommonUsageStats {

    /// View count in source system.
    pub view_count: std::option::Option<i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommonUsageStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view_count][crate::model::CommonUsageStats::view_count].
    pub fn set_view_count<T>(mut self, v: T) -> Self
    where T: std::convert::Into<i64>
    {
        self.view_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view_count][crate::model::CommonUsageStats::view_count].
    pub fn set_or_clear_view_count<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<i64>
    {
        self.view_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CommonUsageStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CommonUsageStats"
    }
}

/// The set of all usage signals that Data Catalog stores.
///
/// Note: Usually, these signals are updated daily. In rare cases, an update may
/// fail but will be performed again on the next day.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UsageSignal {

    /// The end timestamp of the duration of usage statistics.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. BigQuery usage statistics over each of the predefined time
    /// ranges.
    ///
    /// Supported time ranges are `{"24H", "7D", "30D"}`.
    pub usage_within_time_range: std::collections::HashMap<std::string::String,crate::model::UsageStats>,

    /// Common usage statistics over each of the predefined time ranges.
    ///
    /// Supported time ranges are `{"24H", "7D", "30D", "Lifetime"}`.
    pub common_usage_within_time_range: std::collections::HashMap<std::string::String,crate::model::CommonUsageStats>,

    /// Favorite count in the source system.
    pub favorite_count: std::option::Option<i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageSignal {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::UsageSignal::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::UsageSignal::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [usage_within_time_range][crate::model::UsageSignal::usage_within_time_range].
    pub fn set_usage_within_time_range<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::UsageStats>,
    {
        use std::iter::Iterator;
        self.usage_within_time_range = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [common_usage_within_time_range][crate::model::UsageSignal::common_usage_within_time_range].
    pub fn set_common_usage_within_time_range<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CommonUsageStats>,
    {
        use std::iter::Iterator;
        self.common_usage_within_time_range = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [favorite_count][crate::model::UsageSignal::favorite_count].
    pub fn set_favorite_count<T>(mut self, v: T) -> Self
    where T: std::convert::Into<i64>
    {
        self.favorite_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [favorite_count][crate::model::UsageSignal::favorite_count].
    pub fn set_or_clear_favorite_count<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<i64>
    {
        self.favorite_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UsageSignal {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UsageSignal"
    }
}

/// This enum lists all the systems that Data Catalog integrates with.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IntegratedSystem {
    /// Default unknown system.
    Unspecified,
    /// BigQuery.
    Bigquery,
    /// Cloud Pub/Sub.
    CloudPubsub,
    /// Dataproc Metastore.
    DataprocMetastore,
    /// Dataplex.
    Dataplex,
    /// Cloud Spanner
    CloudSpanner,
    /// Cloud Bigtable
    CloudBigtable,
    /// Cloud Sql
    CloudSql,
    /// Looker
    Looker,
    /// Vertex AI
    VertexAi,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IntegratedSystem::value] or
    /// [IntegratedSystem::name].
    UnknownValue(integrated_system::UnknownValue),
}

#[doc(hidden)]
pub mod integrated_system {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IntegratedSystem {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Bigquery => std::option::Option::Some(1),
            Self::CloudPubsub => std::option::Option::Some(2),
            Self::DataprocMetastore => std::option::Option::Some(3),
            Self::Dataplex => std::option::Option::Some(4),
            Self::CloudSpanner => std::option::Option::Some(6),
            Self::CloudBigtable => std::option::Option::Some(7),
            Self::CloudSql => std::option::Option::Some(8),
            Self::Looker => std::option::Option::Some(9),
            Self::VertexAi => std::option::Option::Some(10),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INTEGRATED_SYSTEM_UNSPECIFIED"),
            Self::Bigquery => std::option::Option::Some("BIGQUERY"),
            Self::CloudPubsub => std::option::Option::Some("CLOUD_PUBSUB"),
            Self::DataprocMetastore => std::option::Option::Some("DATAPROC_METASTORE"),
            Self::Dataplex => std::option::Option::Some("DATAPLEX"),
            Self::CloudSpanner => std::option::Option::Some("CLOUD_SPANNER"),
            Self::CloudBigtable => std::option::Option::Some("CLOUD_BIGTABLE"),
            Self::CloudSql => std::option::Option::Some("CLOUD_SQL"),
            Self::Looker => std::option::Option::Some("LOOKER"),
            Self::VertexAi => std::option::Option::Some("VERTEX_AI"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IntegratedSystem {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IntegratedSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IntegratedSystem {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Bigquery,
            2 => Self::CloudPubsub,
            3 => Self::DataprocMetastore,
            4 => Self::Dataplex,
            6 => Self::CloudSpanner,
            7 => Self::CloudBigtable,
            8 => Self::CloudSql,
            9 => Self::Looker,
            10 => Self::VertexAi,
            _ => Self::UnknownValue(integrated_system::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for IntegratedSystem {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INTEGRATED_SYSTEM_UNSPECIFIED" => Self::Unspecified,
            "BIGQUERY" => Self::Bigquery,
            "CLOUD_PUBSUB" => Self::CloudPubsub,
            "DATAPROC_METASTORE" => Self::DataprocMetastore,
            "DATAPLEX" => Self::Dataplex,
            "CLOUD_SPANNER" => Self::CloudSpanner,
            "CLOUD_BIGTABLE" => Self::CloudBigtable,
            "CLOUD_SQL" => Self::CloudSql,
            "LOOKER" => Self::Looker,
            "VERTEX_AI" => Self::VertexAi,
            _ => Self::UnknownValue(integrated_system::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for IntegratedSystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Bigquery => serializer.serialize_i32(1),
            Self::CloudPubsub => serializer.serialize_i32(2),
            Self::DataprocMetastore => serializer.serialize_i32(3),
            Self::Dataplex => serializer.serialize_i32(4),
            Self::CloudSpanner => serializer.serialize_i32(6),
            Self::CloudBigtable => serializer.serialize_i32(7),
            Self::CloudSql => serializer.serialize_i32(8),
            Self::Looker => serializer.serialize_i32(9),
            Self::VertexAi => serializer.serialize_i32(10),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IntegratedSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IntegratedSystem>::new(
            ".google.cloud.datacatalog.v1.IntegratedSystem"))
    }
}

/// This enum describes all the systems that manage
/// Taxonomy and PolicyTag resources in DataCatalog.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ManagingSystem {
    /// Default value
    Unspecified,
    /// Dataplex.
    Dataplex,
    /// Other
    Other,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ManagingSystem::value] or
    /// [ManagingSystem::name].
    UnknownValue(managing_system::UnknownValue),
}

#[doc(hidden)]
pub mod managing_system {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ManagingSystem {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Dataplex => std::option::Option::Some(1),
            Self::Other => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MANAGING_SYSTEM_UNSPECIFIED"),
            Self::Dataplex => std::option::Option::Some("MANAGING_SYSTEM_DATAPLEX"),
            Self::Other => std::option::Option::Some("MANAGING_SYSTEM_OTHER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ManagingSystem {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ManagingSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ManagingSystem {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Dataplex,
            2 => Self::Other,
            _ => Self::UnknownValue(managing_system::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for ManagingSystem {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MANAGING_SYSTEM_UNSPECIFIED" => Self::Unspecified,
            "MANAGING_SYSTEM_DATAPLEX" => Self::Dataplex,
            "MANAGING_SYSTEM_OTHER" => Self::Other,
            _ => Self::UnknownValue(managing_system::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for ManagingSystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Dataplex => serializer.serialize_i32(1),
            Self::Other => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ManagingSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManagingSystem>::new(
            ".google.cloud.datacatalog.v1.ManagingSystem"))
    }
}

/// Metadata automatically ingested from Google Cloud resources like BigQuery
/// tables or Pub/Sub topics always uses enum values from `EntryType` as the type
/// of entry.
///
/// Other sources of metadata like Hive or Oracle databases can identify the type
/// by either using one of the enum values from `EntryType` (for example,
/// `FILESET` for a Cloud Storage fileset) or specifying a custom value using
/// the [`Entry`](#resource:-entry) field `user_specified_type`. For more
/// information, see
/// [Surface files from Cloud Storage with fileset
/// entries](/data-catalog/docs/how-to/filesets) or [Create custom entries for
/// your data sources](/data-catalog/docs/how-to/custom-entries).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EntryType {
    /// Default unknown type.
    Unspecified,
    /// The entry type that has a GoogleSQL schema, including
    /// logical views.
    Table,
    /// The type of models.
    ///
    /// For more information, see [Supported models in BigQuery
    /// ML](/bigquery/docs/bqml-introduction#supported_models).
    Model,
    /// An entry type for streaming entries. For example, a Pub/Sub topic.
    DataStream,
    /// An entry type for a set of files or objects. For example, a
    /// Cloud Storage fileset.
    Fileset,
    /// A group of servers that work together. For example, a Kafka cluster.
    Cluster,
    /// A database.
    Database,
    /// Connection to a data source. For example, a BigQuery
    /// connection.
    DataSourceConnection,
    /// Routine, for example, a BigQuery routine.
    Routine,
    /// A Dataplex lake.
    Lake,
    /// A Dataplex zone.
    Zone,
    /// A service, for example, a Dataproc Metastore service.
    Service,
    /// Schema within a relational database.
    DatabaseSchema,
    /// A Dashboard, for example from Looker.
    Dashboard,
    /// A Looker Explore.
    ///
    /// For more information, see [Looker Explore API]
    /// (<https://developers.looker.com/api/explorer/4.0/methods/LookmlModel/lookml_model_explore>).
    Explore,
    /// A Looker Look.
    ///
    /// For more information, see [Looker Look API]
    /// (<https://developers.looker.com/api/explorer/4.0/methods/Look>).
    Look,
    /// Feature Online Store resource in Vertex AI Feature Store.
    FeatureOnlineStore,
    /// Feature View resource in Vertex AI Feature Store.
    FeatureView,
    /// Feature Group resource in Vertex AI Feature Store.
    FeatureGroup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EntryType::value] or
    /// [EntryType::name].
    UnknownValue(entry_type::UnknownValue),
}

#[doc(hidden)]
pub mod entry_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EntryType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Table => std::option::Option::Some(2),
            Self::Model => std::option::Option::Some(5),
            Self::DataStream => std::option::Option::Some(3),
            Self::Fileset => std::option::Option::Some(4),
            Self::Cluster => std::option::Option::Some(6),
            Self::Database => std::option::Option::Some(7),
            Self::DataSourceConnection => std::option::Option::Some(8),
            Self::Routine => std::option::Option::Some(9),
            Self::Lake => std::option::Option::Some(10),
            Self::Zone => std::option::Option::Some(11),
            Self::Service => std::option::Option::Some(14),
            Self::DatabaseSchema => std::option::Option::Some(15),
            Self::Dashboard => std::option::Option::Some(16),
            Self::Explore => std::option::Option::Some(17),
            Self::Look => std::option::Option::Some(18),
            Self::FeatureOnlineStore => std::option::Option::Some(19),
            Self::FeatureView => std::option::Option::Some(20),
            Self::FeatureGroup => std::option::Option::Some(21),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENTRY_TYPE_UNSPECIFIED"),
            Self::Table => std::option::Option::Some("TABLE"),
            Self::Model => std::option::Option::Some("MODEL"),
            Self::DataStream => std::option::Option::Some("DATA_STREAM"),
            Self::Fileset => std::option::Option::Some("FILESET"),
            Self::Cluster => std::option::Option::Some("CLUSTER"),
            Self::Database => std::option::Option::Some("DATABASE"),
            Self::DataSourceConnection => std::option::Option::Some("DATA_SOURCE_CONNECTION"),
            Self::Routine => std::option::Option::Some("ROUTINE"),
            Self::Lake => std::option::Option::Some("LAKE"),
            Self::Zone => std::option::Option::Some("ZONE"),
            Self::Service => std::option::Option::Some("SERVICE"),
            Self::DatabaseSchema => std::option::Option::Some("DATABASE_SCHEMA"),
            Self::Dashboard => std::option::Option::Some("DASHBOARD"),
            Self::Explore => std::option::Option::Some("EXPLORE"),
            Self::Look => std::option::Option::Some("LOOK"),
            Self::FeatureOnlineStore => std::option::Option::Some("FEATURE_ONLINE_STORE"),
            Self::FeatureView => std::option::Option::Some("FEATURE_VIEW"),
            Self::FeatureGroup => std::option::Option::Some("FEATURE_GROUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EntryType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EntryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EntryType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::Table,
            3 => Self::DataStream,
            4 => Self::Fileset,
            5 => Self::Model,
            6 => Self::Cluster,
            7 => Self::Database,
            8 => Self::DataSourceConnection,
            9 => Self::Routine,
            10 => Self::Lake,
            11 => Self::Zone,
            14 => Self::Service,
            15 => Self::DatabaseSchema,
            16 => Self::Dashboard,
            17 => Self::Explore,
            18 => Self::Look,
            19 => Self::FeatureOnlineStore,
            20 => Self::FeatureView,
            21 => Self::FeatureGroup,
            _ => Self::UnknownValue(entry_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for EntryType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENTRY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TABLE" => Self::Table,
            "MODEL" => Self::Model,
            "DATA_STREAM" => Self::DataStream,
            "FILESET" => Self::Fileset,
            "CLUSTER" => Self::Cluster,
            "DATABASE" => Self::Database,
            "DATA_SOURCE_CONNECTION" => Self::DataSourceConnection,
            "ROUTINE" => Self::Routine,
            "LAKE" => Self::Lake,
            "ZONE" => Self::Zone,
            "SERVICE" => Self::Service,
            "DATABASE_SCHEMA" => Self::DatabaseSchema,
            "DASHBOARD" => Self::Dashboard,
            "EXPLORE" => Self::Explore,
            "LOOK" => Self::Look,
            "FEATURE_ONLINE_STORE" => Self::FeatureOnlineStore,
            "FEATURE_VIEW" => Self::FeatureView,
            "FEATURE_GROUP" => Self::FeatureGroup,
            _ => Self::UnknownValue(entry_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for EntryType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Table => serializer.serialize_i32(2),
            Self::Model => serializer.serialize_i32(5),
            Self::DataStream => serializer.serialize_i32(3),
            Self::Fileset => serializer.serialize_i32(4),
            Self::Cluster => serializer.serialize_i32(6),
            Self::Database => serializer.serialize_i32(7),
            Self::DataSourceConnection => serializer.serialize_i32(8),
            Self::Routine => serializer.serialize_i32(9),
            Self::Lake => serializer.serialize_i32(10),
            Self::Zone => serializer.serialize_i32(11),
            Self::Service => serializer.serialize_i32(14),
            Self::DatabaseSchema => serializer.serialize_i32(15),
            Self::Dashboard => serializer.serialize_i32(16),
            Self::Explore => serializer.serialize_i32(17),
            Self::Look => serializer.serialize_i32(18),
            Self::FeatureOnlineStore => serializer.serialize_i32(19),
            Self::FeatureView => serializer.serialize_i32(20),
            Self::FeatureGroup => serializer.serialize_i32(21),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EntryType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntryType>::new(
            ".google.cloud.datacatalog.v1.EntryType"))
    }
}

/// Configuration related to the opt-in status for the migration of TagTemplates
/// to Dataplex.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TagTemplateMigration {
    /// Default value. Migration of Tag Templates from Data Catalog to Dataplex is
    /// not performed.
    Unspecified,
    /// Migration of Tag Templates from Data Catalog to Dataplex is enabled.
    Enabled,
    /// Migration of Tag Templates from Data Catalog to Dataplex is disabled.
    Disabled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TagTemplateMigration::value] or
    /// [TagTemplateMigration::name].
    UnknownValue(tag_template_migration::UnknownValue),
}

#[doc(hidden)]
pub mod tag_template_migration {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TagTemplateMigration {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enabled => std::option::Option::Some(1),
            Self::Disabled => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TAG_TEMPLATE_MIGRATION_UNSPECIFIED"),
            Self::Enabled => std::option::Option::Some("TAG_TEMPLATE_MIGRATION_ENABLED"),
            Self::Disabled => std::option::Option::Some("TAG_TEMPLATE_MIGRATION_DISABLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TagTemplateMigration {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TagTemplateMigration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TagTemplateMigration {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enabled,
            2 => Self::Disabled,
            _ => Self::UnknownValue(tag_template_migration::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for TagTemplateMigration {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TAG_TEMPLATE_MIGRATION_UNSPECIFIED" => Self::Unspecified,
            "TAG_TEMPLATE_MIGRATION_ENABLED" => Self::Enabled,
            "TAG_TEMPLATE_MIGRATION_DISABLED" => Self::Disabled,
            _ => Self::UnknownValue(tag_template_migration::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for TagTemplateMigration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enabled => serializer.serialize_i32(1),
            Self::Disabled => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TagTemplateMigration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TagTemplateMigration>::new(
            ".google.cloud.datacatalog.v1.TagTemplateMigration"))
    }
}

/// Configuration related to the opt-in status for the UI switch to Dataplex.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CatalogUIExperience {
    /// Default value. The default UI is Dataplex.
    Unspecified,
    /// The UI is Dataplex.
    Enabled,
    /// The UI is Data Catalog.
    Disabled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CatalogUIExperience::value] or
    /// [CatalogUIExperience::name].
    UnknownValue(catalog_ui_experience::UnknownValue),
}

#[doc(hidden)]
pub mod catalog_ui_experience {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CatalogUIExperience {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enabled => std::option::Option::Some(1),
            Self::Disabled => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CATALOG_UI_EXPERIENCE_UNSPECIFIED"),
            Self::Enabled => std::option::Option::Some("CATALOG_UI_EXPERIENCE_ENABLED"),
            Self::Disabled => std::option::Option::Some("CATALOG_UI_EXPERIENCE_DISABLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CatalogUIExperience {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CatalogUIExperience {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CatalogUIExperience {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enabled,
            2 => Self::Disabled,
            _ => Self::UnknownValue(catalog_ui_experience::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for CatalogUIExperience {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CATALOG_UI_EXPERIENCE_UNSPECIFIED" => Self::Unspecified,
            "CATALOG_UI_EXPERIENCE_ENABLED" => Self::Enabled,
            "CATALOG_UI_EXPERIENCE_DISABLED" => Self::Disabled,
            _ => Self::UnknownValue(catalog_ui_experience::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for CatalogUIExperience {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enabled => serializer.serialize_i32(1),
            Self::Disabled => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CatalogUIExperience {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CatalogUIExperience>::new(
            ".google.cloud.datacatalog.v1.CatalogUIExperience"))
    }
}

/// The resource types that can be returned in search results.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SearchResultType {
    /// Default unknown type.
    Unspecified,
    /// An [Entry][google.cloud.datacatalog.v1.Entry].
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    Entry,
    /// A [TagTemplate][google.cloud.datacatalog.v1.TagTemplate].
    ///
    /// [google.cloud.datacatalog.v1.TagTemplate]: crate::model::TagTemplate
    TagTemplate,
    /// An [EntryGroup][google.cloud.datacatalog.v1.EntryGroup].
    ///
    /// [google.cloud.datacatalog.v1.EntryGroup]: crate::model::EntryGroup
    EntryGroup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SearchResultType::value] or
    /// [SearchResultType::name].
    UnknownValue(search_result_type::UnknownValue),
}

#[doc(hidden)]
pub mod search_result_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SearchResultType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Entry => std::option::Option::Some(1),
            Self::TagTemplate => std::option::Option::Some(2),
            Self::EntryGroup => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEARCH_RESULT_TYPE_UNSPECIFIED"),
            Self::Entry => std::option::Option::Some("ENTRY"),
            Self::TagTemplate => std::option::Option::Some("TAG_TEMPLATE"),
            Self::EntryGroup => std::option::Option::Some("ENTRY_GROUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SearchResultType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SearchResultType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SearchResultType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Entry,
            2 => Self::TagTemplate,
            3 => Self::EntryGroup,
            _ => Self::UnknownValue(search_result_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SearchResultType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEARCH_RESULT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ENTRY" => Self::Entry,
            "TAG_TEMPLATE" => Self::TagTemplate,
            "ENTRY_GROUP" => Self::EntryGroup,
            _ => Self::UnknownValue(search_result_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SearchResultType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Entry => serializer.serialize_i32(1),
            Self::TagTemplate => serializer.serialize_i32(2),
            Self::EntryGroup => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SearchResultType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchResultType>::new(
            ".google.cloud.datacatalog.v1.SearchResultType"))
    }
}

/// Table source type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TableSourceType {
    /// Default unknown type.
    Unspecified,
    /// Table view.
    BigqueryView,
    /// BigQuery native table.
    BigqueryTable,
    /// BigQuery materialized view.
    BigqueryMaterializedView,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TableSourceType::value] or
    /// [TableSourceType::name].
    UnknownValue(table_source_type::UnknownValue),
}

#[doc(hidden)]
pub mod table_source_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TableSourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BigqueryView => std::option::Option::Some(2),
            Self::BigqueryTable => std::option::Option::Some(5),
            Self::BigqueryMaterializedView => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TABLE_SOURCE_TYPE_UNSPECIFIED"),
            Self::BigqueryView => std::option::Option::Some("BIGQUERY_VIEW"),
            Self::BigqueryTable => std::option::Option::Some("BIGQUERY_TABLE"),
            Self::BigqueryMaterializedView => std::option::Option::Some("BIGQUERY_MATERIALIZED_VIEW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TableSourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TableSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TableSourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::BigqueryView,
            5 => Self::BigqueryTable,
            7 => Self::BigqueryMaterializedView,
            _ => Self::UnknownValue(table_source_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for TableSourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TABLE_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BIGQUERY_VIEW" => Self::BigqueryView,
            "BIGQUERY_TABLE" => Self::BigqueryTable,
            "BIGQUERY_MATERIALIZED_VIEW" => Self::BigqueryMaterializedView,
            _ => Self::UnknownValue(table_source_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for TableSourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BigqueryView => serializer.serialize_i32(2),
            Self::BigqueryTable => serializer.serialize_i32(5),
            Self::BigqueryMaterializedView => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TableSourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableSourceType>::new(
            ".google.cloud.datacatalog.v1.TableSourceType"))
    }
}
