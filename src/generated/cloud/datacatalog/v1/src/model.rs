// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Specification for the BigQuery connection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryConnectionSpec {
    /// The type of the BigQuery connection.
    pub connection_type: crate::model::big_query_connection_spec::ConnectionType,

    /// True if there are credentials attached to the BigQuery connection; false
    /// otherwise.
    pub has_credential: bool,

    pub connection_spec:
        std::option::Option<crate::model::big_query_connection_spec::ConnectionSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_type][crate::model::BigQueryConnectionSpec::connection_type].
    pub fn set_connection_type<
        T: std::convert::Into<crate::model::big_query_connection_spec::ConnectionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }

    /// Sets the value of [has_credential][crate::model::BigQueryConnectionSpec::has_credential].
    pub fn set_has_credential<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_credential = v.into();
        self
    }

    /// Sets the value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec].
    ///
    /// Note that all the setters affecting `connection_spec` are mutually
    /// exclusive.
    pub fn set_connection_spec<
        T: std::convert::Into<
                std::option::Option<crate::model::big_query_connection_spec::ConnectionSpec>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_spec = v.into();
        self
    }

    /// The value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>> {
        #[allow(unreachable_patterns)]
        self.connection_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_connection_spec::ConnectionSpec::CloudSql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_spec][crate::model::BigQueryConnectionSpec::connection_spec]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `connection_spec` are
    /// mutually exclusive.
    pub fn set_cloud_sql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_spec = std::option::Option::Some(
            crate::model::big_query_connection_spec::ConnectionSpec::CloudSql(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryConnectionSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryConnectionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_type,
            __cloud_sql,
            __has_credential,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryConnectionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionType" => Ok(__FieldTag::__connection_type),
                            "connection_type" => Ok(__FieldTag::__connection_type),
                            "cloudSql" => Ok(__FieldTag::__cloud_sql),
                            "cloud_sql" => Ok(__FieldTag::__cloud_sql),
                            "hasCredential" => Ok(__FieldTag::__has_credential),
                            "has_credential" => Ok(__FieldTag::__has_credential),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryConnectionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryConnectionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_type => {
                            if !fields.insert(__FieldTag::__connection_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_type",
                                ));
                            }
                            result.connection_type = map
                                .next_value::<std::option::Option<
                                    crate::model::big_query_connection_spec::ConnectionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_sql => {
                            if !fields.insert(__FieldTag::__cloud_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql",
                                ));
                            }
                            if result.connection_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_spec`, a oneof with full ID .google.cloud.datacatalog.v1.BigQueryConnectionSpec.cloud_sql, latest field was cloudSql",
                                ));
                            }
                            result.connection_spec = std::option::Option::Some(
                                crate::model::big_query_connection_spec::ConnectionSpec::CloudSql(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::CloudSqlBigQueryConnectionSpec,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__has_credential => {
                            if !fields.insert(__FieldTag::__has_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_credential",
                                ));
                            }
                            result.has_credential = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryConnectionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.connection_type) {
            state.serialize_entry("connectionType", &self.connection_type)?;
        }
        if let Some(value) = self.cloud_sql() {
            state.serialize_entry("cloudSql", value)?;
        }
        if !wkt::internal::is_default(&self.has_credential) {
            state.serialize_entry("hasCredential", &self.has_credential)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BigQueryConnectionSpec].
pub mod big_query_connection_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the BigQuery connection.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionType {
        /// Unspecified type.
        Unspecified,
        /// Cloud SQL connection.
        CloudSql,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectionType::value] or
        /// [ConnectionType::name].
        UnknownValue(connection_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connection_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudSql => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTION_TYPE_UNSPECIFIED"),
                Self::CloudSql => std::option::Option::Some("CLOUD_SQL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudSql,
                _ => Self::UnknownValue(connection_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConnectionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_SQL" => Self::CloudSql,
                _ => Self::UnknownValue(connection_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConnectionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudSql => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionType>::new(
                ".google.cloud.datacatalog.v1.BigQueryConnectionSpec.ConnectionType",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionSpec {
        /// Specification for the BigQuery connection to a Cloud SQL instance.
        CloudSql(std::boxed::Box<crate::model::CloudSqlBigQueryConnectionSpec>),
    }
}

/// Specification for the BigQuery connection to a Cloud SQL instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlBigQueryConnectionSpec {
    /// Cloud SQL instance ID in the format of `project:location:instance`.
    pub instance_id: std::string::String,

    /// Database name.
    pub database: std::string::String,

    /// Type of the Cloud SQL database.
    pub r#type: crate::model::cloud_sql_big_query_connection_spec::DatabaseType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlBigQueryConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_id][crate::model::CloudSqlBigQueryConnectionSpec::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CloudSqlBigQueryConnectionSpec::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CloudSqlBigQueryConnectionSpec::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::cloud_sql_big_query_connection_spec::DatabaseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlBigQueryConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudSqlBigQueryConnectionSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlBigQueryConnectionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_id,
            __database,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlBigQueryConnectionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "database" => Ok(__FieldTag::__database),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlBigQueryConnectionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlBigQueryConnectionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_sql_big_query_connection_spec::DatabaseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlBigQueryConnectionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CloudSqlBigQueryConnectionSpec].
pub mod cloud_sql_big_query_connection_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Cloud SQL database types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Unspecified database type.
        Unspecified,
        /// Cloud SQL for PostgreSQL.
        Postgres,
        /// Cloud SQL for MySQL.
        Mysql,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Postgres => std::option::Option::Some(1),
                Self::Mysql => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::Postgres => std::option::Option::Some("POSTGRES"),
                Self::Mysql => std::option::Option::Some("MYSQL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Postgres,
                2 => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "POSTGRES" => Self::Postgres,
                "MYSQL" => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Postgres => serializer.serialize_i32(1),
                Self::Mysql => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.cloud.datacatalog.v1.CloudSqlBigQueryConnectionSpec.DatabaseType",
            ))
        }
    }
}

/// Fields specific for BigQuery routines.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryRoutineSpec {
    /// Paths of the imported libraries.
    pub imported_libraries: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryRoutineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_libraries][crate::model::BigQueryRoutineSpec::imported_libraries].
    pub fn set_imported_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.imported_libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryRoutineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryRoutineSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryRoutineSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __imported_libraries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryRoutineSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "importedLibraries" => Ok(__FieldTag::__imported_libraries),
                            "imported_libraries" => Ok(__FieldTag::__imported_libraries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryRoutineSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryRoutineSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__imported_libraries => {
                            if !fields.insert(__FieldTag::__imported_libraries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imported_libraries",
                                ));
                            }
                            result.imported_libraries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryRoutineSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.imported_libraries.is_empty() {
            state.serialize_entry("importedLibraries", &self.imported_libraries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Entry metadata relevant only to the user and private to them.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PersonalDetails {
    /// True if the entry is starred by the user; false otherwise.
    pub starred: bool,

    /// Set if the entry is starred; unset otherwise.
    pub star_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PersonalDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [starred][crate::model::PersonalDetails::starred].
    pub fn set_starred<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.starred = v.into();
        self
    }

    /// Sets the value of [star_time][crate::model::PersonalDetails::star_time].
    pub fn set_star_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.star_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [star_time][crate::model::PersonalDetails::star_time].
    pub fn set_or_clear_star_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.star_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PersonalDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PersonalDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PersonalDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __starred,
            __star_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PersonalDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "starred" => Ok(__FieldTag::__starred),
                            "starTime" => Ok(__FieldTag::__star_time),
                            "star_time" => Ok(__FieldTag::__star_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PersonalDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PersonalDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__starred => {
                            if !fields.insert(__FieldTag::__starred) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for starred",
                                ));
                            }
                            result.starred = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__star_time => {
                            if !fields.insert(__FieldTag::__star_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for star_time",
                                ));
                            }
                            result.star_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PersonalDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.starred) {
            state.serialize_entry("starred", &self.starred)?;
        }
        if self.star_time.is_some() {
            state.serialize_entry("starTime", &self.star_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Physical location of an entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSource {
    /// Service that physically stores the data.
    pub service: crate::model::data_source::Service,

    /// Full name of a resource as defined by the service. For example:
    ///
    /// `//bigquery.googleapis.com/projects/{PROJECT_ID}/locations/{LOCATION}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
    pub resource: std::string::String,

    /// Output only. Data Catalog entry name, if applicable.
    pub source_entry: std::string::String,

    pub properties: std::option::Option<crate::model::data_source::Properties>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::DataSource::service].
    pub fn set_service<T: std::convert::Into<crate::model::data_source::Service>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::DataSource::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [source_entry][crate::model::DataSource::source_entry].
    pub fn set_source_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entry = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::DataSource::properties].
    ///
    /// Note that all the setters affecting `properties` are mutually
    /// exclusive.
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::data_source::Properties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::DataSource::properties]
    /// if it holds a `StorageProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::data_source::Properties::StorageProperties(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::DataSource::properties]
    /// to hold a `StorageProperties`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_storage_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = std::option::Option::Some(
            crate::model::data_source::Properties::StorageProperties(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __resource,
            __source_entry,
            __storage_properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "resource" => Ok(__FieldTag::__resource),
                            "sourceEntry" => Ok(__FieldTag::__source_entry),
                            "source_entry" => Ok(__FieldTag::__source_entry),
                            "storageProperties" => Ok(__FieldTag::__storage_properties),
                            "storage_properties" => Ok(__FieldTag::__storage_properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map.next_value::<std::option::Option<crate::model::data_source::Service>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_entry => {
                            if !fields.insert(__FieldTag::__source_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_entry",
                                ));
                            }
                            result.source_entry = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_properties => {
                            if !fields.insert(__FieldTag::__storage_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_properties",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.datacatalog.v1.DataSource.storage_properties, latest field was storageProperties",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::data_source::Properties::StorageProperties(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.service) {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.source_entry.is_empty() {
            state.serialize_entry("sourceEntry", &self.source_entry)?;
        }
        if let Some(value) = self.storage_properties() {
            state.serialize_entry("storageProperties", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataSource].
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;

    /// Name of a service that stores the data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Service {
        /// Default unknown service.
        Unspecified,
        /// Google Cloud Storage service.
        CloudStorage,
        /// BigQuery service.
        Bigquery,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Service::value] or
        /// [Service::name].
        UnknownValue(service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Service {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudStorage => std::option::Option::Some(1),
                Self::Bigquery => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_UNSPECIFIED"),
                Self::CloudStorage => std::option::Option::Some("CLOUD_STORAGE"),
                Self::Bigquery => std::option::Option::Some("BIGQUERY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Service {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Service {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Service {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudStorage,
                2 => Self::Bigquery,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Service {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_STORAGE" => Self::CloudStorage,
                "BIGQUERY" => Self::Bigquery,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Service {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudStorage => serializer.serialize_i32(1),
                Self::Bigquery => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Service {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Service>::new(
                ".google.cloud.datacatalog.v1.DataSource.Service",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Properties {
        /// Detailed properties of the underlying storage.
        StorageProperties(std::boxed::Box<crate::model::StorageProperties>),
    }
}

/// Details the properties of the underlying storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageProperties {
    /// Patterns to identify a set of files for this fileset.
    ///
    /// Examples of a valid `file_pattern`:
    ///
    /// * `gs://bucket_name/dir/*`: matches all files in the `bucket_name/dir`
    ///   directory
    /// * `gs://bucket_name/dir/**`: matches all files in the `bucket_name/dir`
    ///   and all subdirectories recursively
    /// * `gs://bucket_name/file*`: matches files prefixed by `file` in
    ///   `bucket_name`
    /// * `gs://bucket_name/??.txt`: matches files with two characters followed by
    ///   `.txt` in `bucket_name`
    /// * `gs://bucket_name/[aeiou].txt`: matches files that contain a single
    ///   vowel character followed by `.txt` in
    ///   `bucket_name`
    /// * `gs://bucket_name/[a-m].txt`: matches files that contain `a`, `b`, ...
    ///   or `m` followed by `.txt` in `bucket_name`
    /// * `gs://bucket_name/a/*/b`: matches all files in `bucket_name` that match
    ///   the `a/*/b` pattern, such as `a/c/b`, `a/d/b`
    /// * `gs://another_bucket/a.txt`: matches `gs://another_bucket/a.txt`
    pub file_pattern: std::vec::Vec<std::string::String>,

    /// File type in MIME format, for example, `text/plain`.
    pub file_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_pattern][crate::model::StorageProperties::file_pattern].
    pub fn set_file_pattern<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_pattern = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_type][crate::model::StorageProperties::file_type].
    pub fn set_file_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }
}

impl wkt::message::Message for StorageProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StorageProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_pattern,
            __file_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filePattern" => Ok(__FieldTag::__file_pattern),
                            "file_pattern" => Ok(__FieldTag::__file_pattern),
                            "fileType" => Ok(__FieldTag::__file_type),
                            "file_type" => Ok(__FieldTag::__file_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_pattern => {
                            if !fields.insert(__FieldTag::__file_pattern) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_pattern",
                                ));
                            }
                            result.file_pattern = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_type => {
                            if !fields.insert(__FieldTag::__file_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_type",
                                ));
                            }
                            result.file_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_pattern.is_empty() {
            state.serialize_entry("filePattern", &self.file_pattern)?;
        }
        if !self.file_type.is_empty() {
            state.serialize_entry("fileType", &self.file_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCatalogRequest {
    /// Required. The scope of this search request.
    ///
    /// The `scope` is invalid if `include_org_ids`, `include_project_ids` are
    /// empty AND `include_gcp_public_datasets` is set to `false`. In this case,
    /// the request returns an error.
    pub scope: std::option::Option<crate::model::search_catalog_request::Scope>,

    /// Optional. The query string with a minimum of 3 characters and specific
    /// syntax. For more information, see [Data Catalog search
    /// syntax](https://cloud.google.com/data-catalog/docs/how-to/search-reference).
    ///
    /// An empty query string returns all data assets (in the specified scope)
    /// that you have access to.
    ///
    /// A query string can be a simple `xyz` or qualified by predicates:
    ///
    /// * `name:x`
    /// * `column:y`
    /// * `description:z`
    pub query: std::string::String,

    /// Upper bound on the number of results you can get in a single response.
    ///
    /// Can't be negative or 0, defaults to 10 in this case.
    /// The maximum number is 1000. If exceeded, throws an "invalid argument"
    /// exception.
    pub page_size: i32,

    /// Optional. Pagination token that, if specified, returns the next page of
    /// search results. If empty, returns the first page.
    ///
    /// This token is returned in the
    /// [SearchCatalogResponse.next_page_token][google.cloud.datacatalog.v1.SearchCatalogResponse.next_page_token]
    /// field of the response to a previous
    /// [SearchCatalogRequest][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]
    /// call.
    ///
    /// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
    /// [google.cloud.datacatalog.v1.SearchCatalogResponse.next_page_token]: crate::model::SearchCatalogResponse::next_page_token
    pub page_token: std::string::String,

    /// Specifies the order of results.
    ///
    /// Currently supported case-sensitive values are:
    ///
    /// * `relevance` that can only be descending
    /// * `last_modified_timestamp [asc|desc]` with descending (`desc`) as default
    /// * `default` that can only be descending
    ///
    /// Search queries don't guarantee full recall. Results that match your query
    /// might not be returned, even in subsequent result pages. Additionally,
    /// returned (and not returned) results can vary if you repeat search queries.
    /// If you are experiencing recall issues and you don't have to fetch the
    /// results in any specific order, consider setting this parameter to
    /// `default`.
    ///
    /// If this parameter is omitted, it defaults to the descending `relevance`.
    pub order_by: std::string::String,

    /// Optional. If set, use searchAll permission granted on organizations from
    /// `include_org_ids` and projects from `include_project_ids` instead of the
    /// fine grained per resource permissions when filtering the search results.
    /// The only allowed `order_by` criteria for admin_search mode is `default`.
    /// Using this flags guarantees a full recall of the search results.
    pub admin_search: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCatalogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::SearchCatalogRequest::scope].
    pub fn set_scope<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_catalog_request::Scope>,
    {
        self.scope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scope][crate::model::SearchCatalogRequest::scope].
    pub fn set_or_clear_scope<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_catalog_request::Scope>,
    {
        self.scope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query][crate::model::SearchCatalogRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchCatalogRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchCatalogRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchCatalogRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [admin_search][crate::model::SearchCatalogRequest::admin_search].
    pub fn set_admin_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.admin_search = v.into();
        self
    }
}

impl wkt::message::Message for SearchCatalogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchCatalogRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            __query,
            __page_size,
            __page_token,
            __order_by,
            __admin_search,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchCatalogRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            "query" => Ok(__FieldTag::__query),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "adminSearch" => Ok(__FieldTag::__admin_search),
                            "admin_search" => Ok(__FieldTag::__admin_search),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchCatalogRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchCatalogRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope =
                                map.next_value::<std::option::Option<
                                    crate::model::search_catalog_request::Scope,
                                >>()?;
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admin_search => {
                            if !fields.insert(__FieldTag::__admin_search) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_search",
                                ));
                            }
                            result.admin_search = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchCatalogRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.scope.is_some() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.admin_search) {
            state.serialize_entry("adminSearch", &self.admin_search)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchCatalogRequest].
pub mod search_catalog_request {
    #[allow(unused_imports)]
    use super::*;

    /// The criteria that select the subspace used for query matching.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Scope {
        /// The list of organization IDs to search within.
        ///
        /// To find your organization ID, follow the steps from
        /// [Creating and managing organizations]
        /// (/resource-manager/docs/creating-managing-organization).
        pub include_org_ids: std::vec::Vec<std::string::String>,

        /// The list of project IDs to search within.
        ///
        /// For more information on the distinction between project names, IDs, and
        /// numbers, see [Projects](/docs/overview/#projects).
        pub include_project_ids: std::vec::Vec<std::string::String>,

        /// If `true`, include Google Cloud public datasets in
        /// search results. By default, they are excluded.
        ///
        /// See [Google Cloud Public Datasets](/public-datasets) for more
        /// information.
        pub include_gcp_public_datasets: bool,

        /// Optional. The list of locations to search within. If empty, all locations
        /// are searched.
        ///
        /// Returns an error if any location in the list isn't one of the [Supported
        /// regions](https://cloud.google.com/data-catalog/docs/concepts/regions#supported_regions).
        ///
        /// If a location is unreachable, its name is returned in the
        /// `SearchCatalogResponse.unreachable` field. To get additional information
        /// on the error, repeat the search request and set the location name as the
        /// value of this parameter.
        pub restricted_locations: std::vec::Vec<std::string::String>,

        /// Optional. If `true`, search only among starred entries.
        ///
        /// By default, all results are returned, starred or not.
        pub starred_only: bool,

        /// Optional. This field is deprecated. The search mechanism for public and
        /// private tag templates is the same.
        #[deprecated]
        pub include_public_tag_templates: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Scope {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [include_org_ids][crate::model::search_catalog_request::Scope::include_org_ids].
        pub fn set_include_org_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_org_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [include_project_ids][crate::model::search_catalog_request::Scope::include_project_ids].
        pub fn set_include_project_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_project_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [include_gcp_public_datasets][crate::model::search_catalog_request::Scope::include_gcp_public_datasets].
        pub fn set_include_gcp_public_datasets<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.include_gcp_public_datasets = v.into();
            self
        }

        /// Sets the value of [restricted_locations][crate::model::search_catalog_request::Scope::restricted_locations].
        pub fn set_restricted_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.restricted_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [starred_only][crate::model::search_catalog_request::Scope::starred_only].
        pub fn set_starred_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.starred_only = v.into();
            self
        }

        /// Sets the value of [include_public_tag_templates][crate::model::search_catalog_request::Scope::include_public_tag_templates].
        #[deprecated]
        pub fn set_include_public_tag_templates<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.include_public_tag_templates = v.into();
            self
        }
    }

    impl wkt::message::Message for Scope {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogRequest.Scope"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __include_org_ids,
                __include_project_ids,
                __include_gcp_public_datasets,
                __restricted_locations,
                __starred_only,
                __include_public_tag_templates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Scope")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "includeOrgIds" => Ok(__FieldTag::__include_org_ids),
                                "include_org_ids" => Ok(__FieldTag::__include_org_ids),
                                "includeProjectIds" => Ok(__FieldTag::__include_project_ids),
                                "include_project_ids" => Ok(__FieldTag::__include_project_ids),
                                "includeGcpPublicDatasets" => {
                                    Ok(__FieldTag::__include_gcp_public_datasets)
                                }
                                "include_gcp_public_datasets" => {
                                    Ok(__FieldTag::__include_gcp_public_datasets)
                                }
                                "restrictedLocations" => Ok(__FieldTag::__restricted_locations),
                                "restricted_locations" => Ok(__FieldTag::__restricted_locations),
                                "starredOnly" => Ok(__FieldTag::__starred_only),
                                "starred_only" => Ok(__FieldTag::__starred_only),
                                "includePublicTagTemplates" => {
                                    Ok(__FieldTag::__include_public_tag_templates)
                                }
                                "include_public_tag_templates" => {
                                    Ok(__FieldTag::__include_public_tag_templates)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Scope;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Scope")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__include_org_ids => {
                                if !fields.insert(__FieldTag::__include_org_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_org_ids",
                                    ));
                                }
                                result.include_org_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__include_project_ids => {
                                if !fields.insert(__FieldTag::__include_project_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_project_ids",
                                    ));
                                }
                                result.include_project_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__include_gcp_public_datasets => {
                                if !fields.insert(__FieldTag::__include_gcp_public_datasets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_gcp_public_datasets",
                                    ));
                                }
                                result.include_gcp_public_datasets = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__restricted_locations => {
                                if !fields.insert(__FieldTag::__restricted_locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for restricted_locations",
                                    ));
                                }
                                result.restricted_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__starred_only => {
                                if !fields.insert(__FieldTag::__starred_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for starred_only",
                                    ));
                                }
                                result.starred_only = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__include_public_tag_templates => {
                                if !fields.insert(__FieldTag::__include_public_tag_templates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_public_tag_templates",
                                    ));
                                }
                                result.include_public_tag_templates = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.include_org_ids.is_empty() {
                state.serialize_entry("includeOrgIds", &self.include_org_ids)?;
            }
            if !self.include_project_ids.is_empty() {
                state.serialize_entry("includeProjectIds", &self.include_project_ids)?;
            }
            if !wkt::internal::is_default(&self.include_gcp_public_datasets) {
                state.serialize_entry(
                    "includeGcpPublicDatasets",
                    &self.include_gcp_public_datasets,
                )?;
            }
            if !self.restricted_locations.is_empty() {
                state.serialize_entry("restrictedLocations", &self.restricted_locations)?;
            }
            if !wkt::internal::is_default(&self.starred_only) {
                state.serialize_entry("starredOnly", &self.starred_only)?;
            }
            if !wkt::internal::is_default(&self.include_public_tag_templates) {
                state.serialize_entry(
                    "includePublicTagTemplates",
                    &self.include_public_tag_templates,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Response message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]: crate::client::DataCatalog::search_catalog
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCatalogResponse {
    /// Search results.
    pub results: std::vec::Vec<crate::model::SearchCatalogResult>,

    /// The approximate total number of entries matched by the query.
    pub total_size: i32,

    /// Pagination token that can be used in subsequent calls to retrieve the next
    /// page of results.
    pub next_page_token: std::string::String,

    /// Unreachable locations. Search results don't include data from those
    /// locations.
    ///
    /// To get additional information on an error, repeat the search request and
    /// restrict it to specific locations by setting the
    /// `SearchCatalogRequest.scope.restricted_locations` parameter.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCatalogResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchCatalogResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchCatalogResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_size][crate::model::SearchCatalogResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchCatalogResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::SearchCatalogResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchCatalogResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchCatalogResponse {
    type PageItem = crate::model::SearchCatalogResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchCatalogResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __total_size,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchCatalogResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchCatalogResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchCatalogResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SearchCatalogResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchCatalogResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.CreateEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateEntryGroup]: crate::client::DataCatalog::create_entry_group
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntryGroupRequest {
    /// Required. The names of the project and location that the new entry group
    /// belongs to.
    ///
    /// Note: The entry group itself and its child resources might not be
    /// stored in the location specified in its name.
    pub parent: std::string::String,

    /// Required. The ID of the entry group to create.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and must start with a letter or underscore.
    /// The maximum size is 64 bytes when encoded in UTF-8.
    pub entry_group_id: std::string::String,

    /// The entry group to create. Defaults to empty.
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_group_id][crate::model::CreateEntryGroupRequest::entry_group_id].
    pub fn set_entry_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_group_id = v.into();
        self
    }

    /// Sets the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_or_clear_entry_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entry_group_id,
            __entry_group,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entryGroupId" => Ok(__FieldTag::__entry_group_id),
                            "entry_group_id" => Ok(__FieldTag::__entry_group_id),
                            "entryGroup" => Ok(__FieldTag::__entry_group),
                            "entry_group" => Ok(__FieldTag::__entry_group),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_group_id => {
                            if !fields.insert(__FieldTag::__entry_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_group_id",
                                ));
                            }
                            result.entry_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_group => {
                            if !fields.insert(__FieldTag::__entry_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_group",
                                ));
                            }
                            result.entry_group =
                                map.next_value::<std::option::Option<crate::model::EntryGroup>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entry_group_id.is_empty() {
            state.serialize_entry("entryGroupId", &self.entry_group_id)?;
        }
        if self.entry_group.is_some() {
            state.serialize_entry("entryGroup", &self.entry_group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.UpdateEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateEntryGroup]: crate::client::DataCatalog::update_entry_group
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntryGroupRequest {
    /// Required. Updates for the entry group. The `name` field must be set.
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    /// Names of fields whose values to overwrite on an entry group.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_or_clear_entry_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryGroup>,
    {
        self.entry_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_group,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryGroup" => Ok(__FieldTag::__entry_group),
                            "entry_group" => Ok(__FieldTag::__entry_group),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_group => {
                            if !fields.insert(__FieldTag::__entry_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_group",
                                ));
                            }
                            result.entry_group =
                                map.next_value::<std::option::Option<crate::model::EntryGroup>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entry_group.is_some() {
            state.serialize_entry("entryGroup", &self.entry_group)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [GetEntryGroup][google.cloud.datacatalog.v1.DataCatalog.GetEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetEntryGroup]: crate::client::DataCatalog::get_entry_group
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntryGroupRequest {
    /// Required. The name of the entry group to get.
    pub name: std::string::String,

    /// The fields to return. If empty or omitted, all fields are returned.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetEntryGroupRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetEntryGroupRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeleteEntryGroup][google.cloud.datacatalog.v1.DataCatalog.DeleteEntryGroup].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteEntryGroup]: crate::client::DataCatalog::delete_entry_group
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntryGroupRequest {
    /// Required. The name of the entry group to delete.
    pub name: std::string::String,

    /// Optional. If true, deletes all entries in the entry group.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntryGroupRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteEntryGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntryGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntryGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntryGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntryGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntryGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups]: crate::client::DataCatalog::list_entry_groups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryGroupsRequest {
    /// Required. The name of the location that contains the entry groups to list.
    ///
    /// Can be provided as a URL.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// Default is 10. Maximum limit is 1000.
    /// Throws an invalid argument if `page_size` is greater than 1000.
    pub page_size: i32,

    /// Optional. Pagination token that specifies the next page to return.
    /// If empty, returns the first page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntryGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntryGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntryGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntryGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntryGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntryGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntryGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntryGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntryGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups]: crate::client::DataCatalog::list_entry_groups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntryGroupsResponse {
    /// Entry group details.
    pub entry_groups: std::vec::Vec<crate::model::EntryGroup>,

    /// Pagination token to specify in the next call to retrieve the next page of
    /// results. Empty if there are no more items.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_groups][crate::model::ListEntryGroupsResponse::entry_groups].
    pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntryGroup>,
    {
        use std::iter::Iterator;
        self.entry_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntryGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntryGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntryGroupsResponse {
    type PageItem = crate::model::EntryGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entry_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntryGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_groups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntryGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryGroups" => Ok(__FieldTag::__entry_groups),
                            "entry_groups" => Ok(__FieldTag::__entry_groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntryGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntryGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_groups => {
                            if !fields.insert(__FieldTag::__entry_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_groups",
                                ));
                            }
                            result.entry_groups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntryGroup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntryGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entry_groups.is_empty() {
            state.serialize_entry("entryGroups", &self.entry_groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateEntry][google.cloud.datacatalog.v1.DataCatalog.CreateEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateEntry]: crate::client::DataCatalog::create_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntryRequest {
    /// Required. The name of the entry group this entry belongs to.
    ///
    /// Note: The entry itself and its child resources might not be stored in
    /// the location specified in its name.
    pub parent: std::string::String,

    /// Required. The ID of the entry to create.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// and underscores (_).
    /// The maximum size is 64 bytes when encoded in UTF-8.
    pub entry_id: std::string::String,

    /// Required. The entry to create.
    pub entry: std::option::Option<crate::model::Entry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_id][crate::model::CreateEntryRequest::entry_id].
    pub fn set_entry_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_id = v.into();
        self
    }

    /// Sets the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_or_clear_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entry_id,
            __entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entryId" => Ok(__FieldTag::__entry_id),
                            "entry_id" => Ok(__FieldTag::__entry_id),
                            "entry" => Ok(__FieldTag::__entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_id => {
                            if !fields.insert(__FieldTag::__entry_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_id",
                                ));
                            }
                            result.entry_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry => {
                            if !fields.insert(__FieldTag::__entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry",
                                ));
                            }
                            result.entry =
                                map.next_value::<std::option::Option<crate::model::Entry>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entry_id.is_empty() {
            state.serialize_entry("entryId", &self.entry_id)?;
        }
        if self.entry.is_some() {
            state.serialize_entry("entry", &self.entry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateEntry][google.cloud.datacatalog.v1.DataCatalog.UpdateEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateEntry]: crate::client::DataCatalog::update_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntryRequest {
    /// Required. Updates for the entry. The `name` field must be set.
    pub entry: std::option::Option<crate::model::Entry>,

    /// Names of fields whose values to overwrite on an entry.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    ///
    /// You can modify only the fields listed below.
    ///
    /// For entries with type `DATA_STREAM`:
    ///
    /// * `schema`
    ///
    /// For entries with type `FILESET`:
    ///
    /// * `schema`
    /// * `display_name`
    /// * `description`
    /// * `gcs_fileset_spec`
    /// * `gcs_fileset_spec.file_patterns`
    ///
    /// For entries with `user_specified_type`:
    ///
    /// * `schema`
    /// * `display_name`
    /// * `description`
    /// * `user_specified_type`
    /// * `user_specified_system`
    /// * `linked_resource`
    /// * `source_system_timestamps`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_or_clear_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entry>,
    {
        self.entry = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entry" => Ok(__FieldTag::__entry),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry => {
                            if !fields.insert(__FieldTag::__entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry",
                                ));
                            }
                            result.entry =
                                map.next_value::<std::option::Option<crate::model::Entry>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entry.is_some() {
            state.serialize_entry("entry", &self.entry)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeleteEntry][google.cloud.datacatalog.v1.DataCatalog.DeleteEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteEntry]: crate::client::DataCatalog::delete_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntryRequest {
    /// Required. The name of the entry to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [GetEntry][google.cloud.datacatalog.v1.DataCatalog.GetEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetEntry]: crate::client::DataCatalog::get_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntryRequest {
    /// Required. The name of the entry to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [LookupEntry][google.cloud.datacatalog.v1.DataCatalog.LookupEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.LookupEntry]: crate::client::DataCatalog::lookup_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupEntryRequest {
    /// Project where the lookup should be performed. Required to lookup
    /// entry that is not a part of `DPMS` or `DATAPLEX` `integrated_system`
    /// using its `fully_qualified_name`. Ignored in other cases.
    pub project: std::string::String,

    /// Location where the lookup should be performed. Required to lookup
    /// entry that is not a part of `DPMS` or `DATAPLEX` `integrated_system`
    /// using its `fully_qualified_name`. Ignored in other cases.
    pub location: std::string::String,

    /// Required. A full name, SQL name, or a fully qualified name of a
    /// Google Cloud Platform resource.
    pub target_name: std::option::Option<crate::model::lookup_entry_request::TargetName>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::LookupEntryRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::LookupEntryRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name].
    ///
    /// Note that all the setters affecting `target_name` are mutually
    /// exclusive.
    pub fn set_target_name<
        T: std::convert::Into<std::option::Option<crate::model::lookup_entry_request::TargetName>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_name = v.into();
        self
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `LinkedResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn linked_resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::LinkedResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `LinkedResource`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::LinkedResource(v.into()),
        );
        self
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `SqlResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::SqlResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `SqlResource`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_sql_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::SqlResource(v.into()),
        );
        self
    }

    /// The value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// if it holds a `FullyQualifiedName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fully_qualified_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_name.as_ref().and_then(|v| match v {
            crate::model::lookup_entry_request::TargetName::FullyQualifiedName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_name][crate::model::LookupEntryRequest::target_name]
    /// to hold a `FullyQualifiedName`.
    ///
    /// Note that all the setters affecting `target_name` are
    /// mutually exclusive.
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_name = std::option::Option::Some(
            crate::model::lookup_entry_request::TargetName::FullyQualifiedName(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LookupEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.LookupEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __linked_resource,
            __sql_resource,
            __fully_qualified_name,
            __project,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "linkedResource" => Ok(__FieldTag::__linked_resource),
                            "linked_resource" => Ok(__FieldTag::__linked_resource),
                            "sqlResource" => Ok(__FieldTag::__sql_resource),
                            "sql_resource" => Ok(__FieldTag::__sql_resource),
                            "fullyQualifiedName" => Ok(__FieldTag::__fully_qualified_name),
                            "fully_qualified_name" => Ok(__FieldTag::__fully_qualified_name),
                            "project" => Ok(__FieldTag::__project),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__linked_resource => {
                            if !fields.insert(__FieldTag::__linked_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_resource",
                                ));
                            }
                            if result.target_name.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_name`, a oneof with full ID .google.cloud.datacatalog.v1.LookupEntryRequest.linked_resource, latest field was linkedResource",
                                ));
                            }
                            result.target_name = std::option::Option::Some(
                                crate::model::lookup_entry_request::TargetName::LinkedResource(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sql_resource => {
                            if !fields.insert(__FieldTag::__sql_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_resource",
                                ));
                            }
                            if result.target_name.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_name`, a oneof with full ID .google.cloud.datacatalog.v1.LookupEntryRequest.sql_resource, latest field was sqlResource",
                                ));
                            }
                            result.target_name = std::option::Option::Some(
                                crate::model::lookup_entry_request::TargetName::SqlResource(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__fully_qualified_name => {
                            if !fields.insert(__FieldTag::__fully_qualified_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_qualified_name",
                                ));
                            }
                            if result.target_name.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_name`, a oneof with full ID .google.cloud.datacatalog.v1.LookupEntryRequest.fully_qualified_name, latest field was fullyQualifiedName",
                                ));
                            }
                            result.target_name = std::option::Option::Some(
                                crate::model::lookup_entry_request::TargetName::FullyQualifiedName(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.linked_resource() {
            state.serialize_entry("linkedResource", value)?;
        }
        if let Some(value) = self.sql_resource() {
            state.serialize_entry("sqlResource", value)?;
        }
        if let Some(value) = self.fully_qualified_name() {
            state.serialize_entry("fullyQualifiedName", value)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LookupEntryRequest].
pub mod lookup_entry_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. A full name, SQL name, or a fully qualified name of a
    /// Google Cloud Platform resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetName {
        /// The full name of the Google Cloud Platform resource the Data Catalog
        /// entry represents. For more information, see [Full Resource Name]
        /// (<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
        ///
        /// Full names are case-sensitive. For example:
        ///
        /// * `//bigquery.googleapis.com/projects/{PROJECT_ID}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
        /// * `//pubsub.googleapis.com/projects/{PROJECT_ID}/topics/{TOPIC_ID}`
        LinkedResource(std::string::String),
        /// The SQL name of the entry. SQL names are case-sensitive.
        ///
        /// Examples:
        ///
        /// * `pubsub.topic.{PROJECT_ID}.{TOPIC_ID}`
        /// * `pubsub.topic.{PROJECT_ID}.`\``{TOPIC.ID.SEPARATED.WITH.DOTS}`\`
        /// * `bigquery.table.{PROJECT_ID}.{DATASET_ID}.{TABLE_ID}`
        /// * `bigquery.dataset.{PROJECT_ID}.{DATASET_ID}`
        /// * `datacatalog.entry.{PROJECT_ID}.{LOCATION_ID}.{ENTRY_GROUP_ID}.{ENTRY_ID}`
        ///
        /// Identifiers (`*_ID`) should comply with the
        /// [Lexical structure in GoogleSQL]
        /// (<https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical>).
        SqlResource(std::string::String),
        /// [Fully Qualified Name
        /// (FQN)](https://cloud.google.com//data-catalog/docs/fully-qualified-names)
        /// of the resource.
        ///
        /// FQNs take two forms:
        ///
        /// * For non-regionalized resources:
        ///
        ///   `{SYSTEM}:{PROJECT}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
        ///
        /// * For regionalized resources:
        ///
        ///   `{SYSTEM}:{PROJECT}.{LOCATION_ID}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
        ///
        ///
        /// Example for a DPMS table:
        ///
        /// `dataproc_metastore:{PROJECT_ID}.{LOCATION_ID}.{INSTANCE_ID}.{DATABASE_ID}.{TABLE_ID}`
        FullyQualifiedName(std::string::String),
    }
}

/// Entry metadata.
/// A Data Catalog entry represents another resource in Google
/// Cloud Platform (such as a BigQuery dataset or a Pub/Sub topic) or
/// outside of it. You can use the `linked_resource` field
/// in the entry resource to refer to the original resource ID of the source
/// system.
///
/// An entry resource contains resource details, for example, its schema.
/// Additionally, you can attach flexible metadata to an entry in the form of a
/// [Tag][google.cloud.datacatalog.v1.Tag].
///
/// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Entry {
    /// Output only. Identifier. The resource name of an entry in URL format.
    ///
    /// Note: The entry itself and its child resources might not be
    /// stored in the location specified in its name.
    pub name: std::string::String,

    /// The resource this metadata entry refers to.
    ///
    /// For Google Cloud Platform resources, `linked_resource` is the
    /// [Full Resource Name]
    /// (<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
    /// For example, the `linked_resource` for a table resource from BigQuery is:
    ///
    /// `//bigquery.googleapis.com/projects/{PROJECT_ID}/datasets/{DATASET_ID}/tables/{TABLE_ID}`
    ///
    /// Output only when the entry is one of the types in the `EntryType` enum.
    ///
    /// For entries with a `user_specified_type`, this field is optional and
    /// defaults to an empty string.
    ///
    /// The resource string must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), periods (.), colons (:), slashes (/), dashes (-),
    /// and hashes (#).
    /// The maximum size is 200 bytes when encoded in UTF-8.
    pub linked_resource: std::string::String,

    /// [Fully Qualified Name
    /// (FQN)](https://cloud.google.com//data-catalog/docs/fully-qualified-names)
    /// of the resource. Set automatically for entries representing resources from
    /// synced systems. Settable only during creation, and read-only later. Can
    /// be used for search and lookup of the entries.
    pub fully_qualified_name: std::string::String,

    /// Display name of an entry.
    ///
    /// The maximum size is 500 bytes when encoded in UTF-8.
    /// Default value is an empty string.
    pub display_name: std::string::String,

    /// Entry description that can consist of several sentences or paragraphs
    /// that describe entry contents.
    ///
    /// The description must not contain Unicode non-characters as well as C0
    /// and C1 control codes except tabs (HT), new lines (LF), carriage returns
    /// (CR), and page breaks (FF).
    /// The maximum size is 2000 bytes when encoded in UTF-8.
    /// Default value is an empty string.
    pub description: std::string::String,

    /// Business Context of the entry. Not supported for BigQuery datasets
    pub business_context: std::option::Option<crate::model::BusinessContext>,

    /// Schema of the entry. An entry might not have any schema attached to it.
    pub schema: std::option::Option<crate::model::Schema>,

    /// Timestamps from the underlying resource, not from the Data Catalog
    /// entry.
    ///
    /// Output only when the entry has a system listed in the `IntegratedSystem`
    /// enum. For entries with `user_specified_system`, this field is optional
    /// and defaults to an empty timestamp.
    pub source_system_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Resource usage statistics.
    pub usage_signal: std::option::Option<crate::model::UsageSignal>,

    /// Cloud labels attached to the entry.
    ///
    /// In Data Catalog, you can create and modify labels attached only to custom
    /// entries. Synced entries have unmodifiable labels that come from the source
    /// system.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Physical location of the entry.
    pub data_source: std::option::Option<crate::model::DataSource>,

    /// Output only. Additional information related to the entry. Private to the
    /// current user.
    pub personal_details: std::option::Option<crate::model::PersonalDetails>,

    /// Required. Entry type.
    pub entry_type: std::option::Option<crate::model::entry::EntryType>,

    /// The source system of the entry.
    pub system: std::option::Option<crate::model::entry::System>,

    /// System specification.
    /// Can be used as a complement for `spec`, when some metadata is relevant for
    /// all entries existing within given system
    pub system_spec: std::option::Option<crate::model::entry::SystemSpec>,

    /// Type specification.
    pub type_spec: std::option::Option<crate::model::entry::TypeSpec>,

    /// Type- and system-specific information. Specifications for types contain
    /// fields common to all entries of a given type, and sub-specifications with
    /// fields specific to a given source system.
    ///
    /// When extending the API with new types and systems, use this field instead
    /// of the legacy `type_spec`.
    pub spec: std::option::Option<crate::model::entry::Spec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [linked_resource][crate::model::Entry::linked_resource].
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::Entry::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Entry::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Entry::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [business_context][crate::model::Entry::business_context].
    pub fn set_business_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BusinessContext>,
    {
        self.business_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [business_context][crate::model::Entry::business_context].
    pub fn set_or_clear_business_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BusinessContext>,
    {
        self.business_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::Entry::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::Entry::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_system_timestamps][crate::model::Entry::source_system_timestamps].
    pub fn set_source_system_timestamps<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.source_system_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_system_timestamps][crate::model::Entry::source_system_timestamps].
    pub fn set_or_clear_source_system_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.source_system_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [usage_signal][crate::model::Entry::usage_signal].
    pub fn set_usage_signal<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UsageSignal>,
    {
        self.usage_signal = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [usage_signal][crate::model::Entry::usage_signal].
    pub fn set_or_clear_usage_signal<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UsageSignal>,
    {
        self.usage_signal = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Entry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [data_source][crate::model::Entry::data_source].
    pub fn set_data_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSource>,
    {
        self.data_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source][crate::model::Entry::data_source].
    pub fn set_or_clear_data_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSource>,
    {
        self.data_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [personal_details][crate::model::Entry::personal_details].
    pub fn set_personal_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PersonalDetails>,
    {
        self.personal_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [personal_details][crate::model::Entry::personal_details].
    pub fn set_or_clear_personal_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PersonalDetails>,
    {
        self.personal_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type].
    ///
    /// Note that all the setters affecting `entry_type` are mutually
    /// exclusive.
    pub fn set_entry_type<
        T: std::convert::Into<std::option::Option<crate::model::entry::EntryType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry_type = v.into();
        self
    }

    /// The value of [entry_type][crate::model::Entry::entry_type]
    /// if it holds a `Type`, `None` if the field is not set or
    /// holds a different branch.
    pub fn r#type(&self) -> std::option::Option<&crate::model::EntryType> {
        #[allow(unreachable_patterns)]
        self.entry_type.as_ref().and_then(|v| match v {
            crate::model::entry::EntryType::Type(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type]
    /// to hold a `Type`.
    ///
    /// Note that all the setters affecting `entry_type` are
    /// mutually exclusive.
    pub fn set_type<T: std::convert::Into<crate::model::EntryType>>(mut self, v: T) -> Self {
        self.entry_type = std::option::Option::Some(crate::model::entry::EntryType::Type(v.into()));
        self
    }

    /// The value of [entry_type][crate::model::Entry::entry_type]
    /// if it holds a `UserSpecifiedType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_specified_type(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.entry_type.as_ref().and_then(|v| match v {
            crate::model::entry::EntryType::UserSpecifiedType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type]
    /// to hold a `UserSpecifiedType`.
    ///
    /// Note that all the setters affecting `entry_type` are
    /// mutually exclusive.
    pub fn set_user_specified_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_type =
            std::option::Option::Some(crate::model::entry::EntryType::UserSpecifiedType(v.into()));
        self
    }

    /// Sets the value of [system][crate::model::Entry::system].
    ///
    /// Note that all the setters affecting `system` are mutually
    /// exclusive.
    pub fn set_system<T: std::convert::Into<std::option::Option<crate::model::entry::System>>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = v.into();
        self
    }

    /// The value of [system][crate::model::Entry::system]
    /// if it holds a `IntegratedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integrated_system(&self) -> std::option::Option<&crate::model::IntegratedSystem> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::entry::System::IntegratedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::Entry::system]
    /// to hold a `IntegratedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_integrated_system<T: std::convert::Into<crate::model::IntegratedSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.system =
            std::option::Option::Some(crate::model::entry::System::IntegratedSystem(v.into()));
        self
    }

    /// The value of [system][crate::model::Entry::system]
    /// if it holds a `UserSpecifiedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_specified_system(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::entry::System::UserSpecifiedSystem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::Entry::system]
    /// to hold a `UserSpecifiedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_user_specified_system<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.system =
            std::option::Option::Some(crate::model::entry::System::UserSpecifiedSystem(v.into()));
        self
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::entry::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `SqlDatabaseSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_database_system_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlDatabaseSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::SqlDatabaseSystemSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `SqlDatabaseSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_sql_database_system_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlDatabaseSystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::entry::SystemSpec::SqlDatabaseSystemSpec(v.into()),
        );
        self
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `LookerSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn looker_system_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LookerSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::LookerSystemSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `LookerSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_looker_system_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::LookerSystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec =
            std::option::Option::Some(crate::model::entry::SystemSpec::LookerSystemSpec(v.into()));
        self
    }

    /// The value of [system_spec][crate::model::Entry::system_spec]
    /// if it holds a `CloudBigtableSystemSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_bigtable_system_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudBigtableSystemSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::entry::SystemSpec::CloudBigtableSystemSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::Entry::system_spec]
    /// to hold a `CloudBigtableSystemSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_cloud_bigtable_system_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudBigtableSystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::entry::SystemSpec::CloudBigtableSystemSpec(v.into()),
        );
        self
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec].
    ///
    /// Note that all the setters affecting `type_spec` are mutually
    /// exclusive.
    pub fn set_type_spec<
        T: std::convert::Into<std::option::Option<crate::model::entry::TypeSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = v.into();
        self
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `GcsFilesetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_fileset_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsFilesetSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::GcsFilesetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `GcsFilesetSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_gcs_fileset_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsFilesetSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec =
            std::option::Option::Some(crate::model::entry::TypeSpec::GcsFilesetSpec(v.into()));
        self
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `BigqueryTableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_table_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::BigqueryTableSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `BigqueryTableSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_table_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec =
            std::option::Option::Some(crate::model::entry::TypeSpec::BigqueryTableSpec(v.into()));
        self
    }

    /// The value of [type_spec][crate::model::Entry::type_spec]
    /// if it holds a `BigqueryDateShardedSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_date_sharded_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDateShardedSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::entry::TypeSpec::BigqueryDateShardedSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::Entry::type_spec]
    /// to hold a `BigqueryDateShardedSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_date_sharded_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDateShardedSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::entry::TypeSpec::BigqueryDateShardedSpec(v.into()),
        );
        self
    }

    /// Sets the value of [spec][crate::model::Entry::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::entry::Spec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DatabaseTableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_table_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseTableSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DatabaseTableSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DatabaseTableSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_database_table_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseTableSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::entry::Spec::DatabaseTableSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DataSourceConnectionSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_source_connection_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataSourceConnectionSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DataSourceConnectionSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DataSourceConnectionSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_source_connection_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataSourceConnectionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::DataSourceConnectionSpec(
            v.into(),
        ));
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `RoutineSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn routine_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::RoutineSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::RoutineSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `RoutineSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_routine_spec<T: std::convert::Into<std::boxed::Box<crate::model::RoutineSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::RoutineSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `DatasetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dataset_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::DatasetSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::DatasetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `DatasetSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_dataset_spec<T: std::convert::Into<std::boxed::Box<crate::model::DatasetSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::DatasetSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `FilesetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fileset_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::FilesetSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::FilesetSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `FilesetSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_fileset_spec<T: std::convert::Into<std::boxed::Box<crate::model::FilesetSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::FilesetSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `ServiceSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ServiceSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::ServiceSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `ServiceSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_service_spec<T: std::convert::Into<std::boxed::Box<crate::model::ServiceSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::ServiceSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `ModelSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn model_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ModelSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::ModelSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `ModelSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_model_spec<T: std::convert::Into<std::boxed::Box<crate::model::ModelSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(crate::model::entry::Spec::ModelSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::Entry::spec]
    /// if it holds a `FeatureOnlineStoreSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn feature_online_store_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureOnlineStoreSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::entry::Spec::FeatureOnlineStoreSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::Entry::spec]
    /// to hold a `FeatureOnlineStoreSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_feature_online_store_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::FeatureOnlineStoreSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::entry::Spec::FeatureOnlineStoreSpec(v.into()));
        self
    }
}

impl wkt::message::Message for Entry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Entry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __linked_resource,
            __fully_qualified_name,
            __type,
            __user_specified_type,
            __integrated_system,
            __user_specified_system,
            __sql_database_system_spec,
            __looker_system_spec,
            __cloud_bigtable_system_spec,
            __gcs_fileset_spec,
            __bigquery_table_spec,
            __bigquery_date_sharded_spec,
            __database_table_spec,
            __data_source_connection_spec,
            __routine_spec,
            __dataset_spec,
            __fileset_spec,
            __service_spec,
            __model_spec,
            __feature_online_store_spec,
            __display_name,
            __description,
            __business_context,
            __schema,
            __source_system_timestamps,
            __usage_signal,
            __labels,
            __data_source,
            __personal_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "linkedResource" => Ok(__FieldTag::__linked_resource),
                            "linked_resource" => Ok(__FieldTag::__linked_resource),
                            "fullyQualifiedName" => Ok(__FieldTag::__fully_qualified_name),
                            "fully_qualified_name" => Ok(__FieldTag::__fully_qualified_name),
                            "type" => Ok(__FieldTag::__type),
                            "userSpecifiedType" => Ok(__FieldTag::__user_specified_type),
                            "user_specified_type" => Ok(__FieldTag::__user_specified_type),
                            "integratedSystem" => Ok(__FieldTag::__integrated_system),
                            "integrated_system" => Ok(__FieldTag::__integrated_system),
                            "userSpecifiedSystem" => Ok(__FieldTag::__user_specified_system),
                            "user_specified_system" => Ok(__FieldTag::__user_specified_system),
                            "sqlDatabaseSystemSpec" => Ok(__FieldTag::__sql_database_system_spec),
                            "sql_database_system_spec" => {
                                Ok(__FieldTag::__sql_database_system_spec)
                            }
                            "lookerSystemSpec" => Ok(__FieldTag::__looker_system_spec),
                            "looker_system_spec" => Ok(__FieldTag::__looker_system_spec),
                            "cloudBigtableSystemSpec" => {
                                Ok(__FieldTag::__cloud_bigtable_system_spec)
                            }
                            "cloud_bigtable_system_spec" => {
                                Ok(__FieldTag::__cloud_bigtable_system_spec)
                            }
                            "gcsFilesetSpec" => Ok(__FieldTag::__gcs_fileset_spec),
                            "gcs_fileset_spec" => Ok(__FieldTag::__gcs_fileset_spec),
                            "bigqueryTableSpec" => Ok(__FieldTag::__bigquery_table_spec),
                            "bigquery_table_spec" => Ok(__FieldTag::__bigquery_table_spec),
                            "bigqueryDateShardedSpec" => {
                                Ok(__FieldTag::__bigquery_date_sharded_spec)
                            }
                            "bigquery_date_sharded_spec" => {
                                Ok(__FieldTag::__bigquery_date_sharded_spec)
                            }
                            "databaseTableSpec" => Ok(__FieldTag::__database_table_spec),
                            "database_table_spec" => Ok(__FieldTag::__database_table_spec),
                            "dataSourceConnectionSpec" => {
                                Ok(__FieldTag::__data_source_connection_spec)
                            }
                            "data_source_connection_spec" => {
                                Ok(__FieldTag::__data_source_connection_spec)
                            }
                            "routineSpec" => Ok(__FieldTag::__routine_spec),
                            "routine_spec" => Ok(__FieldTag::__routine_spec),
                            "datasetSpec" => Ok(__FieldTag::__dataset_spec),
                            "dataset_spec" => Ok(__FieldTag::__dataset_spec),
                            "filesetSpec" => Ok(__FieldTag::__fileset_spec),
                            "fileset_spec" => Ok(__FieldTag::__fileset_spec),
                            "serviceSpec" => Ok(__FieldTag::__service_spec),
                            "service_spec" => Ok(__FieldTag::__service_spec),
                            "modelSpec" => Ok(__FieldTag::__model_spec),
                            "model_spec" => Ok(__FieldTag::__model_spec),
                            "featureOnlineStoreSpec" => Ok(__FieldTag::__feature_online_store_spec),
                            "feature_online_store_spec" => {
                                Ok(__FieldTag::__feature_online_store_spec)
                            }
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "businessContext" => Ok(__FieldTag::__business_context),
                            "business_context" => Ok(__FieldTag::__business_context),
                            "schema" => Ok(__FieldTag::__schema),
                            "sourceSystemTimestamps" => Ok(__FieldTag::__source_system_timestamps),
                            "source_system_timestamps" => {
                                Ok(__FieldTag::__source_system_timestamps)
                            }
                            "usageSignal" => Ok(__FieldTag::__usage_signal),
                            "usage_signal" => Ok(__FieldTag::__usage_signal),
                            "labels" => Ok(__FieldTag::__labels),
                            "dataSource" => Ok(__FieldTag::__data_source),
                            "data_source" => Ok(__FieldTag::__data_source),
                            "personalDetails" => Ok(__FieldTag::__personal_details),
                            "personal_details" => Ok(__FieldTag::__personal_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__linked_resource => {
                            if !fields.insert(__FieldTag::__linked_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_resource",
                                ));
                            }
                            result.linked_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fully_qualified_name => {
                            if !fields.insert(__FieldTag::__fully_qualified_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_qualified_name",
                                ));
                            }
                            result.fully_qualified_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            if result.entry_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entry_type`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.type, latest field was type",
                                ));
                            }
                            result.entry_type =
                                std::option::Option::Some(crate::model::entry::EntryType::Type(
                                    map.next_value::<std::option::Option<crate::model::EntryType>>(
                                    )?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__user_specified_type => {
                            if !fields.insert(__FieldTag::__user_specified_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_specified_type",
                                ));
                            }
                            if result.entry_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entry_type`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.user_specified_type, latest field was userSpecifiedType",
                                ));
                            }
                            result.entry_type = std::option::Option::Some(
                                crate::model::entry::EntryType::UserSpecifiedType(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__integrated_system => {
                            if !fields.insert(__FieldTag::__integrated_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrated_system",
                                ));
                            }
                            if result.system.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.integrated_system, latest field was integratedSystem",
                                ));
                            }
                            result.system = std::option::Option::Some(
                                crate::model::entry::System::IntegratedSystem(
                                    map.next_value::<std::option::Option<crate::model::IntegratedSystem>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__user_specified_system => {
                            if !fields.insert(__FieldTag::__user_specified_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_specified_system",
                                ));
                            }
                            if result.system.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.user_specified_system, latest field was userSpecifiedSystem",
                                ));
                            }
                            result.system = std::option::Option::Some(
                                crate::model::entry::System::UserSpecifiedSystem(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sql_database_system_spec => {
                            if !fields.insert(__FieldTag::__sql_database_system_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_database_system_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.sql_database_system_spec, latest field was sqlDatabaseSystemSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::entry::SystemSpec::SqlDatabaseSystemSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SqlDatabaseSystemSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__looker_system_spec => {
                            if !fields.insert(__FieldTag::__looker_system_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for looker_system_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.looker_system_spec, latest field was lookerSystemSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::entry::SystemSpec::LookerSystemSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LookerSystemSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_bigtable_system_spec => {
                            if !fields.insert(__FieldTag::__cloud_bigtable_system_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_bigtable_system_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.cloud_bigtable_system_spec, latest field was cloudBigtableSystemSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::entry::SystemSpec::CloudBigtableSystemSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudBigtableSystemSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_fileset_spec => {
                            if !fields.insert(__FieldTag::__gcs_fileset_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_fileset_spec",
                                ));
                            }
                            if result.type_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.gcs_fileset_spec, latest field was gcsFilesetSpec",
                                ));
                            }
                            result.type_spec = std::option::Option::Some(
                                crate::model::entry::TypeSpec::GcsFilesetSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsFilesetSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bigquery_table_spec => {
                            if !fields.insert(__FieldTag::__bigquery_table_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_table_spec",
                                ));
                            }
                            if result.type_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.bigquery_table_spec, latest field was bigqueryTableSpec",
                                ));
                            }
                            result.type_spec = std::option::Option::Some(
                                crate::model::entry::TypeSpec::BigqueryTableSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryTableSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bigquery_date_sharded_spec => {
                            if !fields.insert(__FieldTag::__bigquery_date_sharded_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_date_sharded_spec",
                                ));
                            }
                            if result.type_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.bigquery_date_sharded_spec, latest field was bigqueryDateShardedSpec",
                                ));
                            }
                            result.type_spec = std::option::Option::Some(
                                crate::model::entry::TypeSpec::BigqueryDateShardedSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryDateShardedSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__database_table_spec => {
                            if !fields.insert(__FieldTag::__database_table_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_table_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.database_table_spec, latest field was databaseTableSpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::entry::Spec::DatabaseTableSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DatabaseTableSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_source_connection_spec => {
                            if !fields.insert(__FieldTag::__data_source_connection_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_connection_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.data_source_connection_spec, latest field was dataSourceConnectionSpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::entry::Spec::DataSourceConnectionSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DataSourceConnectionSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__routine_spec => {
                            if !fields.insert(__FieldTag::__routine_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.routine_spec, latest field was routineSpec",
                                ));
                            }
                            result.spec =
                                std::option::Option::Some(crate::model::entry::Spec::RoutineSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RoutineSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__dataset_spec => {
                            if !fields.insert(__FieldTag::__dataset_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.dataset_spec, latest field was datasetSpec",
                                ));
                            }
                            result.spec =
                                std::option::Option::Some(crate::model::entry::Spec::DatasetSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DatasetSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__fileset_spec => {
                            if !fields.insert(__FieldTag::__fileset_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fileset_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.fileset_spec, latest field was filesetSpec",
                                ));
                            }
                            result.spec =
                                std::option::Option::Some(crate::model::entry::Spec::FilesetSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FilesetSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__service_spec => {
                            if !fields.insert(__FieldTag::__service_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.service_spec, latest field was serviceSpec",
                                ));
                            }
                            result.spec =
                                std::option::Option::Some(crate::model::entry::Spec::ServiceSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ServiceSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__model_spec => {
                            if !fields.insert(__FieldTag::__model_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.model_spec, latest field was modelSpec",
                                ));
                            }
                            result.spec =
                                std::option::Option::Some(crate::model::entry::Spec::ModelSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ModelSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__feature_online_store_spec => {
                            if !fields.insert(__FieldTag::__feature_online_store_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_online_store_spec",
                                ));
                            }
                            if result.spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `spec`, a oneof with full ID .google.cloud.datacatalog.v1.Entry.feature_online_store_spec, latest field was featureOnlineStoreSpec",
                                ));
                            }
                            result.spec = std::option::Option::Some(
                                crate::model::entry::Spec::FeatureOnlineStoreSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FeatureOnlineStoreSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__business_context => {
                            if !fields.insert(__FieldTag::__business_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for business_context",
                                ));
                            }
                            result.business_context = map
                                .next_value::<std::option::Option<crate::model::BusinessContext>>(
                                )?;
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::Schema>>()?;
                        }
                        __FieldTag::__source_system_timestamps => {
                            if !fields.insert(__FieldTag::__source_system_timestamps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_system_timestamps",
                                ));
                            }
                            result.source_system_timestamps = map
                                .next_value::<std::option::Option<crate::model::SystemTimestamps>>(
                                )?;
                        }
                        __FieldTag::__usage_signal => {
                            if !fields.insert(__FieldTag::__usage_signal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage_signal",
                                ));
                            }
                            result.usage_signal =
                                map.next_value::<std::option::Option<crate::model::UsageSignal>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source => {
                            if !fields.insert(__FieldTag::__data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source",
                                ));
                            }
                            result.data_source =
                                map.next_value::<std::option::Option<crate::model::DataSource>>()?;
                        }
                        __FieldTag::__personal_details => {
                            if !fields.insert(__FieldTag::__personal_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for personal_details",
                                ));
                            }
                            result.personal_details = map
                                .next_value::<std::option::Option<crate::model::PersonalDetails>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.linked_resource.is_empty() {
            state.serialize_entry("linkedResource", &self.linked_resource)?;
        }
        if !self.fully_qualified_name.is_empty() {
            state.serialize_entry("fullyQualifiedName", &self.fully_qualified_name)?;
        }
        if let Some(value) = self.r#type() {
            state.serialize_entry("type", value)?;
        }
        if let Some(value) = self.user_specified_type() {
            state.serialize_entry("userSpecifiedType", value)?;
        }
        if let Some(value) = self.integrated_system() {
            state.serialize_entry("integratedSystem", value)?;
        }
        if let Some(value) = self.user_specified_system() {
            state.serialize_entry("userSpecifiedSystem", value)?;
        }
        if let Some(value) = self.sql_database_system_spec() {
            state.serialize_entry("sqlDatabaseSystemSpec", value)?;
        }
        if let Some(value) = self.looker_system_spec() {
            state.serialize_entry("lookerSystemSpec", value)?;
        }
        if let Some(value) = self.cloud_bigtable_system_spec() {
            state.serialize_entry("cloudBigtableSystemSpec", value)?;
        }
        if let Some(value) = self.gcs_fileset_spec() {
            state.serialize_entry("gcsFilesetSpec", value)?;
        }
        if let Some(value) = self.bigquery_table_spec() {
            state.serialize_entry("bigqueryTableSpec", value)?;
        }
        if let Some(value) = self.bigquery_date_sharded_spec() {
            state.serialize_entry("bigqueryDateShardedSpec", value)?;
        }
        if let Some(value) = self.database_table_spec() {
            state.serialize_entry("databaseTableSpec", value)?;
        }
        if let Some(value) = self.data_source_connection_spec() {
            state.serialize_entry("dataSourceConnectionSpec", value)?;
        }
        if let Some(value) = self.routine_spec() {
            state.serialize_entry("routineSpec", value)?;
        }
        if let Some(value) = self.dataset_spec() {
            state.serialize_entry("datasetSpec", value)?;
        }
        if let Some(value) = self.fileset_spec() {
            state.serialize_entry("filesetSpec", value)?;
        }
        if let Some(value) = self.service_spec() {
            state.serialize_entry("serviceSpec", value)?;
        }
        if let Some(value) = self.model_spec() {
            state.serialize_entry("modelSpec", value)?;
        }
        if let Some(value) = self.feature_online_store_spec() {
            state.serialize_entry("featureOnlineStoreSpec", value)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.business_context.is_some() {
            state.serialize_entry("businessContext", &self.business_context)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if self.source_system_timestamps.is_some() {
            state.serialize_entry("sourceSystemTimestamps", &self.source_system_timestamps)?;
        }
        if self.usage_signal.is_some() {
            state.serialize_entry("usageSignal", &self.usage_signal)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.data_source.is_some() {
            state.serialize_entry("dataSource", &self.data_source)?;
        }
        if self.personal_details.is_some() {
            state.serialize_entry("personalDetails", &self.personal_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Entry].
pub mod entry {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Entry type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntryType {
        /// The type of the entry.
        ///
        /// For details, see [`EntryType`](#entrytype).
        Type(crate::model::EntryType),
        /// Custom entry type that doesn't match any of the values allowed for input
        /// and listed in the `EntryType` enum.
        ///
        /// When creating an entry, first check the type values in the enum.
        /// If there are no appropriate types for the new entry,
        /// provide a custom value, for example, `my_special_type`.
        ///
        /// The `user_specified_type` string has the following limitations:
        ///
        /// * Is case insensitive.
        /// * Must begin with a letter or underscore.
        /// * Can only contain letters, numbers, and underscores.
        /// * Must be at least 1 character and at most 64 characters long.
        UserSpecifiedType(std::string::String),
    }

    /// The source system of the entry.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum System {
        /// Output only. Indicates the entry's source system that Data Catalog
        /// integrates with, such as BigQuery, Pub/Sub, or Dataproc Metastore.
        IntegratedSystem(crate::model::IntegratedSystem),
        /// Indicates the entry's source system that Data Catalog doesn't
        /// automatically integrate with.
        ///
        /// The `user_specified_system` string has the following limitations:
        ///
        /// * Is case insensitive.
        /// * Must begin with a letter or underscore.
        /// * Can only contain letters, numbers, and underscores.
        /// * Must be at least 1 character and at most 64 characters long.
        UserSpecifiedSystem(std::string::String),
    }

    /// System specification.
    /// Can be used as a complement for `spec`, when some metadata is relevant for
    /// all entries existing within given system
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification that applies to a relational database system. Only settable
        /// when `user_specified_system` is equal to `SQL_DATABASE`
        SqlDatabaseSystemSpec(std::boxed::Box<crate::model::SqlDatabaseSystemSpec>),
        /// Specification that applies to Looker sysstem. Only settable when
        /// `user_specified_system` is equal to `LOOKER`
        LookerSystemSpec(std::boxed::Box<crate::model::LookerSystemSpec>),
        /// Specification that applies to Cloud Bigtable system. Only settable when
        /// `integrated_system` is equal to `CLOUD_BIGTABLE`
        CloudBigtableSystemSpec(std::boxed::Box<crate::model::CloudBigtableSystemSpec>),
    }

    /// Type specification.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeSpec {
        /// Specification that applies to a Cloud Storage fileset. Valid only
        /// for entries with the `FILESET` type.
        GcsFilesetSpec(std::boxed::Box<crate::model::GcsFilesetSpec>),
        /// Output only. Specification that applies to a BigQuery table. Valid only
        /// for entries with the `TABLE` type.
        BigqueryTableSpec(std::boxed::Box<crate::model::BigQueryTableSpec>),
        /// Output only. Specification for a group of BigQuery tables with
        /// the `[prefix]YYYYMMDD` name pattern.
        ///
        /// For more information, see [Introduction to partitioned tables]
        /// (<https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding>).
        BigqueryDateShardedSpec(std::boxed::Box<crate::model::BigQueryDateShardedSpec>),
    }

    /// Type- and system-specific information. Specifications for types contain
    /// fields common to all entries of a given type, and sub-specifications with
    /// fields specific to a given source system.
    ///
    /// When extending the API with new types and systems, use this field instead
    /// of the legacy `type_spec`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Spec {
        /// Specification that applies to a table resource. Valid only
        /// for entries with the `TABLE` or `EXPLORE` type.
        DatabaseTableSpec(std::boxed::Box<crate::model::DatabaseTableSpec>),
        /// Specification that applies to a data source connection. Valid only
        /// for entries with the `DATA_SOURCE_CONNECTION` type.
        DataSourceConnectionSpec(std::boxed::Box<crate::model::DataSourceConnectionSpec>),
        /// Specification that applies to a user-defined function or procedure. Valid
        /// only for entries with the `ROUTINE` type.
        RoutineSpec(std::boxed::Box<crate::model::RoutineSpec>),
        /// Specification that applies to a dataset.
        DatasetSpec(std::boxed::Box<crate::model::DatasetSpec>),
        /// Specification that applies to a fileset resource. Valid only
        /// for entries with the `FILESET` type.
        FilesetSpec(std::boxed::Box<crate::model::FilesetSpec>),
        /// Specification that applies to a Service resource.
        ServiceSpec(std::boxed::Box<crate::model::ServiceSpec>),
        /// Model specification.
        ModelSpec(std::boxed::Box<crate::model::ModelSpec>),
        /// FeatureonlineStore spec for Vertex AI Feature Store.
        FeatureOnlineStoreSpec(std::boxed::Box<crate::model::FeatureOnlineStoreSpec>),
    }
}

/// Specification that applies to a table resource. Valid only
/// for entries with the `TABLE` type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseTableSpec {
    /// Type of this table.
    pub r#type: crate::model::database_table_spec::TableType,

    /// Output only. Fields specific to a Dataplex table and present only in the
    /// Dataplex table entries.
    pub dataplex_table: std::option::Option<crate::model::DataplexTableSpec>,

    /// Spec what applies to tables that are actually views.
    /// Not set for "real" tables.
    pub database_view_spec:
        std::option::Option<crate::model::database_table_spec::DatabaseViewSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::DatabaseTableSpec::type].
    pub fn set_type<T: std::convert::Into<crate::model::database_table_spec::TableType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [dataplex_table][crate::model::DatabaseTableSpec::dataplex_table].
    pub fn set_dataplex_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataplexTableSpec>,
    {
        self.dataplex_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_table][crate::model::DatabaseTableSpec::dataplex_table].
    pub fn set_or_clear_dataplex_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataplexTableSpec>,
    {
        self.dataplex_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_view_spec][crate::model::DatabaseTableSpec::database_view_spec].
    pub fn set_database_view_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database_table_spec::DatabaseViewSpec>,
    {
        self.database_view_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_view_spec][crate::model::DatabaseTableSpec::database_view_spec].
    pub fn set_or_clear_database_view_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database_table_spec::DatabaseViewSpec>,
    {
        self.database_view_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatabaseTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DatabaseTableSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseTableSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __dataplex_table,
            __database_view_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseTableSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "dataplexTable" => Ok(__FieldTag::__dataplex_table),
                            "dataplex_table" => Ok(__FieldTag::__dataplex_table),
                            "databaseViewSpec" => Ok(__FieldTag::__database_view_spec),
                            "database_view_spec" => Ok(__FieldTag::__database_view_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseTableSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseTableSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::database_table_spec::TableType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataplex_table => {
                            if !fields.insert(__FieldTag::__dataplex_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataplex_table",
                                ));
                            }
                            result.dataplex_table = map
                                .next_value::<std::option::Option<crate::model::DataplexTableSpec>>(
                                )?;
                        }
                        __FieldTag::__database_view_spec => {
                            if !fields.insert(__FieldTag::__database_view_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_view_spec",
                                ));
                            }
                            result.database_view_spec = map.next_value::<std::option::Option<
                                crate::model::database_table_spec::DatabaseViewSpec,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseTableSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.dataplex_table.is_some() {
            state.serialize_entry("dataplexTable", &self.dataplex_table)?;
        }
        if self.database_view_spec.is_some() {
            state.serialize_entry("databaseViewSpec", &self.database_view_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatabaseTableSpec].
pub mod database_table_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Specification that applies to database view.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DatabaseViewSpec {
        /// Type of this view.
        pub view_type: crate::model::database_table_spec::database_view_spec::ViewType,

        /// Definition of the view.
        pub source_definition: std::option::Option<
            crate::model::database_table_spec::database_view_spec::SourceDefinition,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DatabaseViewSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [view_type][crate::model::database_table_spec::DatabaseViewSpec::view_type].
        pub fn set_view_type<
            T: std::convert::Into<crate::model::database_table_spec::database_view_spec::ViewType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.view_type = v.into();
            self
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition].
        ///
        /// Note that all the setters affecting `source_definition` are mutually
        /// exclusive.
        pub fn set_source_definition<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::database_table_spec::database_view_spec::SourceDefinition,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_definition = v.into();
            self
        }

        /// The value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// if it holds a `BaseTable`, `None` if the field is not set or
        /// holds a different branch.
        pub fn base_table(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source_definition.as_ref().and_then(|v| match v {
                crate::model::database_table_spec::database_view_spec::SourceDefinition::BaseTable(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// to hold a `BaseTable`.
        ///
        /// Note that all the setters affecting `source_definition` are
        /// mutually exclusive.
        pub fn set_base_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_definition = std::option::Option::Some(
                crate::model::database_table_spec::database_view_spec::SourceDefinition::BaseTable(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// if it holds a `SqlQuery`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_query(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source_definition.as_ref().and_then(|v| match v {
                crate::model::database_table_spec::database_view_spec::SourceDefinition::SqlQuery(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source_definition][crate::model::database_table_spec::DatabaseViewSpec::source_definition]
        /// to hold a `SqlQuery`.
        ///
        /// Note that all the setters affecting `source_definition` are
        /// mutually exclusive.
        pub fn set_sql_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_definition = std::option::Option::Some(
                crate::model::database_table_spec::database_view_spec::SourceDefinition::SqlQuery(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for DatabaseViewSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.DatabaseTableSpec.DatabaseViewSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DatabaseViewSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __view_type,
                __base_table,
                __sql_query,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DatabaseViewSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "viewType" => Ok(__FieldTag::__view_type),
                                "view_type" => Ok(__FieldTag::__view_type),
                                "baseTable" => Ok(__FieldTag::__base_table),
                                "base_table" => Ok(__FieldTag::__base_table),
                                "sqlQuery" => Ok(__FieldTag::__sql_query),
                                "sql_query" => Ok(__FieldTag::__sql_query),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DatabaseViewSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DatabaseViewSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__view_type => {
                                if !fields.insert(__FieldTag::__view_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for view_type",
                                    ));
                                }
                                result.view_type = map.next_value::<std::option::Option<crate::model::database_table_spec::database_view_spec::ViewType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__base_table => {
                                if !fields.insert(__FieldTag::__base_table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for base_table",
                                    ));
                                }
                                if result.source_definition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source_definition`, a oneof with full ID .google.cloud.datacatalog.v1.DatabaseTableSpec.DatabaseViewSpec.base_table, latest field was baseTable",
                                    ));
                                }
                                result.source_definition = std::option::Option::Some(
                                    crate::model::database_table_spec::database_view_spec::SourceDefinition::BaseTable(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__sql_query => {
                                if !fields.insert(__FieldTag::__sql_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_query",
                                    ));
                                }
                                if result.source_definition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source_definition`, a oneof with full ID .google.cloud.datacatalog.v1.DatabaseTableSpec.DatabaseViewSpec.sql_query, latest field was sqlQuery",
                                    ));
                                }
                                result.source_definition = std::option::Option::Some(
                                    crate::model::database_table_spec::database_view_spec::SourceDefinition::SqlQuery(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DatabaseViewSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.view_type) {
                state.serialize_entry("viewType", &self.view_type)?;
            }
            if let Some(value) = self.base_table() {
                state.serialize_entry("baseTable", value)?;
            }
            if let Some(value) = self.sql_query() {
                state.serialize_entry("sqlQuery", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DatabaseViewSpec].
    pub mod database_view_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Concrete type of the view.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ViewType {
            /// Default unknown view type.
            Unspecified,
            /// Standard view.
            StandardView,
            /// Materialized view.
            MaterializedView,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ViewType::value] or
            /// [ViewType::name].
            UnknownValue(view_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod view_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ViewType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::StandardView => std::option::Option::Some(1),
                    Self::MaterializedView => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("VIEW_TYPE_UNSPECIFIED"),
                    Self::StandardView => std::option::Option::Some("STANDARD_VIEW"),
                    Self::MaterializedView => std::option::Option::Some("MATERIALIZED_VIEW"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ViewType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ViewType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ViewType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::StandardView,
                    2 => Self::MaterializedView,
                    _ => Self::UnknownValue(view_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ViewType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VIEW_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "STANDARD_VIEW" => Self::StandardView,
                    "MATERIALIZED_VIEW" => Self::MaterializedView,
                    _ => Self::UnknownValue(view_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ViewType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::StandardView => serializer.serialize_i32(1),
                    Self::MaterializedView => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ViewType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ViewType>::new(
                    ".google.cloud.datacatalog.v1.DatabaseTableSpec.DatabaseViewSpec.ViewType",
                ))
            }
        }

        /// Definition of the view.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SourceDefinition {
            /// Name of a singular table this view reflects one to one.
            BaseTable(std::string::String),
            /// SQL query used to generate this view.
            SqlQuery(std::string::String),
        }
    }

    /// Type of the table.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TableType {
        /// Default unknown table type.
        Unspecified,
        /// Native table.
        Native,
        /// External table.
        External,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TableType::value] or
        /// [TableType::name].
        UnknownValue(table_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod table_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TableType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Native => std::option::Option::Some(1),
                Self::External => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TABLE_TYPE_UNSPECIFIED"),
                Self::Native => std::option::Option::Some("NATIVE"),
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TableType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TableType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TableType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Native,
                2 => Self::External,
                _ => Self::UnknownValue(table_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TableType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NATIVE" => Self::Native,
                "EXTERNAL" => Self::External,
                _ => Self::UnknownValue(table_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TableType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Native => serializer.serialize_i32(1),
                Self::External => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TableType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableType>::new(
                ".google.cloud.datacatalog.v1.DatabaseTableSpec.TableType",
            ))
        }
    }
}

/// Specification that applies to a fileset. Valid only for entries with the
/// 'FILESET' type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FilesetSpec {
    /// Fields specific to a Dataplex fileset and present only in the Dataplex
    /// fileset entries.
    pub dataplex_fileset: std::option::Option<crate::model::DataplexFilesetSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataplex_fileset][crate::model::FilesetSpec::dataplex_fileset].
    pub fn set_dataplex_fileset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataplexFilesetSpec>,
    {
        self.dataplex_fileset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_fileset][crate::model::FilesetSpec::dataplex_fileset].
    pub fn set_or_clear_dataplex_fileset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataplexFilesetSpec>,
    {
        self.dataplex_fileset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FilesetSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FilesetSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataplex_fileset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilesetSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataplexFileset" => Ok(__FieldTag::__dataplex_fileset),
                            "dataplex_fileset" => Ok(__FieldTag::__dataplex_fileset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FilesetSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilesetSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataplex_fileset => {
                            if !fields.insert(__FieldTag::__dataplex_fileset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataplex_fileset",
                                ));
                            }
                            result.dataplex_fileset = map.next_value::<std::option::Option<crate::model::DataplexFilesetSpec>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FilesetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dataplex_fileset.is_some() {
            state.serialize_entry("dataplexFileset", &self.dataplex_fileset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification that applies to a data source connection. Valid only for
/// entries with the `DATA_SOURCE_CONNECTION` type.
/// Only one of internal specs can be set at the time, and cannot
/// be changed later.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSourceConnectionSpec {
    /// Output only. Fields specific to BigQuery connections.
    pub bigquery_connection_spec: std::option::Option<crate::model::BigQueryConnectionSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceConnectionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_connection_spec][crate::model::DataSourceConnectionSpec::bigquery_connection_spec].
    pub fn set_bigquery_connection_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryConnectionSpec>,
    {
        self.bigquery_connection_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_connection_spec][crate::model::DataSourceConnectionSpec::bigquery_connection_spec].
    pub fn set_or_clear_bigquery_connection_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryConnectionSpec>,
    {
        self.bigquery_connection_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataSourceConnectionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataSourceConnectionSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSourceConnectionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_connection_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSourceConnectionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryConnectionSpec" => Ok(__FieldTag::__bigquery_connection_spec),
                            "bigquery_connection_spec" => {
                                Ok(__FieldTag::__bigquery_connection_spec)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSourceConnectionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSourceConnectionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_connection_spec => {
                            if !fields.insert(__FieldTag::__bigquery_connection_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_connection_spec",
                                ));
                            }
                            result.bigquery_connection_spec = map.next_value::<std::option::Option<crate::model::BigQueryConnectionSpec>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSourceConnectionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bigquery_connection_spec.is_some() {
            state.serialize_entry("bigqueryConnectionSpec", &self.bigquery_connection_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification that applies to a routine. Valid only for
/// entries with the `ROUTINE` type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RoutineSpec {
    /// The type of the routine.
    pub routine_type: crate::model::routine_spec::RoutineType,

    /// The language the routine is written in. The exact value depends on the
    /// source system. For BigQuery routines, possible values are:
    ///
    /// * `SQL`
    /// * `JAVASCRIPT`
    pub language: std::string::String,

    /// Arguments of the routine.
    pub routine_arguments: std::vec::Vec<crate::model::routine_spec::Argument>,

    /// Return type of the argument. The exact value depends on the source system
    /// and the language.
    pub return_type: std::string::String,

    /// The body of the routine.
    pub definition_body: std::string::String,

    /// Contains fields specific to the source system.
    pub system_spec: std::option::Option<crate::model::routine_spec::SystemSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RoutineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [routine_type][crate::model::RoutineSpec::routine_type].
    pub fn set_routine_type<T: std::convert::Into<crate::model::routine_spec::RoutineType>>(
        mut self,
        v: T,
    ) -> Self {
        self.routine_type = v.into();
        self
    }

    /// Sets the value of [language][crate::model::RoutineSpec::language].
    pub fn set_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language = v.into();
        self
    }

    /// Sets the value of [routine_arguments][crate::model::RoutineSpec::routine_arguments].
    pub fn set_routine_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::routine_spec::Argument>,
    {
        use std::iter::Iterator;
        self.routine_arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [return_type][crate::model::RoutineSpec::return_type].
    pub fn set_return_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.return_type = v.into();
        self
    }

    /// Sets the value of [definition_body][crate::model::RoutineSpec::definition_body].
    pub fn set_definition_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition_body = v.into();
        self
    }

    /// Sets the value of [system_spec][crate::model::RoutineSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::routine_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::RoutineSpec::system_spec]
    /// if it holds a `BigqueryRoutineSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_routine_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryRoutineSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::routine_spec::SystemSpec::BigqueryRoutineSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::RoutineSpec::system_spec]
    /// to hold a `BigqueryRoutineSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_bigquery_routine_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryRoutineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::routine_spec::SystemSpec::BigqueryRoutineSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RoutineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RoutineSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RoutineSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __routine_type,
            __language,
            __routine_arguments,
            __return_type,
            __definition_body,
            __bigquery_routine_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RoutineSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routineType" => Ok(__FieldTag::__routine_type),
                            "routine_type" => Ok(__FieldTag::__routine_type),
                            "language" => Ok(__FieldTag::__language),
                            "routineArguments" => Ok(__FieldTag::__routine_arguments),
                            "routine_arguments" => Ok(__FieldTag::__routine_arguments),
                            "returnType" => Ok(__FieldTag::__return_type),
                            "return_type" => Ok(__FieldTag::__return_type),
                            "definitionBody" => Ok(__FieldTag::__definition_body),
                            "definition_body" => Ok(__FieldTag::__definition_body),
                            "bigqueryRoutineSpec" => Ok(__FieldTag::__bigquery_routine_spec),
                            "bigquery_routine_spec" => Ok(__FieldTag::__bigquery_routine_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RoutineSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RoutineSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__routine_type => {
                            if !fields.insert(__FieldTag::__routine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_type",
                                ));
                            }
                            result.routine_type = map.next_value::<std::option::Option<crate::model::routine_spec::RoutineType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__language => {
                            if !fields.insert(__FieldTag::__language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language",
                                ));
                            }
                            result.language = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_arguments => {
                            if !fields.insert(__FieldTag::__routine_arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_arguments",
                                ));
                            }
                            result.routine_arguments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::routine_spec::Argument>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_type => {
                            if !fields.insert(__FieldTag::__return_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_type",
                                ));
                            }
                            result.return_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__definition_body => {
                            if !fields.insert(__FieldTag::__definition_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition_body",
                                ));
                            }
                            result.definition_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bigquery_routine_spec => {
                            if !fields.insert(__FieldTag::__bigquery_routine_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_routine_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.RoutineSpec.bigquery_routine_spec, latest field was bigqueryRoutineSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::routine_spec::SystemSpec::BigqueryRoutineSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryRoutineSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RoutineSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.routine_type) {
            state.serialize_entry("routineType", &self.routine_type)?;
        }
        if !self.language.is_empty() {
            state.serialize_entry("language", &self.language)?;
        }
        if !self.routine_arguments.is_empty() {
            state.serialize_entry("routineArguments", &self.routine_arguments)?;
        }
        if !self.return_type.is_empty() {
            state.serialize_entry("returnType", &self.return_type)?;
        }
        if !self.definition_body.is_empty() {
            state.serialize_entry("definitionBody", &self.definition_body)?;
        }
        if let Some(value) = self.bigquery_routine_spec() {
            state.serialize_entry("bigqueryRoutineSpec", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RoutineSpec].
pub mod routine_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Input or output argument of a function or stored procedure.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Argument {
        /// The name of the argument. A return argument of a function might not have
        /// a name.
        pub name: std::string::String,

        /// Specifies whether the argument is input or output.
        pub mode: crate::model::routine_spec::argument::Mode,

        /// Type of the argument. The exact value depends on the source system and
        /// the language.
        pub r#type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Argument {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::routine_spec::Argument::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [mode][crate::model::routine_spec::Argument::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::routine_spec::argument::Mode>>(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::routine_spec::Argument::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Argument {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.RoutineSpec.Argument"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Argument {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __mode,
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Argument")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "mode" => Ok(__FieldTag::__mode),
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Argument;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Argument")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode =
                                    map.next_value::<std::option::Option<
                                        crate::model::routine_spec::argument::Mode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Argument {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.mode) {
                state.serialize_entry("mode", &self.mode)?;
            }
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Argument].
    pub mod argument {
        #[allow(unused_imports)]
        use super::*;

        /// The input or output mode of the argument.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Unspecified mode.
            Unspecified,
            /// The argument is input-only.
            In,
            /// The argument is output-only.
            Out,
            /// The argument is both an input and an output.
            Inout,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::In => std::option::Option::Some(1),
                    Self::Out => std::option::Option::Some(2),
                    Self::Inout => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::In => std::option::Option::Some("IN"),
                    Self::Out => std::option::Option::Some("OUT"),
                    Self::Inout => std::option::Option::Some("INOUT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::In,
                    2 => Self::Out,
                    3 => Self::Inout,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "IN" => Self::In,
                    "OUT" => Self::Out,
                    "INOUT" => Self::Inout,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::In => serializer.serialize_i32(1),
                    Self::Out => serializer.serialize_i32(2),
                    Self::Inout => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.cloud.datacatalog.v1.RoutineSpec.Argument.Mode",
                ))
            }
        }
    }

    /// The fine-grained type of the routine.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoutineType {
        /// Unspecified type.
        Unspecified,
        /// Non-builtin permanent scalar function.
        ScalarFunction,
        /// Stored procedure.
        Procedure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RoutineType::value] or
        /// [RoutineType::name].
        UnknownValue(routine_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod routine_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RoutineType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ScalarFunction => std::option::Option::Some(1),
                Self::Procedure => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUTINE_TYPE_UNSPECIFIED"),
                Self::ScalarFunction => std::option::Option::Some("SCALAR_FUNCTION"),
                Self::Procedure => std::option::Option::Some("PROCEDURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RoutineType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RoutineType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RoutineType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ScalarFunction,
                2 => Self::Procedure,
                _ => Self::UnknownValue(routine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RoutineType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUTINE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCALAR_FUNCTION" => Self::ScalarFunction,
                "PROCEDURE" => Self::Procedure,
                _ => Self::UnknownValue(routine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RoutineType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ScalarFunction => serializer.serialize_i32(1),
                Self::Procedure => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RoutineType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RoutineType>::new(
                ".google.cloud.datacatalog.v1.RoutineSpec.RoutineType",
            ))
        }
    }

    /// Contains fields specific to the source system.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Fields specific for BigQuery routines.
        BigqueryRoutineSpec(std::boxed::Box<crate::model::BigQueryRoutineSpec>),
    }
}

/// Specification that applies to a dataset. Valid only for
/// entries with the `DATASET` type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetSpec {
    /// Fields specific to the source system.
    pub system_spec: std::option::Option<crate::model::dataset_spec::SystemSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system_spec][crate::model::DatasetSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::dataset_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::DatasetSpec::system_spec]
    /// if it holds a `VertexDatasetSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::dataset_spec::SystemSpec::VertexDatasetSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::DatasetSpec::system_spec]
    /// to hold a `VertexDatasetSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::dataset_spec::SystemSpec::VertexDatasetSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatasetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DatasetSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatasetSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vertex_dataset_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vertexDatasetSpec" => Ok(__FieldTag::__vertex_dataset_spec),
                            "vertex_dataset_spec" => Ok(__FieldTag::__vertex_dataset_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatasetSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vertex_dataset_spec => {
                            if !fields.insert(__FieldTag::__vertex_dataset_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_dataset_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.DatasetSpec.vertex_dataset_spec, latest field was vertexDatasetSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::dataset_spec::SystemSpec::VertexDatasetSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VertexDatasetSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatasetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vertex_dataset_spec() {
            state.serialize_entry("vertexDatasetSpec", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatasetSpec].
pub mod dataset_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Fields specific to the source system.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Vertex AI Dataset specific fields
        VertexDatasetSpec(std::boxed::Box<crate::model::VertexDatasetSpec>),
    }
}

/// Specification that applies to
/// entries that are part `SQL_DATABASE` system
/// (user_specified_type)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlDatabaseSystemSpec {
    /// SQL Database Engine.
    /// enum SqlEngine {
    /// UNDEFINED = 0;
    /// MY_SQL = 1;
    /// POSTGRE_SQL = 2;
    /// SQL_SERVER = 3;
    /// }
    /// Engine of the enclosing database instance.
    pub sql_engine: std::string::String,

    /// Version of the database engine.
    pub database_version: std::string::String,

    /// Host of the SQL database
    /// enum InstanceHost {
    /// UNDEFINED = 0;
    /// SELF_HOSTED = 1;
    /// CLOUD_SQL = 2;
    /// AMAZON_RDS = 3;
    /// AZURE_SQL = 4;
    /// }
    /// Host of the enclousing database instance.
    pub instance_host: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabaseSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_engine][crate::model::SqlDatabaseSystemSpec::sql_engine].
    pub fn set_sql_engine<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_engine = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::SqlDatabaseSystemSpec::database_version].
    pub fn set_database_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [instance_host][crate::model::SqlDatabaseSystemSpec::instance_host].
    pub fn set_instance_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_host = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabaseSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SqlDatabaseSystemSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlDatabaseSystemSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_engine,
            __database_version,
            __instance_host,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlDatabaseSystemSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlEngine" => Ok(__FieldTag::__sql_engine),
                            "sql_engine" => Ok(__FieldTag::__sql_engine),
                            "databaseVersion" => Ok(__FieldTag::__database_version),
                            "database_version" => Ok(__FieldTag::__database_version),
                            "instanceHost" => Ok(__FieldTag::__instance_host),
                            "instance_host" => Ok(__FieldTag::__instance_host),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlDatabaseSystemSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlDatabaseSystemSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_engine => {
                            if !fields.insert(__FieldTag::__sql_engine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_engine",
                                ));
                            }
                            result.sql_engine = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_version => {
                            if !fields.insert(__FieldTag::__database_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_version",
                                ));
                            }
                            result.database_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_host => {
                            if !fields.insert(__FieldTag::__instance_host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_host",
                                ));
                            }
                            result.instance_host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlDatabaseSystemSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sql_engine.is_empty() {
            state.serialize_entry("sqlEngine", &self.sql_engine)?;
        }
        if !self.database_version.is_empty() {
            state.serialize_entry("databaseVersion", &self.database_version)?;
        }
        if !self.instance_host.is_empty() {
            state.serialize_entry("instanceHost", &self.instance_host)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification that applies to
/// entries that are part `LOOKER` system
/// (user_specified_type)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LookerSystemSpec {
    /// ID of the parent Looker Instance. Empty if it does not exist.
    /// Example value: `someinstance.looker.com`
    pub parent_instance_id: std::string::String,

    /// Name of the parent Looker Instance. Empty if it does not exist.
    pub parent_instance_display_name: std::string::String,

    /// ID of the parent Model. Empty if it does not exist.
    pub parent_model_id: std::string::String,

    /// Name of the parent Model. Empty if it does not exist.
    pub parent_model_display_name: std::string::String,

    /// ID of the parent View. Empty if it does not exist.
    pub parent_view_id: std::string::String,

    /// Name of the parent View. Empty if it does not exist.
    pub parent_view_display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookerSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent_instance_id][crate::model::LookerSystemSpec::parent_instance_id].
    pub fn set_parent_instance_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_instance_id = v.into();
        self
    }

    /// Sets the value of [parent_instance_display_name][crate::model::LookerSystemSpec::parent_instance_display_name].
    pub fn set_parent_instance_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_instance_display_name = v.into();
        self
    }

    /// Sets the value of [parent_model_id][crate::model::LookerSystemSpec::parent_model_id].
    pub fn set_parent_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model_id = v.into();
        self
    }

    /// Sets the value of [parent_model_display_name][crate::model::LookerSystemSpec::parent_model_display_name].
    pub fn set_parent_model_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_model_display_name = v.into();
        self
    }

    /// Sets the value of [parent_view_id][crate::model::LookerSystemSpec::parent_view_id].
    pub fn set_parent_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_view_id = v.into();
        self
    }

    /// Sets the value of [parent_view_display_name][crate::model::LookerSystemSpec::parent_view_display_name].
    pub fn set_parent_view_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_view_display_name = v.into();
        self
    }
}

impl wkt::message::Message for LookerSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.LookerSystemSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookerSystemSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent_instance_id,
            __parent_instance_display_name,
            __parent_model_id,
            __parent_model_display_name,
            __parent_view_id,
            __parent_view_display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookerSystemSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parentInstanceId" => Ok(__FieldTag::__parent_instance_id),
                            "parent_instance_id" => Ok(__FieldTag::__parent_instance_id),
                            "parentInstanceDisplayName" => {
                                Ok(__FieldTag::__parent_instance_display_name)
                            }
                            "parent_instance_display_name" => {
                                Ok(__FieldTag::__parent_instance_display_name)
                            }
                            "parentModelId" => Ok(__FieldTag::__parent_model_id),
                            "parent_model_id" => Ok(__FieldTag::__parent_model_id),
                            "parentModelDisplayName" => Ok(__FieldTag::__parent_model_display_name),
                            "parent_model_display_name" => {
                                Ok(__FieldTag::__parent_model_display_name)
                            }
                            "parentViewId" => Ok(__FieldTag::__parent_view_id),
                            "parent_view_id" => Ok(__FieldTag::__parent_view_id),
                            "parentViewDisplayName" => Ok(__FieldTag::__parent_view_display_name),
                            "parent_view_display_name" => {
                                Ok(__FieldTag::__parent_view_display_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookerSystemSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookerSystemSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent_instance_id => {
                            if !fields.insert(__FieldTag::__parent_instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_instance_id",
                                ));
                            }
                            result.parent_instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_instance_display_name => {
                            if !fields.insert(__FieldTag::__parent_instance_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_instance_display_name",
                                ));
                            }
                            result.parent_instance_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_model_id => {
                            if !fields.insert(__FieldTag::__parent_model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_model_id",
                                ));
                            }
                            result.parent_model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_model_display_name => {
                            if !fields.insert(__FieldTag::__parent_model_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_model_display_name",
                                ));
                            }
                            result.parent_model_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_view_id => {
                            if !fields.insert(__FieldTag::__parent_view_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_view_id",
                                ));
                            }
                            result.parent_view_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_view_display_name => {
                            if !fields.insert(__FieldTag::__parent_view_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_view_display_name",
                                ));
                            }
                            result.parent_view_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookerSystemSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent_instance_id.is_empty() {
            state.serialize_entry("parentInstanceId", &self.parent_instance_id)?;
        }
        if !self.parent_instance_display_name.is_empty() {
            state.serialize_entry(
                "parentInstanceDisplayName",
                &self.parent_instance_display_name,
            )?;
        }
        if !self.parent_model_id.is_empty() {
            state.serialize_entry("parentModelId", &self.parent_model_id)?;
        }
        if !self.parent_model_display_name.is_empty() {
            state.serialize_entry("parentModelDisplayName", &self.parent_model_display_name)?;
        }
        if !self.parent_view_id.is_empty() {
            state.serialize_entry("parentViewId", &self.parent_view_id)?;
        }
        if !self.parent_view_display_name.is_empty() {
            state.serialize_entry("parentViewDisplayName", &self.parent_view_display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification that applies to
/// all entries that are part of `CLOUD_BIGTABLE` system
/// (user_specified_type)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudBigtableSystemSpec {
    /// Display name of the Instance. This is user specified and different from
    /// the resource name.
    pub instance_display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudBigtableSystemSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_display_name][crate::model::CloudBigtableSystemSpec::instance_display_name].
    pub fn set_instance_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_display_name = v.into();
        self
    }
}

impl wkt::message::Message for CloudBigtableSystemSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableSystemSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudBigtableSystemSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudBigtableSystemSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceDisplayName" => Ok(__FieldTag::__instance_display_name),
                            "instance_display_name" => Ok(__FieldTag::__instance_display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudBigtableSystemSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudBigtableSystemSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_display_name => {
                            if !fields.insert(__FieldTag::__instance_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_display_name",
                                ));
                            }
                            result.instance_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudBigtableSystemSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_display_name.is_empty() {
            state.serialize_entry("instanceDisplayName", &self.instance_display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification that applies to Instance
/// entries that are part of `CLOUD_BIGTABLE` system.
/// (user_specified_type)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudBigtableInstanceSpec {
    /// The list of clusters for the Instance.
    pub cloud_bigtable_cluster_specs:
        std::vec::Vec<crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudBigtableInstanceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_bigtable_cluster_specs][crate::model::CloudBigtableInstanceSpec::cloud_bigtable_cluster_specs].
    pub fn set_cloud_bigtable_cluster_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec>,
    {
        use std::iter::Iterator;
        self.cloud_bigtable_cluster_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudBigtableInstanceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableInstanceSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudBigtableInstanceSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_bigtable_cluster_specs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudBigtableInstanceSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudBigtableClusterSpecs" => {
                                Ok(__FieldTag::__cloud_bigtable_cluster_specs)
                            }
                            "cloud_bigtable_cluster_specs" => {
                                Ok(__FieldTag::__cloud_bigtable_cluster_specs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudBigtableInstanceSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudBigtableInstanceSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_bigtable_cluster_specs => {
                            if !fields.insert(__FieldTag::__cloud_bigtable_cluster_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_bigtable_cluster_specs",
                                ));
                            }
                            result.cloud_bigtable_cluster_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudBigtableInstanceSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_bigtable_cluster_specs.is_empty() {
            state.serialize_entry(
                "cloudBigtableClusterSpecs",
                &self.cloud_bigtable_cluster_specs,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CloudBigtableInstanceSpec].
pub mod cloud_bigtable_instance_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Spec that applies to clusters of an Instance of Cloud Bigtable.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudBigtableClusterSpec {
        /// Name of the cluster.
        pub display_name: std::string::String,

        /// Location of the cluster, typically a Cloud zone.
        pub location: std::string::String,

        /// Type of the resource. For a cluster this would be "CLUSTER".
        pub r#type: std::string::String,

        /// A link back to the parent resource, in this case Instance.
        pub linked_resource: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudBigtableClusterSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [location][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [linked_resource][crate::model::cloud_bigtable_instance_spec::CloudBigtableClusterSpec::linked_resource].
        pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.linked_resource = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudBigtableClusterSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.CloudBigtableInstanceSpec.CloudBigtableClusterSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudBigtableClusterSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __location,
                __type,
                __linked_resource,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudBigtableClusterSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "location" => Ok(__FieldTag::__location),
                                "type" => Ok(__FieldTag::__type),
                                "linkedResource" => Ok(__FieldTag::__linked_resource),
                                "linked_resource" => Ok(__FieldTag::__linked_resource),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudBigtableClusterSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudBigtableClusterSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__linked_resource => {
                                if !fields.insert(__FieldTag::__linked_resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for linked_resource",
                                    ));
                                }
                                result.linked_resource = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudBigtableClusterSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.linked_resource.is_empty() {
                state.serialize_entry("linkedResource", &self.linked_resource)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Specification that applies to a Service resource. Valid only
/// for entries with the `SERVICE` type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceSpec {
    /// System spec
    pub system_spec: std::option::Option<crate::model::service_spec::SystemSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system_spec][crate::model::ServiceSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::service_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ServiceSpec::system_spec]
    /// if it holds a `CloudBigtableInstanceSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_bigtable_instance_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudBigtableInstanceSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::service_spec::SystemSpec::CloudBigtableInstanceSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ServiceSpec::system_spec]
    /// to hold a `CloudBigtableInstanceSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_cloud_bigtable_instance_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudBigtableInstanceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::service_spec::SystemSpec::CloudBigtableInstanceSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ServiceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ServiceSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_bigtable_instance_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudBigtableInstanceSpec" => {
                                Ok(__FieldTag::__cloud_bigtable_instance_spec)
                            }
                            "cloud_bigtable_instance_spec" => {
                                Ok(__FieldTag::__cloud_bigtable_instance_spec)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_bigtable_instance_spec => {
                            if !fields.insert(__FieldTag::__cloud_bigtable_instance_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_bigtable_instance_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.ServiceSpec.cloud_bigtable_instance_spec, latest field was cloudBigtableInstanceSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::service_spec::SystemSpec::CloudBigtableInstanceSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudBigtableInstanceSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_bigtable_instance_spec() {
            state.serialize_entry("cloudBigtableInstanceSpec", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ServiceSpec].
pub mod service_spec {
    #[allow(unused_imports)]
    use super::*;

    /// System spec
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification that applies to Instance entries of `CLOUD_BIGTABLE`
        /// system.
        CloudBigtableInstanceSpec(std::boxed::Box<crate::model::CloudBigtableInstanceSpec>),
    }
}

/// Detail description of the source information of a Vertex model.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexModelSourceInfo {
    /// Type of the model source.
    pub source_type: crate::model::vertex_model_source_info::ModelSourceType,

    /// If this Model is copy of another Model. If true then
    /// [source_type][google.cloud.datacatalog.v1.VertexModelSourceInfo.source_type]
    /// pertains to the original.
    ///
    /// [google.cloud.datacatalog.v1.VertexModelSourceInfo.source_type]: crate::model::VertexModelSourceInfo::source_type
    pub copy: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexModelSourceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::VertexModelSourceInfo::source_type].
    pub fn set_source_type<
        T: std::convert::Into<crate::model::vertex_model_source_info::ModelSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [copy][crate::model::VertexModelSourceInfo::copy].
    pub fn set_copy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.copy = v.into();
        self
    }
}

impl wkt::message::Message for VertexModelSourceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexModelSourceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexModelSourceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_type,
            __copy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexModelSourceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceType" => Ok(__FieldTag::__source_type),
                            "source_type" => Ok(__FieldTag::__source_type),
                            "copy" => Ok(__FieldTag::__copy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexModelSourceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexModelSourceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_type => {
                            if !fields.insert(__FieldTag::__source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_type",
                                ));
                            }
                            result.source_type = map
                                .next_value::<std::option::Option<
                                    crate::model::vertex_model_source_info::ModelSourceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__copy => {
                            if !fields.insert(__FieldTag::__copy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy",
                                ));
                            }
                            result.copy = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexModelSourceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source_type) {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if !wkt::internal::is_default(&self.copy) {
            state.serialize_entry("copy", &self.copy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VertexModelSourceInfo].
pub mod vertex_model_source_info {
    #[allow(unused_imports)]
    use super::*;

    /// Source of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelSourceType {
        /// Should not be used.
        Unspecified,
        /// The Model is uploaded by automl training pipeline.
        Automl,
        /// The Model is uploaded by user or custom training pipeline.
        Custom,
        /// The Model is registered and sync'ed from BigQuery ML.
        Bqml,
        /// The Model is saved or tuned from Model Garden.
        ModelGarden,
        /// The Model is saved or tuned from Genie.
        Genie,
        /// The Model is uploaded by text embedding finetuning pipeline.
        CustomTextEmbedding,
        /// The Model is saved or tuned from Marketplace.
        Marketplace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelSourceType::value] or
        /// [ModelSourceType::name].
        UnknownValue(model_source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelSourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automl => std::option::Option::Some(1),
                Self::Custom => std::option::Option::Some(2),
                Self::Bqml => std::option::Option::Some(3),
                Self::ModelGarden => std::option::Option::Some(4),
                Self::Genie => std::option::Option::Some(5),
                Self::CustomTextEmbedding => std::option::Option::Some(6),
                Self::Marketplace => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_SOURCE_TYPE_UNSPECIFIED"),
                Self::Automl => std::option::Option::Some("AUTOML"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::Bqml => std::option::Option::Some("BQML"),
                Self::ModelGarden => std::option::Option::Some("MODEL_GARDEN"),
                Self::Genie => std::option::Option::Some("GENIE"),
                Self::CustomTextEmbedding => std::option::Option::Some("CUSTOM_TEXT_EMBEDDING"),
                Self::Marketplace => std::option::Option::Some("MARKETPLACE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelSourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelSourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelSourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automl,
                2 => Self::Custom,
                3 => Self::Bqml,
                4 => Self::ModelGarden,
                5 => Self::Genie,
                6 => Self::CustomTextEmbedding,
                7 => Self::Marketplace,
                _ => Self::UnknownValue(model_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelSourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOML" => Self::Automl,
                "CUSTOM" => Self::Custom,
                "BQML" => Self::Bqml,
                "MODEL_GARDEN" => Self::ModelGarden,
                "GENIE" => Self::Genie,
                "CUSTOM_TEXT_EMBEDDING" => Self::CustomTextEmbedding,
                "MARKETPLACE" => Self::Marketplace,
                _ => Self::UnknownValue(model_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelSourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automl => serializer.serialize_i32(1),
                Self::Custom => serializer.serialize_i32(2),
                Self::Bqml => serializer.serialize_i32(3),
                Self::ModelGarden => serializer.serialize_i32(4),
                Self::Genie => serializer.serialize_i32(5),
                Self::CustomTextEmbedding => serializer.serialize_i32(6),
                Self::Marketplace => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelSourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelSourceType>::new(
                ".google.cloud.datacatalog.v1.VertexModelSourceInfo.ModelSourceType",
            ))
        }
    }
}

/// Specification for vertex model resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexModelSpec {
    /// The version ID of the model.
    pub version_id: std::string::String,

    /// User provided version aliases so that a model version can be referenced via
    /// alias
    pub version_aliases: std::vec::Vec<std::string::String>,

    /// The description of this version.
    pub version_description: std::string::String,

    /// Source of a Vertex model.
    pub vertex_model_source_info: std::option::Option<crate::model::VertexModelSourceInfo>,

    /// URI of the Docker image to be used as the custom container for serving
    /// predictions.
    pub container_image_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexModelSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version_id][crate::model::VertexModelSpec::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::VertexModelSpec::version_aliases].
    pub fn set_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version_description][crate::model::VertexModelSpec::version_description].
    pub fn set_version_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_description = v.into();
        self
    }

    /// Sets the value of [vertex_model_source_info][crate::model::VertexModelSpec::vertex_model_source_info].
    pub fn set_vertex_model_source_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VertexModelSourceInfo>,
    {
        self.vertex_model_source_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vertex_model_source_info][crate::model::VertexModelSpec::vertex_model_source_info].
    pub fn set_or_clear_vertex_model_source_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VertexModelSourceInfo>,
    {
        self.vertex_model_source_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container_image_uri][crate::model::VertexModelSpec::container_image_uri].
    pub fn set_container_image_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_image_uri = v.into();
        self
    }
}

impl wkt::message::Message for VertexModelSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexModelSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexModelSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version_id,
            __version_aliases,
            __version_description,
            __vertex_model_source_info,
            __container_image_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexModelSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versionId" => Ok(__FieldTag::__version_id),
                            "version_id" => Ok(__FieldTag::__version_id),
                            "versionAliases" => Ok(__FieldTag::__version_aliases),
                            "version_aliases" => Ok(__FieldTag::__version_aliases),
                            "versionDescription" => Ok(__FieldTag::__version_description),
                            "version_description" => Ok(__FieldTag::__version_description),
                            "vertexModelSourceInfo" => Ok(__FieldTag::__vertex_model_source_info),
                            "vertex_model_source_info" => {
                                Ok(__FieldTag::__vertex_model_source_info)
                            }
                            "containerImageUri" => Ok(__FieldTag::__container_image_uri),
                            "container_image_uri" => Ok(__FieldTag::__container_image_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexModelSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexModelSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version_id => {
                            if !fields.insert(__FieldTag::__version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_id",
                                ));
                            }
                            result.version_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_aliases => {
                            if !fields.insert(__FieldTag::__version_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_aliases",
                                ));
                            }
                            result.version_aliases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__version_description => {
                            if !fields.insert(__FieldTag::__version_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_description",
                                ));
                            }
                            result.version_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vertex_model_source_info => {
                            if !fields.insert(__FieldTag::__vertex_model_source_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_model_source_info",
                                ));
                            }
                            result.vertex_model_source_info = map.next_value::<std::option::Option<crate::model::VertexModelSourceInfo>>()?
                                ;
                        }
                        __FieldTag::__container_image_uri => {
                            if !fields.insert(__FieldTag::__container_image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_image_uri",
                                ));
                            }
                            result.container_image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexModelSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version_id.is_empty() {
            state.serialize_entry("versionId", &self.version_id)?;
        }
        if !self.version_aliases.is_empty() {
            state.serialize_entry("versionAliases", &self.version_aliases)?;
        }
        if !self.version_description.is_empty() {
            state.serialize_entry("versionDescription", &self.version_description)?;
        }
        if self.vertex_model_source_info.is_some() {
            state.serialize_entry("vertexModelSourceInfo", &self.vertex_model_source_info)?;
        }
        if !self.container_image_uri.is_empty() {
            state.serialize_entry("containerImageUri", &self.container_image_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification for vertex dataset resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexDatasetSpec {
    /// The number of DataItems in this Dataset. Only apply for non-structured
    /// Dataset.
    pub data_item_count: i64,

    /// Type of the dataset.
    pub data_type: crate::model::vertex_dataset_spec::DataType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item_count][crate::model::VertexDatasetSpec::data_item_count].
    pub fn set_data_item_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_item_count = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::VertexDatasetSpec::data_type].
    pub fn set_data_type<T: std::convert::Into<crate::model::vertex_dataset_spec::DataType>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_type = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.VertexDatasetSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexDatasetSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_item_count,
            __data_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexDatasetSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataItemCount" => Ok(__FieldTag::__data_item_count),
                            "data_item_count" => Ok(__FieldTag::__data_item_count),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexDatasetSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexDatasetSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_item_count => {
                            if !fields.insert(__FieldTag::__data_item_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_item_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_item_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type =
                                map.next_value::<std::option::Option<
                                    crate::model::vertex_dataset_spec::DataType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexDatasetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.data_item_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataItemCount", &__With(&self.data_item_count))?;
        }
        if !wkt::internal::is_default(&self.data_type) {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VertexDatasetSpec].
pub mod vertex_dataset_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Type of data stored in the dataset.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataType {
        /// Should not be used.
        Unspecified,
        /// Structured data dataset.
        Table,
        /// Image dataset which supports ImageClassification, ImageObjectDetection
        /// and ImageSegmentation problems.
        Image,
        /// Document dataset which supports TextClassification, TextExtraction and
        /// TextSentiment problems.
        Text,
        /// Video dataset which supports VideoClassification, VideoObjectTracking and
        /// VideoActionRecognition problems.
        Video,
        /// Conversation dataset which supports conversation problems.
        Conversation,
        /// TimeSeries dataset.
        TimeSeries,
        /// Document dataset which supports DocumentAnnotation problems.
        Document,
        /// TextToSpeech dataset which supports TextToSpeech problems.
        TextToSpeech,
        /// Translation dataset which supports Translation problems.
        Translation,
        /// Store Vision dataset which is used for HITL integration.
        StoreVision,
        /// Enterprise Knowledge Graph dataset which is used for HITL labeling
        /// integration.
        EnterpriseKnowledgeGraph,
        /// Text prompt dataset which supports Large Language Models.
        TextPrompt,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataType::value] or
        /// [DataType::name].
        UnknownValue(data_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Table => std::option::Option::Some(1),
                Self::Image => std::option::Option::Some(2),
                Self::Text => std::option::Option::Some(3),
                Self::Video => std::option::Option::Some(4),
                Self::Conversation => std::option::Option::Some(5),
                Self::TimeSeries => std::option::Option::Some(6),
                Self::Document => std::option::Option::Some(7),
                Self::TextToSpeech => std::option::Option::Some(8),
                Self::Translation => std::option::Option::Some(9),
                Self::StoreVision => std::option::Option::Some(10),
                Self::EnterpriseKnowledgeGraph => std::option::Option::Some(11),
                Self::TextPrompt => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_TYPE_UNSPECIFIED"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Image => std::option::Option::Some("IMAGE"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Video => std::option::Option::Some("VIDEO"),
                Self::Conversation => std::option::Option::Some("CONVERSATION"),
                Self::TimeSeries => std::option::Option::Some("TIME_SERIES"),
                Self::Document => std::option::Option::Some("DOCUMENT"),
                Self::TextToSpeech => std::option::Option::Some("TEXT_TO_SPEECH"),
                Self::Translation => std::option::Option::Some("TRANSLATION"),
                Self::StoreVision => std::option::Option::Some("STORE_VISION"),
                Self::EnterpriseKnowledgeGraph => {
                    std::option::Option::Some("ENTERPRISE_KNOWLEDGE_GRAPH")
                }
                Self::TextPrompt => std::option::Option::Some("TEXT_PROMPT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Table,
                2 => Self::Image,
                3 => Self::Text,
                4 => Self::Video,
                5 => Self::Conversation,
                6 => Self::TimeSeries,
                7 => Self::Document,
                8 => Self::TextToSpeech,
                9 => Self::Translation,
                10 => Self::StoreVision,
                11 => Self::EnterpriseKnowledgeGraph,
                12 => Self::TextPrompt,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TABLE" => Self::Table,
                "IMAGE" => Self::Image,
                "TEXT" => Self::Text,
                "VIDEO" => Self::Video,
                "CONVERSATION" => Self::Conversation,
                "TIME_SERIES" => Self::TimeSeries,
                "DOCUMENT" => Self::Document,
                "TEXT_TO_SPEECH" => Self::TextToSpeech,
                "TRANSLATION" => Self::Translation,
                "STORE_VISION" => Self::StoreVision,
                "ENTERPRISE_KNOWLEDGE_GRAPH" => Self::EnterpriseKnowledgeGraph,
                "TEXT_PROMPT" => Self::TextPrompt,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Table => serializer.serialize_i32(1),
                Self::Image => serializer.serialize_i32(2),
                Self::Text => serializer.serialize_i32(3),
                Self::Video => serializer.serialize_i32(4),
                Self::Conversation => serializer.serialize_i32(5),
                Self::TimeSeries => serializer.serialize_i32(6),
                Self::Document => serializer.serialize_i32(7),
                Self::TextToSpeech => serializer.serialize_i32(8),
                Self::Translation => serializer.serialize_i32(9),
                Self::StoreVision => serializer.serialize_i32(10),
                Self::EnterpriseKnowledgeGraph => serializer.serialize_i32(11),
                Self::TextPrompt => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataType>::new(
                ".google.cloud.datacatalog.v1.VertexDatasetSpec.DataType",
            ))
        }
    }
}

/// Specification that applies to a model. Valid only for
/// entries with the `MODEL` type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModelSpec {
    /// System spec
    pub system_spec: std::option::Option<crate::model::model_spec::SystemSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system_spec][crate::model::ModelSpec::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::model_spec::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ModelSpec::system_spec]
    /// if it holds a `VertexModelSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_model_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexModelSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::model_spec::SystemSpec::VertexModelSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ModelSpec::system_spec]
    /// to hold a `VertexModelSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_vertex_model_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexModelSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::model_spec::SystemSpec::VertexModelSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ModelSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModelSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModelSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vertex_model_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vertexModelSpec" => Ok(__FieldTag::__vertex_model_spec),
                            "vertex_model_spec" => Ok(__FieldTag::__vertex_model_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModelSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vertex_model_spec => {
                            if !fields.insert(__FieldTag::__vertex_model_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_model_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.ModelSpec.vertex_model_spec, latest field was vertexModelSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::model_spec::SystemSpec::VertexModelSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VertexModelSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModelSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vertex_model_spec() {
            state.serialize_entry("vertexModelSpec", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ModelSpec].
pub mod model_spec {
    #[allow(unused_imports)]
    use super::*;

    /// System spec
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Specification for vertex model resources.
        VertexModelSpec(std::boxed::Box<crate::model::VertexModelSpec>),
    }
}

/// Detail description of the source information of a Vertex Feature Online
/// Store.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FeatureOnlineStoreSpec {
    /// Output only. Type of underlying storage for the FeatureOnlineStore.
    pub storage_type: crate::model::feature_online_store_spec::StorageType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FeatureOnlineStoreSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStoreSpec::storage_type].
    pub fn set_storage_type<
        T: std::convert::Into<crate::model::feature_online_store_spec::StorageType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }
}

impl wkt::message::Message for FeatureOnlineStoreSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FeatureOnlineStoreSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FeatureOnlineStoreSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FeatureOnlineStoreSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storageType" => Ok(__FieldTag::__storage_type),
                            "storage_type" => Ok(__FieldTag::__storage_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FeatureOnlineStoreSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FeatureOnlineStoreSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_type => {
                            if !fields.insert(__FieldTag::__storage_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_type",
                                ));
                            }
                            result.storage_type = map
                                .next_value::<std::option::Option<
                                    crate::model::feature_online_store_spec::StorageType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FeatureOnlineStoreSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.storage_type) {
            state.serialize_entry("storageType", &self.storage_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FeatureOnlineStoreSpec].
pub mod feature_online_store_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Type of underlying storage type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// Should not be used.
        Unspecified,
        /// Underlsying storgae is Bigtable.
        Bigtable,
        /// Underlying is optimized online server (Lightning).
        Optimized,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bigtable => std::option::Option::Some(1),
                Self::Optimized => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Bigtable => std::option::Option::Some("BIGTABLE"),
                Self::Optimized => std::option::Option::Some("OPTIMIZED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bigtable,
                2 => Self::Optimized,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BIGTABLE" => Self::Bigtable,
                "OPTIMIZED" => Self::Optimized,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bigtable => serializer.serialize_i32(1),
                Self::Optimized => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.datacatalog.v1.FeatureOnlineStoreSpec.StorageType",
            ))
        }
    }
}

/// Business Context of the entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BusinessContext {
    /// Entry overview fields for rich text descriptions of entries.
    pub entry_overview: std::option::Option<crate::model::EntryOverview>,

    /// Contact people for the entry.
    pub contacts: std::option::Option<crate::model::Contacts>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BusinessContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_overview][crate::model::BusinessContext::entry_overview].
    pub fn set_entry_overview<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryOverview>,
    {
        self.entry_overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_overview][crate::model::BusinessContext::entry_overview].
    pub fn set_or_clear_entry_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryOverview>,
    {
        self.entry_overview = v.map(|x| x.into());
        self
    }

    /// Sets the value of [contacts][crate::model::BusinessContext::contacts].
    pub fn set_contacts<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Contacts>,
    {
        self.contacts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contacts][crate::model::BusinessContext::contacts].
    pub fn set_or_clear_contacts<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Contacts>,
    {
        self.contacts = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BusinessContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BusinessContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BusinessContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_overview,
            __contacts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BusinessContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryOverview" => Ok(__FieldTag::__entry_overview),
                            "entry_overview" => Ok(__FieldTag::__entry_overview),
                            "contacts" => Ok(__FieldTag::__contacts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BusinessContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BusinessContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_overview => {
                            if !fields.insert(__FieldTag::__entry_overview) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_overview",
                                ));
                            }
                            result.entry_overview = map
                                .next_value::<std::option::Option<crate::model::EntryOverview>>()?;
                        }
                        __FieldTag::__contacts => {
                            if !fields.insert(__FieldTag::__contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contacts",
                                ));
                            }
                            result.contacts =
                                map.next_value::<std::option::Option<crate::model::Contacts>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BusinessContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entry_overview.is_some() {
            state.serialize_entry("entryOverview", &self.entry_overview)?;
        }
        if self.contacts.is_some() {
            state.serialize_entry("contacts", &self.contacts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Entry overview fields for rich text descriptions of entries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntryOverview {
    /// Entry overview with support for rich text.
    ///
    /// The overview must only contain Unicode characters, and should be
    /// formatted using HTML.
    /// The maximum length is 10 MiB as this value holds HTML descriptions
    /// including encoded images. The maximum length of the text without images
    /// is 100 KiB.
    pub overview: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryOverview {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overview][crate::model::EntryOverview::overview].
    pub fn set_overview<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.overview = v.into();
        self
    }
}

impl wkt::message::Message for EntryOverview {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.EntryOverview"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntryOverview {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __overview,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntryOverview")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "overview" => Ok(__FieldTag::__overview),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntryOverview;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntryOverview")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__overview => {
                            if !fields.insert(__FieldTag::__overview) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overview",
                                ));
                            }
                            result.overview = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntryOverview {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.overview.is_empty() {
            state.serialize_entry("overview", &self.overview)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contact people for the entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Contacts {
    /// The list of contact people for the entry.
    pub people: std::vec::Vec<crate::model::contacts::Person>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Contacts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [people][crate::model::Contacts::people].
    pub fn set_people<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::contacts::Person>,
    {
        use std::iter::Iterator;
        self.people = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Contacts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Contacts"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Contacts {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __people,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Contacts")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "people" => Ok(__FieldTag::__people),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Contacts;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Contacts")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__people => {
                            if !fields.insert(__FieldTag::__people) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for people",
                                ));
                            }
                            result.people =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::contacts::Person>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Contacts {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.people.is_empty() {
            state.serialize_entry("people", &self.people)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Contacts].
pub mod contacts {
    #[allow(unused_imports)]
    use super::*;

    /// A contact person for the entry.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Person {
        /// Designation of the person, for example, Data Steward.
        pub designation: std::string::String,

        /// Email of the person in the format of `john.doe@xyz`,
        /// `<john.doe@xyz>`, or `John Doe<john.doe@xyz>`.
        pub email: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Person {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [designation][crate::model::contacts::Person::designation].
        pub fn set_designation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.designation = v.into();
            self
        }

        /// Sets the value of [email][crate::model::contacts::Person::email].
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }
    }

    impl wkt::message::Message for Person {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.Contacts.Person"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Person {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __designation,
                __email,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Person")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "designation" => Ok(__FieldTag::__designation),
                                "email" => Ok(__FieldTag::__email),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Person;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Person")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__designation => {
                                if !fields.insert(__FieldTag::__designation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for designation",
                                    ));
                                }
                                result.designation = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__email => {
                                if !fields.insert(__FieldTag::__email) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for email",
                                    ));
                                }
                                result.email = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Person {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.designation.is_empty() {
                state.serialize_entry("designation", &self.designation)?;
            }
            if !self.email.is_empty() {
                state.serialize_entry("email", &self.email)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Entry group metadata.
///
/// An `EntryGroup` resource represents a logical grouping of zero or more
/// Data Catalog [Entry][google.cloud.datacatalog.v1.Entry] resources.
///
/// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntryGroup {
    /// Identifier. The resource name of the entry group in URL format.
    ///
    /// Note: The entry group itself and its child resources might not be
    /// stored in the location specified in its name.
    pub name: std::string::String,

    /// A short name to identify the entry group, for example,
    /// "analytics data - jan 2011". Default value is an empty string.
    pub display_name: std::string::String,

    /// Entry group description. Can consist of several sentences or
    /// paragraphs that describe the entry group contents.
    /// Default value is an empty string.
    pub description: std::string::String,

    /// Output only. Timestamps of the entry group. Default value is empty.
    pub data_catalog_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Optional. When set to [true], it means DataCatalog EntryGroup was
    /// transferred to Dataplex Catalog Service. It makes EntryGroup and its
    /// Entries to be read-only in DataCatalog. However, new Tags on EntryGroup and
    /// its Entries can be created. After setting the flag to [true] it cannot be
    /// unset.
    pub transferred_to_dataplex: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntryGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntryGroup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntryGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [data_catalog_timestamps][crate::model::EntryGroup::data_catalog_timestamps].
    pub fn set_data_catalog_timestamps<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.data_catalog_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_catalog_timestamps][crate::model::EntryGroup::data_catalog_timestamps].
    pub fn set_or_clear_data_catalog_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.data_catalog_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transferred_to_dataplex][crate::model::EntryGroup::transferred_to_dataplex].
    pub fn set_transferred_to_dataplex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.transferred_to_dataplex = v.into();
        self
    }
}

impl wkt::message::Message for EntryGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.EntryGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntryGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __data_catalog_timestamps,
            __transferred_to_dataplex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntryGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "dataCatalogTimestamps" => Ok(__FieldTag::__data_catalog_timestamps),
                            "data_catalog_timestamps" => Ok(__FieldTag::__data_catalog_timestamps),
                            "transferredToDataplex" => Ok(__FieldTag::__transferred_to_dataplex),
                            "transferred_to_dataplex" => Ok(__FieldTag::__transferred_to_dataplex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntryGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntryGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_catalog_timestamps => {
                            if !fields.insert(__FieldTag::__data_catalog_timestamps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_catalog_timestamps",
                                ));
                            }
                            result.data_catalog_timestamps = map
                                .next_value::<std::option::Option<crate::model::SystemTimestamps>>(
                                )?;
                        }
                        __FieldTag::__transferred_to_dataplex => {
                            if !fields.insert(__FieldTag::__transferred_to_dataplex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transferred_to_dataplex",
                                ));
                            }
                            result.transferred_to_dataplex = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntryGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.data_catalog_timestamps.is_some() {
            state.serialize_entry("dataCatalogTimestamps", &self.data_catalog_timestamps)?;
        }
        if !wkt::internal::is_default(&self.transferred_to_dataplex) {
            state.serialize_entry("transferredToDataplex", &self.transferred_to_dataplex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplate]: crate::client::DataCatalog::create_tag_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTagTemplateRequest {
    /// Required. The name of the project and the template location
    /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
    pub parent: std::string::String,

    /// Required. The ID of the tag template to create.
    ///
    /// The ID must contain only lowercase letters (a-z), numbers (0-9),
    /// or underscores (_), and must start with a letter or underscore.
    /// The maximum size is 64 bytes when encoded in UTF-8.
    pub tag_template_id: std::string::String,

    /// Required. The tag template to create.
    pub tag_template: std::option::Option<crate::model::TagTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template_id][crate::model::CreateTagTemplateRequest::tag_template_id].
    pub fn set_tag_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_template_id = v.into();
        self
    }

    /// Sets the value of [tag_template][crate::model::CreateTagTemplateRequest::tag_template].
    pub fn set_tag_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplate>,
    {
        self.tag_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template][crate::model::CreateTagTemplateRequest::tag_template].
    pub fn set_or_clear_tag_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplate>,
    {
        self.tag_template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTagTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __tag_template_id,
            __tag_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTagTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tagTemplateId" => Ok(__FieldTag::__tag_template_id),
                            "tag_template_id" => Ok(__FieldTag::__tag_template_id),
                            "tagTemplate" => Ok(__FieldTag::__tag_template),
                            "tag_template" => Ok(__FieldTag::__tag_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTagTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTagTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_template_id => {
                            if !fields.insert(__FieldTag::__tag_template_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template_id",
                                ));
                            }
                            result.tag_template_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_template => {
                            if !fields.insert(__FieldTag::__tag_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template",
                                ));
                            }
                            result.tag_template =
                                map.next_value::<std::option::Option<crate::model::TagTemplate>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTagTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.tag_template_id.is_empty() {
            state.serialize_entry("tagTemplateId", &self.tag_template_id)?;
        }
        if self.tag_template.is_some() {
            state.serialize_entry("tagTemplate", &self.tag_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [GetTagTemplate][google.cloud.datacatalog.v1.DataCatalog.GetTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.GetTagTemplate]: crate::client::DataCatalog::get_tag_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTagTemplateRequest {
    /// Required. The name of the tag template to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTagTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetTagTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTagTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTagTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTagTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTagTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTagTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplate]: crate::client::DataCatalog::update_tag_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTagTemplateRequest {
    /// Required. The template to update. The `name` field must be set.
    pub tag_template: std::option::Option<crate::model::TagTemplate>,

    /// Names of fields whose values to overwrite on a tag template. Currently,
    /// only `display_name` and `is_publicly_readable` can be overwritten.
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    ///
    /// Note: Updating the `is_publicly_readable` field may require up to 12
    /// hours to take effect in search results.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_template][crate::model::UpdateTagTemplateRequest::tag_template].
    pub fn set_tag_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplate>,
    {
        self.tag_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template][crate::model::UpdateTagTemplateRequest::tag_template].
    pub fn set_or_clear_tag_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplate>,
    {
        self.tag_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagTemplateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTagTemplateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTagTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tag_template,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTagTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tagTemplate" => Ok(__FieldTag::__tag_template),
                            "tag_template" => Ok(__FieldTag::__tag_template),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTagTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTagTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tag_template => {
                            if !fields.insert(__FieldTag::__tag_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template",
                                ));
                            }
                            result.tag_template =
                                map.next_value::<std::option::Option<crate::model::TagTemplate>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTagTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tag_template.is_some() {
            state.serialize_entry("tagTemplate", &self.tag_template)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeleteTagTemplate][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplate].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplate]: crate::client::DataCatalog::delete_tag_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTagTemplateRequest {
    /// Required. The name of the tag template to delete.
    pub name: std::string::String,

    /// Required. If true, deletes all tags that use this template.
    ///
    /// Currently, `true` is the only supported value.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTagTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteTagTemplateRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTagTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTagTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTagTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTagTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTagTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateTag][google.cloud.datacatalog.v1.DataCatalog.CreateTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTag]: crate::client::DataCatalog::create_tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTagRequest {
    /// Required. The name of the resource to attach this tag to.
    ///
    /// Tags can be attached to entries or entry groups. An entry can have up to
    /// 1000 attached tags.
    ///
    /// Note: The tag and its child resources might not be stored in
    /// the location specified in its name.
    pub parent: std::string::String,

    /// Required. The tag to create.
    pub tag: std::option::Option<crate::model::Tag>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::CreateTagRequest::tag].
    pub fn set_tag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag][crate::model::CreateTagRequest::tag].
    pub fn set_or_clear_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTagRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __tag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTagRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tag" => Ok(__FieldTag::__tag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTagRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTagRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            result.tag =
                                map.next_value::<std::option::Option<crate::model::Tag>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTagRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.tag.is_some() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateTag][google.cloud.datacatalog.v1.DataCatalog.UpdateTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTag]: crate::client::DataCatalog::update_tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTagRequest {
    /// Required. The updated tag. The "name" field must be set.
    pub tag: std::option::Option<crate::model::Tag>,

    /// Names of fields whose values to overwrite on a tag. Currently, a tag has
    /// the only modifiable field with the name `fields`.
    ///
    /// In general, if this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the
    /// request body, their values are emptied.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag][crate::model::UpdateTagRequest::tag].
    pub fn set_tag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag][crate::model::UpdateTagRequest::tag].
    pub fn set_or_clear_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTagRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tag,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTagRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tag" => Ok(__FieldTag::__tag),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTagRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTagRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            result.tag =
                                map.next_value::<std::option::Option<crate::model::Tag>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTagRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tag.is_some() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeleteTag][google.cloud.datacatalog.v1.DataCatalog.DeleteTag].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTag]: crate::client::DataCatalog::delete_tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTagRequest {
    /// Required. The name of the tag to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTagRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTagRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTagRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTagRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTagRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplateField]: crate::client::DataCatalog::create_tag_template_field
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTagTemplateFieldRequest {
    /// Required. The name of the project and the template location
    /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
    pub parent: std::string::String,

    /// Required. The ID of the tag template field to create.
    ///
    /// Note: Adding a required field to an existing template is *not* allowed.
    ///
    /// Field IDs can contain letters (both uppercase and lowercase), numbers
    /// (0-9), underscores (_) and dashes (-). Field IDs must be at least 1
    /// character long and at most 128 characters long. Field IDs must also be
    /// unique within their template.
    pub tag_template_field_id: std::string::String,

    /// Required. The tag template field to create.
    pub tag_template_field: std::option::Option<crate::model::TagTemplateField>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagTemplateFieldRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template_field_id][crate::model::CreateTagTemplateFieldRequest::tag_template_field_id].
    pub fn set_tag_template_field_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template_field_id = v.into();
        self
    }

    /// Sets the value of [tag_template_field][crate::model::CreateTagTemplateFieldRequest::tag_template_field].
    pub fn set_tag_template_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplateField>,
    {
        self.tag_template_field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template_field][crate::model::CreateTagTemplateFieldRequest::tag_template_field].
    pub fn set_or_clear_tag_template_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplateField>,
    {
        self.tag_template_field = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTagTemplateFieldRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTagTemplateFieldRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __tag_template_field_id,
            __tag_template_field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTagTemplateFieldRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tagTemplateFieldId" => Ok(__FieldTag::__tag_template_field_id),
                            "tag_template_field_id" => Ok(__FieldTag::__tag_template_field_id),
                            "tagTemplateField" => Ok(__FieldTag::__tag_template_field),
                            "tag_template_field" => Ok(__FieldTag::__tag_template_field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTagTemplateFieldRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTagTemplateFieldRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_template_field_id => {
                            if !fields.insert(__FieldTag::__tag_template_field_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template_field_id",
                                ));
                            }
                            result.tag_template_field_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_template_field => {
                            if !fields.insert(__FieldTag::__tag_template_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template_field",
                                ));
                            }
                            result.tag_template_field = map
                                .next_value::<std::option::Option<crate::model::TagTemplateField>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTagTemplateFieldRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.tag_template_field_id.is_empty() {
            state.serialize_entry("tagTemplateFieldId", &self.tag_template_field_id)?;
        }
        if self.tag_template_field.is_some() {
            state.serialize_entry("tagTemplateField", &self.tag_template_field)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplateField]: crate::client::DataCatalog::update_tag_template_field
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTagTemplateFieldRequest {
    /// Required. The name of the tag template field.
    pub name: std::string::String,

    /// Required. The template to update.
    pub tag_template_field: std::option::Option<crate::model::TagTemplateField>,

    /// Optional. Names of fields whose values to overwrite on an individual field
    /// of a tag template. The following fields are modifiable:
    ///
    /// * `display_name`
    /// * `type.enum_type`
    /// * `is_required`
    ///
    /// If this parameter is absent or empty, all modifiable fields
    /// are overwritten. If such fields are non-required and omitted in the request
    /// body, their values are emptied with one exception: when updating an enum
    /// type, the provided values are merged with the existing values. Therefore,
    /// enum values can only be added, existing enum values cannot be deleted or
    /// renamed.
    ///
    /// Additionally, updating a template field from optional to required is
    /// *not* allowed.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tag_template_field][crate::model::UpdateTagTemplateFieldRequest::tag_template_field].
    pub fn set_tag_template_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplateField>,
    {
        self.tag_template_field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_template_field][crate::model::UpdateTagTemplateFieldRequest::tag_template_field].
    pub fn set_or_clear_tag_template_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TagTemplateField>,
    {
        self.tag_template_field = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagTemplateFieldRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTagTemplateFieldRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTagTemplateFieldRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTagTemplateFieldRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __tag_template_field,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTagTemplateFieldRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "tagTemplateField" => Ok(__FieldTag::__tag_template_field),
                            "tag_template_field" => Ok(__FieldTag::__tag_template_field),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTagTemplateFieldRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTagTemplateFieldRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_template_field => {
                            if !fields.insert(__FieldTag::__tag_template_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template_field",
                                ));
                            }
                            result.tag_template_field = map
                                .next_value::<std::option::Option<crate::model::TagTemplateField>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTagTemplateFieldRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.tag_template_field.is_some() {
            state.serialize_entry("tagTemplateField", &self.tag_template_field)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [RenameTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateField]: crate::client::DataCatalog::rename_tag_template_field
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameTagTemplateFieldRequest {
    /// Required. The name of the tag template field.
    pub name: std::string::String,

    /// Required. The new ID of this tag template field. For example,
    /// `my_new_field`.
    pub new_tag_template_field_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_tag_template_field_id][crate::model::RenameTagTemplateFieldRequest::new_tag_template_field_id].
    pub fn set_new_tag_template_field_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_tag_template_field_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RenameTagTemplateFieldRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenameTagTemplateFieldRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __new_tag_template_field_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RenameTagTemplateFieldRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "newTagTemplateFieldId" => Ok(__FieldTag::__new_tag_template_field_id),
                            "new_tag_template_field_id" => {
                                Ok(__FieldTag::__new_tag_template_field_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenameTagTemplateFieldRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenameTagTemplateFieldRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_tag_template_field_id => {
                            if !fields.insert(__FieldTag::__new_tag_template_field_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_tag_template_field_id",
                                ));
                            }
                            result.new_tag_template_field_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenameTagTemplateFieldRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.new_tag_template_field_id.is_empty() {
            state.serialize_entry("newTagTemplateFieldId", &self.new_tag_template_field_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [RenameTagTemplateFieldEnumValue][google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateFieldEnumValue].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateFieldEnumValue]: crate::client::DataCatalog::rename_tag_template_field_enum_value
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameTagTemplateFieldEnumValueRequest {
    /// Required. The name of the enum field value.
    pub name: std::string::String,

    /// Required. The new display name of the enum value. For example,
    /// `my_new_enum_value`.
    pub new_enum_value_display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameTagTemplateFieldEnumValueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameTagTemplateFieldEnumValueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_enum_value_display_name][crate::model::RenameTagTemplateFieldEnumValueRequest::new_enum_value_display_name].
    pub fn set_new_enum_value_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_enum_value_display_name = v.into();
        self
    }
}

impl wkt::message::Message for RenameTagTemplateFieldEnumValueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RenameTagTemplateFieldEnumValueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenameTagTemplateFieldEnumValueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __new_enum_value_display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for RenameTagTemplateFieldEnumValueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "newEnumValueDisplayName" => {
                                Ok(__FieldTag::__new_enum_value_display_name)
                            }
                            "new_enum_value_display_name" => {
                                Ok(__FieldTag::__new_enum_value_display_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenameTagTemplateFieldEnumValueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenameTagTemplateFieldEnumValueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_enum_value_display_name => {
                            if !fields.insert(__FieldTag::__new_enum_value_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_enum_value_display_name",
                                ));
                            }
                            result.new_enum_value_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenameTagTemplateFieldEnumValueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.new_enum_value_display_name.is_empty() {
            state.serialize_entry("newEnumValueDisplayName", &self.new_enum_value_display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeleteTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplateField].
///
/// [google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplateField]: crate::client::DataCatalog::delete_tag_template_field
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTagTemplateFieldRequest {
    /// Required. The name of the tag template field to delete.
    pub name: std::string::String,

    /// Required. If true, deletes this field from any tags that use it.
    ///
    /// Currently, `true` is the only supported value.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTagTemplateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagTemplateFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteTagTemplateFieldRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagTemplateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTagTemplateFieldRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTagTemplateFieldRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTagTemplateFieldRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTagTemplateFieldRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTagTemplateFieldRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTagTemplateFieldRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTagsRequest {
    /// Required. The name of the Data Catalog resource to list the tags of.
    ///
    /// The resource can be an [Entry][google.cloud.datacatalog.v1.Entry]
    /// or an [EntryGroup][google.cloud.datacatalog.v1.EntryGroup]
    /// (without `/entries/{entries}` at the end).
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    /// [google.cloud.datacatalog.v1.EntryGroup]: crate::model::EntryGroup
    pub parent: std::string::String,

    /// The maximum number of tags to return. Default is 10. Maximum limit is 1000.
    pub page_size: i32,

    /// Pagination token that specifies the next page to return. If empty, the
    /// first page is returned.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTagsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTagsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTagsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTagsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTagsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTagsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTagsResponse {
    /// [Tag][google.cloud.datacatalog.v1.Tag] details.
    ///
    /// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// Pagination token of the next results page. Empty if there are
    /// no more items in results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tags][crate::model::ListTagsResponse::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTagsResponse {
    type PageItem = crate::model::Tag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTagsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tags,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTagsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tags" => Ok(__FieldTag::__tags),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTagsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTagsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTagsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReconcileTagsRequest {
    /// Required. Name of [Entry][google.cloud.datacatalog.v1.Entry] to be tagged.
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    pub parent: std::string::String,

    /// Required. The name of the tag template, which is used for reconciliation.
    pub tag_template: std::string::String,

    /// If set to `true`, deletes entry tags related to a tag template
    /// not listed in the tags source from an entry. If set to `false`,
    /// unlisted tags are retained.
    pub force_delete_missing: bool,

    /// A list of tags to apply to an entry. A tag can specify a
    /// tag template, which must be the template specified in the
    /// `ReconcileTagsRequest`.
    /// The sole entry and each of its columns must be mentioned at most once.
    pub tags: std::vec::Vec<crate::model::Tag>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconcileTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReconcileTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_template][crate::model::ReconcileTagsRequest::tag_template].
    pub fn set_tag_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_template = v.into();
        self
    }

    /// Sets the value of [force_delete_missing][crate::model::ReconcileTagsRequest::force_delete_missing].
    pub fn set_force_delete_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_delete_missing = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::ReconcileTagsRequest::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReconcileTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReconcileTagsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __tag_template,
            __force_delete_missing,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReconcileTagsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tagTemplate" => Ok(__FieldTag::__tag_template),
                            "tag_template" => Ok(__FieldTag::__tag_template),
                            "forceDeleteMissing" => Ok(__FieldTag::__force_delete_missing),
                            "force_delete_missing" => Ok(__FieldTag::__force_delete_missing),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReconcileTagsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReconcileTagsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_template => {
                            if !fields.insert(__FieldTag::__tag_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template",
                                ));
                            }
                            result.tag_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force_delete_missing => {
                            if !fields.insert(__FieldTag::__force_delete_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force_delete_missing",
                                ));
                            }
                            result.force_delete_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReconcileTagsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.tag_template.is_empty() {
            state.serialize_entry("tagTemplate", &self.tag_template)?;
        }
        if !wkt::internal::is_default(&self.force_delete_missing) {
            state.serialize_entry("forceDeleteMissing", &self.force_delete_missing)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// [Long-running operation][google.longrunning.Operation]
/// response message returned by
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReconcileTagsResponse {
    /// Number of tags created in the request.
    pub created_tags_count: i64,

    /// Number of tags updated in the request.
    pub updated_tags_count: i64,

    /// Number of tags deleted in the request.
    pub deleted_tags_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconcileTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_tags_count][crate::model::ReconcileTagsResponse::created_tags_count].
    pub fn set_created_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.created_tags_count = v.into();
        self
    }

    /// Sets the value of [updated_tags_count][crate::model::ReconcileTagsResponse::updated_tags_count].
    pub fn set_updated_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.updated_tags_count = v.into();
        self
    }

    /// Sets the value of [deleted_tags_count][crate::model::ReconcileTagsResponse::deleted_tags_count].
    pub fn set_deleted_tags_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.deleted_tags_count = v.into();
        self
    }
}

impl wkt::message::Message for ReconcileTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReconcileTagsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __created_tags_count,
            __updated_tags_count,
            __deleted_tags_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReconcileTagsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createdTagsCount" => Ok(__FieldTag::__created_tags_count),
                            "created_tags_count" => Ok(__FieldTag::__created_tags_count),
                            "updatedTagsCount" => Ok(__FieldTag::__updated_tags_count),
                            "updated_tags_count" => Ok(__FieldTag::__updated_tags_count),
                            "deletedTagsCount" => Ok(__FieldTag::__deleted_tags_count),
                            "deleted_tags_count" => Ok(__FieldTag::__deleted_tags_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReconcileTagsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReconcileTagsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__created_tags_count => {
                            if !fields.insert(__FieldTag::__created_tags_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for created_tags_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.created_tags_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__updated_tags_count => {
                            if !fields.insert(__FieldTag::__updated_tags_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for updated_tags_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.updated_tags_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__deleted_tags_count => {
                            if !fields.insert(__FieldTag::__deleted_tags_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted_tags_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.deleted_tags_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReconcileTagsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.created_tags_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("createdTagsCount", &__With(&self.created_tags_count))?;
        }
        if !wkt::internal::is_default(&self.updated_tags_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("updatedTagsCount", &__With(&self.updated_tags_count))?;
        }
        if !wkt::internal::is_default(&self.deleted_tags_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("deletedTagsCount", &__With(&self.deleted_tags_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// [Long-running operation][google.longrunning.Operation]
/// metadata message returned by the
/// [ReconcileTags][google.cloud.datacatalog.v1.DataCatalog.ReconcileTags].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ReconcileTags]: crate::client::DataCatalog::reconcile_tags
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReconcileTagsMetadata {
    /// State of the reconciliation operation.
    pub state: crate::model::reconcile_tags_metadata::ReconciliationState,

    /// Maps the name of each tagged column (or empty string for a
    /// sole entry) to tagging operation [status][google.rpc.Status].
    ///
    /// [google.rpc.Status]: rpc::model::Status
    pub errors: std::collections::HashMap<std::string::String, rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconcileTagsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ReconcileTagsMetadata::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::reconcile_tags_metadata::ReconciliationState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ReconcileTagsMetadata::errors].
    pub fn set_errors<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ReconcileTagsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReconcileTagsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReconcileTagsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReconcileTagsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReconcileTagsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReconcileTagsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::reconcile_tags_metadata::ReconciliationState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        rpc::model::Status,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReconcileTagsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReconcileTagsMetadata].
pub mod reconcile_tags_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum holding possible states of the reconciliation operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReconciliationState {
        /// Default value. This value is unused.
        Unspecified,
        /// The reconciliation has been queued and awaits for execution.
        ReconciliationQueued,
        /// The reconciliation is in progress.
        ReconciliationInProgress,
        /// The reconciliation has been finished.
        ReconciliationDone,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReconciliationState::value] or
        /// [ReconciliationState::name].
        UnknownValue(reconciliation_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reconciliation_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReconciliationState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReconciliationQueued => std::option::Option::Some(1),
                Self::ReconciliationInProgress => std::option::Option::Some(2),
                Self::ReconciliationDone => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECONCILIATION_STATE_UNSPECIFIED"),
                Self::ReconciliationQueued => std::option::Option::Some("RECONCILIATION_QUEUED"),
                Self::ReconciliationInProgress => {
                    std::option::Option::Some("RECONCILIATION_IN_PROGRESS")
                }
                Self::ReconciliationDone => std::option::Option::Some("RECONCILIATION_DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReconciliationState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReconciliationState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReconciliationState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReconciliationQueued,
                2 => Self::ReconciliationInProgress,
                3 => Self::ReconciliationDone,
                _ => Self::UnknownValue(reconciliation_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReconciliationState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECONCILIATION_STATE_UNSPECIFIED" => Self::Unspecified,
                "RECONCILIATION_QUEUED" => Self::ReconciliationQueued,
                "RECONCILIATION_IN_PROGRESS" => Self::ReconciliationInProgress,
                "RECONCILIATION_DONE" => Self::ReconciliationDone,
                _ => Self::UnknownValue(reconciliation_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReconciliationState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReconciliationQueued => serializer.serialize_i32(1),
                Self::ReconciliationInProgress => serializer.serialize_i32(2),
                Self::ReconciliationDone => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReconciliationState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReconciliationState>::new(
                ".google.cloud.datacatalog.v1.ReconcileTagsMetadata.ReconciliationState",
            ))
        }
    }
}

/// Request message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntries]: crate::client::DataCatalog::list_entries
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntriesRequest {
    /// Required. The name of the entry group that contains the entries to list.
    ///
    /// Can be provided in URL format.
    pub parent: std::string::String,

    /// The maximum number of items to return. Default is 10. Maximum limit is
    /// 1000. Throws an invalid argument if `page_size` is more than 1000.
    pub page_size: i32,

    /// Pagination token that specifies the next page to return. If empty, the
    /// first page is returned.
    pub page_token: std::string::String,

    /// The fields to return for each entry. If empty or omitted, all
    /// fields are returned.
    ///
    /// For example, to return a list of entries with only the `name` field,
    /// set `read_mask` to only one path with the `name` value.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListEntriesRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListEntriesRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ListEntries]: crate::client::DataCatalog::list_entries
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntriesResponse {
    /// Entry details.
    pub entries: std::vec::Vec<crate::model::Entry>,

    /// Pagination token of the next results page. Empty if there are no more items
    /// in results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::ListEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntriesResponse {
    type PageItem = crate::model::Entry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [StarEntry][google.cloud.datacatalog.v1.DataCatalog.StarEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.StarEntry]: crate::client::DataCatalog::star_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StarEntryRequest {
    /// Required. The name of the entry to mark as starred.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StarEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StarEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StarEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StarEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StarEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StarEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StarEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StarEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StarEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [StarEntry][google.cloud.datacatalog.v1.DataCatalog.StarEntry].
/// Empty for now
///
/// [google.cloud.datacatalog.v1.DataCatalog.StarEntry]: crate::client::DataCatalog::star_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StarEntryResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StarEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StarEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.StarEntryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StarEntryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StarEntryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StarEntryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StarEntryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StarEntryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UnstarEntry][google.cloud.datacatalog.v1.DataCatalog.UnstarEntry].
///
/// [google.cloud.datacatalog.v1.DataCatalog.UnstarEntry]: crate::client::DataCatalog::unstar_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UnstarEntryRequest {
    /// Required. The name of the entry to mark as **not** starred.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnstarEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UnstarEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UnstarEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UnstarEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UnstarEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnstarEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UnstarEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnstarEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UnstarEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [UnstarEntry][google.cloud.datacatalog.v1.DataCatalog.UnstarEntry].
/// Empty for now
///
/// [google.cloud.datacatalog.v1.DataCatalog.UnstarEntry]: crate::client::DataCatalog::unstar_entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UnstarEntryResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnstarEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UnstarEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UnstarEntryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UnstarEntryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnstarEntryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UnstarEntryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnstarEntryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UnstarEntryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries]
/// method.
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntriesRequest {
    /// Required. Target entry group for ingested entries.
    pub parent: std::string::String,

    /// Optional. (Optional) Dataplex task job id, if specified will be used as
    /// part of ImportEntries LRO ID
    pub job_id: std::string::String,

    /// Source of imported entries, e.g. dump stored in a Cloud Storage
    pub source: std::option::Option<crate::model::import_entries_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::ImportEntriesRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportEntriesRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_entries_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportEntriesRequest::source]
    /// if it holds a `GcsBucketPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_bucket_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_entries_request::Source::GcsBucketPath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportEntriesRequest::source]
    /// to hold a `GcsBucketPath`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_bucket_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_entries_request::Source::GcsBucketPath(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __gcs_bucket_path,
            __job_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "gcsBucketPath" => Ok(__FieldTag::__gcs_bucket_path),
                            "gcs_bucket_path" => Ok(__FieldTag::__gcs_bucket_path),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_bucket_path => {
                            if !fields.insert(__FieldTag::__gcs_bucket_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_bucket_path",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.datacatalog.v1.ImportEntriesRequest.gcs_bucket_path, latest field was gcsBucketPath",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_entries_request::Source::GcsBucketPath(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.gcs_bucket_path() {
            state.serialize_entry("gcsBucketPath", value)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportEntriesRequest].
pub mod import_entries_request {
    #[allow(unused_imports)]
    use super::*;

    /// Source of imported entries, e.g. dump stored in a Cloud Storage
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Path to a Cloud Storage bucket that contains a dump ready for ingestion.
        GcsBucketPath(std::string::String),
    }
}

/// Response message for [long-running operation][google.longrunning.Operation]
/// returned by the
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntriesResponse {
    /// Cumulative number of entries created and entries updated as a result of
    /// import operation.
    pub upserted_entries_count: std::option::Option<i64>,

    /// Number of entries deleted as a result of import operation.
    pub deleted_entries_count: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upserted_entries_count][crate::model::ImportEntriesResponse::upserted_entries_count].
    pub fn set_upserted_entries_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.upserted_entries_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upserted_entries_count][crate::model::ImportEntriesResponse::upserted_entries_count].
    pub fn set_or_clear_upserted_entries_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.upserted_entries_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted_entries_count][crate::model::ImportEntriesResponse::deleted_entries_count].
    pub fn set_deleted_entries_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.deleted_entries_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted_entries_count][crate::model::ImportEntriesResponse::deleted_entries_count].
    pub fn set_or_clear_deleted_entries_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.deleted_entries_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __upserted_entries_count,
            __deleted_entries_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "upsertedEntriesCount" => Ok(__FieldTag::__upserted_entries_count),
                            "upserted_entries_count" => Ok(__FieldTag::__upserted_entries_count),
                            "deletedEntriesCount" => Ok(__FieldTag::__deleted_entries_count),
                            "deleted_entries_count" => Ok(__FieldTag::__deleted_entries_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__upserted_entries_count => {
                            if !fields.insert(__FieldTag::__upserted_entries_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upserted_entries_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.upserted_entries_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__deleted_entries_count => {
                            if !fields.insert(__FieldTag::__deleted_entries_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted_entries_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.deleted_entries_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.upserted_entries_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "upsertedEntriesCount",
                &__With(&self.upserted_entries_count),
            )?;
        }
        if self.deleted_entries_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("deletedEntriesCount", &__With(&self.deleted_entries_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata message for [long-running operation][google.longrunning.Operation]
/// returned by the
/// [ImportEntries][google.cloud.datacatalog.v1.DataCatalog.ImportEntries].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ImportEntries]: crate::client::DataCatalog::import_entries
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntriesMetadata {
    /// State of the import operation.
    pub state: crate::model::import_entries_metadata::ImportState,

    /// Partial errors that are encountered during the ImportEntries operation.
    /// There is no guarantee that all the encountered errors are reported.
    /// However, if no errors are reported, it means that no errors were
    /// encountered.
    pub errors: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ImportEntriesMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_entries_metadata::ImportState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ImportEntriesMetadata::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportEntriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportEntriesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntriesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntriesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntriesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntriesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::import_entries_metadata::ImportState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportEntriesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportEntriesMetadata].
pub mod import_entries_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enum holding possible states of the import operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportState {
        /// Default value. This value is unused.
        Unspecified,
        /// The dump with entries has been queued for import.
        ImportQueued,
        /// The import of entries is in progress.
        ImportInProgress,
        /// The import of entries has been finished.
        ImportDone,
        /// The import of entries has been abandoned in favor of a newer request.
        ImportObsolete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ImportState::value] or
        /// [ImportState::name].
        UnknownValue(import_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod import_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ImportState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ImportQueued => std::option::Option::Some(1),
                Self::ImportInProgress => std::option::Option::Some(2),
                Self::ImportDone => std::option::Option::Some(3),
                Self::ImportObsolete => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPORT_STATE_UNSPECIFIED"),
                Self::ImportQueued => std::option::Option::Some("IMPORT_QUEUED"),
                Self::ImportInProgress => std::option::Option::Some("IMPORT_IN_PROGRESS"),
                Self::ImportDone => std::option::Option::Some("IMPORT_DONE"),
                Self::ImportObsolete => std::option::Option::Some("IMPORT_OBSOLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ImportState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ImportState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ImportState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ImportQueued,
                2 => Self::ImportInProgress,
                3 => Self::ImportDone,
                4 => Self::ImportObsolete,
                _ => Self::UnknownValue(import_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ImportState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPORT_STATE_UNSPECIFIED" => Self::Unspecified,
                "IMPORT_QUEUED" => Self::ImportQueued,
                "IMPORT_IN_PROGRESS" => Self::ImportInProgress,
                "IMPORT_DONE" => Self::ImportDone,
                "IMPORT_OBSOLETE" => Self::ImportObsolete,
                _ => Self::UnknownValue(import_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ImportState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ImportQueued => serializer.serialize_i32(1),
                Self::ImportInProgress => serializer.serialize_i32(2),
                Self::ImportDone => serializer.serialize_i32(3),
                Self::ImportObsolete => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ImportState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportState>::new(
                ".google.cloud.datacatalog.v1.ImportEntriesMetadata.ImportState",
            ))
        }
    }
}

/// Request message for
/// [ModifyEntryOverview][google.cloud.datacatalog.v1.DataCatalog.ModifyEntryOverview].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ModifyEntryOverview]: crate::client::DataCatalog::modify_entry_overview
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyEntryOverviewRequest {
    /// Required. The full resource name of the entry.
    pub name: std::string::String,

    /// Required. The new value for the Entry Overview.
    pub entry_overview: std::option::Option<crate::model::EntryOverview>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyEntryOverviewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyEntryOverviewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [entry_overview][crate::model::ModifyEntryOverviewRequest::entry_overview].
    pub fn set_entry_overview<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntryOverview>,
    {
        self.entry_overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_overview][crate::model::ModifyEntryOverviewRequest::entry_overview].
    pub fn set_or_clear_entry_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntryOverview>,
    {
        self.entry_overview = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ModifyEntryOverviewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModifyEntryOverviewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModifyEntryOverviewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __entry_overview,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModifyEntryOverviewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "entryOverview" => Ok(__FieldTag::__entry_overview),
                            "entry_overview" => Ok(__FieldTag::__entry_overview),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModifyEntryOverviewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModifyEntryOverviewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_overview => {
                            if !fields.insert(__FieldTag::__entry_overview) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_overview",
                                ));
                            }
                            result.entry_overview = map
                                .next_value::<std::option::Option<crate::model::EntryOverview>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModifyEntryOverviewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.entry_overview.is_some() {
            state.serialize_entry("entryOverview", &self.entry_overview)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ModifyEntryContacts][google.cloud.datacatalog.v1.DataCatalog.ModifyEntryContacts].
///
/// [google.cloud.datacatalog.v1.DataCatalog.ModifyEntryContacts]: crate::client::DataCatalog::modify_entry_contacts
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyEntryContactsRequest {
    /// Required. The full resource name of the entry.
    pub name: std::string::String,

    /// Required. The new value for the Contacts.
    pub contacts: std::option::Option<crate::model::Contacts>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyEntryContactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyEntryContactsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [contacts][crate::model::ModifyEntryContactsRequest::contacts].
    pub fn set_contacts<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Contacts>,
    {
        self.contacts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contacts][crate::model::ModifyEntryContactsRequest::contacts].
    pub fn set_or_clear_contacts<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Contacts>,
    {
        self.contacts = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ModifyEntryContactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ModifyEntryContactsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModifyEntryContactsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __contacts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModifyEntryContactsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "contacts" => Ok(__FieldTag::__contacts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModifyEntryContactsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModifyEntryContactsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contacts => {
                            if !fields.insert(__FieldTag::__contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contacts",
                                ));
                            }
                            result.contacts =
                                map.next_value::<std::option::Option<crate::model::Contacts>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModifyEntryContactsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.contacts.is_some() {
            state.serialize_entry("contacts", &self.contacts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SetConfig][google.cloud.datacatalog.v1.DataCatalog.SetConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.SetConfig]: crate::client::DataCatalog::set_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SetConfigRequest {
    /// Required. The organization or project whose config is being specified.
    pub name: std::string::String,

    /// The configuration field to set.
    pub configuration: std::option::Option<crate::model::set_config_request::Configuration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration].
    ///
    /// Note that all the setters affecting `configuration` are mutually
    /// exclusive.
    pub fn set_configuration<
        T: std::convert::Into<std::option::Option<crate::model::set_config_request::Configuration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = v.into();
        self
    }

    /// The value of [configuration][crate::model::SetConfigRequest::configuration]
    /// if it holds a `TagTemplateMigration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag_template_migration(
        &self,
    ) -> std::option::Option<&crate::model::TagTemplateMigration> {
        #[allow(unreachable_patterns)]
        self.configuration.as_ref().and_then(|v| match v {
            crate::model::set_config_request::Configuration::TagTemplateMigration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration]
    /// to hold a `TagTemplateMigration`.
    ///
    /// Note that all the setters affecting `configuration` are
    /// mutually exclusive.
    pub fn set_tag_template_migration<T: std::convert::Into<crate::model::TagTemplateMigration>>(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = std::option::Option::Some(
            crate::model::set_config_request::Configuration::TagTemplateMigration(v.into()),
        );
        self
    }

    /// The value of [configuration][crate::model::SetConfigRequest::configuration]
    /// if it holds a `CatalogUiExperience`, `None` if the field is not set or
    /// holds a different branch.
    pub fn catalog_ui_experience(&self) -> std::option::Option<&crate::model::CatalogUIExperience> {
        #[allow(unreachable_patterns)]
        self.configuration.as_ref().and_then(|v| match v {
            crate::model::set_config_request::Configuration::CatalogUiExperience(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [configuration][crate::model::SetConfigRequest::configuration]
    /// to hold a `CatalogUiExperience`.
    ///
    /// Note that all the setters affecting `configuration` are
    /// mutually exclusive.
    pub fn set_catalog_ui_experience<T: std::convert::Into<crate::model::CatalogUIExperience>>(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = std::option::Option::Some(
            crate::model::set_config_request::Configuration::CatalogUiExperience(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __tag_template_migration,
            __catalog_ui_experience,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "tagTemplateMigration" => Ok(__FieldTag::__tag_template_migration),
                            "tag_template_migration" => Ok(__FieldTag::__tag_template_migration),
                            "catalogUiExperience" => Ok(__FieldTag::__catalog_ui_experience),
                            "catalog_ui_experience" => Ok(__FieldTag::__catalog_ui_experience),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_template_migration => {
                            if !fields.insert(__FieldTag::__tag_template_migration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template_migration",
                                ));
                            }
                            if result.configuration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `configuration`, a oneof with full ID .google.cloud.datacatalog.v1.SetConfigRequest.tag_template_migration, latest field was tagTemplateMigration",
                                ));
                            }
                            result.configuration = std::option::Option::Some(
                                crate::model::set_config_request::Configuration::TagTemplateMigration(
                                    map.next_value::<std::option::Option<crate::model::TagTemplateMigration>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__catalog_ui_experience => {
                            if !fields.insert(__FieldTag::__catalog_ui_experience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog_ui_experience",
                                ));
                            }
                            if result.configuration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `configuration`, a oneof with full ID .google.cloud.datacatalog.v1.SetConfigRequest.catalog_ui_experience, latest field was catalogUiExperience",
                                ));
                            }
                            result.configuration = std::option::Option::Some(
                                crate::model::set_config_request::Configuration::CatalogUiExperience(
                                    map.next_value::<std::option::Option<crate::model::CatalogUIExperience>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.tag_template_migration() {
            state.serialize_entry("tagTemplateMigration", value)?;
        }
        if let Some(value) = self.catalog_ui_experience() {
            state.serialize_entry("catalogUiExperience", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SetConfigRequest].
pub mod set_config_request {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration field to set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Configuration {
        /// Opt-in status for the migration of Tag Templates to Dataplex.
        TagTemplateMigration(crate::model::TagTemplateMigration),
        /// Opt-in status for the UI switch to Dataplex.
        CatalogUiExperience(crate::model::CatalogUIExperience),
    }
}

/// Request message for
/// [RetrieveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig]: crate::client::DataCatalog::retrieve_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveConfigRequest {
    /// Required. The organization whose config is being retrieved.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetrieveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RetrieveConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetrieveConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetrieveConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetrieveConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetrieveConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetrieveConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [RetrieveEffectiveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig]: crate::client::DataCatalog::retrieve_effective_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveEffectiveConfigRequest {
    /// Required. The resource whose effective config is being retrieved.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveEffectiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetrieveEffectiveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveEffectiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.RetrieveEffectiveConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetrieveEffectiveConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetrieveEffectiveConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetrieveEffectiveConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetrieveEffectiveConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetrieveEffectiveConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The configuration related to the migration from Data Catalog to Dataplex that
/// has been applied to an organization and any projects under it. It is the
/// response message for
/// [RetrieveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveConfig]: crate::client::DataCatalog::retrieve_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OrganizationConfig {
    /// Map of organizations and project resource names and their configuration.
    /// The format for the map keys is `organizations/{organizationId}` or
    /// `projects/{projectId}`.
    pub config: std::collections::HashMap<std::string::String, crate::model::MigrationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrganizationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::OrganizationConfig::config].
    pub fn set_config<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::MigrationConfig>,
    {
        use std::iter::Iterator;
        self.config = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for OrganizationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.OrganizationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OrganizationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OrganizationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OrganizationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OrganizationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::MigrationConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OrganizationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.config.is_empty() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The configuration related to the migration to Dataplex applied to an
/// organization or project.
/// It is the response message for
/// [SetConfig][google.cloud.datacatalog.v1.DataCatalog.SetConfig] and
/// [RetrieveEffectiveConfig][google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig].
///
/// [google.cloud.datacatalog.v1.DataCatalog.RetrieveEffectiveConfig]: crate::client::DataCatalog::retrieve_effective_config
/// [google.cloud.datacatalog.v1.DataCatalog.SetConfig]: crate::client::DataCatalog::set_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationConfig {
    /// Opt-in status for the migration of Tag Templates to Dataplex.
    pub tag_template_migration: crate::model::TagTemplateMigration,

    /// Opt-in status for the UI switch to Dataplex.
    pub catalog_ui_experience: crate::model::CatalogUIExperience,

    /// The time when the Tag Template migration was enabled.
    /// If the Tag Template migration is not enabled, this field is not set.
    pub template_migration_enabled_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_template_migration][crate::model::MigrationConfig::tag_template_migration].
    pub fn set_tag_template_migration<T: std::convert::Into<crate::model::TagTemplateMigration>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag_template_migration = v.into();
        self
    }

    /// Sets the value of [catalog_ui_experience][crate::model::MigrationConfig::catalog_ui_experience].
    pub fn set_catalog_ui_experience<T: std::convert::Into<crate::model::CatalogUIExperience>>(
        mut self,
        v: T,
    ) -> Self {
        self.catalog_ui_experience = v.into();
        self
    }

    /// Sets the value of [template_migration_enabled_time][crate::model::MigrationConfig::template_migration_enabled_time].
    pub fn set_template_migration_enabled_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.template_migration_enabled_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template_migration_enabled_time][crate::model::MigrationConfig::template_migration_enabled_time].
    pub fn set_or_clear_template_migration_enabled_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.template_migration_enabled_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.MigrationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tag_template_migration,
            __catalog_ui_experience,
            __template_migration_enabled_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tagTemplateMigration" => Ok(__FieldTag::__tag_template_migration),
                            "tag_template_migration" => Ok(__FieldTag::__tag_template_migration),
                            "catalogUiExperience" => Ok(__FieldTag::__catalog_ui_experience),
                            "catalog_ui_experience" => Ok(__FieldTag::__catalog_ui_experience),
                            "templateMigrationEnabledTime" => {
                                Ok(__FieldTag::__template_migration_enabled_time)
                            }
                            "template_migration_enabled_time" => {
                                Ok(__FieldTag::__template_migration_enabled_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tag_template_migration => {
                            if !fields.insert(__FieldTag::__tag_template_migration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_template_migration",
                                ));
                            }
                            result.tag_template_migration = map.next_value::<std::option::Option<crate::model::TagTemplateMigration>>()?.unwrap_or_default();
                        }
                        __FieldTag::__catalog_ui_experience => {
                            if !fields.insert(__FieldTag::__catalog_ui_experience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog_ui_experience",
                                ));
                            }
                            result.catalog_ui_experience = map.next_value::<std::option::Option<crate::model::CatalogUIExperience>>()?.unwrap_or_default();
                        }
                        __FieldTag::__template_migration_enabled_time => {
                            if !fields.insert(__FieldTag::__template_migration_enabled_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_migration_enabled_time",
                                ));
                            }
                            result.template_migration_enabled_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.tag_template_migration) {
            state.serialize_entry("tagTemplateMigration", &self.tag_template_migration)?;
        }
        if !wkt::internal::is_default(&self.catalog_ui_experience) {
            state.serialize_entry("catalogUiExperience", &self.catalog_ui_experience)?;
        }
        if self.template_migration_enabled_time.is_some() {
            state.serialize_entry(
                "templateMigrationEnabledTime",
                &self.template_migration_enabled_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Common Dataplex fields.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexSpec {
    /// Fully qualified resource name of an asset in Dataplex, to which the
    /// underlying data source (Cloud Storage bucket or BigQuery dataset) of the
    /// entity is attached.
    pub asset: std::string::String,

    /// Format of the data.
    pub data_format: std::option::Option<crate::model::PhysicalSchema>,

    /// Compression format of the data, e.g., zip, gzip etc.
    pub compression_format: std::string::String,

    /// Project ID of the underlying Cloud Storage or BigQuery data. Note that
    /// this may not be the same project as the correspondingly Dataplex lake /
    /// zone / asset.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset][crate::model::DataplexSpec::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::DataplexSpec::data_format].
    pub fn set_data_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhysicalSchema>,
    {
        self.data_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_format][crate::model::DataplexSpec::data_format].
    pub fn set_or_clear_data_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhysicalSchema>,
    {
        self.data_format = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compression_format][crate::model::DataplexSpec::compression_format].
    pub fn set_compression_format<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.compression_format = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DataplexSpec::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for DataplexSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataplexSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __asset,
            __data_format,
            __compression_format,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataplexSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "asset" => Ok(__FieldTag::__asset),
                            "dataFormat" => Ok(__FieldTag::__data_format),
                            "data_format" => Ok(__FieldTag::__data_format),
                            "compressionFormat" => Ok(__FieldTag::__compression_format),
                            "compression_format" => Ok(__FieldTag::__compression_format),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataplexSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataplexSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_format => {
                            if !fields.insert(__FieldTag::__data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_format",
                                ));
                            }
                            result.data_format = map
                                .next_value::<std::option::Option<crate::model::PhysicalSchema>>(
                                )?;
                        }
                        __FieldTag::__compression_format => {
                            if !fields.insert(__FieldTag::__compression_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compression_format",
                                ));
                            }
                            result.compression_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataplexSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.asset.is_empty() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if self.data_format.is_some() {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self.compression_format.is_empty() {
            state.serialize_entry("compressionFormat", &self.compression_format)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Entry specyfication for a Dataplex fileset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexFilesetSpec {
    /// Common Dataplex fields.
    pub dataplex_spec: std::option::Option<crate::model::DataplexSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexFilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataplex_spec][crate::model::DataplexFilesetSpec::dataplex_spec].
    pub fn set_dataplex_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataplexSpec>,
    {
        self.dataplex_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_spec][crate::model::DataplexFilesetSpec::dataplex_spec].
    pub fn set_or_clear_dataplex_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataplexSpec>,
    {
        self.dataplex_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataplexFilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexFilesetSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataplexFilesetSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataplex_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataplexFilesetSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataplexSpec" => Ok(__FieldTag::__dataplex_spec),
                            "dataplex_spec" => Ok(__FieldTag::__dataplex_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataplexFilesetSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataplexFilesetSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataplex_spec => {
                            if !fields.insert(__FieldTag::__dataplex_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataplex_spec",
                                ));
                            }
                            result.dataplex_spec = map
                                .next_value::<std::option::Option<crate::model::DataplexSpec>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataplexFilesetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dataplex_spec.is_some() {
            state.serialize_entry("dataplexSpec", &self.dataplex_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Entry specification for a Dataplex table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexTableSpec {
    /// List of external tables registered by Dataplex in other systems based on
    /// the same underlying data.
    ///
    /// External tables allow to query this data in those systems.
    pub external_tables: std::vec::Vec<crate::model::DataplexExternalTable>,

    /// Common Dataplex fields.
    pub dataplex_spec: std::option::Option<crate::model::DataplexSpec>,

    /// Indicates if the table schema is managed by the user or not.
    pub user_managed: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_tables][crate::model::DataplexTableSpec::external_tables].
    pub fn set_external_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataplexExternalTable>,
    {
        use std::iter::Iterator;
        self.external_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dataplex_spec][crate::model::DataplexTableSpec::dataplex_spec].
    pub fn set_dataplex_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataplexSpec>,
    {
        self.dataplex_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataplex_spec][crate::model::DataplexTableSpec::dataplex_spec].
    pub fn set_or_clear_dataplex_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataplexSpec>,
    {
        self.dataplex_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_managed][crate::model::DataplexTableSpec::user_managed].
    pub fn set_user_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.user_managed = v.into();
        self
    }
}

impl wkt::message::Message for DataplexTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexTableSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataplexTableSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_tables,
            __dataplex_spec,
            __user_managed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataplexTableSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalTables" => Ok(__FieldTag::__external_tables),
                            "external_tables" => Ok(__FieldTag::__external_tables),
                            "dataplexSpec" => Ok(__FieldTag::__dataplex_spec),
                            "dataplex_spec" => Ok(__FieldTag::__dataplex_spec),
                            "userManaged" => Ok(__FieldTag::__user_managed),
                            "user_managed" => Ok(__FieldTag::__user_managed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataplexTableSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataplexTableSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_tables => {
                            if !fields.insert(__FieldTag::__external_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_tables",
                                ));
                            }
                            result.external_tables = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataplexExternalTable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataplex_spec => {
                            if !fields.insert(__FieldTag::__dataplex_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataplex_spec",
                                ));
                            }
                            result.dataplex_spec = map
                                .next_value::<std::option::Option<crate::model::DataplexSpec>>()?;
                        }
                        __FieldTag::__user_managed => {
                            if !fields.insert(__FieldTag::__user_managed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed",
                                ));
                            }
                            result.user_managed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataplexTableSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.external_tables.is_empty() {
            state.serialize_entry("externalTables", &self.external_tables)?;
        }
        if self.dataplex_spec.is_some() {
            state.serialize_entry("dataplexSpec", &self.dataplex_spec)?;
        }
        if !wkt::internal::is_default(&self.user_managed) {
            state.serialize_entry("userManaged", &self.user_managed)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// External table registered by Dataplex.
/// Dataplex publishes data discovered from an asset into multiple other systems
/// (BigQuery, DPMS) in form of tables. We call them "external tables". External
/// tables are also synced into the Data Catalog.
/// This message contains pointers to
/// those external tables (fully qualified name, resource name et cetera) within
/// the Data Catalog.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataplexExternalTable {
    /// Service in which the external table is registered.
    pub system: crate::model::IntegratedSystem,

    /// Fully qualified name (FQN) of the external table.
    pub fully_qualified_name: std::string::String,

    /// Google Cloud resource name of the external table.
    pub google_cloud_resource: std::string::String,

    /// Name of the Data Catalog entry representing the external table.
    pub data_catalog_entry: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataplexExternalTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [system][crate::model::DataplexExternalTable::system].
    pub fn set_system<T: std::convert::Into<crate::model::IntegratedSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::DataplexExternalTable::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [google_cloud_resource][crate::model::DataplexExternalTable::google_cloud_resource].
    pub fn set_google_cloud_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_cloud_resource = v.into();
        self
    }

    /// Sets the value of [data_catalog_entry][crate::model::DataplexExternalTable::data_catalog_entry].
    pub fn set_data_catalog_entry<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_catalog_entry = v.into();
        self
    }
}

impl wkt::message::Message for DataplexExternalTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DataplexExternalTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataplexExternalTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __system,
            __fully_qualified_name,
            __google_cloud_resource,
            __data_catalog_entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataplexExternalTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "system" => Ok(__FieldTag::__system),
                            "fullyQualifiedName" => Ok(__FieldTag::__fully_qualified_name),
                            "fully_qualified_name" => Ok(__FieldTag::__fully_qualified_name),
                            "googleCloudResource" => Ok(__FieldTag::__google_cloud_resource),
                            "google_cloud_resource" => Ok(__FieldTag::__google_cloud_resource),
                            "dataCatalogEntry" => Ok(__FieldTag::__data_catalog_entry),
                            "data_catalog_entry" => Ok(__FieldTag::__data_catalog_entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataplexExternalTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataplexExternalTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__system => {
                            if !fields.insert(__FieldTag::__system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system",
                                ));
                            }
                            result.system = map
                                .next_value::<std::option::Option<crate::model::IntegratedSystem>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fully_qualified_name => {
                            if !fields.insert(__FieldTag::__fully_qualified_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_qualified_name",
                                ));
                            }
                            result.fully_qualified_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__google_cloud_resource => {
                            if !fields.insert(__FieldTag::__google_cloud_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_cloud_resource",
                                ));
                            }
                            result.google_cloud_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_catalog_entry => {
                            if !fields.insert(__FieldTag::__data_catalog_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_catalog_entry",
                                ));
                            }
                            result.data_catalog_entry = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataplexExternalTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.system) {
            state.serialize_entry("system", &self.system)?;
        }
        if !self.fully_qualified_name.is_empty() {
            state.serialize_entry("fullyQualifiedName", &self.fully_qualified_name)?;
        }
        if !self.google_cloud_resource.is_empty() {
            state.serialize_entry("googleCloudResource", &self.google_cloud_resource)?;
        }
        if !self.data_catalog_entry.is_empty() {
            state.serialize_entry("dataCatalogEntry", &self.data_catalog_entry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Wrapper containing Entry and information about Tags
/// that should and should not be attached to it.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TaggedEntry {
    /// Optional. Tags that should be ingested into the Data Catalog.
    /// Caller should populate template name, column and fields.
    pub present_tags: std::vec::Vec<crate::model::Tag>,

    /// Optional. Tags that should be deleted from the Data Catalog.
    /// Caller should populate template name and column only.
    pub absent_tags: std::vec::Vec<crate::model::Tag>,

    /// Required. Entry to be ingested.
    pub entry: std::option::Option<crate::model::tagged_entry::Entry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaggedEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [present_tags][crate::model::TaggedEntry::present_tags].
    pub fn set_present_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.present_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [absent_tags][crate::model::TaggedEntry::absent_tags].
    pub fn set_absent_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.absent_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entry][crate::model::TaggedEntry::entry].
    ///
    /// Note that all the setters affecting `entry` are mutually
    /// exclusive.
    pub fn set_entry<
        T: std::convert::Into<std::option::Option<crate::model::tagged_entry::Entry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }

    /// The value of [entry][crate::model::TaggedEntry::entry]
    /// if it holds a `V1Entry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn v1_entry(&self) -> std::option::Option<&std::boxed::Box<crate::model::Entry>> {
        #[allow(unreachable_patterns)]
        self.entry.as_ref().and_then(|v| match v {
            crate::model::tagged_entry::Entry::V1Entry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry][crate::model::TaggedEntry::entry]
    /// to hold a `V1Entry`.
    ///
    /// Note that all the setters affecting `entry` are
    /// mutually exclusive.
    pub fn set_v1_entry<T: std::convert::Into<std::boxed::Box<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry =
            std::option::Option::Some(crate::model::tagged_entry::Entry::V1Entry(v.into()));
        self
    }
}

impl wkt::message::Message for TaggedEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TaggedEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TaggedEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __v1_entry,
            __present_tags,
            __absent_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TaggedEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "v1Entry" => Ok(__FieldTag::__v1_entry),
                            "v1_entry" => Ok(__FieldTag::__v1_entry),
                            "presentTags" => Ok(__FieldTag::__present_tags),
                            "present_tags" => Ok(__FieldTag::__present_tags),
                            "absentTags" => Ok(__FieldTag::__absent_tags),
                            "absent_tags" => Ok(__FieldTag::__absent_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TaggedEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TaggedEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__v1_entry => {
                            if !fields.insert(__FieldTag::__v1_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for v1_entry",
                                ));
                            }
                            if result.entry.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entry`, a oneof with full ID .google.cloud.datacatalog.v1.TaggedEntry.v1_entry, latest field was v1Entry",
                                ));
                            }
                            result.entry =
                                std::option::Option::Some(
                                    crate::model::tagged_entry::Entry::V1Entry(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Entry>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__present_tags => {
                            if !fields.insert(__FieldTag::__present_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for present_tags",
                                ));
                            }
                            result.present_tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__absent_tags => {
                            if !fields.insert(__FieldTag::__absent_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for absent_tags",
                                ));
                            }
                            result.absent_tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TaggedEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.v1_entry() {
            state.serialize_entry("v1Entry", value)?;
        }
        if !self.present_tags.is_empty() {
            state.serialize_entry("presentTags", &self.present_tags)?;
        }
        if !self.absent_tags.is_empty() {
            state.serialize_entry("absentTags", &self.absent_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TaggedEntry].
pub mod tagged_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Entry to be ingested.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Entry {
        /// Non-encrypted Data Catalog v1 Entry.
        V1Entry(std::boxed::Box<crate::model::Entry>),
    }
}

/// Wrapper for any item that can be contained in the dump.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DumpItem {
    pub item: std::option::Option<crate::model::dump_item::Item>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DumpItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::DumpItem::item].
    ///
    /// Note that all the setters affecting `item` are mutually
    /// exclusive.
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::dump_item::Item>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// The value of [item][crate::model::DumpItem::item]
    /// if it holds a `TaggedEntry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tagged_entry(&self) -> std::option::Option<&std::boxed::Box<crate::model::TaggedEntry>> {
        #[allow(unreachable_patterns)]
        self.item.as_ref().and_then(|v| match v {
            crate::model::dump_item::Item::TaggedEntry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [item][crate::model::DumpItem::item]
    /// to hold a `TaggedEntry`.
    ///
    /// Note that all the setters affecting `item` are
    /// mutually exclusive.
    pub fn set_tagged_entry<T: std::convert::Into<std::boxed::Box<crate::model::TaggedEntry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = std::option::Option::Some(crate::model::dump_item::Item::TaggedEntry(v.into()));
        self
    }
}

impl wkt::message::Message for DumpItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DumpItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DumpItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tagged_entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DumpItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taggedEntry" => Ok(__FieldTag::__tagged_entry),
                            "tagged_entry" => Ok(__FieldTag::__tagged_entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DumpItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DumpItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tagged_entry => {
                            if !fields.insert(__FieldTag::__tagged_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tagged_entry",
                                ));
                            }
                            if result.item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `item`, a oneof with full ID .google.cloud.datacatalog.v1.DumpItem.tagged_entry, latest field was taggedEntry",
                                ));
                            }
                            result.item = std::option::Option::Some(
                                crate::model::dump_item::Item::TaggedEntry(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TaggedEntry>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DumpItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.tagged_entry() {
            state.serialize_entry("taggedEntry", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DumpItem].
pub mod dump_item {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Item {
        /// Entry and its tags.
        TaggedEntry(std::boxed::Box<crate::model::TaggedEntry>),
    }
}

/// Describes a Cloud Storage fileset entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsFilesetSpec {
    /// Required. Patterns to identify a set of files in Google Cloud Storage.
    ///
    /// For more information, see [Wildcard Names]
    /// (<https://cloud.google.com/storage/docs/wildcards>).
    ///
    /// Note: Currently, bucket wildcards are not supported.
    ///
    /// Examples of valid `file_patterns`:
    ///
    /// * `gs://bucket_name/dir/*`: matches all files in `bucket_name/dir`
    ///   directory
    /// * `gs://bucket_name/dir/**`: matches all files in `bucket_name/dir`
    ///   and all subdirectories
    /// * `gs://bucket_name/file*`: matches files prefixed by `file` in
    ///   `bucket_name`
    /// * `gs://bucket_name/??.txt`: matches files with two characters followed by
    ///   `.txt` in `bucket_name`
    /// * `gs://bucket_name/[aeiou].txt`: matches files that contain a single
    ///   vowel character followed by `.txt` in
    ///   `bucket_name`
    /// * `gs://bucket_name/[a-m].txt`: matches files that contain `a`, `b`, ...
    ///   or `m` followed by `.txt` in `bucket_name`
    /// * `gs://bucket_name/a/*/b`: matches all files in `bucket_name` that match
    ///   the `a/*/b` pattern, such as `a/c/b`, `a/d/b`
    /// * `gs://another_bucket/a.txt`: matches `gs://another_bucket/a.txt`
    ///
    /// You can combine wildcards to match complex sets of files, for example:
    ///
    /// `gs://bucket_name/[a-m]??.j*g`
    pub file_patterns: std::vec::Vec<std::string::String>,

    /// Output only. Sample files contained in this fileset, not all files
    /// contained in this fileset are represented here.
    pub sample_gcs_file_specs: std::vec::Vec<crate::model::GcsFileSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsFilesetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_patterns][crate::model::GcsFilesetSpec::file_patterns].
    pub fn set_file_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_gcs_file_specs][crate::model::GcsFilesetSpec::sample_gcs_file_specs].
    pub fn set_sample_gcs_file_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcsFileSpec>,
    {
        use std::iter::Iterator;
        self.sample_gcs_file_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcsFilesetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GcsFilesetSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsFilesetSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_patterns,
            __sample_gcs_file_specs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsFilesetSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filePatterns" => Ok(__FieldTag::__file_patterns),
                            "file_patterns" => Ok(__FieldTag::__file_patterns),
                            "sampleGcsFileSpecs" => Ok(__FieldTag::__sample_gcs_file_specs),
                            "sample_gcs_file_specs" => Ok(__FieldTag::__sample_gcs_file_specs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsFilesetSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsFilesetSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_patterns => {
                            if !fields.insert(__FieldTag::__file_patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_patterns",
                                ));
                            }
                            result.file_patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sample_gcs_file_specs => {
                            if !fields.insert(__FieldTag::__sample_gcs_file_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_gcs_file_specs",
                                ));
                            }
                            result.sample_gcs_file_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GcsFileSpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsFilesetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_patterns.is_empty() {
            state.serialize_entry("filePatterns", &self.file_patterns)?;
        }
        if !self.sample_gcs_file_specs.is_empty() {
            state.serialize_entry("sampleGcsFileSpecs", &self.sample_gcs_file_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification of a single file in Cloud Storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsFileSpec {
    /// Required. Full file path. Example: `gs://bucket_name/a/b.txt`.
    pub file_path: std::string::String,

    /// Output only. Creation, modification, and expiration timestamps of a Cloud
    /// Storage file.
    pub gcs_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Output only. File size in bytes.
    pub size_bytes: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsFileSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::GcsFileSpec::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [gcs_timestamps][crate::model::GcsFileSpec::gcs_timestamps].
    pub fn set_gcs_timestamps<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.gcs_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcs_timestamps][crate::model::GcsFileSpec::gcs_timestamps].
    pub fn set_or_clear_gcs_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.gcs_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [size_bytes][crate::model::GcsFileSpec::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }
}

impl wkt::message::Message for GcsFileSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GcsFileSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsFileSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_path,
            __gcs_timestamps,
            __size_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsFileSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filePath" => Ok(__FieldTag::__file_path),
                            "file_path" => Ok(__FieldTag::__file_path),
                            "gcsTimestamps" => Ok(__FieldTag::__gcs_timestamps),
                            "gcs_timestamps" => Ok(__FieldTag::__gcs_timestamps),
                            "sizeBytes" => Ok(__FieldTag::__size_bytes),
                            "size_bytes" => Ok(__FieldTag::__size_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsFileSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsFileSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_path => {
                            if !fields.insert(__FieldTag::__file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_path",
                                ));
                            }
                            result.file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_timestamps => {
                            if !fields.insert(__FieldTag::__gcs_timestamps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_timestamps",
                                ));
                            }
                            result.gcs_timestamps = map
                                .next_value::<std::option::Option<crate::model::SystemTimestamps>>(
                                )?;
                        }
                        __FieldTag::__size_bytes => {
                            if !fields.insert(__FieldTag::__size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsFileSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_path.is_empty() {
            state.serialize_entry("filePath", &self.file_path)?;
        }
        if self.gcs_timestamps.is_some() {
            state.serialize_entry("gcsTimestamps", &self.gcs_timestamps)?;
        }
        if !wkt::internal::is_default(&self.size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeBytes", &__With(&self.size_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Native schema used by a resource represented as an entry. Used by query
/// engines for deserializing and parsing source data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PhysicalSchema {
    pub schema: std::option::Option<crate::model::physical_schema::Schema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhysicalSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema].
    ///
    /// Note that all the setters affecting `schema` are mutually
    /// exclusive.
    pub fn set_schema<
        T: std::convert::Into<std::option::Option<crate::model::physical_schema::Schema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Avro`, `None` if the field is not set or
    /// holds a different branch.
    pub fn avro(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::AvroSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Avro(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Avro`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_avro<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::AvroSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Avro(v.into()));
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Thrift`, `None` if the field is not set or
    /// holds a different branch.
    pub fn thrift(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ThriftSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Thrift(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Thrift`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_thrift<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ThriftSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Thrift(v.into()));
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Protobuf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn protobuf(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ProtobufSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Protobuf(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Protobuf`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_protobuf<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ProtobufSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Protobuf(v.into()));
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Parquet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn parquet(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::ParquetSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Parquet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Parquet`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_parquet<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::ParquetSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Parquet(v.into()));
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Orc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn orc(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::OrcSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Orc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Orc`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_orc<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::OrcSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Orc(v.into()));
        self
    }

    /// The value of [schema][crate::model::PhysicalSchema::schema]
    /// if it holds a `Csv`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::physical_schema::CsvSchema>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::physical_schema::Schema::Csv(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::PhysicalSchema::schema]
    /// to hold a `Csv`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_csv<
        T: std::convert::Into<std::boxed::Box<crate::model::physical_schema::CsvSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::physical_schema::Schema::Csv(v.into()));
        self
    }
}

impl wkt::message::Message for PhysicalSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhysicalSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __avro,
            __thrift,
            __protobuf,
            __parquet,
            __orc,
            __csv,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhysicalSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "avro" => Ok(__FieldTag::__avro),
                            "thrift" => Ok(__FieldTag::__thrift),
                            "protobuf" => Ok(__FieldTag::__protobuf),
                            "parquet" => Ok(__FieldTag::__parquet),
                            "orc" => Ok(__FieldTag::__orc),
                            "csv" => Ok(__FieldTag::__csv),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhysicalSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhysicalSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__avro => {
                            if !fields.insert(__FieldTag::__avro) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avro",
                                ));
                            }
                            if result.schema.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema`, a oneof with full ID .google.cloud.datacatalog.v1.PhysicalSchema.avro, latest field was avro",
                                ));
                            }
                            result.schema = std::option::Option::Some(
                                crate::model::physical_schema::Schema::Avro(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::physical_schema::AvroSchema>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__thrift => {
                            if !fields.insert(__FieldTag::__thrift) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for thrift",
                                ));
                            }
                            if result.schema.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema`, a oneof with full ID .google.cloud.datacatalog.v1.PhysicalSchema.thrift, latest field was thrift",
                                ));
                            }
                            result.schema = std::option::Option::Some(
                                crate::model::physical_schema::Schema::Thrift(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::physical_schema::ThriftSchema,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__protobuf => {
                            if !fields.insert(__FieldTag::__protobuf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protobuf",
                                ));
                            }
                            if result.schema.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema`, a oneof with full ID .google.cloud.datacatalog.v1.PhysicalSchema.protobuf, latest field was protobuf",
                                ));
                            }
                            result.schema = std::option::Option::Some(
                                crate::model::physical_schema::Schema::Protobuf(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::physical_schema::ProtobufSchema,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__parquet => {
                            if !fields.insert(__FieldTag::__parquet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parquet",
                                ));
                            }
                            if result.schema.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema`, a oneof with full ID .google.cloud.datacatalog.v1.PhysicalSchema.parquet, latest field was parquet",
                                ));
                            }
                            result.schema = std::option::Option::Some(
                                crate::model::physical_schema::Schema::Parquet(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::physical_schema::ParquetSchema,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__orc => {
                            if !fields.insert(__FieldTag::__orc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for orc",
                                ));
                            }
                            if result.schema.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema`, a oneof with full ID .google.cloud.datacatalog.v1.PhysicalSchema.orc, latest field was orc",
                                ));
                            }
                            result.schema = std::option::Option::Some(
                                crate::model::physical_schema::Schema::Orc(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::physical_schema::OrcSchema>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__csv => {
                            if !fields.insert(__FieldTag::__csv) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv",
                                ));
                            }
                            if result.schema.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema`, a oneof with full ID .google.cloud.datacatalog.v1.PhysicalSchema.csv, latest field was csv",
                                ));
                            }
                            result.schema = std::option::Option::Some(
                                crate::model::physical_schema::Schema::Csv(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::physical_schema::CsvSchema>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhysicalSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.avro() {
            state.serialize_entry("avro", value)?;
        }
        if let Some(value) = self.thrift() {
            state.serialize_entry("thrift", value)?;
        }
        if let Some(value) = self.protobuf() {
            state.serialize_entry("protobuf", value)?;
        }
        if let Some(value) = self.parquet() {
            state.serialize_entry("parquet", value)?;
        }
        if let Some(value) = self.orc() {
            state.serialize_entry("orc", value)?;
        }
        if let Some(value) = self.csv() {
            state.serialize_entry("csv", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PhysicalSchema].
pub mod physical_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Schema in Avro JSON format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AvroSchema {
        /// JSON source of the Avro schema.
        pub text: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AvroSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::AvroSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for AvroSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.AvroSchema"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AvroSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AvroSchema")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AvroSchema;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AvroSchema")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AvroSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Schema in Thrift format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThriftSchema {
        /// Thrift IDL source of the schema.
        pub text: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThriftSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::ThriftSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for ThriftSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ThriftSchema"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ThriftSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ThriftSchema")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ThriftSchema;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ThriftSchema")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ThriftSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Schema in protocol buffer format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProtobufSchema {
        /// Protocol buffer source of the schema.
        pub text: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProtobufSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::physical_schema::ProtobufSchema::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for ProtobufSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ProtobufSchema"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ProtobufSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ProtobufSchema")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ProtobufSchema;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ProtobufSchema")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ProtobufSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Marks a Parquet-encoded data source.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ParquetSchema {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ParquetSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ParquetSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.ParquetSchema"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ParquetSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ParquetSchema")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ParquetSchema;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ParquetSchema")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ParquetSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Marks an ORC-encoded data source.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OrcSchema {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OrcSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for OrcSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.OrcSchema"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OrcSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OrcSchema")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OrcSchema;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OrcSchema")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OrcSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Marks a CSV-encoded data source.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CsvSchema {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for CsvSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.PhysicalSchema.CsvSchema"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CsvSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CsvSchema")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CsvSchema;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CsvSchema")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CsvSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schema {
        /// Schema in Avro JSON format.
        Avro(std::boxed::Box<crate::model::physical_schema::AvroSchema>),
        /// Schema in Thrift format.
        Thrift(std::boxed::Box<crate::model::physical_schema::ThriftSchema>),
        /// Schema in protocol buffer format.
        Protobuf(std::boxed::Box<crate::model::physical_schema::ProtobufSchema>),
        /// Marks a Parquet-encoded data source.
        Parquet(std::boxed::Box<crate::model::physical_schema::ParquetSchema>),
        /// Marks an ORC-encoded data source.
        Orc(std::boxed::Box<crate::model::physical_schema::OrcSchema>),
        /// Marks a CSV-encoded data source.
        Csv(std::boxed::Box<crate::model::physical_schema::CsvSchema>),
    }
}

/// A taxonomy is a collection of hierarchical policy tags that classify data
/// along a common axis.
///
/// For example, a "data sensitivity" taxonomy might contain the following policy
/// tags:
///
/// ```norust
/// + PII
///   + Account number
///   + Age
///   + SSN
///   + Zipcode
/// + Financials
///   + Revenue
/// ```
///
/// A "data origin" taxonomy might contain the following policy tags:
///
/// ```norust
/// + User data
/// + Employee data
/// + Partner data
/// + Public data
/// ```
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Taxonomy {
    /// Identifier. Resource name of this taxonomy in URL format.
    ///
    /// Note: Policy tag manager generates unique taxonomy IDs.
    pub name: std::string::String,

    /// Required. User-defined name of this taxonomy.
    ///
    /// The name can't start or end with spaces, must contain only Unicode letters,
    /// numbers, underscores, dashes, and spaces, and be at most 200 bytes long
    /// when encoded in UTF-8.
    ///
    /// The taxonomy display name must be unique within an organization.
    pub display_name: std::string::String,

    /// Optional. Description of this taxonomy. If not set, defaults to empty.
    ///
    /// The description must contain only Unicode characters, tabs, newlines,
    /// carriage returns, and page breaks, and be at most 2000 bytes long when
    /// encoded in UTF-8.
    pub description: std::string::String,

    /// Output only. Number of policy tags in this taxonomy.
    pub policy_tag_count: i32,

    /// Output only. Creation and modification timestamps of this taxonomy.
    pub taxonomy_timestamps: std::option::Option<crate::model::SystemTimestamps>,

    /// Optional. A list of policy types that are activated for this taxonomy. If
    /// not set, defaults to an empty list.
    pub activated_policy_types: std::vec::Vec<crate::model::taxonomy::PolicyType>,

    /// Output only. Identity of the service which owns the Taxonomy. This field is
    /// only populated when the taxonomy is created by a Google Cloud service.
    /// Currently only 'DATAPLEX' is supported.
    pub service: std::option::Option<crate::model::taxonomy::Service>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Taxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Taxonomy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Taxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Taxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy_tag_count][crate::model::Taxonomy::policy_tag_count].
    pub fn set_policy_tag_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.policy_tag_count = v.into();
        self
    }

    /// Sets the value of [taxonomy_timestamps][crate::model::Taxonomy::taxonomy_timestamps].
    pub fn set_taxonomy_timestamps<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.taxonomy_timestamps = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [taxonomy_timestamps][crate::model::Taxonomy::taxonomy_timestamps].
    pub fn set_or_clear_taxonomy_timestamps<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SystemTimestamps>,
    {
        self.taxonomy_timestamps = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activated_policy_types][crate::model::Taxonomy::activated_policy_types].
    pub fn set_activated_policy_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::taxonomy::PolicyType>,
    {
        use std::iter::Iterator;
        self.activated_policy_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service][crate::model::Taxonomy::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::taxonomy::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::Taxonomy::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::taxonomy::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Taxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Taxonomy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Taxonomy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __policy_tag_count,
            __taxonomy_timestamps,
            __activated_policy_types,
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Taxonomy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "policyTagCount" => Ok(__FieldTag::__policy_tag_count),
                            "policy_tag_count" => Ok(__FieldTag::__policy_tag_count),
                            "taxonomyTimestamps" => Ok(__FieldTag::__taxonomy_timestamps),
                            "taxonomy_timestamps" => Ok(__FieldTag::__taxonomy_timestamps),
                            "activatedPolicyTypes" => Ok(__FieldTag::__activated_policy_types),
                            "activated_policy_types" => Ok(__FieldTag::__activated_policy_types),
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Taxonomy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Taxonomy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_tag_count => {
                            if !fields.insert(__FieldTag::__policy_tag_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tag_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.policy_tag_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__taxonomy_timestamps => {
                            if !fields.insert(__FieldTag::__taxonomy_timestamps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomy_timestamps",
                                ));
                            }
                            result.taxonomy_timestamps = map
                                .next_value::<std::option::Option<crate::model::SystemTimestamps>>(
                                )?;
                        }
                        __FieldTag::__activated_policy_types => {
                            if !fields.insert(__FieldTag::__activated_policy_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activated_policy_types",
                                ));
                            }
                            result.activated_policy_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::taxonomy::PolicyType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<crate::model::taxonomy::Service>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Taxonomy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.policy_tag_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("policyTagCount", &__With(&self.policy_tag_count))?;
        }
        if self.taxonomy_timestamps.is_some() {
            state.serialize_entry("taxonomyTimestamps", &self.taxonomy_timestamps)?;
        }
        if !self.activated_policy_types.is_empty() {
            state.serialize_entry("activatedPolicyTypes", &self.activated_policy_types)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Taxonomy].
pub mod taxonomy {
    #[allow(unused_imports)]
    use super::*;

    /// The source system of the Taxonomy.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Service {
        /// The Google Cloud service name.
        pub name: crate::model::ManagingSystem,

        /// The service agent for the service.
        pub identity: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Service {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::taxonomy::Service::name].
        pub fn set_name<T: std::convert::Into<crate::model::ManagingSystem>>(
            mut self,
            v: T,
        ) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [identity][crate::model::taxonomy::Service::identity].
        pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.identity = v.into();
            self
        }
    }

    impl wkt::message::Message for Service {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.Taxonomy.Service"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Service {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __identity,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Service")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "identity" => Ok(__FieldTag::__identity),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Service;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Service")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map.next_value::<std::option::Option<crate::model::ManagingSystem>>()?.unwrap_or_default();
                            }
                            __FieldTag::__identity => {
                                if !fields.insert(__FieldTag::__identity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for identity",
                                    ));
                                }
                                result.identity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Service {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.name) {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.identity.is_empty() {
                state.serialize_entry("identity", &self.identity)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines policy types where the policy tags can be used for.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PolicyType {
        /// Unspecified policy type.
        Unspecified,
        /// Fine-grained access control policy that enables access control on
        /// tagged sub-resources.
        FineGrainedAccessControl,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PolicyType::value] or
        /// [PolicyType::name].
        UnknownValue(policy_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod policy_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PolicyType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FineGrainedAccessControl => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POLICY_TYPE_UNSPECIFIED"),
                Self::FineGrainedAccessControl => {
                    std::option::Option::Some("FINE_GRAINED_ACCESS_CONTROL")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PolicyType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PolicyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PolicyType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FineGrainedAccessControl,
                _ => Self::UnknownValue(policy_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PolicyType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POLICY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FINE_GRAINED_ACCESS_CONTROL" => Self::FineGrainedAccessControl,
                _ => Self::UnknownValue(policy_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PolicyType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FineGrainedAccessControl => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PolicyType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PolicyType>::new(
                ".google.cloud.datacatalog.v1.Taxonomy.PolicyType",
            ))
        }
    }
}

/// Denotes one policy tag in a taxonomy, for example, SSN.
///
/// Policy tags can be defined in a hierarchy. For example:
///
/// ```norust
/// + Geolocation
///   + LatLong
///   + City
///   + ZipCode
/// ```
///
/// Where the "Geolocation" policy tag contains three children.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PolicyTag {
    /// Identifier. Resource name of this policy tag in the URL format.
    ///
    /// The policy tag manager generates unique taxonomy IDs and policy tag IDs.
    pub name: std::string::String,

    /// Required. User-defined name of this policy tag.
    ///
    /// The name can't start or end with spaces and must be unique within the
    /// parent taxonomy, contain only Unicode letters, numbers, underscores, dashes
    /// and spaces, and be at most 200 bytes long when encoded in UTF-8.
    pub display_name: std::string::String,

    /// Description of this policy tag. If not set, defaults to empty.
    ///
    /// The description must contain only Unicode characters,
    /// tabs, newlines, carriage returns and page breaks, and be at most 2000 bytes
    /// long when encoded in UTF-8.
    pub description: std::string::String,

    /// Resource name of this policy tag's parent policy tag. If empty, this is a
    /// top level tag. If not set, defaults to an empty string.
    ///
    /// For example, for the "LatLong" policy tag in the example above, this field
    /// contains the resource name of the "Geolocation" policy tag, and, for
    /// "Geolocation", this field is empty.
    pub parent_policy_tag: std::string::String,

    /// Output only. Resource names of child policy tags of this policy tag.
    pub child_policy_tags: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PolicyTag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PolicyTag::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PolicyTag::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parent_policy_tag][crate::model::PolicyTag::parent_policy_tag].
    pub fn set_parent_policy_tag<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_policy_tag = v.into();
        self
    }

    /// Sets the value of [child_policy_tags][crate::model::PolicyTag::child_policy_tags].
    pub fn set_child_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PolicyTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.PolicyTag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PolicyTag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __parent_policy_tag,
            __child_policy_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyTag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "parentPolicyTag" => Ok(__FieldTag::__parent_policy_tag),
                            "parent_policy_tag" => Ok(__FieldTag::__parent_policy_tag),
                            "childPolicyTags" => Ok(__FieldTag::__child_policy_tags),
                            "child_policy_tags" => Ok(__FieldTag::__child_policy_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PolicyTag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyTag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_policy_tag => {
                            if !fields.insert(__FieldTag::__parent_policy_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_policy_tag",
                                ));
                            }
                            result.parent_policy_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__child_policy_tags => {
                            if !fields.insert(__FieldTag::__child_policy_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for child_policy_tags",
                                ));
                            }
                            result.child_policy_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PolicyTag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.parent_policy_tag.is_empty() {
            state.serialize_entry("parentPolicyTag", &self.parent_policy_tag)?;
        }
        if !self.child_policy_tags.is_empty() {
            state.serialize_entry("childPolicyTags", &self.child_policy_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.CreateTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.CreateTaxonomy]: crate::client::PolicyTagManager::create_taxonomy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTaxonomyRequest {
    /// Required. Resource name of the project that the taxonomy will belong to.
    pub parent: std::string::String,

    /// The taxonomy to create.
    pub taxonomy: std::option::Option<crate::model::Taxonomy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTaxonomyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [taxonomy][crate::model::CreateTaxonomyRequest::taxonomy].
    pub fn set_taxonomy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Taxonomy>,
    {
        self.taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [taxonomy][crate::model::CreateTaxonomyRequest::taxonomy].
    pub fn set_or_clear_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Taxonomy>,
    {
        self.taxonomy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreateTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __taxonomy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "taxonomy" => Ok(__FieldTag::__taxonomy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__taxonomy => {
                            if !fields.insert(__FieldTag::__taxonomy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomy",
                                ));
                            }
                            result.taxonomy =
                                map.next_value::<std::option::Option<crate::model::Taxonomy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.taxonomy.is_some() {
            state.serialize_entry("taxonomy", &self.taxonomy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeleteTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.DeleteTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.DeleteTaxonomy]: crate::client::PolicyTagManager::delete_taxonomy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTaxonomyRequest {
    /// Required. Resource name of the taxonomy to delete.
    ///
    /// Note: All policy tags in this taxonomy are also deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeleteTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.UpdateTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.UpdateTaxonomy]: crate::client::PolicyTagManager::update_taxonomy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTaxonomyRequest {
    /// The taxonomy to update. You can update only its description, display name,
    /// and activated policy types.
    pub taxonomy: std::option::Option<crate::model::Taxonomy>,

    /// Specifies fields to update. If not set, defaults to all fields you can
    /// update.
    ///
    /// For more information, see [FieldMask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>).
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomy][crate::model::UpdateTaxonomyRequest::taxonomy].
    pub fn set_taxonomy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Taxonomy>,
    {
        self.taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [taxonomy][crate::model::UpdateTaxonomyRequest::taxonomy].
    pub fn set_or_clear_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Taxonomy>,
    {
        self.taxonomy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTaxonomyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTaxonomyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdateTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taxonomy,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taxonomy" => Ok(__FieldTag::__taxonomy),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taxonomy => {
                            if !fields.insert(__FieldTag::__taxonomy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomy",
                                ));
                            }
                            result.taxonomy =
                                map.next_value::<std::option::Option<crate::model::Taxonomy>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.taxonomy.is_some() {
            state.serialize_entry("taxonomy", &self.taxonomy)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ListTaxonomies][google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies]: crate::client::PolicyTagManager::list_taxonomies
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTaxonomiesRequest {
    /// Required. Resource name of the project to list the taxonomies of.
    pub parent: std::string::String,

    /// The maximum number of items to return. Must be a value between 1 and 1000
    /// inclusively. If not set, defaults to 50.
    pub page_size: i32,

    /// The pagination token of the next results page. If not set,
    /// the first page is returned.
    ///
    /// The token is returned in the response to a previous list request.
    pub page_token: std::string::String,

    /// Supported field for filter is 'service' and value is 'dataplex'.
    /// Eg: service=dataplex.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTaxonomiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTaxonomiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTaxonomiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTaxonomiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTaxonomiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTaxonomiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTaxonomiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTaxonomiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTaxonomiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ListTaxonomies][google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListTaxonomies]: crate::client::PolicyTagManager::list_taxonomies
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTaxonomiesResponse {
    /// Taxonomies that the project contains.
    pub taxonomies: std::vec::Vec<crate::model::Taxonomy>,

    /// Pagination token of the next results page. Empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ListTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Taxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTaxonomiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListTaxonomiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTaxonomiesResponse {
    type PageItem = crate::model::Taxonomy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.taxonomies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTaxonomiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taxonomies,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTaxonomiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taxonomies" => Ok(__FieldTag::__taxonomies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTaxonomiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTaxonomiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taxonomies => {
                            if !fields.insert(__FieldTag::__taxonomies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomies",
                                ));
                            }
                            result.taxonomies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Taxonomy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTaxonomiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.taxonomies.is_empty() {
            state.serialize_entry("taxonomies", &self.taxonomies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [GetTaxonomy][google.cloud.datacatalog.v1.PolicyTagManager.GetTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.GetTaxonomy]: crate::client::PolicyTagManager::get_taxonomy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTaxonomyRequest {
    /// Required. Resource name of the taxonomy to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreatePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.CreatePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.CreatePolicyTag]: crate::client::PolicyTagManager::create_policy_tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePolicyTagRequest {
    /// Required. Resource name of the taxonomy that the policy tag will belong to.
    pub parent: std::string::String,

    /// The policy tag to create.
    pub policy_tag: std::option::Option<crate::model::PolicyTag>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePolicyTagRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy_tag][crate::model::CreatePolicyTagRequest::policy_tag].
    pub fn set_policy_tag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PolicyTag>,
    {
        self.policy_tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy_tag][crate::model::CreatePolicyTagRequest::policy_tag].
    pub fn set_or_clear_policy_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PolicyTag>,
    {
        self.policy_tag = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreatePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CreatePolicyTagRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePolicyTagRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __policy_tag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePolicyTagRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "policyTag" => Ok(__FieldTag::__policy_tag),
                            "policy_tag" => Ok(__FieldTag::__policy_tag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePolicyTagRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePolicyTagRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_tag => {
                            if !fields.insert(__FieldTag::__policy_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tag",
                                ));
                            }
                            result.policy_tag =
                                map.next_value::<std::option::Option<crate::model::PolicyTag>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePolicyTagRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.policy_tag.is_some() {
            state.serialize_entry("policyTag", &self.policy_tag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeletePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.DeletePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.DeletePolicyTag]: crate::client::PolicyTagManager::delete_policy_tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePolicyTagRequest {
    /// Required. Resource name of the policy tag to delete.
    ///
    /// Note: All of its descendant policy tags are also deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePolicyTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.DeletePolicyTagRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePolicyTagRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePolicyTagRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePolicyTagRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePolicyTagRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePolicyTagRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdatePolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.UpdatePolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.UpdatePolicyTag]: crate::client::PolicyTagManager::update_policy_tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePolicyTagRequest {
    /// The policy tag to update. You can update only its description, display
    /// name, and parent policy tag fields.
    pub policy_tag: std::option::Option<crate::model::PolicyTag>,

    /// Specifies the fields to update.
    ///
    /// You can update only display name, description, and parent policy tag.
    /// If not set, defaults to all updatable fields.
    /// For more information, see [FieldMask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>).
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tag][crate::model::UpdatePolicyTagRequest::policy_tag].
    pub fn set_policy_tag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PolicyTag>,
    {
        self.policy_tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy_tag][crate::model::UpdatePolicyTagRequest::policy_tag].
    pub fn set_or_clear_policy_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PolicyTag>,
    {
        self.policy_tag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePolicyTagRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePolicyTagRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdatePolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UpdatePolicyTagRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePolicyTagRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy_tag,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePolicyTagRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policyTag" => Ok(__FieldTag::__policy_tag),
                            "policy_tag" => Ok(__FieldTag::__policy_tag),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePolicyTagRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePolicyTagRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy_tag => {
                            if !fields.insert(__FieldTag::__policy_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tag",
                                ));
                            }
                            result.policy_tag =
                                map.next_value::<std::option::Option<crate::model::PolicyTag>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePolicyTagRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.policy_tag.is_some() {
            state.serialize_entry("policyTag", &self.policy_tag)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ListPolicyTags][google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags]: crate::client::PolicyTagManager::list_policy_tags
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPolicyTagsRequest {
    /// Required. Resource name of the taxonomy to list the policy tags of.
    pub parent: std::string::String,

    /// The maximum number of items to return. Must be a value between 1 and 1000
    /// inclusively.
    /// If not set, defaults to 50.
    pub page_size: i32,

    /// The pagination token of the next results page. If not set, returns the
    /// first page.
    ///
    /// The token is returned in the response to a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPolicyTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPolicyTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPolicyTagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPolicyTagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPolicyTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListPolicyTagsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPolicyTagsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPolicyTagsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPolicyTagsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPolicyTagsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPolicyTagsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ListPolicyTags][google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.ListPolicyTags]: crate::client::PolicyTagManager::list_policy_tags
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPolicyTagsResponse {
    /// The policy tags that belong to the taxonomy.
    pub policy_tags: std::vec::Vec<crate::model::PolicyTag>,

    /// Pagination token of the next results page. Empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPolicyTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tags][crate::model::ListPolicyTagsResponse::policy_tags].
    pub fn set_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PolicyTag>,
    {
        use std::iter::Iterator;
        self.policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPolicyTagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPolicyTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ListPolicyTagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPolicyTagsResponse {
    type PageItem = crate::model::PolicyTag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policy_tags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPolicyTagsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy_tags,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPolicyTagsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policyTags" => Ok(__FieldTag::__policy_tags),
                            "policy_tags" => Ok(__FieldTag::__policy_tags),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPolicyTagsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPolicyTagsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy_tags => {
                            if !fields.insert(__FieldTag::__policy_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tags",
                                ));
                            }
                            result.policy_tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PolicyTag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPolicyTagsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy_tags.is_empty() {
            state.serialize_entry("policyTags", &self.policy_tags)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [GetPolicyTag][google.cloud.datacatalog.v1.PolicyTagManager.GetPolicyTag].
///
/// [google.cloud.datacatalog.v1.PolicyTagManager.GetPolicyTag]: crate::client::PolicyTagManager::get_policy_tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPolicyTagRequest {
    /// Required. Resource name of the policy tag.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPolicyTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPolicyTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPolicyTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.GetPolicyTagRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPolicyTagRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPolicyTagRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPolicyTagRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPolicyTagRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPolicyTagRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A nested protocol buffer that represents a taxonomy and the hierarchy of its
/// policy tags. Used for taxonomy replacement, import, and
/// export.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SerializedTaxonomy {
    /// Required. Display name of the taxonomy. At most 200 bytes when encoded in
    /// UTF-8.
    pub display_name: std::string::String,

    /// Description of the serialized taxonomy. At most 2000 bytes when
    /// encoded in UTF-8. If not set, defaults to an empty description.
    pub description: std::string::String,

    /// Top level policy tags associated with the taxonomy, if any.
    pub policy_tags: std::vec::Vec<crate::model::SerializedPolicyTag>,

    /// A list of policy types that are activated per taxonomy.
    pub activated_policy_types: std::vec::Vec<crate::model::taxonomy::PolicyType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SerializedTaxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::SerializedTaxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SerializedTaxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy_tags][crate::model::SerializedTaxonomy::policy_tags].
    pub fn set_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedPolicyTag>,
    {
        use std::iter::Iterator;
        self.policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [activated_policy_types][crate::model::SerializedTaxonomy::activated_policy_types].
    pub fn set_activated_policy_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::taxonomy::PolicyType>,
    {
        use std::iter::Iterator;
        self.activated_policy_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerializedTaxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SerializedTaxonomy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SerializedTaxonomy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __description,
            __policy_tags,
            __activated_policy_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SerializedTaxonomy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "policyTags" => Ok(__FieldTag::__policy_tags),
                            "policy_tags" => Ok(__FieldTag::__policy_tags),
                            "activatedPolicyTypes" => Ok(__FieldTag::__activated_policy_types),
                            "activated_policy_types" => Ok(__FieldTag::__activated_policy_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SerializedTaxonomy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SerializedTaxonomy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_tags => {
                            if !fields.insert(__FieldTag::__policy_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tags",
                                ));
                            }
                            result.policy_tags = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SerializedPolicyTag>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__activated_policy_types => {
                            if !fields.insert(__FieldTag::__activated_policy_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activated_policy_types",
                                ));
                            }
                            result.activated_policy_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::taxonomy::PolicyType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SerializedTaxonomy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.policy_tags.is_empty() {
            state.serialize_entry("policyTags", &self.policy_tags)?;
        }
        if !self.activated_policy_types.is_empty() {
            state.serialize_entry("activatedPolicyTypes", &self.activated_policy_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A nested protocol buffer that represents a policy tag and all its
/// descendants.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SerializedPolicyTag {
    /// Resource name of the policy tag.
    ///
    /// This field is ignored when calling `ImportTaxonomies`.
    pub policy_tag: std::string::String,

    /// Required. Display name of the policy tag. At most 200 bytes when encoded
    /// in UTF-8.
    pub display_name: std::string::String,

    /// Description of the serialized policy tag. At most
    /// 2000 bytes when encoded in UTF-8. If not set, defaults to an
    /// empty description.
    pub description: std::string::String,

    /// Children of the policy tag, if any.
    pub child_policy_tags: std::vec::Vec<crate::model::SerializedPolicyTag>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SerializedPolicyTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_tag][crate::model::SerializedPolicyTag::policy_tag].
    pub fn set_policy_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_tag = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SerializedPolicyTag::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SerializedPolicyTag::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [child_policy_tags][crate::model::SerializedPolicyTag::child_policy_tags].
    pub fn set_child_policy_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedPolicyTag>,
    {
        use std::iter::Iterator;
        self.child_policy_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerializedPolicyTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SerializedPolicyTag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SerializedPolicyTag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy_tag,
            __display_name,
            __description,
            __child_policy_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SerializedPolicyTag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policyTag" => Ok(__FieldTag::__policy_tag),
                            "policy_tag" => Ok(__FieldTag::__policy_tag),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "childPolicyTags" => Ok(__FieldTag::__child_policy_tags),
                            "child_policy_tags" => Ok(__FieldTag::__child_policy_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SerializedPolicyTag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SerializedPolicyTag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy_tag => {
                            if !fields.insert(__FieldTag::__policy_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tag",
                                ));
                            }
                            result.policy_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__child_policy_tags => {
                            if !fields.insert(__FieldTag::__child_policy_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for child_policy_tags",
                                ));
                            }
                            result.child_policy_tags = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SerializedPolicyTag>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SerializedPolicyTag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy_tag.is_empty() {
            state.serialize_entry("policyTag", &self.policy_tag)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.child_policy_tags.is_empty() {
            state.serialize_entry("childPolicyTags", &self.child_policy_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ReplaceTaxonomy][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ReplaceTaxonomy].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ReplaceTaxonomy]: crate::client::PolicyTagManagerSerialization::replace_taxonomy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplaceTaxonomyRequest {
    /// Required. Resource name of the taxonomy to update.
    pub name: std::string::String,

    /// Required. Taxonomy to update along with its child policy tags.
    pub serialized_taxonomy: std::option::Option<crate::model::SerializedTaxonomy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReplaceTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [serialized_taxonomy][crate::model::ReplaceTaxonomyRequest::serialized_taxonomy].
    pub fn set_serialized_taxonomy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SerializedTaxonomy>,
    {
        self.serialized_taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serialized_taxonomy][crate::model::ReplaceTaxonomyRequest::serialized_taxonomy].
    pub fn set_or_clear_serialized_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SerializedTaxonomy>,
    {
        self.serialized_taxonomy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplaceTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ReplaceTaxonomyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplaceTaxonomyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __serialized_taxonomy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplaceTaxonomyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "serializedTaxonomy" => Ok(__FieldTag::__serialized_taxonomy),
                            "serialized_taxonomy" => Ok(__FieldTag::__serialized_taxonomy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplaceTaxonomyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplaceTaxonomyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serialized_taxonomy => {
                            if !fields.insert(__FieldTag::__serialized_taxonomy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serialized_taxonomy",
                                ));
                            }
                            result.serialized_taxonomy = map.next_value::<std::option::Option<crate::model::SerializedTaxonomy>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplaceTaxonomyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.serialized_taxonomy.is_some() {
            state.serialize_entry("serializedTaxonomy", &self.serialized_taxonomy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies]: crate::client::PolicyTagManagerSerialization::import_taxonomies
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportTaxonomiesRequest {
    /// Required. Resource name of project that the imported taxonomies will belong
    /// to.
    pub parent: std::string::String,

    /// Source taxonomies to import.
    pub source: std::option::Option<crate::model::import_taxonomies_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_taxonomies_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_taxonomies_request::Source::InlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<T: std::convert::Into<std::boxed::Box<crate::model::InlineSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_taxonomies_request::Source::InlineSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// if it holds a `CrossRegionalSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cross_regional_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CrossRegionalSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_taxonomies_request::Source::CrossRegionalSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportTaxonomiesRequest::source]
    /// to hold a `CrossRegionalSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cross_regional_source<
        T: std::convert::Into<std::boxed::Box<crate::model::CrossRegionalSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_taxonomies_request::Source::CrossRegionalSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportTaxonomiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportTaxonomiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __inline_source,
            __cross_regional_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportTaxonomiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "inlineSource" => Ok(__FieldTag::__inline_source),
                            "inline_source" => Ok(__FieldTag::__inline_source),
                            "crossRegionalSource" => Ok(__FieldTag::__cross_regional_source),
                            "cross_regional_source" => Ok(__FieldTag::__cross_regional_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportTaxonomiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportTaxonomiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inline_source => {
                            if !fields.insert(__FieldTag::__inline_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.datacatalog.v1.ImportTaxonomiesRequest.inline_source, latest field was inlineSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_taxonomies_request::Source::InlineSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InlineSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cross_regional_source => {
                            if !fields.insert(__FieldTag::__cross_regional_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_regional_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.datacatalog.v1.ImportTaxonomiesRequest.cross_regional_source, latest field was crossRegionalSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_taxonomies_request::Source::CrossRegionalSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CrossRegionalSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportTaxonomiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if let Some(value) = self.cross_regional_source() {
            state.serialize_entry("crossRegionalSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportTaxonomiesRequest].
pub mod import_taxonomies_request {
    #[allow(unused_imports)]
    use super::*;

    /// Source taxonomies to import.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Inline source taxonomy to import.
        InlineSource(std::boxed::Box<crate::model::InlineSource>),
        /// Cross-regional source taxonomy to import.
        CrossRegionalSource(std::boxed::Box<crate::model::CrossRegionalSource>),
    }
}

/// Inline source containing taxonomies to import.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InlineSource {
    /// Required. Taxonomies to import.
    pub taxonomies: std::vec::Vec<crate::model::SerializedTaxonomy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::InlineSource::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedTaxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InlineSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.InlineSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InlineSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taxonomies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InlineSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taxonomies" => Ok(__FieldTag::__taxonomies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InlineSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InlineSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taxonomies => {
                            if !fields.insert(__FieldTag::__taxonomies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomies",
                                ));
                            }
                            result.taxonomies = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SerializedTaxonomy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.taxonomies.is_empty() {
            state.serialize_entry("taxonomies", &self.taxonomies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cross-regional source used to import an existing taxonomy into a different
/// region.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CrossRegionalSource {
    /// Required. The resource name of the source taxonomy to import.
    pub taxonomy: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CrossRegionalSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomy][crate::model::CrossRegionalSource::taxonomy].
    pub fn set_taxonomy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.taxonomy = v.into();
        self
    }
}

impl wkt::message::Message for CrossRegionalSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CrossRegionalSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CrossRegionalSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taxonomy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CrossRegionalSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taxonomy" => Ok(__FieldTag::__taxonomy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CrossRegionalSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CrossRegionalSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taxonomy => {
                            if !fields.insert(__FieldTag::__taxonomy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomy",
                                ));
                            }
                            result.taxonomy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CrossRegionalSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.taxonomy.is_empty() {
            state.serialize_entry("taxonomy", &self.taxonomy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ImportTaxonomies]: crate::client::PolicyTagManagerSerialization::import_taxonomies
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportTaxonomiesResponse {
    /// Imported taxonomies.
    pub taxonomies: std::vec::Vec<crate::model::Taxonomy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ImportTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Taxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ImportTaxonomiesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportTaxonomiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taxonomies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportTaxonomiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taxonomies" => Ok(__FieldTag::__taxonomies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportTaxonomiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportTaxonomiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taxonomies => {
                            if !fields.insert(__FieldTag::__taxonomies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomies",
                                ));
                            }
                            result.taxonomies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Taxonomy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportTaxonomiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.taxonomies.is_empty() {
            state.serialize_entry("taxonomies", &self.taxonomies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies]: crate::client::PolicyTagManagerSerialization::export_taxonomies
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportTaxonomiesRequest {
    /// Required. Resource name of the project that the exported taxonomies belong
    /// to.
    pub parent: std::string::String,

    /// Required. Resource names of the taxonomies to export.
    pub taxonomies: std::vec::Vec<std::string::String>,

    /// Required. Export destination for taxonomies.
    pub destination: std::option::Option<crate::model::export_taxonomies_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [taxonomies][crate::model::ExportTaxonomiesRequest::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination][crate::model::ExportTaxonomiesRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_taxonomies_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportTaxonomiesRequest::destination]
    /// if it holds a `SerializedTaxonomies`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serialized_taxonomies(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_taxonomies_request::Destination::SerializedTaxonomies(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportTaxonomiesRequest::destination]
    /// to hold a `SerializedTaxonomies`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_serialized_taxonomies<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_taxonomies_request::Destination::SerializedTaxonomies(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ExportTaxonomiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportTaxonomiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __taxonomies,
            __serialized_taxonomies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportTaxonomiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "taxonomies" => Ok(__FieldTag::__taxonomies),
                            "serializedTaxonomies" => Ok(__FieldTag::__serialized_taxonomies),
                            "serialized_taxonomies" => Ok(__FieldTag::__serialized_taxonomies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportTaxonomiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportTaxonomiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__taxonomies => {
                            if !fields.insert(__FieldTag::__taxonomies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomies",
                                ));
                            }
                            result.taxonomies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__serialized_taxonomies => {
                            if !fields.insert(__FieldTag::__serialized_taxonomies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serialized_taxonomies",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.datacatalog.v1.ExportTaxonomiesRequest.serialized_taxonomies, latest field was serializedTaxonomies",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_taxonomies_request::Destination::SerializedTaxonomies(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportTaxonomiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.taxonomies.is_empty() {
            state.serialize_entry("taxonomies", &self.taxonomies)?;
        }
        if let Some(value) = self.serialized_taxonomies() {
            state.serialize_entry("serializedTaxonomies", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportTaxonomiesRequest].
pub mod export_taxonomies_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Export destination for taxonomies.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Serialized export taxonomies that contain all the policy
        /// tags as nested protocol buffers.
        SerializedTaxonomies(bool),
    }
}

/// Response message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies].
///
/// [google.cloud.datacatalog.v1.PolicyTagManagerSerialization.ExportTaxonomies]: crate::client::PolicyTagManagerSerialization::export_taxonomies
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportTaxonomiesResponse {
    /// List of taxonomies and policy tags as nested protocol buffers.
    pub taxonomies: std::vec::Vec<crate::model::SerializedTaxonomy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taxonomies][crate::model::ExportTaxonomiesResponse::taxonomies].
    pub fn set_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SerializedTaxonomy>,
    {
        use std::iter::Iterator;
        self.taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ExportTaxonomiesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportTaxonomiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taxonomies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportTaxonomiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taxonomies" => Ok(__FieldTag::__taxonomies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportTaxonomiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportTaxonomiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taxonomies => {
                            if !fields.insert(__FieldTag::__taxonomies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taxonomies",
                                ));
                            }
                            result.taxonomies = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SerializedTaxonomy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportTaxonomiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.taxonomies.is_empty() {
            state.serialize_entry("taxonomies", &self.taxonomies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a schema, for example, a BigQuery, GoogleSQL, or Avro schema.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {
    /// The unified GoogleSQL-like schema of columns.
    ///
    /// The overall maximum number of columns and nested columns is 10,000.
    /// The maximum nested depth is 15 levels.
    pub columns: std::vec::Vec<crate::model::ColumnSchema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::Schema::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnSchema>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Schema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Schema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Schema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ColumnSchema>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Schema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A column within a schema. Columns can be nested inside
/// other columns.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ColumnSchema {
    /// Required. Name of the column.
    ///
    /// Must be a UTF-8 string without dots (.).
    /// The maximum size is 64 bytes.
    pub column: std::string::String,

    /// Required. Type of the column.
    ///
    /// Must be a UTF-8 string with the maximum size of 128 bytes.
    pub r#type: std::string::String,

    /// Optional. Description of the column. Default value is an empty string.
    ///
    /// The description must be a UTF-8 string with the maximum size of 2000
    /// bytes.
    pub description: std::string::String,

    /// Optional. A column's mode indicates whether values in this column are
    /// required, nullable, or repeated.
    ///
    /// Only `NULLABLE`, `REQUIRED`, and `REPEATED` values are supported.
    /// Default mode is `NULLABLE`.
    pub mode: std::string::String,

    /// Optional. Default value for the column.
    pub default_value: std::string::String,

    /// Optional. Ordinal position
    pub ordinal_position: i32,

    /// Optional. Most important inclusion of this column.
    pub highest_indexing_type: crate::model::column_schema::IndexingType,

    /// Optional. Schema of sub-columns. A column can have zero or more
    /// sub-columns.
    pub subcolumns: std::vec::Vec<crate::model::ColumnSchema>,

    /// Optional. The subtype of the RANGE, if the type of this field is RANGE. If
    /// the type is RANGE, this field is required. Possible values for the field
    /// element type of a RANGE include:
    ///
    /// * DATE
    /// * DATETIME
    /// * TIMESTAMP
    pub range_element_type: std::option::Option<crate::model::column_schema::FieldElementType>,

    /// Optional. Garbage collection policy for the column or column family.
    /// Applies to systems like Cloud Bigtable.
    pub gc_rule: std::string::String,

    /// Information only applying for columns in Entries from a specific system.
    pub system_spec: std::option::Option<crate::model::column_schema::SystemSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::ColumnSchema::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ColumnSchema::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ColumnSchema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::ColumnSchema::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::ColumnSchema::default_value].
    pub fn set_default_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::ColumnSchema::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [highest_indexing_type][crate::model::ColumnSchema::highest_indexing_type].
    pub fn set_highest_indexing_type<
        T: std::convert::Into<crate::model::column_schema::IndexingType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.highest_indexing_type = v.into();
        self
    }

    /// Sets the value of [subcolumns][crate::model::ColumnSchema::subcolumns].
    pub fn set_subcolumns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnSchema>,
    {
        use std::iter::Iterator;
        self.subcolumns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [range_element_type][crate::model::ColumnSchema::range_element_type].
    pub fn set_range_element_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::column_schema::FieldElementType>,
    {
        self.range_element_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range_element_type][crate::model::ColumnSchema::range_element_type].
    pub fn set_or_clear_range_element_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::column_schema::FieldElementType>,
    {
        self.range_element_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gc_rule][crate::model::ColumnSchema::gc_rule].
    pub fn set_gc_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gc_rule = v.into();
        self
    }

    /// Sets the value of [system_spec][crate::model::ColumnSchema::system_spec].
    ///
    /// Note that all the setters affecting `system_spec` are mutually
    /// exclusive.
    pub fn set_system_spec<
        T: std::convert::Into<std::option::Option<crate::model::column_schema::SystemSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = v.into();
        self
    }

    /// The value of [system_spec][crate::model::ColumnSchema::system_spec]
    /// if it holds a `LookerColumnSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn looker_column_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::column_schema::LookerColumnSpec>> {
        #[allow(unreachable_patterns)]
        self.system_spec.as_ref().and_then(|v| match v {
            crate::model::column_schema::SystemSpec::LookerColumnSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system_spec][crate::model::ColumnSchema::system_spec]
    /// to hold a `LookerColumnSpec`.
    ///
    /// Note that all the setters affecting `system_spec` are
    /// mutually exclusive.
    pub fn set_looker_column_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::column_schema::LookerColumnSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_spec = std::option::Option::Some(
            crate::model::column_schema::SystemSpec::LookerColumnSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ColumnSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColumnSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column,
            __type,
            __description,
            __mode,
            __default_value,
            __ordinal_position,
            __highest_indexing_type,
            __subcolumns,
            __looker_column_spec,
            __range_element_type,
            __gc_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "column" => Ok(__FieldTag::__column),
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            "mode" => Ok(__FieldTag::__mode),
                            "defaultValue" => Ok(__FieldTag::__default_value),
                            "default_value" => Ok(__FieldTag::__default_value),
                            "ordinalPosition" => Ok(__FieldTag::__ordinal_position),
                            "ordinal_position" => Ok(__FieldTag::__ordinal_position),
                            "highestIndexingType" => Ok(__FieldTag::__highest_indexing_type),
                            "highest_indexing_type" => Ok(__FieldTag::__highest_indexing_type),
                            "subcolumns" => Ok(__FieldTag::__subcolumns),
                            "lookerColumnSpec" => Ok(__FieldTag::__looker_column_spec),
                            "looker_column_spec" => Ok(__FieldTag::__looker_column_spec),
                            "rangeElementType" => Ok(__FieldTag::__range_element_type),
                            "range_element_type" => Ok(__FieldTag::__range_element_type),
                            "gcRule" => Ok(__FieldTag::__gc_rule),
                            "gc_rule" => Ok(__FieldTag::__gc_rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColumnSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_value => {
                            if !fields.insert(__FieldTag::__default_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_value",
                                ));
                            }
                            result.default_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ordinal_position => {
                            if !fields.insert(__FieldTag::__ordinal_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ordinal_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ordinal_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__highest_indexing_type => {
                            if !fields.insert(__FieldTag::__highest_indexing_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for highest_indexing_type",
                                ));
                            }
                            result.highest_indexing_type = map.next_value::<std::option::Option<crate::model::column_schema::IndexingType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__subcolumns => {
                            if !fields.insert(__FieldTag::__subcolumns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subcolumns",
                                ));
                            }
                            result.subcolumns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ColumnSchema>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__looker_column_spec => {
                            if !fields.insert(__FieldTag::__looker_column_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for looker_column_spec",
                                ));
                            }
                            if result.system_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_spec`, a oneof with full ID .google.cloud.datacatalog.v1.ColumnSchema.looker_column_spec, latest field was lookerColumnSpec",
                                ));
                            }
                            result.system_spec = std::option::Option::Some(
                                crate::model::column_schema::SystemSpec::LookerColumnSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::column_schema::LookerColumnSpec,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__range_element_type => {
                            if !fields.insert(__FieldTag::__range_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_element_type",
                                ));
                            }
                            result.range_element_type = map.next_value::<std::option::Option<
                                crate::model::column_schema::FieldElementType,
                            >>()?;
                        }
                        __FieldTag::__gc_rule => {
                            if !fields.insert(__FieldTag::__gc_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gc_rule",
                                ));
                            }
                            result.gc_rule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColumnSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.mode.is_empty() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.default_value.is_empty() {
            state.serialize_entry("defaultValue", &self.default_value)?;
        }
        if !wkt::internal::is_default(&self.ordinal_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ordinalPosition", &__With(&self.ordinal_position))?;
        }
        if !wkt::internal::is_default(&self.highest_indexing_type) {
            state.serialize_entry("highestIndexingType", &self.highest_indexing_type)?;
        }
        if !self.subcolumns.is_empty() {
            state.serialize_entry("subcolumns", &self.subcolumns)?;
        }
        if let Some(value) = self.looker_column_spec() {
            state.serialize_entry("lookerColumnSpec", value)?;
        }
        if self.range_element_type.is_some() {
            state.serialize_entry("rangeElementType", &self.range_element_type)?;
        }
        if !self.gc_rule.is_empty() {
            state.serialize_entry("gcRule", &self.gc_rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ColumnSchema].
pub mod column_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Column info specific to Looker System.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LookerColumnSpec {
        /// Looker specific column type of this column.
        pub r#type: crate::model::column_schema::looker_column_spec::LookerColumnType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LookerColumnSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::column_schema::LookerColumnSpec::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::column_schema::looker_column_spec::LookerColumnType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for LookerColumnSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema.LookerColumnSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LookerColumnSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LookerColumnSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LookerColumnSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LookerColumnSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map.next_value::<std::option::Option<crate::model::column_schema::looker_column_spec::LookerColumnType>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LookerColumnSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [LookerColumnSpec].
    pub mod looker_column_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Column type in Looker.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LookerColumnType {
            /// Unspecified.
            Unspecified,
            /// Dimension.
            Dimension,
            /// Dimension group - parent for Dimension.
            DimensionGroup,
            /// Filter.
            Filter,
            /// Measure.
            Measure,
            /// Parameter.
            Parameter,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LookerColumnType::value] or
            /// [LookerColumnType::name].
            UnknownValue(looker_column_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod looker_column_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LookerColumnType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Dimension => std::option::Option::Some(1),
                    Self::DimensionGroup => std::option::Option::Some(2),
                    Self::Filter => std::option::Option::Some(3),
                    Self::Measure => std::option::Option::Some(4),
                    Self::Parameter => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("LOOKER_COLUMN_TYPE_UNSPECIFIED")
                    }
                    Self::Dimension => std::option::Option::Some("DIMENSION"),
                    Self::DimensionGroup => std::option::Option::Some("DIMENSION_GROUP"),
                    Self::Filter => std::option::Option::Some("FILTER"),
                    Self::Measure => std::option::Option::Some("MEASURE"),
                    Self::Parameter => std::option::Option::Some("PARAMETER"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LookerColumnType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LookerColumnType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LookerColumnType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Dimension,
                    2 => Self::DimensionGroup,
                    3 => Self::Filter,
                    4 => Self::Measure,
                    5 => Self::Parameter,
                    _ => Self::UnknownValue(looker_column_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LookerColumnType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOOKER_COLUMN_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "DIMENSION" => Self::Dimension,
                    "DIMENSION_GROUP" => Self::DimensionGroup,
                    "FILTER" => Self::Filter,
                    "MEASURE" => Self::Measure,
                    "PARAMETER" => Self::Parameter,
                    _ => Self::UnknownValue(looker_column_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LookerColumnType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Dimension => serializer.serialize_i32(1),
                    Self::DimensionGroup => serializer.serialize_i32(2),
                    Self::Filter => serializer.serialize_i32(3),
                    Self::Measure => serializer.serialize_i32(4),
                    Self::Parameter => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LookerColumnType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LookerColumnType>::new(
                    ".google.cloud.datacatalog.v1.ColumnSchema.LookerColumnSpec.LookerColumnType",
                ))
            }
        }
    }

    /// Represents the type of a field element.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FieldElementType {
        /// Required. The type of a field element. See
        /// [ColumnSchema.type][google.cloud.datacatalog.v1.ColumnSchema.type].
        ///
        /// [google.cloud.datacatalog.v1.ColumnSchema.type]: crate::model::ColumnSchema::type
        pub r#type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FieldElementType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::column_schema::FieldElementType::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for FieldElementType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.ColumnSchema.FieldElementType"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FieldElementType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FieldElementType")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FieldElementType;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FieldElementType")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FieldElementType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Specifies inclusion of the column in an index
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IndexingType {
        /// Unspecified.
        Unspecified,
        /// Column not a part of an index.
        None,
        /// Column Part of non unique index.
        NonUnique,
        /// Column part of unique index.
        Unique,
        /// Column part of the primary key.
        PrimaryKey,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IndexingType::value] or
        /// [IndexingType::name].
        UnknownValue(indexing_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod indexing_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IndexingType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::NonUnique => std::option::Option::Some(2),
                Self::Unique => std::option::Option::Some(3),
                Self::PrimaryKey => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INDEXING_TYPE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("INDEXING_TYPE_NONE"),
                Self::NonUnique => std::option::Option::Some("INDEXING_TYPE_NON_UNIQUE"),
                Self::Unique => std::option::Option::Some("INDEXING_TYPE_UNIQUE"),
                Self::PrimaryKey => std::option::Option::Some("INDEXING_TYPE_PRIMARY_KEY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IndexingType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IndexingType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IndexingType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::NonUnique,
                3 => Self::Unique,
                4 => Self::PrimaryKey,
                _ => Self::UnknownValue(indexing_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IndexingType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INDEXING_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INDEXING_TYPE_NONE" => Self::None,
                "INDEXING_TYPE_NON_UNIQUE" => Self::NonUnique,
                "INDEXING_TYPE_UNIQUE" => Self::Unique,
                "INDEXING_TYPE_PRIMARY_KEY" => Self::PrimaryKey,
                _ => Self::UnknownValue(indexing_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IndexingType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::NonUnique => serializer.serialize_i32(2),
                Self::Unique => serializer.serialize_i32(3),
                Self::PrimaryKey => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IndexingType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndexingType>::new(
                ".google.cloud.datacatalog.v1.ColumnSchema.IndexingType",
            ))
        }
    }

    /// Information only applying for columns in Entries from a specific system.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SystemSpec {
        /// Looker specific column info of this column.
        LookerColumnSpec(std::boxed::Box<crate::model::column_schema::LookerColumnSpec>),
    }
}

/// Result in the response to a search request.
///
/// Each result captures details of one entry that matches the search.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCatalogResult {
    /// Type of the search result.
    ///
    /// You can use this field to determine which get method to call to fetch the
    /// full resource.
    pub search_result_type: crate::model::SearchResultType,

    /// Sub-type of the search result.
    ///
    /// A dot-delimited full type of the resource. The same type you
    /// specify in the `type` search predicate.
    ///
    /// Examples: `entry.table`, `entry.dataStream`, `tagTemplate`.
    pub search_result_subtype: std::string::String,

    /// The relative name of the resource in URL format.
    ///
    /// Examples:
    ///
    /// * `projects/{PROJECT_ID}/locations/{LOCATION_ID}/entryGroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`
    /// * `projects/{PROJECT_ID}/tagTemplates/{TAG_TEMPLATE_ID}`
    pub relative_resource_name: std::string::String,

    /// The full name of the Google Cloud resource the entry belongs to.
    ///
    /// For more information, see [Full Resource Name]
    /// (/apis/design/resource_names#full_resource_name).
    ///
    /// Example:
    ///
    /// `//bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID`
    pub linked_resource: std::string::String,

    /// The last modification timestamp of the entry in the source system.
    pub modify_time: std::option::Option<wkt::Timestamp>,

    /// Fully qualified name (FQN) of the resource.
    ///
    /// FQNs take two forms:
    ///
    /// * For non-regionalized resources:
    ///
    ///   `{SYSTEM}:{PROJECT}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
    ///
    /// * For regionalized resources:
    ///
    ///   `{SYSTEM}:{PROJECT}.{LOCATION_ID}.{PATH_TO_RESOURCE_SEPARATED_WITH_DOTS}`
    ///
    ///
    /// Example for a DPMS table:
    ///
    /// `dataproc_metastore:PROJECT_ID.LOCATION_ID.INSTANCE_ID.DATABASE_ID.TABLE_ID`
    pub fully_qualified_name: std::string::String,

    /// The display name of the result.
    pub display_name: std::string::String,

    /// Entry description that can consist of several sentences or paragraphs that
    /// describe entry contents.
    pub description: std::string::String,

    /// The source system of the entry. Applicable only when the
    /// `search_result_type` is `ENTRY`.
    pub system: std::option::Option<crate::model::search_catalog_result::System>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCatalogResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_result_type][crate::model::SearchCatalogResult::search_result_type].
    pub fn set_search_result_type<T: std::convert::Into<crate::model::SearchResultType>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_result_type = v.into();
        self
    }

    /// Sets the value of [search_result_subtype][crate::model::SearchCatalogResult::search_result_subtype].
    pub fn set_search_result_subtype<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_result_subtype = v.into();
        self
    }

    /// Sets the value of [relative_resource_name][crate::model::SearchCatalogResult::relative_resource_name].
    pub fn set_relative_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.relative_resource_name = v.into();
        self
    }

    /// Sets the value of [linked_resource][crate::model::SearchCatalogResult::linked_resource].
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [modify_time][crate::model::SearchCatalogResult::modify_time].
    pub fn set_modify_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.modify_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [modify_time][crate::model::SearchCatalogResult::modify_time].
    pub fn set_or_clear_modify_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.modify_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::SearchCatalogResult::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SearchCatalogResult::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SearchCatalogResult::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system].
    ///
    /// Note that all the setters affecting `system` are mutually
    /// exclusive.
    pub fn set_system<
        T: std::convert::Into<std::option::Option<crate::model::search_catalog_result::System>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system = v.into();
        self
    }

    /// The value of [system][crate::model::SearchCatalogResult::system]
    /// if it holds a `IntegratedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integrated_system(&self) -> std::option::Option<&crate::model::IntegratedSystem> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::search_catalog_result::System::IntegratedSystem(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system]
    /// to hold a `IntegratedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_integrated_system<T: std::convert::Into<crate::model::IntegratedSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = std::option::Option::Some(
            crate::model::search_catalog_result::System::IntegratedSystem(v.into()),
        );
        self
    }

    /// The value of [system][crate::model::SearchCatalogResult::system]
    /// if it holds a `UserSpecifiedSystem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_specified_system(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.system.as_ref().and_then(|v| match v {
            crate::model::search_catalog_result::System::UserSpecifiedSystem(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [system][crate::model::SearchCatalogResult::system]
    /// to hold a `UserSpecifiedSystem`.
    ///
    /// Note that all the setters affecting `system` are
    /// mutually exclusive.
    pub fn set_user_specified_system<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.system = std::option::Option::Some(
            crate::model::search_catalog_result::System::UserSpecifiedSystem(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SearchCatalogResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SearchCatalogResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchCatalogResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __search_result_type,
            __search_result_subtype,
            __relative_resource_name,
            __linked_resource,
            __modify_time,
            __integrated_system,
            __user_specified_system,
            __fully_qualified_name,
            __display_name,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchCatalogResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "searchResultType" => Ok(__FieldTag::__search_result_type),
                            "search_result_type" => Ok(__FieldTag::__search_result_type),
                            "searchResultSubtype" => Ok(__FieldTag::__search_result_subtype),
                            "search_result_subtype" => Ok(__FieldTag::__search_result_subtype),
                            "relativeResourceName" => Ok(__FieldTag::__relative_resource_name),
                            "relative_resource_name" => Ok(__FieldTag::__relative_resource_name),
                            "linkedResource" => Ok(__FieldTag::__linked_resource),
                            "linked_resource" => Ok(__FieldTag::__linked_resource),
                            "modifyTime" => Ok(__FieldTag::__modify_time),
                            "modify_time" => Ok(__FieldTag::__modify_time),
                            "integratedSystem" => Ok(__FieldTag::__integrated_system),
                            "integrated_system" => Ok(__FieldTag::__integrated_system),
                            "userSpecifiedSystem" => Ok(__FieldTag::__user_specified_system),
                            "user_specified_system" => Ok(__FieldTag::__user_specified_system),
                            "fullyQualifiedName" => Ok(__FieldTag::__fully_qualified_name),
                            "fully_qualified_name" => Ok(__FieldTag::__fully_qualified_name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchCatalogResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchCatalogResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__search_result_type => {
                            if !fields.insert(__FieldTag::__search_result_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_result_type",
                                ));
                            }
                            result.search_result_type = map
                                .next_value::<std::option::Option<crate::model::SearchResultType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__search_result_subtype => {
                            if !fields.insert(__FieldTag::__search_result_subtype) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_result_subtype",
                                ));
                            }
                            result.search_result_subtype = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relative_resource_name => {
                            if !fields.insert(__FieldTag::__relative_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_resource_name",
                                ));
                            }
                            result.relative_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__linked_resource => {
                            if !fields.insert(__FieldTag::__linked_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_resource",
                                ));
                            }
                            result.linked_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__modify_time => {
                            if !fields.insert(__FieldTag::__modify_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for modify_time",
                                ));
                            }
                            result.modify_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__integrated_system => {
                            if !fields.insert(__FieldTag::__integrated_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrated_system",
                                ));
                            }
                            if result.system.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system`, a oneof with full ID .google.cloud.datacatalog.v1.SearchCatalogResult.integrated_system, latest field was integratedSystem",
                                ));
                            }
                            result.system = std::option::Option::Some(
                                crate::model::search_catalog_result::System::IntegratedSystem(
                                    map.next_value::<std::option::Option<crate::model::IntegratedSystem>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__user_specified_system => {
                            if !fields.insert(__FieldTag::__user_specified_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_specified_system",
                                ));
                            }
                            if result.system.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system`, a oneof with full ID .google.cloud.datacatalog.v1.SearchCatalogResult.user_specified_system, latest field was userSpecifiedSystem",
                                ));
                            }
                            result.system = std::option::Option::Some(
                                crate::model::search_catalog_result::System::UserSpecifiedSystem(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__fully_qualified_name => {
                            if !fields.insert(__FieldTag::__fully_qualified_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_qualified_name",
                                ));
                            }
                            result.fully_qualified_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchCatalogResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.search_result_type) {
            state.serialize_entry("searchResultType", &self.search_result_type)?;
        }
        if !self.search_result_subtype.is_empty() {
            state.serialize_entry("searchResultSubtype", &self.search_result_subtype)?;
        }
        if !self.relative_resource_name.is_empty() {
            state.serialize_entry("relativeResourceName", &self.relative_resource_name)?;
        }
        if !self.linked_resource.is_empty() {
            state.serialize_entry("linkedResource", &self.linked_resource)?;
        }
        if self.modify_time.is_some() {
            state.serialize_entry("modifyTime", &self.modify_time)?;
        }
        if let Some(value) = self.integrated_system() {
            state.serialize_entry("integratedSystem", value)?;
        }
        if let Some(value) = self.user_specified_system() {
            state.serialize_entry("userSpecifiedSystem", value)?;
        }
        if !self.fully_qualified_name.is_empty() {
            state.serialize_entry("fullyQualifiedName", &self.fully_qualified_name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchCatalogResult].
pub mod search_catalog_result {
    #[allow(unused_imports)]
    use super::*;

    /// The source system of the entry. Applicable only when the
    /// `search_result_type` is `ENTRY`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum System {
        /// Output only. The source system that Data Catalog automatically integrates
        /// with, such as BigQuery, Cloud Pub/Sub, or Dataproc Metastore.
        IntegratedSystem(crate::model::IntegratedSystem),
        /// Custom source system that you can manually integrate Data Catalog with.
        UserSpecifiedSystem(std::string::String),
    }
}

/// Describes a BigQuery table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryTableSpec {
    /// Output only. The table source type.
    pub table_source_type: crate::model::TableSourceType,

    /// Output only.
    pub type_spec: std::option::Option<crate::model::big_query_table_spec::TypeSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_source_type][crate::model::BigQueryTableSpec::table_source_type].
    pub fn set_table_source_type<T: std::convert::Into<crate::model::TableSourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_source_type = v.into();
        self
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec].
    ///
    /// Note that all the setters affecting `type_spec` are mutually
    /// exclusive.
    pub fn set_type_spec<
        T: std::convert::Into<std::option::Option<crate::model::big_query_table_spec::TypeSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = v.into();
        self
    }

    /// The value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// if it holds a `ViewSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn view_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::ViewSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_table_spec::TypeSpec::ViewSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// to hold a `ViewSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_view_spec<T: std::convert::Into<std::boxed::Box<crate::model::ViewSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::big_query_table_spec::TypeSpec::ViewSpec(v.into()),
        );
        self
    }

    /// The value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// if it holds a `TableSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_spec(&self) -> std::option::Option<&std::boxed::Box<crate::model::TableSpec>> {
        #[allow(unreachable_patterns)]
        self.type_spec.as_ref().and_then(|v| match v {
            crate::model::big_query_table_spec::TypeSpec::TableSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_spec][crate::model::BigQueryTableSpec::type_spec]
    /// to hold a `TableSpec`.
    ///
    /// Note that all the setters affecting `type_spec` are
    /// mutually exclusive.
    pub fn set_table_spec<T: std::convert::Into<std::boxed::Box<crate::model::TableSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_spec = std::option::Option::Some(
            crate::model::big_query_table_spec::TypeSpec::TableSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryTableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryTableSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryTableSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_source_type,
            __view_spec,
            __table_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryTableSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableSourceType" => Ok(__FieldTag::__table_source_type),
                            "table_source_type" => Ok(__FieldTag::__table_source_type),
                            "viewSpec" => Ok(__FieldTag::__view_spec),
                            "view_spec" => Ok(__FieldTag::__view_spec),
                            "tableSpec" => Ok(__FieldTag::__table_spec),
                            "table_spec" => Ok(__FieldTag::__table_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryTableSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryTableSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_source_type => {
                            if !fields.insert(__FieldTag::__table_source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_source_type",
                                ));
                            }
                            result.table_source_type = map
                                .next_value::<std::option::Option<crate::model::TableSourceType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view_spec => {
                            if !fields.insert(__FieldTag::__view_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view_spec",
                                ));
                            }
                            if result.type_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_spec`, a oneof with full ID .google.cloud.datacatalog.v1.BigQueryTableSpec.view_spec, latest field was viewSpec",
                                ));
                            }
                            result.type_spec = std::option::Option::Some(
                                crate::model::big_query_table_spec::TypeSpec::ViewSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ViewSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__table_spec => {
                            if !fields.insert(__FieldTag::__table_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_spec",
                                ));
                            }
                            if result.type_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_spec`, a oneof with full ID .google.cloud.datacatalog.v1.BigQueryTableSpec.table_spec, latest field was tableSpec",
                                ));
                            }
                            result.type_spec = std::option::Option::Some(
                                crate::model::big_query_table_spec::TypeSpec::TableSpec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TableSpec>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryTableSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.table_source_type) {
            state.serialize_entry("tableSourceType", &self.table_source_type)?;
        }
        if let Some(value) = self.view_spec() {
            state.serialize_entry("viewSpec", value)?;
        }
        if let Some(value) = self.table_spec() {
            state.serialize_entry("tableSpec", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BigQueryTableSpec].
pub mod big_query_table_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Output only.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeSpec {
        /// Table view specification. Populated only if
        /// the `table_source_type` is `BIGQUERY_VIEW`.
        ViewSpec(std::boxed::Box<crate::model::ViewSpec>),
        /// Specification of a BigQuery table. Populated only if
        /// the `table_source_type` is `BIGQUERY_TABLE`.
        TableSpec(std::boxed::Box<crate::model::TableSpec>),
    }
}

/// Table view specification.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ViewSpec {
    /// Output only. The query that defines the table view.
    pub view_query: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViewSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view_query][crate::model::ViewSpec::view_query].
    pub fn set_view_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.view_query = v.into();
        self
    }
}

impl wkt::message::Message for ViewSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.ViewSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ViewSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __view_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ViewSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "viewQuery" => Ok(__FieldTag::__view_query),
                            "view_query" => Ok(__FieldTag::__view_query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ViewSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ViewSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__view_query => {
                            if !fields.insert(__FieldTag::__view_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view_query",
                                ));
                            }
                            result.view_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ViewSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.view_query.is_empty() {
            state.serialize_entry("viewQuery", &self.view_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Normal BigQuery table specification.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableSpec {
    /// Output only. If the table is date-sharded, that is, it matches the
    /// `[prefix]YYYYMMDD` name pattern, this field is the Data Catalog resource
    /// name of the date-sharded grouped entry. For example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/entrygroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`.
    ///
    /// Otherwise, `grouped_entry` is empty.
    pub grouped_entry: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [grouped_entry][crate::model::TableSpec::grouped_entry].
    pub fn set_grouped_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grouped_entry = v.into();
        self
    }
}

impl wkt::message::Message for TableSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TableSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __grouped_entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "groupedEntry" => Ok(__FieldTag::__grouped_entry),
                            "grouped_entry" => Ok(__FieldTag::__grouped_entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__grouped_entry => {
                            if !fields.insert(__FieldTag::__grouped_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grouped_entry",
                                ));
                            }
                            result.grouped_entry = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.grouped_entry.is_empty() {
            state.serialize_entry("groupedEntry", &self.grouped_entry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specification for a group of BigQuery tables with the `[prefix]YYYYMMDD` name
/// pattern.
///
/// For more information, see [Introduction to partitioned tables]
/// (<https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding>).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDateShardedSpec {
    /// Output only. The Data Catalog resource name of the dataset entry the
    /// current table belongs to. For example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/entrygroups/{ENTRY_GROUP_ID}/entries/{ENTRY_ID}`.
    pub dataset: std::string::String,

    /// Output only. The table name prefix of the shards.
    ///
    /// The name of any given shard is `[table_prefix]YYYYMMDD`.
    /// For example, for the `MyTable20180101` shard, the
    /// `table_prefix` is `MyTable`.
    pub table_prefix: std::string::String,

    /// Output only. Total number of shards.
    pub shard_count: i64,

    /// Output only. BigQuery resource name of the latest shard.
    pub latest_shard_resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDateShardedSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::BigQueryDateShardedSpec::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [table_prefix][crate::model::BigQueryDateShardedSpec::table_prefix].
    pub fn set_table_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_prefix = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::BigQueryDateShardedSpec::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [latest_shard_resource][crate::model::BigQueryDateShardedSpec::latest_shard_resource].
    pub fn set_latest_shard_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_shard_resource = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDateShardedSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.BigQueryDateShardedSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryDateShardedSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            __table_prefix,
            __shard_count,
            __latest_shard_resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDateShardedSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            "tablePrefix" => Ok(__FieldTag::__table_prefix),
                            "table_prefix" => Ok(__FieldTag::__table_prefix),
                            "shardCount" => Ok(__FieldTag::__shard_count),
                            "shard_count" => Ok(__FieldTag::__shard_count),
                            "latestShardResource" => Ok(__FieldTag::__latest_shard_resource),
                            "latest_shard_resource" => Ok(__FieldTag::__latest_shard_resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryDateShardedSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDateShardedSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_prefix => {
                            if !fields.insert(__FieldTag::__table_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_prefix",
                                ));
                            }
                            result.table_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shard_count => {
                            if !fields.insert(__FieldTag::__shard_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shard_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shard_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__latest_shard_resource => {
                            if !fields.insert(__FieldTag::__latest_shard_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_shard_resource",
                                ));
                            }
                            result.latest_shard_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryDateShardedSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self.table_prefix.is_empty() {
            state.serialize_entry("tablePrefix", &self.table_prefix)?;
        }
        if !wkt::internal::is_default(&self.shard_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shardCount", &__With(&self.shard_count))?;
        }
        if !self.latest_shard_resource.is_empty() {
            state.serialize_entry("latestShardResource", &self.latest_shard_resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Tags contain custom metadata and are attached to Data Catalog resources. Tags
/// conform with the specification of their tag template.
///
/// See [Data Catalog
/// IAM](https://cloud.google.com/data-catalog/docs/concepts/iam) for information
/// on the permissions needed to create or view tags.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Tag {
    /// Identifier. The resource name of the tag in URL format where tag ID is a
    /// system-generated identifier.
    ///
    /// Note: The tag itself might not be stored in the location specified in its
    /// name.
    pub name: std::string::String,

    /// Required. The resource name of the tag template this tag uses. Example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE_ID}`
    ///
    /// This field cannot be modified after creation.
    pub template: std::string::String,

    /// Output only. The display name of the tag template.
    pub template_display_name: std::string::String,

    /// Required. Maps the ID of a tag field to its value and additional
    /// information about that field.
    ///
    /// Tag template defines valid field IDs. A tag
    /// must have at least 1 field and at most 500 fields.
    pub fields: std::collections::HashMap<std::string::String, crate::model::TagField>,

    /// Output only. Denotes the transfer status of the Tag Template.
    pub dataplex_transfer_status: crate::model::tag_template::DataplexTransferStatus,

    /// The scope within the parent resource that this tag is attached to. If not
    /// provided, the tag is attached to the parent resource itself.
    ///
    /// Deleting the scope from the parent resource deletes all tags attached
    /// to that scope.
    ///
    /// These fields cannot be updated after creation.
    pub scope: std::option::Option<crate::model::tag::Scope>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Tag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [template][crate::model::Tag::template].
    pub fn set_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [template_display_name][crate::model::Tag::template_display_name].
    pub fn set_template_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.template_display_name = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Tag::fields].
    pub fn set_fields<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TagField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [dataplex_transfer_status][crate::model::Tag::dataplex_transfer_status].
    pub fn set_dataplex_transfer_status<
        T: std::convert::Into<crate::model::tag_template::DataplexTransferStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_transfer_status = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Tag::scope].
    ///
    /// Note that all the setters affecting `scope` are mutually
    /// exclusive.
    pub fn set_scope<T: std::convert::Into<std::option::Option<crate::model::tag::Scope>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// The value of [scope][crate::model::Tag::scope]
    /// if it holds a `Column`, `None` if the field is not set or
    /// holds a different branch.
    pub fn column(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.scope.as_ref().and_then(|v| match v {
            crate::model::tag::Scope::Column(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scope][crate::model::Tag::scope]
    /// to hold a `Column`.
    ///
    /// Note that all the setters affecting `scope` are
    /// mutually exclusive.
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = std::option::Option::Some(crate::model::tag::Scope::Column(v.into()));
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.Tag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Tag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __template,
            __template_display_name,
            __column,
            __fields,
            __dataplex_transfer_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "template" => Ok(__FieldTag::__template),
                            "templateDisplayName" => Ok(__FieldTag::__template_display_name),
                            "template_display_name" => Ok(__FieldTag::__template_display_name),
                            "column" => Ok(__FieldTag::__column),
                            "fields" => Ok(__FieldTag::__fields),
                            "dataplexTransferStatus" => Ok(__FieldTag::__dataplex_transfer_status),
                            "dataplex_transfer_status" => {
                                Ok(__FieldTag::__dataplex_transfer_status)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Tag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template_display_name => {
                            if !fields.insert(__FieldTag::__template_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_display_name",
                                ));
                            }
                            result.template_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            if result.scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `scope`, a oneof with full ID .google.cloud.datacatalog.v1.Tag.column, latest field was column",
                                ));
                            }
                            result.scope =
                                std::option::Option::Some(crate::model::tag::Scope::Column(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TagField,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataplex_transfer_status => {
                            if !fields.insert(__FieldTag::__dataplex_transfer_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataplex_transfer_status",
                                ));
                            }
                            result.dataplex_transfer_status = map
                                .next_value::<std::option::Option<
                                    crate::model::tag_template::DataplexTransferStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Tag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.template.is_empty() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self.template_display_name.is_empty() {
            state.serialize_entry("templateDisplayName", &self.template_display_name)?;
        }
        if let Some(value) = self.column() {
            state.serialize_entry("column", value)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !wkt::internal::is_default(&self.dataplex_transfer_status) {
            state.serialize_entry("dataplexTransferStatus", &self.dataplex_transfer_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Tag].
pub mod tag {
    #[allow(unused_imports)]
    use super::*;

    /// The scope within the parent resource that this tag is attached to. If not
    /// provided, the tag is attached to the parent resource itself.
    ///
    /// Deleting the scope from the parent resource deletes all tags attached
    /// to that scope.
    ///
    /// These fields cannot be updated after creation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Resources like entry can have schemas associated with them. This scope
        /// allows you to attach tags to an individual column based on that schema.
        ///
        /// To attach a tag to a nested column, separate column names with a dot
        /// (`.`). Example: `column.nested_column`.
        Column(std::string::String),
    }
}

/// Contains the value and additional information on a field within
/// a [Tag][google.cloud.datacatalog.v1.Tag].
///
/// [google.cloud.datacatalog.v1.Tag]: crate::model::Tag
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TagField {
    /// Output only. The display name of this field.
    pub display_name: std::string::String,

    /// Output only. The order of this field with respect to other fields in this
    /// tag. Can be set by
    /// [Tag][google.cloud.datacatalog.v1.TagTemplateField.order].
    ///
    /// For example, a higher value can indicate a more important field.
    /// The value can be negative. Multiple fields can have the same order, and
    /// field orders within a tag don't have to be sequential.
    ///
    /// [google.cloud.datacatalog.v1.TagTemplateField.order]: crate::model::TagTemplateField::order
    pub order: i32,

    /// Required. The value of this field.
    pub kind: std::option::Option<crate::model::tag_field::Kind>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TagField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::TagField::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [order][crate::model::TagField::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::TagField::kind].
    ///
    /// Note that all the setters affecting `kind` are mutually
    /// exclusive.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::tag_field::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::DoubleValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::StringValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::BoolValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `TimestampValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timestamp_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::TimestampValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `TimestampValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_timestamp_value<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::tag_field::Kind::TimestampValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `EnumValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn enum_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::tag_field::EnumValue>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::EnumValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `EnumValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_enum_value<
        T: std::convert::Into<std::boxed::Box<crate::model::tag_field::EnumValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::tag_field::Kind::EnumValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::TagField::kind]
    /// if it holds a `RichtextValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn richtext_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::tag_field::Kind::RichtextValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::TagField::kind]
    /// to hold a `RichtextValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_richtext_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::tag_field::Kind::RichtextValue(v.into()));
        self
    }
}

impl wkt::message::Message for TagField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagField"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TagField {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __double_value,
            __string_value,
            __bool_value,
            __timestamp_value,
            __enum_value,
            __richtext_value,
            __order,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TagField")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "doubleValue" => Ok(__FieldTag::__double_value),
                            "double_value" => Ok(__FieldTag::__double_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "timestampValue" => Ok(__FieldTag::__timestamp_value),
                            "timestamp_value" => Ok(__FieldTag::__timestamp_value),
                            "enumValue" => Ok(__FieldTag::__enum_value),
                            "enum_value" => Ok(__FieldTag::__enum_value),
                            "richtextValue" => Ok(__FieldTag::__richtext_value),
                            "richtext_value" => Ok(__FieldTag::__richtext_value),
                            "order" => Ok(__FieldTag::__order),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TagField;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TagField")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__double_value => {
                            if !fields.insert(__FieldTag::__double_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.datacatalog.v1.TagField.double_value, latest field was doubleValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::tag_field::Kind::DoubleValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.datacatalog.v1.TagField.string_value, latest field was stringValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::tag_field::Kind::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.datacatalog.v1.TagField.bool_value, latest field was boolValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::tag_field::Kind::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__timestamp_value => {
                            if !fields.insert(__FieldTag::__timestamp_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.datacatalog.v1.TagField.timestamp_value, latest field was timestampValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::tag_field::Kind::TimestampValue(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__enum_value => {
                            if !fields.insert(__FieldTag::__enum_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.datacatalog.v1.TagField.enum_value, latest field was enumValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::tag_field::Kind::EnumValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::tag_field::EnumValue>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__richtext_value => {
                            if !fields.insert(__FieldTag::__richtext_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for richtext_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.datacatalog.v1.TagField.richtext_value, latest field was richtextValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::tag_field::Kind::RichtextValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__order => {
                            if !fields.insert(__FieldTag::__order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.order = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TagField {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.double_value() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("doubleValue", &__With(value))?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.timestamp_value() {
            state.serialize_entry("timestampValue", value)?;
        }
        if let Some(value) = self.enum_value() {
            state.serialize_entry("enumValue", value)?;
        }
        if let Some(value) = self.richtext_value() {
            state.serialize_entry("richtextValue", value)?;
        }
        if !wkt::internal::is_default(&self.order) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("order", &__With(&self.order))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TagField].
pub mod tag_field {
    #[allow(unused_imports)]
    use super::*;

    /// An enum value.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EnumValue {
        /// The display name of the enum value.
        pub display_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EnumValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::tag_field::EnumValue::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EnumValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.TagField.EnumValue"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EnumValue {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EnumValue")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EnumValue;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EnumValue")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EnumValue {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Required. The value of this field.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// The value of a tag field with a double type.
        DoubleValue(f64),
        /// The value of a tag field with a string type.
        ///
        /// The maximum length is 2000 UTF-8 characters.
        StringValue(std::string::String),
        /// The value of a tag field with a boolean type.
        BoolValue(bool),
        /// The value of a tag field with a timestamp type.
        TimestampValue(std::boxed::Box<wkt::Timestamp>),
        /// The value of a tag field with an enum type.
        ///
        /// This value must be one of the allowed values listed in this enum.
        EnumValue(std::boxed::Box<crate::model::tag_field::EnumValue>),
        /// The value of a tag field with a rich text type.
        ///
        /// The maximum length is 10 MiB as this value holds HTML descriptions
        /// including encoded images. The maximum length of the text without images
        /// is 100 KiB.
        RichtextValue(std::string::String),
    }
}

/// A tag template defines a tag that can have one or more typed fields.
///
/// The template is used to create tags that are attached to Google Cloud
/// resources. [Tag template roles]
/// (<https://cloud.google.com/iam/docs/understanding-roles#data-catalog-roles>)
/// provide permissions to create, edit, and use the template. For example,
/// see the [TagTemplate User]
/// (<https://cloud.google.com/data-catalog/docs/how-to/template-user>) role
/// that includes a permission to use the tag template to tag resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TagTemplate {
    /// Identifier. The resource name of the tag template in URL format.
    ///
    /// Note: The tag template itself and its child resources might not be
    /// stored in the location specified in its name.
    pub name: std::string::String,

    /// Display name for this template. Defaults to an empty string.
    ///
    /// The name must contain only Unicode letters, numbers (0-9), underscores (_),
    /// dashes (-), spaces ( ), and can't start or end with spaces.
    /// The maximum length is 200 characters.
    pub display_name: std::string::String,

    /// Indicates whether tags created with this template are public. Public tags
    /// do not require tag template access to appear in
    /// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags] API response.
    ///
    /// Additionally, you can search for a public tag by value with a
    /// simple search query in addition to using a ``tag:`` predicate.
    ///
    /// [google.cloud.datacatalog.v1.DataCatalog.ListTags]: crate::client::DataCatalog::list_tags
    pub is_publicly_readable: bool,

    /// Required. Map of tag template field IDs to the settings for the field.
    /// This map is an exhaustive list of the allowed fields. The map must contain
    /// at least one field and at most 500 fields.
    ///
    /// The keys to this map are tag template field IDs. The IDs have the
    /// following limitations:
    ///
    /// * Can contain uppercase and lowercase letters, numbers (0-9) and
    ///   underscores (_).
    /// * Must be at least 1 character and at most 64 characters long.
    /// * Must start with a letter or underscore.
    pub fields: std::collections::HashMap<std::string::String, crate::model::TagTemplateField>,

    /// Optional. Transfer status of the TagTemplate
    pub dataplex_transfer_status: crate::model::tag_template::DataplexTransferStatus,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TagTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TagTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TagTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [is_publicly_readable][crate::model::TagTemplate::is_publicly_readable].
    pub fn set_is_publicly_readable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_publicly_readable = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TagTemplate::fields].
    pub fn set_fields<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TagTemplateField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [dataplex_transfer_status][crate::model::TagTemplate::dataplex_transfer_status].
    pub fn set_dataplex_transfer_status<
        T: std::convert::Into<crate::model::tag_template::DataplexTransferStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_transfer_status = v.into();
        self
    }
}

impl wkt::message::Message for TagTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TagTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __is_publicly_readable,
            __fields,
            __dataplex_transfer_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TagTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "isPubliclyReadable" => Ok(__FieldTag::__is_publicly_readable),
                            "is_publicly_readable" => Ok(__FieldTag::__is_publicly_readable),
                            "fields" => Ok(__FieldTag::__fields),
                            "dataplexTransferStatus" => Ok(__FieldTag::__dataplex_transfer_status),
                            "dataplex_transfer_status" => {
                                Ok(__FieldTag::__dataplex_transfer_status)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TagTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TagTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_publicly_readable => {
                            if !fields.insert(__FieldTag::__is_publicly_readable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_publicly_readable",
                                ));
                            }
                            result.is_publicly_readable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TagTemplateField,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataplex_transfer_status => {
                            if !fields.insert(__FieldTag::__dataplex_transfer_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataplex_transfer_status",
                                ));
                            }
                            result.dataplex_transfer_status = map
                                .next_value::<std::option::Option<
                                    crate::model::tag_template::DataplexTransferStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TagTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.is_publicly_readable) {
            state.serialize_entry("isPubliclyReadable", &self.is_publicly_readable)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !wkt::internal::is_default(&self.dataplex_transfer_status) {
            state.serialize_entry("dataplexTransferStatus", &self.dataplex_transfer_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TagTemplate].
pub mod tag_template {
    #[allow(unused_imports)]
    use super::*;

    /// This enum describes TagTemplate transfer status to Dataplex service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataplexTransferStatus {
        /// Default value. TagTemplate and its tags are only visible and editable in
        /// DataCatalog.
        Unspecified,
        /// TagTemplate and its tags are auto-copied to Dataplex service.
        /// Visible in both services. Editable in DataCatalog, read-only in Dataplex.
        /// Deprecated: Individual TagTemplate migration is deprecated in favor of
        /// organization or project wide TagTemplate migration opt-in.
        #[deprecated]
        Migrated,
        /// TagTemplate and its tags are auto-copied to Dataplex service.
        /// Visible in both services. Editable in Dataplex, read-only in DataCatalog.
        Transferred,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataplexTransferStatus::value] or
        /// [DataplexTransferStatus::name].
        UnknownValue(dataplex_transfer_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dataplex_transfer_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataplexTransferStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Migrated => std::option::Option::Some(1),
                Self::Transferred => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DATAPLEX_TRANSFER_STATUS_UNSPECIFIED")
                }
                Self::Migrated => std::option::Option::Some("MIGRATED"),
                Self::Transferred => std::option::Option::Some("TRANSFERRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataplexTransferStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataplexTransferStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataplexTransferStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Migrated,
                2 => Self::Transferred,
                _ => Self::UnknownValue(dataplex_transfer_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataplexTransferStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATAPLEX_TRANSFER_STATUS_UNSPECIFIED" => Self::Unspecified,
                "MIGRATED" => Self::Migrated,
                "TRANSFERRED" => Self::Transferred,
                _ => Self::UnknownValue(dataplex_transfer_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataplexTransferStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Migrated => serializer.serialize_i32(1),
                Self::Transferred => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataplexTransferStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataplexTransferStatus>::new(
                ".google.cloud.datacatalog.v1.TagTemplate.DataplexTransferStatus",
            ))
        }
    }
}

/// The template for an individual field within a tag template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TagTemplateField {
    /// Identifier. The resource name of the tag template field in URL format.
    /// Example:
    ///
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE}/fields/{FIELD}`
    ///
    /// Note: The tag template field itself might not be stored in the location
    /// specified in its name.
    ///
    /// The name must contain only letters (a-z, A-Z), numbers (0-9),
    /// or underscores (_), and must start with a letter or underscore.
    /// The maximum length is 64 characters.
    pub name: std::string::String,

    /// The display name for this field. Defaults to an empty string.
    ///
    /// The name must contain only Unicode letters, numbers (0-9), underscores (_),
    /// dashes (-), spaces ( ), and can't start or end with spaces.
    /// The maximum length is 200 characters.
    pub display_name: std::string::String,

    /// Required. The type of value this tag field can contain.
    pub r#type: std::option::Option<crate::model::FieldType>,

    /// If true, this field is required. Defaults to false.
    pub is_required: bool,

    /// The description for this field. Defaults to an empty string.
    pub description: std::string::String,

    /// The order of this field with respect to other fields in this tag
    /// template.
    ///
    /// For example, a higher value can indicate a more important field.
    /// The value can be negative. Multiple fields can have the same order and
    /// field orders within a tag don't have to be sequential.
    pub order: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TagTemplateField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TagTemplateField::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TagTemplateField::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TagTemplateField::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldType>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::TagTemplateField::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldType>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_required][crate::model::TagTemplateField::is_required].
    pub fn set_is_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_required = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TagTemplateField::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [order][crate::model::TagTemplateField::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }
}

impl wkt::message::Message for TagTemplateField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.TagTemplateField"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TagTemplateField {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __type,
            __is_required,
            __description,
            __order,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TagTemplateField")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "type" => Ok(__FieldTag::__type),
                            "isRequired" => Ok(__FieldTag::__is_required),
                            "is_required" => Ok(__FieldTag::__is_required),
                            "description" => Ok(__FieldTag::__description),
                            "order" => Ok(__FieldTag::__order),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TagTemplateField;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TagTemplateField")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<crate::model::FieldType>>()?;
                        }
                        __FieldTag::__is_required => {
                            if !fields.insert(__FieldTag::__is_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_required",
                                ));
                            }
                            result.is_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order => {
                            if !fields.insert(__FieldTag::__order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.order = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TagTemplateField {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.is_required) {
            state.serialize_entry("isRequired", &self.is_required)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.order) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("order", &__With(&self.order))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FieldType {
    /// Required.
    pub type_decl: std::option::Option<crate::model::field_type::TypeDecl>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl].
    ///
    /// Note that all the setters affecting `type_decl` are mutually
    /// exclusive.
    pub fn set_type_decl<
        T: std::convert::Into<std::option::Option<crate::model::field_type::TypeDecl>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_decl = v.into();
        self
    }

    /// The value of [type_decl][crate::model::FieldType::type_decl]
    /// if it holds a `PrimitiveType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn primitive_type(&self) -> std::option::Option<&crate::model::field_type::PrimitiveType> {
        #[allow(unreachable_patterns)]
        self.type_decl.as_ref().and_then(|v| match v {
            crate::model::field_type::TypeDecl::PrimitiveType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl]
    /// to hold a `PrimitiveType`.
    ///
    /// Note that all the setters affecting `type_decl` are
    /// mutually exclusive.
    pub fn set_primitive_type<T: std::convert::Into<crate::model::field_type::PrimitiveType>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_decl =
            std::option::Option::Some(crate::model::field_type::TypeDecl::PrimitiveType(v.into()));
        self
    }

    /// The value of [type_decl][crate::model::FieldType::type_decl]
    /// if it holds a `EnumType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn enum_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::field_type::EnumType>> {
        #[allow(unreachable_patterns)]
        self.type_decl.as_ref().and_then(|v| match v {
            crate::model::field_type::TypeDecl::EnumType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_decl][crate::model::FieldType::type_decl]
    /// to hold a `EnumType`.
    ///
    /// Note that all the setters affecting `type_decl` are
    /// mutually exclusive.
    pub fn set_enum_type<
        T: std::convert::Into<std::boxed::Box<crate::model::field_type::EnumType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.type_decl =
            std::option::Option::Some(crate::model::field_type::TypeDecl::EnumType(v.into()));
        self
    }
}

impl wkt::message::Message for FieldType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.FieldType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FieldType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __primitive_type,
            __enum_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "primitiveType" => Ok(__FieldTag::__primitive_type),
                            "primitive_type" => Ok(__FieldTag::__primitive_type),
                            "enumType" => Ok(__FieldTag::__enum_type),
                            "enum_type" => Ok(__FieldTag::__enum_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FieldType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__primitive_type => {
                            if !fields.insert(__FieldTag::__primitive_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primitive_type",
                                ));
                            }
                            if result.type_decl.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_decl`, a oneof with full ID .google.cloud.datacatalog.v1.FieldType.primitive_type, latest field was primitiveType",
                                ));
                            }
                            result.type_decl = std::option::Option::Some(
                                crate::model::field_type::TypeDecl::PrimitiveType(
                                    map.next_value::<std::option::Option<
                                        crate::model::field_type::PrimitiveType,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__enum_type => {
                            if !fields.insert(__FieldTag::__enum_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_type",
                                ));
                            }
                            if result.type_decl.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_decl`, a oneof with full ID .google.cloud.datacatalog.v1.FieldType.enum_type, latest field was enumType",
                                ));
                            }
                            result.type_decl = std::option::Option::Some(
                                crate::model::field_type::TypeDecl::EnumType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::field_type::EnumType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FieldType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.primitive_type() {
            state.serialize_entry("primitiveType", value)?;
        }
        if let Some(value) = self.enum_type() {
            state.serialize_entry("enumType", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FieldType].
pub mod field_type {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EnumType {
        /// The set of allowed values for this enum.
        ///
        /// This set must not be empty and can include up to 100 allowed values.
        /// The display names of the values in this set must not be empty and must
        /// be case-insensitively unique within this set.
        ///
        /// The order of items in this set is preserved. This field can be used to
        /// create, remove, and reorder enum values. To rename enum values, use the
        /// `RenameTagTemplateFieldEnumValue` method.
        pub allowed_values: std::vec::Vec<crate::model::field_type::enum_type::EnumValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EnumType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_values][crate::model::field_type::EnumType::allowed_values].
        pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::field_type::enum_type::EnumValue>,
        {
            use std::iter::Iterator;
            self.allowed_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EnumType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.datacatalog.v1.FieldType.EnumType"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EnumType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allowed_values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EnumType")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allowedValues" => Ok(__FieldTag::__allowed_values),
                                "allowed_values" => Ok(__FieldTag::__allowed_values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EnumType;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EnumType")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allowed_values => {
                                if !fields.insert(__FieldTag::__allowed_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_values",
                                    ));
                                }
                                result.allowed_values = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::field_type::enum_type::EnumValue,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EnumType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allowed_values.is_empty() {
                state.serialize_entry("allowedValues", &self.allowed_values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [EnumType].
    pub mod enum_type {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct EnumValue {
            /// Required. The display name of the enum value. Must not be an empty
            /// string.
            ///
            /// The name must contain only Unicode letters, numbers (0-9), underscores
            /// (_), dashes (-), spaces ( ), and can't start or end with spaces. The
            /// maximum length is 200 characters.
            pub display_name: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EnumValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [display_name][crate::model::field_type::enum_type::EnumValue::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }
        }

        impl wkt::message::Message for EnumValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.datacatalog.v1.FieldType.EnumType.EnumValue"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for EnumValue {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __display_name,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for EnumValue")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = EnumValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct EnumValue")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for EnumValue {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrimitiveType {
        /// The default invalid value for a type.
        Unspecified,
        /// A double precision number.
        Double,
        /// An UTF-8 string.
        String,
        /// A boolean value.
        Bool,
        /// A timestamp.
        Timestamp,
        /// A Richtext description.
        Richtext,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrimitiveType::value] or
        /// [PrimitiveType::name].
        UnknownValue(primitive_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod primitive_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrimitiveType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Double => std::option::Option::Some(1),
                Self::String => std::option::Option::Some(2),
                Self::Bool => std::option::Option::Some(3),
                Self::Timestamp => std::option::Option::Some(4),
                Self::Richtext => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIMITIVE_TYPE_UNSPECIFIED"),
                Self::Double => std::option::Option::Some("DOUBLE"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::Timestamp => std::option::Option::Some("TIMESTAMP"),
                Self::Richtext => std::option::Option::Some("RICHTEXT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrimitiveType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrimitiveType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrimitiveType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Double,
                2 => Self::String,
                3 => Self::Bool,
                4 => Self::Timestamp,
                5 => Self::Richtext,
                _ => Self::UnknownValue(primitive_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrimitiveType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIMITIVE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DOUBLE" => Self::Double,
                "STRING" => Self::String,
                "BOOL" => Self::Bool,
                "TIMESTAMP" => Self::Timestamp,
                "RICHTEXT" => Self::Richtext,
                _ => Self::UnknownValue(primitive_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrimitiveType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Double => serializer.serialize_i32(1),
                Self::String => serializer.serialize_i32(2),
                Self::Bool => serializer.serialize_i32(3),
                Self::Timestamp => serializer.serialize_i32(4),
                Self::Richtext => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrimitiveType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrimitiveType>::new(
                ".google.cloud.datacatalog.v1.FieldType.PrimitiveType",
            ))
        }
    }

    /// Required.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeDecl {
        /// Primitive types, such as string, boolean, etc.
        PrimitiveType(crate::model::field_type::PrimitiveType),
        /// An enum type.
        EnumType(std::boxed::Box<crate::model::field_type::EnumType>),
    }
}

/// Timestamps associated with this resource in a particular system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SystemTimestamps {
    /// Creation timestamp of the resource within the given system.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Timestamp of the last modification of the resource or its metadata within
    /// a given system.
    ///
    /// Note: Depending on the source system, not every modification updates this
    /// timestamp.
    /// For example, BigQuery timestamps every metadata modification but not data
    /// or permission changes.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Expiration timestamp of the resource within the given system.
    ///
    /// Currently only applicable to BigQuery resources.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SystemTimestamps {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::SystemTimestamps::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SystemTimestamps::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::SystemTimestamps::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SystemTimestamps::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::SystemTimestamps::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::SystemTimestamps::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SystemTimestamps {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.SystemTimestamps"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SystemTimestamps {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SystemTimestamps")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SystemTimestamps;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SystemTimestamps")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SystemTimestamps {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Detailed statistics on the entry's usage.
///
/// Usage statistics have the following limitations:
///
/// - Only BigQuery tables have them.
/// - They only include BigQuery query jobs.
/// - They might be underestimated because wildcard table references
///   are not yet counted. For more information, see
///   [Querying multiple tables using a wildcard table]
///   (<https://cloud.google.com/bigquery/docs/querying-wildcard-tables>)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UsageStats {
    /// The number of successful uses of the underlying entry.
    pub total_completions: f32,

    /// The number of failed attempts to use the underlying entry.
    pub total_failures: f32,

    /// The number of cancelled attempts to use the underlying entry.
    pub total_cancellations: f32,

    /// Total time spent only on successful uses, in milliseconds.
    pub total_execution_time_for_completions_millis: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_completions][crate::model::UsageStats::total_completions].
    pub fn set_total_completions<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_completions = v.into();
        self
    }

    /// Sets the value of [total_failures][crate::model::UsageStats::total_failures].
    pub fn set_total_failures<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_failures = v.into();
        self
    }

    /// Sets the value of [total_cancellations][crate::model::UsageStats::total_cancellations].
    pub fn set_total_cancellations<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.total_cancellations = v.into();
        self
    }

    /// Sets the value of [total_execution_time_for_completions_millis][crate::model::UsageStats::total_execution_time_for_completions_millis].
    pub fn set_total_execution_time_for_completions_millis<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_execution_time_for_completions_millis = v.into();
        self
    }
}

impl wkt::message::Message for UsageStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UsageStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UsageStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_completions,
            __total_failures,
            __total_cancellations,
            __total_execution_time_for_completions_millis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsageStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalCompletions" => Ok(__FieldTag::__total_completions),
                            "total_completions" => Ok(__FieldTag::__total_completions),
                            "totalFailures" => Ok(__FieldTag::__total_failures),
                            "total_failures" => Ok(__FieldTag::__total_failures),
                            "totalCancellations" => Ok(__FieldTag::__total_cancellations),
                            "total_cancellations" => Ok(__FieldTag::__total_cancellations),
                            "totalExecutionTimeForCompletionsMillis" => {
                                Ok(__FieldTag::__total_execution_time_for_completions_millis)
                            }
                            "total_execution_time_for_completions_millis" => {
                                Ok(__FieldTag::__total_execution_time_for_completions_millis)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UsageStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsageStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_completions => {
                            if !fields.insert(__FieldTag::__total_completions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_completions",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_completions =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_failures => {
                            if !fields.insert(__FieldTag::__total_failures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_failures",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_failures =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_cancellations => {
                            if !fields.insert(__FieldTag::__total_cancellations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_cancellations",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_cancellations =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_execution_time_for_completions_millis => {
                            if !fields
                                .insert(__FieldTag::__total_execution_time_for_completions_millis)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_execution_time_for_completions_millis",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_execution_time_for_completions_millis =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UsageStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_completions) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCompletions", &__With(&self.total_completions))?;
        }
        if !wkt::internal::is_default(&self.total_failures) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalFailures", &__With(&self.total_failures))?;
        }
        if !wkt::internal::is_default(&self.total_cancellations) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCancellations", &__With(&self.total_cancellations))?;
        }
        if !wkt::internal::is_default(&self.total_execution_time_for_completions_millis) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalExecutionTimeForCompletionsMillis",
                &__With(&self.total_execution_time_for_completions_millis),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Common statistics on the entry's usage.
///
/// They can be set on any system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommonUsageStats {
    /// View count in source system.
    pub view_count: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommonUsageStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view_count][crate::model::CommonUsageStats::view_count].
    pub fn set_view_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.view_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view_count][crate::model::CommonUsageStats::view_count].
    pub fn set_or_clear_view_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.view_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CommonUsageStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.CommonUsageStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommonUsageStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __view_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommonUsageStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "viewCount" => Ok(__FieldTag::__view_count),
                            "view_count" => Ok(__FieldTag::__view_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommonUsageStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommonUsageStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__view_count => {
                            if !fields.insert(__FieldTag::__view_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.view_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommonUsageStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.view_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("viewCount", &__With(&self.view_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The set of all usage signals that Data Catalog stores.
///
/// Note: Usually, these signals are updated daily. In rare cases, an update may
/// fail but will be performed again on the next day.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UsageSignal {
    /// The end timestamp of the duration of usage statistics.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. BigQuery usage statistics over each of the predefined time
    /// ranges.
    ///
    /// Supported time ranges are `{"24H", "7D", "30D"}`.
    pub usage_within_time_range:
        std::collections::HashMap<std::string::String, crate::model::UsageStats>,

    /// Common usage statistics over each of the predefined time ranges.
    ///
    /// Supported time ranges are `{"24H", "7D", "30D", "Lifetime"}`.
    pub common_usage_within_time_range:
        std::collections::HashMap<std::string::String, crate::model::CommonUsageStats>,

    /// Favorite count in the source system.
    pub favorite_count: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageSignal {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::UsageSignal::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::UsageSignal::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [usage_within_time_range][crate::model::UsageSignal::usage_within_time_range].
    pub fn set_usage_within_time_range<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::UsageStats>,
    {
        use std::iter::Iterator;
        self.usage_within_time_range = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [common_usage_within_time_range][crate::model::UsageSignal::common_usage_within_time_range].
    pub fn set_common_usage_within_time_range<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CommonUsageStats>,
    {
        use std::iter::Iterator;
        self.common_usage_within_time_range =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [favorite_count][crate::model::UsageSignal::favorite_count].
    pub fn set_favorite_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.favorite_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [favorite_count][crate::model::UsageSignal::favorite_count].
    pub fn set_or_clear_favorite_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.favorite_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UsageSignal {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.v1.UsageSignal"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UsageSignal {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_time,
            __usage_within_time_range,
            __common_usage_within_time_range,
            __favorite_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsageSignal")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "usageWithinTimeRange" => Ok(__FieldTag::__usage_within_time_range),
                            "usage_within_time_range" => Ok(__FieldTag::__usage_within_time_range),
                            "commonUsageWithinTimeRange" => {
                                Ok(__FieldTag::__common_usage_within_time_range)
                            }
                            "common_usage_within_time_range" => {
                                Ok(__FieldTag::__common_usage_within_time_range)
                            }
                            "favoriteCount" => Ok(__FieldTag::__favorite_count),
                            "favorite_count" => Ok(__FieldTag::__favorite_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UsageSignal;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsageSignal")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__usage_within_time_range => {
                            if !fields.insert(__FieldTag::__usage_within_time_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage_within_time_range",
                                ));
                            }
                            result.usage_within_time_range = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::UsageStats,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__common_usage_within_time_range => {
                            if !fields.insert(__FieldTag::__common_usage_within_time_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_usage_within_time_range",
                                ));
                            }
                            result.common_usage_within_time_range = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::CommonUsageStats,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__favorite_count => {
                            if !fields.insert(__FieldTag::__favorite_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for favorite_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.favorite_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UsageSignal {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.usage_within_time_range.is_empty() {
            state.serialize_entry("usageWithinTimeRange", &self.usage_within_time_range)?;
        }
        if !self.common_usage_within_time_range.is_empty() {
            state.serialize_entry(
                "commonUsageWithinTimeRange",
                &self.common_usage_within_time_range,
            )?;
        }
        if self.favorite_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("favoriteCount", &__With(&self.favorite_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This enum lists all the systems that Data Catalog integrates with.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IntegratedSystem {
    /// Default unknown system.
    Unspecified,
    /// BigQuery.
    Bigquery,
    /// Cloud Pub/Sub.
    CloudPubsub,
    /// Dataproc Metastore.
    DataprocMetastore,
    /// Dataplex.
    Dataplex,
    /// Cloud Spanner
    CloudSpanner,
    /// Cloud Bigtable
    CloudBigtable,
    /// Cloud Sql
    CloudSql,
    /// Looker
    Looker,
    /// Vertex AI
    VertexAi,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IntegratedSystem::value] or
    /// [IntegratedSystem::name].
    UnknownValue(integrated_system::UnknownValue),
}

#[doc(hidden)]
pub mod integrated_system {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IntegratedSystem {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Bigquery => std::option::Option::Some(1),
            Self::CloudPubsub => std::option::Option::Some(2),
            Self::DataprocMetastore => std::option::Option::Some(3),
            Self::Dataplex => std::option::Option::Some(4),
            Self::CloudSpanner => std::option::Option::Some(6),
            Self::CloudBigtable => std::option::Option::Some(7),
            Self::CloudSql => std::option::Option::Some(8),
            Self::Looker => std::option::Option::Some(9),
            Self::VertexAi => std::option::Option::Some(10),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INTEGRATED_SYSTEM_UNSPECIFIED"),
            Self::Bigquery => std::option::Option::Some("BIGQUERY"),
            Self::CloudPubsub => std::option::Option::Some("CLOUD_PUBSUB"),
            Self::DataprocMetastore => std::option::Option::Some("DATAPROC_METASTORE"),
            Self::Dataplex => std::option::Option::Some("DATAPLEX"),
            Self::CloudSpanner => std::option::Option::Some("CLOUD_SPANNER"),
            Self::CloudBigtable => std::option::Option::Some("CLOUD_BIGTABLE"),
            Self::CloudSql => std::option::Option::Some("CLOUD_SQL"),
            Self::Looker => std::option::Option::Some("LOOKER"),
            Self::VertexAi => std::option::Option::Some("VERTEX_AI"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IntegratedSystem {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IntegratedSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IntegratedSystem {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Bigquery,
            2 => Self::CloudPubsub,
            3 => Self::DataprocMetastore,
            4 => Self::Dataplex,
            6 => Self::CloudSpanner,
            7 => Self::CloudBigtable,
            8 => Self::CloudSql,
            9 => Self::Looker,
            10 => Self::VertexAi,
            _ => Self::UnknownValue(integrated_system::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IntegratedSystem {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INTEGRATED_SYSTEM_UNSPECIFIED" => Self::Unspecified,
            "BIGQUERY" => Self::Bigquery,
            "CLOUD_PUBSUB" => Self::CloudPubsub,
            "DATAPROC_METASTORE" => Self::DataprocMetastore,
            "DATAPLEX" => Self::Dataplex,
            "CLOUD_SPANNER" => Self::CloudSpanner,
            "CLOUD_BIGTABLE" => Self::CloudBigtable,
            "CLOUD_SQL" => Self::CloudSql,
            "LOOKER" => Self::Looker,
            "VERTEX_AI" => Self::VertexAi,
            _ => Self::UnknownValue(integrated_system::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IntegratedSystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Bigquery => serializer.serialize_i32(1),
            Self::CloudPubsub => serializer.serialize_i32(2),
            Self::DataprocMetastore => serializer.serialize_i32(3),
            Self::Dataplex => serializer.serialize_i32(4),
            Self::CloudSpanner => serializer.serialize_i32(6),
            Self::CloudBigtable => serializer.serialize_i32(7),
            Self::CloudSql => serializer.serialize_i32(8),
            Self::Looker => serializer.serialize_i32(9),
            Self::VertexAi => serializer.serialize_i32(10),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IntegratedSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IntegratedSystem>::new(
            ".google.cloud.datacatalog.v1.IntegratedSystem",
        ))
    }
}

/// This enum describes all the systems that manage
/// Taxonomy and PolicyTag resources in DataCatalog.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ManagingSystem {
    /// Default value
    Unspecified,
    /// Dataplex.
    Dataplex,
    /// Other
    Other,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ManagingSystem::value] or
    /// [ManagingSystem::name].
    UnknownValue(managing_system::UnknownValue),
}

#[doc(hidden)]
pub mod managing_system {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ManagingSystem {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Dataplex => std::option::Option::Some(1),
            Self::Other => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MANAGING_SYSTEM_UNSPECIFIED"),
            Self::Dataplex => std::option::Option::Some("MANAGING_SYSTEM_DATAPLEX"),
            Self::Other => std::option::Option::Some("MANAGING_SYSTEM_OTHER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ManagingSystem {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ManagingSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ManagingSystem {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Dataplex,
            2 => Self::Other,
            _ => Self::UnknownValue(managing_system::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ManagingSystem {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MANAGING_SYSTEM_UNSPECIFIED" => Self::Unspecified,
            "MANAGING_SYSTEM_DATAPLEX" => Self::Dataplex,
            "MANAGING_SYSTEM_OTHER" => Self::Other,
            _ => Self::UnknownValue(managing_system::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ManagingSystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Dataplex => serializer.serialize_i32(1),
            Self::Other => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ManagingSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManagingSystem>::new(
            ".google.cloud.datacatalog.v1.ManagingSystem",
        ))
    }
}

/// Metadata automatically ingested from Google Cloud resources like BigQuery
/// tables or Pub/Sub topics always uses enum values from `EntryType` as the type
/// of entry.
///
/// Other sources of metadata like Hive or Oracle databases can identify the type
/// by either using one of the enum values from `EntryType` (for example,
/// `FILESET` for a Cloud Storage fileset) or specifying a custom value using
/// the [`Entry`](#resource:-entry) field `user_specified_type`. For more
/// information, see
/// [Surface files from Cloud Storage with fileset
/// entries](/data-catalog/docs/how-to/filesets) or [Create custom entries for
/// your data sources](/data-catalog/docs/how-to/custom-entries).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EntryType {
    /// Default unknown type.
    Unspecified,
    /// The entry type that has a GoogleSQL schema, including
    /// logical views.
    Table,
    /// The type of models.
    ///
    /// For more information, see [Supported models in BigQuery
    /// ML](/bigquery/docs/bqml-introduction#supported_models).
    Model,
    /// An entry type for streaming entries. For example, a Pub/Sub topic.
    DataStream,
    /// An entry type for a set of files or objects. For example, a
    /// Cloud Storage fileset.
    Fileset,
    /// A group of servers that work together. For example, a Kafka cluster.
    Cluster,
    /// A database.
    Database,
    /// Connection to a data source. For example, a BigQuery
    /// connection.
    DataSourceConnection,
    /// Routine, for example, a BigQuery routine.
    Routine,
    /// A Dataplex lake.
    Lake,
    /// A Dataplex zone.
    Zone,
    /// A service, for example, a Dataproc Metastore service.
    Service,
    /// Schema within a relational database.
    DatabaseSchema,
    /// A Dashboard, for example from Looker.
    Dashboard,
    /// A Looker Explore.
    ///
    /// For more information, see [Looker Explore API]
    /// (<https://developers.looker.com/api/explorer/4.0/methods/LookmlModel/lookml_model_explore>).
    Explore,
    /// A Looker Look.
    ///
    /// For more information, see [Looker Look API]
    /// (<https://developers.looker.com/api/explorer/4.0/methods/Look>).
    Look,
    /// Feature Online Store resource in Vertex AI Feature Store.
    FeatureOnlineStore,
    /// Feature View resource in Vertex AI Feature Store.
    FeatureView,
    /// Feature Group resource in Vertex AI Feature Store.
    FeatureGroup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EntryType::value] or
    /// [EntryType::name].
    UnknownValue(entry_type::UnknownValue),
}

#[doc(hidden)]
pub mod entry_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EntryType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Table => std::option::Option::Some(2),
            Self::Model => std::option::Option::Some(5),
            Self::DataStream => std::option::Option::Some(3),
            Self::Fileset => std::option::Option::Some(4),
            Self::Cluster => std::option::Option::Some(6),
            Self::Database => std::option::Option::Some(7),
            Self::DataSourceConnection => std::option::Option::Some(8),
            Self::Routine => std::option::Option::Some(9),
            Self::Lake => std::option::Option::Some(10),
            Self::Zone => std::option::Option::Some(11),
            Self::Service => std::option::Option::Some(14),
            Self::DatabaseSchema => std::option::Option::Some(15),
            Self::Dashboard => std::option::Option::Some(16),
            Self::Explore => std::option::Option::Some(17),
            Self::Look => std::option::Option::Some(18),
            Self::FeatureOnlineStore => std::option::Option::Some(19),
            Self::FeatureView => std::option::Option::Some(20),
            Self::FeatureGroup => std::option::Option::Some(21),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENTRY_TYPE_UNSPECIFIED"),
            Self::Table => std::option::Option::Some("TABLE"),
            Self::Model => std::option::Option::Some("MODEL"),
            Self::DataStream => std::option::Option::Some("DATA_STREAM"),
            Self::Fileset => std::option::Option::Some("FILESET"),
            Self::Cluster => std::option::Option::Some("CLUSTER"),
            Self::Database => std::option::Option::Some("DATABASE"),
            Self::DataSourceConnection => std::option::Option::Some("DATA_SOURCE_CONNECTION"),
            Self::Routine => std::option::Option::Some("ROUTINE"),
            Self::Lake => std::option::Option::Some("LAKE"),
            Self::Zone => std::option::Option::Some("ZONE"),
            Self::Service => std::option::Option::Some("SERVICE"),
            Self::DatabaseSchema => std::option::Option::Some("DATABASE_SCHEMA"),
            Self::Dashboard => std::option::Option::Some("DASHBOARD"),
            Self::Explore => std::option::Option::Some("EXPLORE"),
            Self::Look => std::option::Option::Some("LOOK"),
            Self::FeatureOnlineStore => std::option::Option::Some("FEATURE_ONLINE_STORE"),
            Self::FeatureView => std::option::Option::Some("FEATURE_VIEW"),
            Self::FeatureGroup => std::option::Option::Some("FEATURE_GROUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EntryType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EntryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EntryType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::Table,
            3 => Self::DataStream,
            4 => Self::Fileset,
            5 => Self::Model,
            6 => Self::Cluster,
            7 => Self::Database,
            8 => Self::DataSourceConnection,
            9 => Self::Routine,
            10 => Self::Lake,
            11 => Self::Zone,
            14 => Self::Service,
            15 => Self::DatabaseSchema,
            16 => Self::Dashboard,
            17 => Self::Explore,
            18 => Self::Look,
            19 => Self::FeatureOnlineStore,
            20 => Self::FeatureView,
            21 => Self::FeatureGroup,
            _ => Self::UnknownValue(entry_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EntryType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENTRY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TABLE" => Self::Table,
            "MODEL" => Self::Model,
            "DATA_STREAM" => Self::DataStream,
            "FILESET" => Self::Fileset,
            "CLUSTER" => Self::Cluster,
            "DATABASE" => Self::Database,
            "DATA_SOURCE_CONNECTION" => Self::DataSourceConnection,
            "ROUTINE" => Self::Routine,
            "LAKE" => Self::Lake,
            "ZONE" => Self::Zone,
            "SERVICE" => Self::Service,
            "DATABASE_SCHEMA" => Self::DatabaseSchema,
            "DASHBOARD" => Self::Dashboard,
            "EXPLORE" => Self::Explore,
            "LOOK" => Self::Look,
            "FEATURE_ONLINE_STORE" => Self::FeatureOnlineStore,
            "FEATURE_VIEW" => Self::FeatureView,
            "FEATURE_GROUP" => Self::FeatureGroup,
            _ => Self::UnknownValue(entry_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EntryType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Table => serializer.serialize_i32(2),
            Self::Model => serializer.serialize_i32(5),
            Self::DataStream => serializer.serialize_i32(3),
            Self::Fileset => serializer.serialize_i32(4),
            Self::Cluster => serializer.serialize_i32(6),
            Self::Database => serializer.serialize_i32(7),
            Self::DataSourceConnection => serializer.serialize_i32(8),
            Self::Routine => serializer.serialize_i32(9),
            Self::Lake => serializer.serialize_i32(10),
            Self::Zone => serializer.serialize_i32(11),
            Self::Service => serializer.serialize_i32(14),
            Self::DatabaseSchema => serializer.serialize_i32(15),
            Self::Dashboard => serializer.serialize_i32(16),
            Self::Explore => serializer.serialize_i32(17),
            Self::Look => serializer.serialize_i32(18),
            Self::FeatureOnlineStore => serializer.serialize_i32(19),
            Self::FeatureView => serializer.serialize_i32(20),
            Self::FeatureGroup => serializer.serialize_i32(21),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EntryType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntryType>::new(
            ".google.cloud.datacatalog.v1.EntryType",
        ))
    }
}

/// Configuration related to the opt-in status for the migration of TagTemplates
/// to Dataplex.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TagTemplateMigration {
    /// Default value. Migration of Tag Templates from Data Catalog to Dataplex is
    /// not performed.
    Unspecified,
    /// Migration of Tag Templates from Data Catalog to Dataplex is enabled.
    Enabled,
    /// Migration of Tag Templates from Data Catalog to Dataplex is disabled.
    Disabled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TagTemplateMigration::value] or
    /// [TagTemplateMigration::name].
    UnknownValue(tag_template_migration::UnknownValue),
}

#[doc(hidden)]
pub mod tag_template_migration {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TagTemplateMigration {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enabled => std::option::Option::Some(1),
            Self::Disabled => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TAG_TEMPLATE_MIGRATION_UNSPECIFIED"),
            Self::Enabled => std::option::Option::Some("TAG_TEMPLATE_MIGRATION_ENABLED"),
            Self::Disabled => std::option::Option::Some("TAG_TEMPLATE_MIGRATION_DISABLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TagTemplateMigration {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TagTemplateMigration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TagTemplateMigration {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enabled,
            2 => Self::Disabled,
            _ => Self::UnknownValue(tag_template_migration::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TagTemplateMigration {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TAG_TEMPLATE_MIGRATION_UNSPECIFIED" => Self::Unspecified,
            "TAG_TEMPLATE_MIGRATION_ENABLED" => Self::Enabled,
            "TAG_TEMPLATE_MIGRATION_DISABLED" => Self::Disabled,
            _ => Self::UnknownValue(tag_template_migration::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TagTemplateMigration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enabled => serializer.serialize_i32(1),
            Self::Disabled => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TagTemplateMigration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TagTemplateMigration>::new(
            ".google.cloud.datacatalog.v1.TagTemplateMigration",
        ))
    }
}

/// Configuration related to the opt-in status for the UI switch to Dataplex.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CatalogUIExperience {
    /// Default value. The default UI is Dataplex.
    Unspecified,
    /// The UI is Dataplex.
    Enabled,
    /// The UI is Data Catalog.
    Disabled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CatalogUIExperience::value] or
    /// [CatalogUIExperience::name].
    UnknownValue(catalog_ui_experience::UnknownValue),
}

#[doc(hidden)]
pub mod catalog_ui_experience {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CatalogUIExperience {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enabled => std::option::Option::Some(1),
            Self::Disabled => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CATALOG_UI_EXPERIENCE_UNSPECIFIED"),
            Self::Enabled => std::option::Option::Some("CATALOG_UI_EXPERIENCE_ENABLED"),
            Self::Disabled => std::option::Option::Some("CATALOG_UI_EXPERIENCE_DISABLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CatalogUIExperience {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CatalogUIExperience {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CatalogUIExperience {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enabled,
            2 => Self::Disabled,
            _ => Self::UnknownValue(catalog_ui_experience::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CatalogUIExperience {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CATALOG_UI_EXPERIENCE_UNSPECIFIED" => Self::Unspecified,
            "CATALOG_UI_EXPERIENCE_ENABLED" => Self::Enabled,
            "CATALOG_UI_EXPERIENCE_DISABLED" => Self::Disabled,
            _ => Self::UnknownValue(catalog_ui_experience::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CatalogUIExperience {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enabled => serializer.serialize_i32(1),
            Self::Disabled => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CatalogUIExperience {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CatalogUIExperience>::new(
            ".google.cloud.datacatalog.v1.CatalogUIExperience",
        ))
    }
}

/// The resource types that can be returned in search results.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SearchResultType {
    /// Default unknown type.
    Unspecified,
    /// An [Entry][google.cloud.datacatalog.v1.Entry].
    ///
    /// [google.cloud.datacatalog.v1.Entry]: crate::model::Entry
    Entry,
    /// A [TagTemplate][google.cloud.datacatalog.v1.TagTemplate].
    ///
    /// [google.cloud.datacatalog.v1.TagTemplate]: crate::model::TagTemplate
    TagTemplate,
    /// An [EntryGroup][google.cloud.datacatalog.v1.EntryGroup].
    ///
    /// [google.cloud.datacatalog.v1.EntryGroup]: crate::model::EntryGroup
    EntryGroup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SearchResultType::value] or
    /// [SearchResultType::name].
    UnknownValue(search_result_type::UnknownValue),
}

#[doc(hidden)]
pub mod search_result_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SearchResultType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Entry => std::option::Option::Some(1),
            Self::TagTemplate => std::option::Option::Some(2),
            Self::EntryGroup => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEARCH_RESULT_TYPE_UNSPECIFIED"),
            Self::Entry => std::option::Option::Some("ENTRY"),
            Self::TagTemplate => std::option::Option::Some("TAG_TEMPLATE"),
            Self::EntryGroup => std::option::Option::Some("ENTRY_GROUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SearchResultType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SearchResultType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SearchResultType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Entry,
            2 => Self::TagTemplate,
            3 => Self::EntryGroup,
            _ => Self::UnknownValue(search_result_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SearchResultType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEARCH_RESULT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ENTRY" => Self::Entry,
            "TAG_TEMPLATE" => Self::TagTemplate,
            "ENTRY_GROUP" => Self::EntryGroup,
            _ => Self::UnknownValue(search_result_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SearchResultType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Entry => serializer.serialize_i32(1),
            Self::TagTemplate => serializer.serialize_i32(2),
            Self::EntryGroup => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SearchResultType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchResultType>::new(
            ".google.cloud.datacatalog.v1.SearchResultType",
        ))
    }
}

/// Table source type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TableSourceType {
    /// Default unknown type.
    Unspecified,
    /// Table view.
    BigqueryView,
    /// BigQuery native table.
    BigqueryTable,
    /// BigQuery materialized view.
    BigqueryMaterializedView,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TableSourceType::value] or
    /// [TableSourceType::name].
    UnknownValue(table_source_type::UnknownValue),
}

#[doc(hidden)]
pub mod table_source_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TableSourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BigqueryView => std::option::Option::Some(2),
            Self::BigqueryTable => std::option::Option::Some(5),
            Self::BigqueryMaterializedView => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TABLE_SOURCE_TYPE_UNSPECIFIED"),
            Self::BigqueryView => std::option::Option::Some("BIGQUERY_VIEW"),
            Self::BigqueryTable => std::option::Option::Some("BIGQUERY_TABLE"),
            Self::BigqueryMaterializedView => {
                std::option::Option::Some("BIGQUERY_MATERIALIZED_VIEW")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TableSourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TableSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TableSourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::BigqueryView,
            5 => Self::BigqueryTable,
            7 => Self::BigqueryMaterializedView,
            _ => Self::UnknownValue(table_source_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TableSourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TABLE_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BIGQUERY_VIEW" => Self::BigqueryView,
            "BIGQUERY_TABLE" => Self::BigqueryTable,
            "BIGQUERY_MATERIALIZED_VIEW" => Self::BigqueryMaterializedView,
            _ => Self::UnknownValue(table_source_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TableSourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BigqueryView => serializer.serialize_i32(2),
            Self::BigqueryTable => serializer.serialize_i32(5),
            Self::BigqueryMaterializedView => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TableSourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableSourceType>::new(
            ".google.cloud.datacatalog.v1.TableSourceType",
        ))
    }
}
