// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A process is the definition of a data transformation operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Process {
    /// Immutable. The resource name of the lineage process. Format:
    /// `projects/{project}/locations/{location}/processes/{process}`.
    /// Can be specified or auto-assigned.
    /// {process} must be not longer than 200 characters and only
    /// contain characters in a set: `a-zA-Z0-9_-:.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A human-readable name you can set to display in a user interface.
    /// Must be not longer than 200 characters and only contain UTF-8 letters
    /// or numbers, spaces or characters like `_-:&.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The attributes of the process. Should only be used for the
    /// purpose of non-semantic management (classifying, describing or labeling the
    /// process).
    ///
    /// Up to 100 attributes are allowed.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub attributes: std::collections::HashMap<std::string::String, wkt::Value>,

    /// Optional. The origin of this process and its runs and lineage events.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub origin: std::option::Option<crate::model::Origin>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Process {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Process::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Process::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::Process::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [origin][crate::model::Process::origin].
    pub fn set_origin<T: std::convert::Into<std::option::Option<crate::model::Origin>>>(
        mut self,
        v: T,
    ) -> Self {
        self.origin = v.into();
        self
    }
}

impl wkt::message::Message for Process {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.Process"
    }
}

/// A lineage run represents an execution of a process that creates
/// lineage events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Run {
    /// Immutable. The resource name of the run. Format:
    /// `projects/{project}/locations/{location}/processes/{process}/runs/{run}`.
    /// Can be specified or auto-assigned.
    /// {run} must be not longer than 200 characters and only
    /// contain characters in a set: `a-zA-Z0-9_-:.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A human-readable name you can set to display in a user interface.
    /// Must be not longer than 1024 characters and only contain UTF-8 letters
    /// or numbers, spaces or characters like `_-:&.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The attributes of the run. Should only be used for the purpose of
    /// non-semantic management (classifying, describing or labeling the run).
    ///
    /// Up to 100 attributes are allowed.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub attributes: std::collections::HashMap<std::string::String, wkt::Value>,

    /// Required. The timestamp of the start of the run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The timestamp of the end of the run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Required. The state of the run.
    pub state: crate::model::run::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Run {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Run::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Run::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::Run::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::Run::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Run::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Run::state].
    pub fn set_state<T: std::convert::Into<crate::model::run::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Run {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.Run"
    }
}

/// Defines additional types related to [Run].
pub mod run {
    #[allow(unused_imports)]
    use super::*;

    /// The current state of the run.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. The true state may be any of the below or a
        /// different state that is not supported here explicitly.
        Unknown,
        /// The run is still executing.
        Started,
        /// The run completed.
        Completed,
        /// The run failed.
        Failed,
        /// The run aborted.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(1),
                Self::Completed => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Aborted => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Started,
                2 => Self::Completed,
                3 => Self::Failed,
                4 => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "STARTED" => Self::Started,
                "COMPLETED" => Self::Completed,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(1),
                Self::Completed => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Aborted => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datacatalog.lineage.v1.Run.State",
            ))
        }
    }
}

/// A lineage event represents an operation on assets. Within the operation, the
/// data flows from the source to the target defined in the links field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LineageEvent {
    /// Immutable. The resource name of the lineage event.
    /// Format:
    /// `projects/{project}/locations/{location}/processes/{process}/runs/{run}/lineageEvents/{lineage_event}`.
    /// Can be specified or auto-assigned.
    /// {lineage_event} must be not longer than 200 characters and only
    /// contain characters in a set: `a-zA-Z0-9_-:.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. List of source-target pairs. Can't contain more than 100 tuples.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub links: std::vec::Vec<crate::model::EventLink>,

    /// Required. The beginning of the transformation which resulted in this
    /// lineage event. For streaming scenarios, it should be the beginning of the
    /// period from which the lineage is being reported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The end of the transformation which resulted in this lineage
    /// event.  For streaming scenarios, it should be the end of the period from
    /// which the lineage is being reported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LineageEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LineageEvent::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [links][crate::model::LineageEvent::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventLink>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::LineageEvent::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::LineageEvent::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for LineageEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.LineageEvent"
    }
}

/// A lineage between source and target entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventLink {
    /// Required. Reference to the source entity
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::EntityReference>,

    /// Required. Reference to the target entity
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::EntityReference>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventLink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::EventLink::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::EntityReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [target][crate::model::EventLink::target].
    pub fn set_target<T: std::convert::Into<std::option::Option<crate::model::EntityReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }
}

impl wkt::message::Message for EventLink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.EventLink"
    }
}

/// The soft reference to everything you can attach a lineage event to.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityReference {
    /// Required. [Fully Qualified Name
    /// (FQN)](https://cloud.google.com/data-catalog/docs/fully-qualified-names)
    /// of the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fully_qualified_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fully_qualified_name][crate::model::EntityReference::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }
}

impl wkt::message::Message for EntityReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.EntityReference"
    }
}

/// Metadata describing the operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The current operation state.
    pub state: crate::model::operation_metadata::State,

    /// Output only. The type of the operation being performed.
    pub operation_type: crate::model::operation_metadata::Type,

    /// Output only. The [relative name]
    /// (<https://cloud.google.com//apis/design/resource_names#relative_resource_name>)
    /// of the resource being operated on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// Output only. The UUID of the resource being operated on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uuid: std::string::String,

    /// Output only. The timestamp of the operation submission to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the operation termination, regardless of its
    /// success. This field is unset if the operation is still ongoing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::OperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::OperationMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation_metadata::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::OperationMetadata::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [resource_uuid][crate::model::OperationMetadata::resource_uuid].
    pub fn set_resource_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.OperationMetadata"
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// An enum with the state of the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The operation has been created but is not yet started.
        Pending,
        /// The operation is underway.
        Running,
        /// The operation completed successfully.
        Succeeded,
        /// The operation is no longer running and did not succeed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.datacatalog.lineage.v1.OperationMetadata.State",
            ))
        }
    }

    /// Type of the long running operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unused.
        Unspecified,
        /// The resource deletion operation.
        Delete,
        /// The resource creation operation.
        Create,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Delete => std::option::Option::Some(1),
                Self::Create => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Delete,
                2 => Self::Create,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "DELETE" => Self::Delete,
                "CREATE" => Self::Create,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Delete => serializer.serialize_i32(1),
                Self::Create => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.datacatalog.lineage.v1.OperationMetadata.Type",
            ))
        }
    }
}

/// Request message for
/// [ProcessOpenLineageRunEvent][google.cloud.datacatalog.lineage.v1.ProcessOpenLineageRunEvent].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProcessOpenLineageRunEventRequest {
    /// Required. The name of the project and its location that should own the
    /// process, run, and lineage event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. OpenLineage message following OpenLineage format:
    /// <https://github.com/OpenLineage/OpenLineage/blob/main/spec/OpenLineage.json>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub open_lineage: std::option::Option<wkt::Struct>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended. This request is idempotent only if a
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessOpenLineageRunEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ProcessOpenLineageRunEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [open_lineage][crate::model::ProcessOpenLineageRunEventRequest::open_lineage].
    pub fn set_open_lineage<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.open_lineage = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ProcessOpenLineageRunEventRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for ProcessOpenLineageRunEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ProcessOpenLineageRunEventRequest"
    }
}

/// Response message for
/// [ProcessOpenLineageRunEvent][google.cloud.datacatalog.lineage.v1.ProcessOpenLineageRunEvent].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProcessOpenLineageRunEventResponse {
    /// Created process name.
    /// Format: `projects/{project}/locations/{location}/processes/{process}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub process: std::string::String,

    /// Created run name.
    /// Format:
    /// `projects/{project}/locations/{location}/processes/{process}/runs/{run}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub run: std::string::String,

    /// Created lineage event names.
    /// Format:
    /// `projects/{project}/locations/{location}/processes/{process}/runs/{run}/lineageEvents/{lineage_event}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub lineage_events: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessOpenLineageRunEventResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [process][crate::model::ProcessOpenLineageRunEventResponse::process].
    pub fn set_process<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.process = v.into();
        self
    }

    /// Sets the value of [run][crate::model::ProcessOpenLineageRunEventResponse::run].
    pub fn set_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.run = v.into();
        self
    }

    /// Sets the value of [lineage_events][crate::model::ProcessOpenLineageRunEventResponse::lineage_events].
    pub fn set_lineage_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.lineage_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProcessOpenLineageRunEventResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ProcessOpenLineageRunEventResponse"
    }
}

/// Request message for
/// [CreateProcess][google.cloud.datacatalog.lineage.v1.CreateProcess].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateProcessRequest {
    /// Required. The name of the project and its location that should own the
    /// process.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The process to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub process: std::option::Option<crate::model::Process>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended. This request is idempotent only if a
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProcessRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProcessRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [process][crate::model::CreateProcessRequest::process].
    pub fn set_process<T: std::convert::Into<std::option::Option<crate::model::Process>>>(
        mut self,
        v: T,
    ) -> Self {
        self.process = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateProcessRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateProcessRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.CreateProcessRequest"
    }
}

/// Request message for
/// [UpdateProcess][google.cloud.datacatalog.lineage.v1.UpdateProcess].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateProcessRequest {
    /// Required. The lineage process to update.
    ///
    /// The process's `name` field is used to identify the process to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub process: std::option::Option<crate::model::Process>,

    /// The list of fields to update. Currently not used. The whole message is
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true and the process is not found, the request inserts it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProcessRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [process][crate::model::UpdateProcessRequest::process].
    pub fn set_process<T: std::convert::Into<std::option::Option<crate::model::Process>>>(
        mut self,
        v: T,
    ) -> Self {
        self.process = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProcessRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateProcessRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProcessRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.UpdateProcessRequest"
    }
}

/// Request message for
/// [GetProcess][google.cloud.datacatalog.lineage.v1.GetProcess].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProcessRequest {
    /// Required. The name of the process to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProcessRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProcessRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProcessRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.GetProcessRequest"
    }
}

/// Request message for
/// [ListProcesses][google.cloud.datacatalog.lineage.v1.ListProcesses].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProcessesRequest {
    /// Required. The name of the project and its location that owns this
    /// collection of processes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of processes to return. The service may return
    /// fewer than this value. If unspecified, at most 50 processes are
    /// returned. The maximum value is 100; values greater than 100 are cut to
    /// 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The page token received from a previous `ListProcesses` call. Specify
    /// it to get the next page.
    ///
    /// When paginating, all other parameters specified in this call must
    /// match the parameters of the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProcessesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProcessesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProcessesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ListProcessesRequest"
    }
}

/// Response message for
/// [ListProcesses][google.cloud.datacatalog.lineage.v1.ListProcesses].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProcessesResponse {
    /// The processes from the specified project and location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub processes: std::vec::Vec<crate::model::Process>,

    /// The token to specify as `page_token` in the next call to get the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processes][crate::model::ListProcessesResponse::processes].
    pub fn set_processes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Process>,
    {
        use std::iter::Iterator;
        self.processes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProcessesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ListProcessesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProcessesResponse {
    type PageItem = crate::model::Process;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.processes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DeleteProcess][google.cloud.datacatalog.lineage.v1.DeleteProcess].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteProcessRequest {
    /// Required. The name of the process to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true and the process is not found, the request
    /// succeeds but the server doesn't perform any actions.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProcessRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProcessRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteProcessRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProcessRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.DeleteProcessRequest"
    }
}

/// Request message for
/// [CreateRun][google.cloud.datacatalog.lineage.v1.CreateRun].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRunRequest {
    /// Required. The name of the process that should own the run.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The run to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub run: std::option::Option<crate::model::Run>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended. This request is idempotent only if a
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRunRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [run][crate::model::CreateRunRequest::run].
    pub fn set_run<T: std::convert::Into<std::option::Option<crate::model::Run>>>(
        mut self,
        v: T,
    ) -> Self {
        self.run = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateRunRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.CreateRunRequest"
    }
}

/// Request message for
/// [UpdateRun][google.cloud.datacatalog.lineage.v1.UpdateRun].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRunRequest {
    /// Required. The lineage run to update.
    ///
    /// The run's `name` field is used to identify the run to update.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/processes/{process}/runs/{run}`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub run: std::option::Option<crate::model::Run>,

    /// The list of fields to update. Currently not used. The whole message is
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true and the run is not found, the request creates it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [run][crate::model::UpdateRunRequest::run].
    pub fn set_run<T: std::convert::Into<std::option::Option<crate::model::Run>>>(
        mut self,
        v: T,
    ) -> Self {
        self.run = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRunRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateRunRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.UpdateRunRequest"
    }
}

/// Request message for
/// [GetRun][google.cloud.datacatalog.lineage.v1.GetRun].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRunRequest {
    /// Required. The name of the run to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.GetRunRequest"
    }
}

/// Request message for
/// [ListRuns][google.cloud.datacatalog.lineage.v1.ListRuns].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRunsRequest {
    /// Required. The name of process that owns this collection of runs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of runs to return. The service may return
    /// fewer than this value. If unspecified, at most 50 runs are
    /// returned. The maximum value is 100; values greater than 100 are cut to
    /// 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The page token received from a previous `ListRuns` call. Specify
    /// it to get the next page.
    ///
    /// When paginating, all other parameters specified in this call must
    /// match the parameters of the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ListRunsRequest"
    }
}

/// Response message for
/// [ListRuns][google.cloud.datacatalog.lineage.v1.ListRuns].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRunsResponse {
    /// The runs from the specified project and location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub runs: std::vec::Vec<crate::model::Run>,

    /// The token to specify as `page_token` in the next call to get the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runs][crate::model::ListRunsResponse::runs].
    pub fn set_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Run>,
    {
        use std::iter::Iterator;
        self.runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ListRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRunsResponse {
    type PageItem = crate::model::Run;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DeleteRun][google.cloud.datacatalog.lineage.v1.DeleteRun].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRunRequest {
    /// Required. The name of the run to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true and the run is not found, the request
    /// succeeds but the server doesn't perform any actions.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteRunRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.DeleteRunRequest"
    }
}

/// Request message for
/// [CreateLineageEvent][google.cloud.datacatalog.lineage.v1.CreateLineageEvent].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateLineageEventRequest {
    /// Required. The name of the run that should own the lineage event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The lineage event to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lineage_event: std::option::Option<crate::model::LineageEvent>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended. This request is idempotent only if a
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLineageEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLineageEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [lineage_event][crate::model::CreateLineageEventRequest::lineage_event].
    pub fn set_lineage_event<
        T: std::convert::Into<std::option::Option<crate::model::LineageEvent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lineage_event = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateLineageEventRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateLineageEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.CreateLineageEventRequest"
    }
}

/// Request message for
/// [GetLineageEvent][google.cloud.datacatalog.lineage.v1.GetLineageEvent].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLineageEventRequest {
    /// Required. The name of the lineage event to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLineageEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLineageEventRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLineageEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.GetLineageEventRequest"
    }
}

/// Request message for
/// [ListLineageEvents][google.cloud.datacatalog.lineage.v1.ListLineageEvents].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLineageEventsRequest {
    /// Required. The name of the run that owns the collection of lineage events to
    /// get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of lineage events to return.
    ///
    /// The service may return fewer events than this value.
    /// If unspecified, at most 50 events are returned. The maximum value is 100;
    /// values greater than 100 are cut to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The page token received from a previous `ListLineageEvents` call. Specify
    /// it to get the next page.
    ///
    /// When paginating, all other parameters specified in this call must
    /// match the parameters of the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLineageEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLineageEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLineageEventsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLineageEventsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLineageEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ListLineageEventsRequest"
    }
}

/// Response message for
/// [ListLineageEvents][google.cloud.datacatalog.lineage.v1.ListLineageEvents].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLineageEventsResponse {
    /// Lineage events from the specified project and location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub lineage_events: std::vec::Vec<crate::model::LineageEvent>,

    /// The token to specify as `page_token` in the next call to get the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLineageEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lineage_events][crate::model::ListLineageEventsResponse::lineage_events].
    pub fn set_lineage_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineageEvent>,
    {
        use std::iter::Iterator;
        self.lineage_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLineageEventsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLineageEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ListLineageEventsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLineageEventsResponse {
    type PageItem = crate::model::LineageEvent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.lineage_events
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DeleteLineageEvent][google.cloud.datacatalog.lineage.v1.DeleteLineageEvent].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteLineageEventRequest {
    /// Required. The name of the lineage event to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true and the lineage event is not found, the request
    /// succeeds but the server doesn't perform any actions.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLineageEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLineageEventRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteLineageEventRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLineageEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.DeleteLineageEventRequest"
    }
}

/// Request message for
/// [SearchLinks][google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks].
///
/// [google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks]: crate::client::Lineage::search_links
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchLinksRequest {
    /// Required. The project and location you want search in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of links to return in a single page of the
    /// response. A page may contain fewer links than this value. If unspecified,
    /// at most 10 links are returned.
    ///
    /// Maximum value is 100; values greater than 100 are reduced to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token received from a previous `SearchLinksRequest`
    /// call. Use it to get the next page.
    ///
    /// When requesting subsequent pages of a response, remember that
    /// all parameters must match the values you provided
    /// in the original request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The asset for which you want to retrieve links.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub criteria: std::option::Option<crate::model::search_links_request::Criteria>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchLinksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchLinksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchLinksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchLinksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [criteria][crate::model::SearchLinksRequest::criteria].
    ///
    /// Note that all the setters affecting `criteria` are mutually
    /// exclusive.
    pub fn set_criteria<
        T: std::convert::Into<std::option::Option<crate::model::search_links_request::Criteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.criteria = v.into();
        self
    }

    /// The value of [criteria][crate::model::SearchLinksRequest::criteria]
    /// if it holds a `Source`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source(&self) -> std::option::Option<&std::boxed::Box<crate::model::EntityReference>> {
        #[allow(unreachable_patterns)]
        self.criteria.as_ref().and_then(|v| match v {
            crate::model::search_links_request::Criteria::Source(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [criteria][crate::model::SearchLinksRequest::criteria]
    /// to hold a `Source`.
    ///
    /// Note that all the setters affecting `criteria` are
    /// mutually exclusive.
    pub fn set_source<T: std::convert::Into<std::boxed::Box<crate::model::EntityReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.criteria = std::option::Option::Some(
            crate::model::search_links_request::Criteria::Source(v.into()),
        );
        self
    }

    /// The value of [criteria][crate::model::SearchLinksRequest::criteria]
    /// if it holds a `Target`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target(&self) -> std::option::Option<&std::boxed::Box<crate::model::EntityReference>> {
        #[allow(unreachable_patterns)]
        self.criteria.as_ref().and_then(|v| match v {
            crate::model::search_links_request::Criteria::Target(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [criteria][crate::model::SearchLinksRequest::criteria]
    /// to hold a `Target`.
    ///
    /// Note that all the setters affecting `criteria` are
    /// mutually exclusive.
    pub fn set_target<T: std::convert::Into<std::boxed::Box<crate::model::EntityReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.criteria = std::option::Option::Some(
            crate::model::search_links_request::Criteria::Target(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SearchLinksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.SearchLinksRequest"
    }
}

/// Defines additional types related to [SearchLinksRequest].
pub mod search_links_request {
    #[allow(unused_imports)]
    use super::*;

    /// The asset for which you want to retrieve links.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Criteria {
        /// Optional. Send asset information in the **source** field to retrieve all
        /// links that lead from the specified asset to downstream assets.
        Source(std::boxed::Box<crate::model::EntityReference>),
        /// Optional. Send asset information in the **target** field to retrieve all
        /// links that lead from upstream assets to the specified asset.
        Target(std::boxed::Box<crate::model::EntityReference>),
    }
}

/// Response message for
/// [SearchLinks][google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks].
///
/// [google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks]: crate::client::Lineage::search_links
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchLinksResponse {
    /// The list of links for a given asset. Can be empty if the asset has no
    /// relations of requested type (source or target).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub links: std::vec::Vec<crate::model::Link>,

    /// The token to specify as `page_token` in the subsequent call to get the next
    /// page. Omitted if there are no more pages in the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchLinksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [links][crate::model::SearchLinksResponse::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Link>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchLinksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchLinksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.SearchLinksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchLinksResponse {
    type PageItem = crate::model::Link;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.links
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Links represent the data flow between **source** (upstream)
/// and **target** (downstream) assets in transformation pipelines.
///
/// Links are created when LineageEvents record data transformation between
/// related assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Link {
    /// Output only. Immutable. The name of the link. Format:
    /// `projects/{project}/locations/{location}/links/{link}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The pointer to the entity that is the **source** of this link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::EntityReference>,

    /// The pointer to the entity that is the **target** of this link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::EntityReference>,

    /// The start of the first event establishing this link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end of the last event establishing this link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Link {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Link::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Link::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::EntityReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [target][crate::model::Link::target].
    pub fn set_target<T: std::convert::Into<std::option::Option<crate::model::EntityReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Link::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Link::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for Link {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.Link"
    }
}

/// Request message for
/// [BatchSearchLinkProcesses][google.cloud.datacatalog.lineage.v1.Lineage.BatchSearchLinkProcesses].
///
/// [google.cloud.datacatalog.lineage.v1.Lineage.BatchSearchLinkProcesses]: crate::client::Lineage::batch_search_link_processes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchSearchLinkProcessesRequest {
    /// Required. The project and location where you want to search.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. An array of links to check for their associated LineageProcesses.
    ///
    /// The maximum number of items in this array is 100.
    /// If the request contains more than 100 links, it returns the
    /// `INVALID_ARGUMENT` error.
    ///
    /// Format: `projects/{project}/locations/{location}/links/{link}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub links: std::vec::Vec<std::string::String>,

    /// The maximum number of processes to return in a single page of the response.
    /// A page may contain fewer results than this value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The page token received from a previous `BatchSearchLinkProcesses` call.
    /// Use it to get the next page.
    ///
    /// When requesting subsequent pages of a response, remember that
    /// all parameters must match the values you provided
    /// in the original request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchSearchLinkProcessesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchSearchLinkProcessesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [links][crate::model::BatchSearchLinkProcessesRequest::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_size][crate::model::BatchSearchLinkProcessesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::BatchSearchLinkProcessesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for BatchSearchLinkProcessesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.BatchSearchLinkProcessesRequest"
    }
}

/// Response message for
/// [BatchSearchLinkProcesses][google.cloud.datacatalog.lineage.v1.Lineage.BatchSearchLinkProcesses].
///
/// [google.cloud.datacatalog.lineage.v1.Lineage.BatchSearchLinkProcesses]: crate::client::Lineage::batch_search_link_processes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchSearchLinkProcessesResponse {
    /// An array of processes associated with the specified links.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub process_links: std::vec::Vec<crate::model::ProcessLinks>,

    /// The token to specify as `page_token` in the subsequent call to get the next
    /// page. Omitted if there are no more pages in the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchSearchLinkProcessesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [process_links][crate::model::BatchSearchLinkProcessesResponse::process_links].
    pub fn set_process_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProcessLinks>,
    {
        use std::iter::Iterator;
        self.process_links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::BatchSearchLinkProcessesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for BatchSearchLinkProcessesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.BatchSearchLinkProcessesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for BatchSearchLinkProcessesResponse {
    type PageItem = crate::model::ProcessLinks;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.process_links
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Links associated with a specific process.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProcessLinks {
    /// The process name in the format of
    /// `projects/{project}/locations/{location}/processes/{process}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub process: std::string::String,

    /// An array containing link details objects of the links provided in
    /// the original request.
    ///
    /// A single process can result in creating multiple links.
    /// If any of the links you provide in the request are created by
    /// the same process, they all are included in this array.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub links: std::vec::Vec<crate::model::ProcessLinkInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessLinks {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [process][crate::model::ProcessLinks::process].
    pub fn set_process<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.process = v.into();
        self
    }

    /// Sets the value of [links][crate::model::ProcessLinks::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProcessLinkInfo>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProcessLinks {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ProcessLinks"
    }
}

/// Link details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProcessLinkInfo {
    /// The name of the link in the format of
    /// `projects/{project}/locations/{location}/links/{link}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub link: std::string::String,

    /// The start of the first event establishing this link-process tuple.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end of the last event establishing this link-process tuple.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessLinkInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [link][crate::model::ProcessLinkInfo::link].
    pub fn set_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.link = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ProcessLinkInfo::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ProcessLinkInfo::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for ProcessLinkInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.ProcessLinkInfo"
    }
}

/// Origin of a process.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Origin {
    /// Type of the source.
    ///
    /// Use of a source_type other than `CUSTOM` for process creation
    /// or updating is highly discouraged, and may be restricted in the future
    /// without notice.
    pub source_type: crate::model::origin::SourceType,

    /// If the source_type isn't CUSTOM, the value of this field should be a GCP
    /// resource name of the system, which reports lineage. The project and
    /// location parts of the resource name must match the project and location of
    /// the lineage resource being created. Examples:
    ///
    /// - `{source_type: COMPOSER, name:
    ///   "projects/foo/locations/us/environments/bar"}`
    /// - `{source_type: BIGQUERY, name: "projects/foo/locations/eu"}`
    /// - `{source_type: CUSTOM,   name: "myCustomIntegration"}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Origin {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::Origin::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::origin::SourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Origin::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Origin {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.datacatalog.lineage.v1.Origin"
    }
}

/// Defines additional types related to [Origin].
pub mod origin {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the source of a process.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        /// Source is Unspecified
        Unspecified,
        /// A custom source
        Custom,
        /// BigQuery
        Bigquery,
        /// Data Fusion
        DataFusion,
        /// Composer
        Composer,
        /// Looker Studio
        LookerStudio,
        /// Dataproc
        Dataproc,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Custom => std::option::Option::Some(1),
                Self::Bigquery => std::option::Option::Some(2),
                Self::DataFusion => std::option::Option::Some(3),
                Self::Composer => std::option::Option::Some(4),
                Self::LookerStudio => std::option::Option::Some(5),
                Self::Dataproc => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::Bigquery => std::option::Option::Some("BIGQUERY"),
                Self::DataFusion => std::option::Option::Some("DATA_FUSION"),
                Self::Composer => std::option::Option::Some("COMPOSER"),
                Self::LookerStudio => std::option::Option::Some("LOOKER_STUDIO"),
                Self::Dataproc => std::option::Option::Some("DATAPROC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Custom,
                2 => Self::Bigquery,
                3 => Self::DataFusion,
                4 => Self::Composer,
                5 => Self::LookerStudio,
                6 => Self::Dataproc,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOM" => Self::Custom,
                "BIGQUERY" => Self::Bigquery,
                "DATA_FUSION" => Self::DataFusion,
                "COMPOSER" => Self::Composer,
                "LOOKER_STUDIO" => Self::LookerStudio,
                "DATAPROC" => Self::Dataproc,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Custom => serializer.serialize_i32(1),
                Self::Bigquery => serializer.serialize_i32(2),
                Self::DataFusion => serializer.serialize_i32(3),
                Self::Composer => serializer.serialize_i32(4),
                Self::LookerStudio => serializer.serialize_i32(5),
                Self::Dataproc => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.datacatalog.lineage.v1.Origin.SourceType",
            ))
        }
    }
}
