// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents resource cloud locations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudLocation {
    /// Identifier. Name of the cloud location. Unique name of the cloud location
    /// including project and location using the form:
    /// `projects/{project_id}/locations/{location}/cloudLocations/{cloud_location}`
    pub name: std::string::String,

    /// Output only. The containing cloud location in the strict nesting hierarchy.
    /// For example, the containing cloud location of a zone is a region.
    pub containing_cloud_location: std::string::String,

    /// Optional. The human-readable name of the cloud location. Example:
    /// us-east-2, us-east1.
    pub display_name: std::string::String,

    /// Optional. The provider of the cloud location. Values can be Google Cloud or
    /// third-party providers, including AWS, Azure, or Oracle Cloud
    /// Infrastructure.
    pub cloud_provider: crate::model::cloud_location::CloudProvider,

    /// Optional. The two-letter ISO 3166-1 alpha-2 code of the cloud location.
    /// Examples: US, JP, KR.
    pub territory_code: std::string::String,

    /// Optional. The type of the cloud location.
    pub cloud_location_type: crate::model::cloud_location::CloudLocationType,

    /// Optional. The carbon free energy percentage of the cloud location. This
    /// represents the average percentage of time customers' application will be
    /// running on carbon-free energy. See
    /// <https://cloud.google.com/sustainability/region-carbon> for more details.
    /// There is a difference between default value 0 and unset value. 0 means the
    /// carbon free energy percentage is 0%, while unset value means the carbon
    /// footprint data is not available.
    pub carbon_free_energy_percentage: std::option::Option<f32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudLocation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [containing_cloud_location][crate::model::CloudLocation::containing_cloud_location].
    pub fn set_containing_cloud_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.containing_cloud_location = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudLocation::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [cloud_provider][crate::model::CloudLocation::cloud_provider].
    pub fn set_cloud_provider<
        T: std::convert::Into<crate::model::cloud_location::CloudProvider>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider = v.into();
        self
    }

    /// Sets the value of [territory_code][crate::model::CloudLocation::territory_code].
    pub fn set_territory_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.territory_code = v.into();
        self
    }

    /// Sets the value of [cloud_location_type][crate::model::CloudLocation::cloud_location_type].
    pub fn set_cloud_location_type<
        T: std::convert::Into<crate::model::cloud_location::CloudLocationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_location_type = v.into();
        self
    }

    /// Sets the value of [carbon_free_energy_percentage][crate::model::CloudLocation::carbon_free_energy_percentage].
    pub fn set_carbon_free_energy_percentage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.carbon_free_energy_percentage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [carbon_free_energy_percentage][crate::model::CloudLocation::carbon_free_energy_percentage].
    pub fn set_or_clear_carbon_free_energy_percentage<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.carbon_free_energy_percentage = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.locationfinder.v1.CloudLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __containing_cloud_location,
            __display_name,
            __cloud_provider,
            __territory_code,
            __cloud_location_type,
            __carbon_free_energy_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "containingCloudLocation" => {
                                Ok(__FieldTag::__containing_cloud_location)
                            }
                            "containing_cloud_location" => {
                                Ok(__FieldTag::__containing_cloud_location)
                            }
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "cloudProvider" => Ok(__FieldTag::__cloud_provider),
                            "cloud_provider" => Ok(__FieldTag::__cloud_provider),
                            "territoryCode" => Ok(__FieldTag::__territory_code),
                            "territory_code" => Ok(__FieldTag::__territory_code),
                            "cloudLocationType" => Ok(__FieldTag::__cloud_location_type),
                            "cloud_location_type" => Ok(__FieldTag::__cloud_location_type),
                            "carbonFreeEnergyPercentage" => {
                                Ok(__FieldTag::__carbon_free_energy_percentage)
                            }
                            "carbon_free_energy_percentage" => {
                                Ok(__FieldTag::__carbon_free_energy_percentage)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__containing_cloud_location => {
                            if !fields.insert(__FieldTag::__containing_cloud_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containing_cloud_location",
                                ));
                            }
                            result.containing_cloud_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_provider => {
                            if !fields.insert(__FieldTag::__cloud_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_provider",
                                ));
                            }
                            result.cloud_provider =
                                map.next_value::<std::option::Option<
                                    crate::model::cloud_location::CloudProvider,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__territory_code => {
                            if !fields.insert(__FieldTag::__territory_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for territory_code",
                                ));
                            }
                            result.territory_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_location_type => {
                            if !fields.insert(__FieldTag::__cloud_location_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_location_type",
                                ));
                            }
                            result.cloud_location_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_location::CloudLocationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__carbon_free_energy_percentage => {
                            if !fields.insert(__FieldTag::__carbon_free_energy_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for carbon_free_energy_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.carbon_free_energy_percentage = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.containing_cloud_location.is_empty() {
            state.serialize_entry("containingCloudLocation", &self.containing_cloud_location)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.cloud_provider) {
            state.serialize_entry("cloudProvider", &self.cloud_provider)?;
        }
        if !self.territory_code.is_empty() {
            state.serialize_entry("territoryCode", &self.territory_code)?;
        }
        if !wkt::internal::is_default(&self.cloud_location_type) {
            state.serialize_entry("cloudLocationType", &self.cloud_location_type)?;
        }
        if self.carbon_free_energy_percentage.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "carbonFreeEnergyPercentage",
                &__With(&self.carbon_free_energy_percentage),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudLocation");
        debug_struct.field("name", &self.name);
        debug_struct.field("containing_cloud_location", &self.containing_cloud_location);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("cloud_provider", &self.cloud_provider);
        debug_struct.field("territory_code", &self.territory_code);
        debug_struct.field("cloud_location_type", &self.cloud_location_type);
        debug_struct.field(
            "carbon_free_energy_percentage",
            &self.carbon_free_energy_percentage,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudLocation].
pub mod cloud_location {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the cloud provider. This enum lists all possible providers of
    /// cloud locations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudProvider {
        /// Unspecified type.
        Unspecified,
        /// Cloud provider type for Google Cloud.
        Gcp,
        /// Cloud provider type for AWS.
        Aws,
        /// Cloud provider type for Azure.
        Azure,
        /// Cloud provider type for OCI.
        Oci,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CloudProvider::value] or
        /// [CloudProvider::name].
        UnknownValue(cloud_provider::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cloud_provider {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CloudProvider {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gcp => std::option::Option::Some(1),
                Self::Aws => std::option::Option::Some(2),
                Self::Azure => std::option::Option::Some(3),
                Self::Oci => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLOUD_PROVIDER_UNSPECIFIED"),
                Self::Gcp => std::option::Option::Some("CLOUD_PROVIDER_GCP"),
                Self::Aws => std::option::Option::Some("CLOUD_PROVIDER_AWS"),
                Self::Azure => std::option::Option::Some("CLOUD_PROVIDER_AZURE"),
                Self::Oci => std::option::Option::Some("CLOUD_PROVIDER_OCI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CloudProvider {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CloudProvider {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CloudProvider {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gcp,
                2 => Self::Aws,
                3 => Self::Azure,
                4 => Self::Oci,
                _ => Self::UnknownValue(cloud_provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CloudProvider {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLOUD_PROVIDER_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_PROVIDER_GCP" => Self::Gcp,
                "CLOUD_PROVIDER_AWS" => Self::Aws,
                "CLOUD_PROVIDER_AZURE" => Self::Azure,
                "CLOUD_PROVIDER_OCI" => Self::Oci,
                _ => Self::UnknownValue(cloud_provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CloudProvider {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gcp => serializer.serialize_i32(1),
                Self::Aws => serializer.serialize_i32(2),
                Self::Azure => serializer.serialize_i32(3),
                Self::Oci => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CloudProvider {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudProvider>::new(
                ".google.cloud.locationfinder.v1.CloudLocation.CloudProvider",
            ))
        }
    }

    /// The type of the cloud location. This enum lists all possible categories of
    /// cloud locations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudLocationType {
        /// Unspecified type.
        Unspecified,
        /// CloudLocation type for region.
        Region,
        /// CloudLocation type for zone.
        Zone,
        /// CloudLocation type for region extension.
        RegionExtension,
        /// CloudLocation type for Google Distributed Cloud Connected Zone.
        GdccZone,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CloudLocationType::value] or
        /// [CloudLocationType::name].
        UnknownValue(cloud_location_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cloud_location_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CloudLocationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Region => std::option::Option::Some(1),
                Self::Zone => std::option::Option::Some(2),
                Self::RegionExtension => std::option::Option::Some(3),
                Self::GdccZone => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLOUD_LOCATION_TYPE_UNSPECIFIED"),
                Self::Region => std::option::Option::Some("CLOUD_LOCATION_TYPE_REGION"),
                Self::Zone => std::option::Option::Some("CLOUD_LOCATION_TYPE_ZONE"),
                Self::RegionExtension => {
                    std::option::Option::Some("CLOUD_LOCATION_TYPE_REGION_EXTENSION")
                }
                Self::GdccZone => std::option::Option::Some("CLOUD_LOCATION_TYPE_GDCC_ZONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CloudLocationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CloudLocationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CloudLocationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Region,
                2 => Self::Zone,
                3 => Self::RegionExtension,
                4 => Self::GdccZone,
                _ => Self::UnknownValue(cloud_location_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CloudLocationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLOUD_LOCATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_LOCATION_TYPE_REGION" => Self::Region,
                "CLOUD_LOCATION_TYPE_ZONE" => Self::Zone,
                "CLOUD_LOCATION_TYPE_REGION_EXTENSION" => Self::RegionExtension,
                "CLOUD_LOCATION_TYPE_GDCC_ZONE" => Self::GdccZone,
                _ => Self::UnknownValue(cloud_location_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CloudLocationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Region => serializer.serialize_i32(1),
                Self::Zone => serializer.serialize_i32(2),
                Self::RegionExtension => serializer.serialize_i32(3),
                Self::GdccZone => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CloudLocationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudLocationType>::new(
                ".google.cloud.locationfinder.v1.CloudLocation.CloudLocationType",
            ))
        }
    }
}

/// Message for requesting list of cloud locations..
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudLocationsRequest {
    /// Required. The parent, which owns this collection of cloud locations.
    /// Format: projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Optional. The maximum number of cloud locations to return per page. The
    /// service might return fewer cloud locations than this value. If unspecified,
    /// server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Provide page token returned by a previous 'ListCloudLocations' call to
    /// retrieve the next page of results. When paginating, all other parameters
    /// provided to 'ListCloudLocations' must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. A filter expression that filters resources listed in the
    /// response. The expression is in the form of field=value. For example,
    /// 'cloud_location_type=CLOUD_LOCATION_TYPE_REGION'. Multiple filter queries
    /// are space-separated. For example,
    /// 'cloud_location_type=CLOUD_LOCATION_TYPE_REGION territory_code="US"' By
    /// default, each expression is an AND expression. However, you can include AND
    /// and OR expressions explicitly.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudLocationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudLocationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudLocationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudLocationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloudLocationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudLocationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.locationfinder.v1.ListCloudLocationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudLocationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudLocationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudLocationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudLocationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudLocationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudLocationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudLocationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing cloud locations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudLocationsResponse {
    /// Output only. List of cloud locations.
    pub cloud_locations: std::vec::Vec<crate::model::CloudLocation>,

    /// Output only. The continuation token, used to page through large result
    /// sets. Provide this value in a subsequent request as page_token in
    /// subsequent requests to retrieve the next page. If this field is not
    /// present, there are no subsequent results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudLocationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_locations][crate::model::ListCloudLocationsResponse::cloud_locations].
    pub fn set_cloud_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudLocation>,
    {
        use std::iter::Iterator;
        self.cloud_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudLocationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudLocationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.locationfinder.v1.ListCloudLocationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudLocationsResponse {
    type PageItem = crate::model::CloudLocation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_locations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudLocationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_locations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudLocationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudLocations" => Ok(__FieldTag::__cloud_locations),
                            "cloud_locations" => Ok(__FieldTag::__cloud_locations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudLocationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudLocationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_locations => {
                            if !fields.insert(__FieldTag::__cloud_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_locations",
                                ));
                            }
                            result.cloud_locations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloudLocation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudLocationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_locations.is_empty() {
            state.serialize_entry("cloudLocations", &self.cloud_locations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudLocationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudLocationsResponse");
        debug_struct.field("cloud_locations", &self.cloud_locations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a cloud location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloudLocationRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudLocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudLocationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudLocationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.locationfinder.v1.GetCloudLocationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCloudLocationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloudLocationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCloudLocationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloudLocationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCloudLocationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCloudLocationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCloudLocationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for searching cloud locations from a given source location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCloudLocationsRequest {
    /// Required. The parent, which owns this collection of cloud locations.
    /// Format: projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Required. The source cloud location to search from.
    /// Example search can be searching nearby cloud locations from the source
    /// cloud location by latency.
    pub source_cloud_location: std::string::String,

    /// Optional. The maximum number of cloud locations to return. The service
    /// might return fewer cloud locations than this value. If unspecified, server
    /// will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Provide Page token returned by a previous 'ListCloudLocations' call to
    /// retrieve the next page of results. When paginating, all other parameters
    /// provided to 'ListCloudLocations' must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. The query string in search query syntax. While filter is used to
    /// filter the search results by attributes, query is used to specify the
    /// search requirements.
    pub query: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCloudLocationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchCloudLocationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_cloud_location][crate::model::SearchCloudLocationsRequest::source_cloud_location].
    pub fn set_source_cloud_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_cloud_location = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchCloudLocationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchCloudLocationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchCloudLocationsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }
}

impl wkt::message::Message for SearchCloudLocationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.locationfinder.v1.SearchCloudLocationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchCloudLocationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_cloud_location,
            __page_size,
            __page_token,
            __query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchCloudLocationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceCloudLocation" => Ok(__FieldTag::__source_cloud_location),
                            "source_cloud_location" => Ok(__FieldTag::__source_cloud_location),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "query" => Ok(__FieldTag::__query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchCloudLocationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchCloudLocationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_cloud_location => {
                            if !fields.insert(__FieldTag::__source_cloud_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_cloud_location",
                                ));
                            }
                            result.source_cloud_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchCloudLocationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.source_cloud_location.is_empty() {
            state.serialize_entry("sourceCloudLocation", &self.source_cloud_location)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchCloudLocationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchCloudLocationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("source_cloud_location", &self.source_cloud_location);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("query", &self.query);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to searching cloud locations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchCloudLocationsResponse {
    /// Output only. List of cloud locations.
    pub cloud_locations: std::vec::Vec<crate::model::CloudLocation>,

    /// Output only. The continuation token, used to page through large result
    /// sets. Provide this value in a subsequent request as page_token in
    /// subsequent requests to retrieve the next page. If this field is not
    /// present, there are no subsequent results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCloudLocationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_locations][crate::model::SearchCloudLocationsResponse::cloud_locations].
    pub fn set_cloud_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudLocation>,
    {
        use std::iter::Iterator;
        self.cloud_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchCloudLocationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchCloudLocationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.locationfinder.v1.SearchCloudLocationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchCloudLocationsResponse {
    type PageItem = crate::model::CloudLocation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_locations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchCloudLocationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_locations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchCloudLocationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudLocations" => Ok(__FieldTag::__cloud_locations),
                            "cloud_locations" => Ok(__FieldTag::__cloud_locations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchCloudLocationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchCloudLocationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_locations => {
                            if !fields.insert(__FieldTag::__cloud_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_locations",
                                ));
                            }
                            result.cloud_locations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloudLocation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchCloudLocationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_locations.is_empty() {
            state.serialize_entry("cloudLocations", &self.cloud_locations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchCloudLocationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchCloudLocationsResponse");
        debug_struct.field("cloud_locations", &self.cloud_locations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
