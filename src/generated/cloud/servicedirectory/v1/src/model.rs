// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An individual endpoint that provides a
/// [service][google.cloud.servicedirectory.v1.Service]. The service must
/// already exist to create an endpoint.
///
/// [google.cloud.servicedirectory.v1.Service]: crate::model::Service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Endpoint {
    /// Immutable. The resource name for the endpoint in the format
    /// `projects/*/locations/*/namespaces/*/services/*/endpoints/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. An IPv4 or IPv6 address. Service Directory rejects bad addresses
    /// like:
    ///
    /// * `8.8.8`
    /// * `8.8.8.8:53`
    /// * `test:bad:address`
    /// * `[::1]`
    /// * `[::1]:8080`
    ///
    /// Limited to 45 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub address: std::string::String,

    /// Optional. Service Directory rejects values outside of `[0, 65535]`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub port: i32,

    /// Optional. Annotations for the endpoint. This data can be consumed by
    /// service clients.
    ///
    /// Restrictions:
    ///
    /// * The entire annotations dictionary may contain up to 512 characters,
    ///   spread accoss all key-value pairs. Annotations that go beyond this
    ///   limit are rejected
    /// * Valid annotation keys have two segments: an optional prefix and name,
    ///   separated by a slash (/). The name segment is required and must be 63
    ///   characters or less, beginning and ending with an alphanumeric character
    ///   ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and
    ///   alphanumerics between. The prefix is optional. If specified, the prefix
    ///   must be a DNS subdomain: a series of DNS labels separated by dots (.),
    ///   not longer than 253 characters in total, followed by a slash (/)
    ///   Annotations that fails to meet these requirements are rejected.
    ///
    /// Note: This field is equivalent to the `metadata` field in the v1beta1 API.
    /// They have the same syntax and read/write to the same location in Service
    /// Directory.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. The Google Compute Engine network (VPC) of the endpoint in the
    /// format `projects/<project number>/locations/global/networks/*`.
    ///
    /// The project must be specified by project number (project id is rejected).
    /// Incorrectly formatted networks are rejected, we also check to make sure
    /// that you have the servicedirectory.networks.attach permission on the
    /// project specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub network: std::string::String,

    /// Output only. The globally unique identifier of the endpoint in the UUID4
    /// format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Endpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Endpoint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [address][crate::model::Endpoint::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [port][crate::model::Endpoint::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Endpoint::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network][crate::model::Endpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Endpoint::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for Endpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.Endpoint"
    }
}

/// The request message for
/// [LookupService.ResolveService][google.cloud.servicedirectory.v1.LookupService.ResolveService].
/// Looks up a service by its name, returns the service and its endpoints.
///
/// [google.cloud.servicedirectory.v1.LookupService.ResolveService]: crate::client::LookupService::resolve_service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResolveServiceRequest {
    /// Required. The name of the service to resolve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. The maximum number of endpoints to return. Defaults to 25.
    /// Maximum is 100. If a value less than one is specified, the Default is used.
    /// If a value greater than the Maximum is specified, the Maximum is used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub max_endpoints: i32,

    /// Optional. The filter applied to the endpoints of the resolved service.
    ///
    /// General `filter` string syntax:
    /// `<field> <operator> <value> (<logical connector>)`
    ///
    /// * `<field>` can be `name`, `address`, `port`, or `annotations.<key>` for
    ///   map field
    /// * `<operator>` can be `<`, `>`, `<=`, `>=`, `!=`, `=`, `:`. Of which `:`
    ///   means `HAS`, and is roughly the same as `=`
    /// * `<value>` must be the same data type as field
    /// * `<logical connector>` can be `AND`, `OR`, `NOT`
    ///
    /// Examples of valid filters:
    ///
    /// * `annotations.owner` returns endpoints that have a annotation with the
    ///   key `owner`, this is the same as `annotations:owner`
    /// * `annotations.protocol=gRPC` returns endpoints that have key/value
    ///   `protocol=gRPC`
    /// * `address=192.108.1.105` returns endpoints that have this address
    /// * `port>8080` returns endpoints that have port number larger than 8080
    ///
    /// `name>projects/my-project/locations/us-east1/namespaces/my-namespace/services/my-service/endpoints/endpoint-c`
    /// returns endpoints that have name that is alphabetically later than the
    /// string, so "endpoint-e" is returned but "endpoint-a" is not
    /// *
    /// `name=projects/my-project/locations/us-central1/namespaces/my-namespace/services/my-service/endpoints/ep-1`
    /// returns the endpoint that has an endpoint_id equal to `ep-1`
    ///
    /// * `annotations.owner!=sd AND annotations.foo=bar` returns endpoints that
    ///   have `owner` in annotation key but value is not `sd` AND have
    ///   key/value `foo=bar`
    /// * `doesnotexist.foo=bar` returns an empty list. Note that endpoint
    ///   doesn't have a field called "doesnotexist". Since the filter does not
    ///   match any endpoint, it returns no results
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub endpoint_filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResolveServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResolveServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [max_endpoints][crate::model::ResolveServiceRequest::max_endpoints].
    pub fn set_max_endpoints<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_endpoints = v.into();
        self
    }

    /// Sets the value of [endpoint_filter][crate::model::ResolveServiceRequest::endpoint_filter].
    pub fn set_endpoint_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint_filter = v.into();
        self
    }
}

impl wkt::message::Message for ResolveServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ResolveServiceRequest"
    }
}

/// The response message for
/// [LookupService.ResolveService][google.cloud.servicedirectory.v1.LookupService.ResolveService].
///
/// [google.cloud.servicedirectory.v1.LookupService.ResolveService]: crate::client::LookupService::resolve_service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResolveServiceResponse {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResolveServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::ResolveServiceResponse::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::ResolveServiceResponse::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ResolveServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ResolveServiceResponse"
    }
}

/// A container for [services][google.cloud.servicedirectory.v1.Service].
/// Namespaces allow administrators to group services together and define
/// permissions for a collection of services.
///
/// [google.cloud.servicedirectory.v1.Service]: crate::model::Service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Namespace {
    /// Immutable. The resource name for the namespace in the format
    /// `projects/*/locations/*/namespaces/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Resource labels associated with this namespace.
    /// No more than 64 user labels can be associated with a given resource. Label
    /// keys and values can be no longer than 63 characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The globally unique identifier of the namespace in the UUID4
    /// format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Namespace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Namespace::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Namespace::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uid][crate::model::Namespace::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for Namespace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.Namespace"
    }
}

/// The request message for
/// [RegistrationService.CreateNamespace][google.cloud.servicedirectory.v1.RegistrationService.CreateNamespace].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.CreateNamespace]: crate::client::RegistrationService::create_namespace
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNamespaceRequest {
    /// Required. The resource name of the project and location the namespace
    /// will be created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The Resource ID must be 1-63 characters long, and comply with
    /// <a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank">RFC1035</a>.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression `[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?` which means the first
    /// character must be a lowercase letter, and all following characters must
    /// be a dash, lowercase letter, or digit, except the last character, which
    /// cannot be a dash.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub namespace_id: std::string::String,

    /// Required. A namespace with initial fields set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub namespace: std::option::Option<crate::model::Namespace>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNamespaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNamespaceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [namespace_id][crate::model::CreateNamespaceRequest::namespace_id].
    pub fn set_namespace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace_id = v.into();
        self
    }

    /// Sets the value of [namespace][crate::model::CreateNamespaceRequest::namespace].
    pub fn set_namespace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Namespace>,
    {
        self.namespace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [namespace][crate::model::CreateNamespaceRequest::namespace].
    pub fn set_or_clear_namespace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Namespace>,
    {
        self.namespace = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNamespaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.CreateNamespaceRequest"
    }
}

/// The request message for
/// [RegistrationService.ListNamespaces][google.cloud.servicedirectory.v1.RegistrationService.ListNamespaces].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.ListNamespaces]: crate::client::RegistrationService::list_namespaces
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNamespacesRequest {
    /// Required. The resource name of the project and location whose namespaces
    /// you'd like to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. The filter to list results by.
    ///
    /// General `filter` string syntax:
    /// `<field> <operator> <value> (<logical connector>)`
    ///
    /// * `<field>` can be `name` or `labels.<key>` for map field
    /// * `<operator>` can be `<`, `>`, `<=`, `>=`, `!=`, `=`, `:`. Of which `:`
    ///   means `HAS`, and is roughly the same as `=`
    /// * `<value>` must be the same data type as field
    /// * `<logical connector>` can be `AND`, `OR`, `NOT`
    ///
    /// Examples of valid filters:
    ///
    /// * `labels.owner` returns namespaces that have a label with the key
    ///   `owner`, this is the same as `labels:owner`
    /// * `labels.owner=sd` returns namespaces that have key/value
    ///   `owner=sd`
    /// * `name>projects/my-project/locations/us-east1/namespaces/namespace-c`
    ///   returns namespaces that have name that is alphabetically later than the
    ///   string, so "namespace-e" is returned but "namespace-a" is not
    /// * `labels.owner!=sd AND labels.foo=bar` returns namespaces that have
    ///   `owner` in label key but value is not `sd` AND have key/value `foo=bar`
    /// * `doesnotexist.foo=bar` returns an empty list. Note that namespace
    ///   doesn't have a field called "doesnotexist". Since the filter does not
    ///   match any namespaces, it returns no results
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. The order to list results by.
    ///
    /// General `order_by` string syntax: `<field> (<asc|desc>) (,)`
    ///
    /// * `<field>` allows value: `name`
    /// * `<asc|desc>` ascending or descending order by `<field>`. If this is
    ///   left blank, `asc` is used
    ///
    /// Note that an empty `order_by` string results in default order, which is
    /// order by `name` in ascending order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNamespacesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNamespacesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNamespacesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNamespacesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNamespacesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNamespacesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNamespacesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ListNamespacesRequest"
    }
}

/// The response message for
/// [RegistrationService.ListNamespaces][google.cloud.servicedirectory.v1.RegistrationService.ListNamespaces].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.ListNamespaces]: crate::client::RegistrationService::list_namespaces
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNamespacesResponse {
    /// The list of namespaces.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub namespaces: std::vec::Vec<crate::model::Namespace>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNamespacesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespaces][crate::model::ListNamespacesResponse::namespaces].
    pub fn set_namespaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Namespace>,
    {
        use std::iter::Iterator;
        self.namespaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNamespacesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNamespacesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ListNamespacesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNamespacesResponse {
    type PageItem = crate::model::Namespace;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.namespaces
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for
/// [RegistrationService.GetNamespace][google.cloud.servicedirectory.v1.RegistrationService.GetNamespace].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.GetNamespace]: crate::client::RegistrationService::get_namespace
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNamespaceRequest {
    /// Required. The name of the namespace to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNamespaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNamespaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNamespaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.GetNamespaceRequest"
    }
}

/// The request message for
/// [RegistrationService.UpdateNamespace][google.cloud.servicedirectory.v1.RegistrationService.UpdateNamespace].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.UpdateNamespace]: crate::client::RegistrationService::update_namespace
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNamespaceRequest {
    /// Required. The updated namespace.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub namespace: std::option::Option<crate::model::Namespace>,

    /// Required. List of fields to be updated in this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNamespaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespace][crate::model::UpdateNamespaceRequest::namespace].
    pub fn set_namespace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Namespace>,
    {
        self.namespace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [namespace][crate::model::UpdateNamespaceRequest::namespace].
    pub fn set_or_clear_namespace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Namespace>,
    {
        self.namespace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNamespaceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNamespaceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNamespaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.UpdateNamespaceRequest"
    }
}

/// The request message for
/// [RegistrationService.DeleteNamespace][google.cloud.servicedirectory.v1.RegistrationService.DeleteNamespace].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.DeleteNamespace]: crate::client::RegistrationService::delete_namespace
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNamespaceRequest {
    /// Required. The name of the namespace to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNamespaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNamespaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNamespaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.DeleteNamespaceRequest"
    }
}

/// The request message for
/// [RegistrationService.CreateService][google.cloud.servicedirectory.v1.RegistrationService.CreateService].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.CreateService]: crate::client::RegistrationService::create_service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateServiceRequest {
    /// Required. The resource name of the namespace this service will belong to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The Resource ID must be 1-63 characters long, and comply with
    /// <a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank">RFC1035</a>.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression `[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?` which means the first
    /// character must be a lowercase letter, and all following characters must
    /// be a dash, lowercase letter, or digit, except the last character, which
    /// cannot be a dash.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_id: std::string::String,

    /// Required. A service  with initial fields set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateServiceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service_id][crate::model::CreateServiceRequest::service_id].
    pub fn set_service_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_id = v.into();
        self
    }

    /// Sets the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.CreateServiceRequest"
    }
}

/// The request message for
/// [RegistrationService.ListServices][google.cloud.servicedirectory.v1.RegistrationService.ListServices].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.ListServices]: crate::client::RegistrationService::list_services
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Required. The resource name of the namespace whose services you'd
    /// like to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. The filter to list results by.
    ///
    /// General `filter` string syntax:
    /// `<field> <operator> <value> (<logical connector>)`
    ///
    /// * `<field>` can be `name` or `annotations.<key>` for map field
    /// * `<operator>` can be `<`, `>`, `<=`, `>=`, `!=`, `=`, `:`. Of which `:`
    ///   means `HAS`, and is roughly the same as `=`
    /// * `<value>` must be the same data type as field
    /// * `<logical connector>` can be `AND`, `OR`, `NOT`
    ///
    /// Examples of valid filters:
    ///
    /// * `annotations.owner` returns services that have a annotation with the
    ///   key `owner`, this is the same as `annotations:owner`
    /// * `annotations.protocol=gRPC` returns services that have key/value
    ///   `protocol=gRPC`
    ///
    /// `name>projects/my-project/locations/us-east1/namespaces/my-namespace/services/service-c`
    /// returns services that have name that is alphabetically later than the
    /// string, so "service-e" is returned but "service-a" is not
    ///
    /// * `annotations.owner!=sd AND annotations.foo=bar` returns services that
    ///   have `owner` in annotation key but value is not `sd` AND have
    ///   key/value `foo=bar`
    /// * `doesnotexist.foo=bar` returns an empty list. Note that service
    ///   doesn't have a field called "doesnotexist". Since the filter does not
    ///   match any services, it returns no results
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. The order to list results by.
    ///
    /// General `order_by` string syntax: `<field> (<asc|desc>) (,)`
    ///
    /// * `<field>` allows value: `name`
    /// * `<asc|desc>` ascending or descending order by `<field>`. If this is
    ///   left blank, `asc` is used
    ///
    /// Note that an empty `order_by` string results in default order, which is
    /// order by `name` in ascending order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServicesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListServicesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ListServicesRequest"
    }
}

/// The response message for
/// [RegistrationService.ListServices][google.cloud.servicedirectory.v1.RegistrationService.ListServices].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.ListServices]: crate::client::RegistrationService::list_services
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The list of services.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub services: std::vec::Vec<crate::model::Service>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for
/// [RegistrationService.GetService][google.cloud.servicedirectory.v1.RegistrationService.GetService].
/// This should not be used for looking up a service. Instead, use the `resolve`
/// method as it contains all endpoints and associated annotations.
///
/// [google.cloud.servicedirectory.v1.RegistrationService.GetService]: crate::client::RegistrationService::get_service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Required. The name of the service to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.GetServiceRequest"
    }
}

/// The request message for
/// [RegistrationService.UpdateService][google.cloud.servicedirectory.v1.RegistrationService.UpdateService].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.UpdateService]: crate::client::RegistrationService::update_service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Required. The updated service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    /// Required. List of fields to be updated in this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.UpdateServiceRequest"
    }
}

/// The request message for
/// [RegistrationService.DeleteService][google.cloud.servicedirectory.v1.RegistrationService.DeleteService].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.DeleteService]: crate::client::RegistrationService::delete_service
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Required. The name of the service to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.DeleteServiceRequest"
    }
}

/// The request message for
/// [RegistrationService.CreateEndpoint][google.cloud.servicedirectory.v1.RegistrationService.CreateEndpoint].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.CreateEndpoint]: crate::client::RegistrationService::create_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEndpointRequest {
    /// Required. The resource name of the service that this endpoint provides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The Resource ID must be 1-63 characters long, and comply with
    /// <a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank">RFC1035</a>.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression `[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?` which means the first
    /// character must be a lowercase letter, and all following characters must
    /// be a dash, lowercase letter, or digit, except the last character, which
    /// cannot be a dash.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub endpoint_id: std::string::String,

    /// Required. A endpoint with initial fields set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEndpointRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [endpoint_id][crate::model::CreateEndpointRequest::endpoint_id].
    pub fn set_endpoint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint_id = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::CreateEndpointRequest::endpoint].
    pub fn set_endpoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.endpoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoint][crate::model::CreateEndpointRequest::endpoint].
    pub fn set_or_clear_endpoint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.endpoint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.CreateEndpointRequest"
    }
}

/// The request message for
/// [RegistrationService.ListEndpoints][google.cloud.servicedirectory.v1.RegistrationService.ListEndpoints].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.ListEndpoints]: crate::client::RegistrationService::list_endpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEndpointsRequest {
    /// Required. The resource name of the service whose endpoints you'd like to
    /// list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. The filter to list results by.
    ///
    /// General `filter` string syntax:
    /// `<field> <operator> <value> (<logical connector>)`
    ///
    /// * `<field>` can be `name`, `address`, `port`, or `annotations.<key>` for
    ///   map field
    /// * `<operator>` can be `<`, `>`, `<=`, `>=`, `!=`, `=`, `:`. Of which `:`
    ///   means `HAS`, and is roughly the same as `=`
    /// * `<value>` must be the same data type as field
    /// * `<logical connector>` can be `AND`, `OR`, `NOT`
    ///
    /// Examples of valid filters:
    ///
    /// * `annotations.owner` returns endpoints that have a annotation with the
    ///   key `owner`, this is the same as `annotations:owner`
    /// * `annotations.protocol=gRPC` returns endpoints that have key/value
    ///   `protocol=gRPC`
    /// * `address=192.108.1.105` returns endpoints that have this address
    /// * `port>8080` returns endpoints that have port number larger than 8080
    ///
    /// `name>projects/my-project/locations/us-east1/namespaces/my-namespace/services/my-service/endpoints/endpoint-c`
    /// returns endpoints that have name that is alphabetically later than the
    /// string, so "endpoint-e" is returned but "endpoint-a" is not
    ///
    /// * `annotations.owner!=sd AND annotations.foo=bar` returns endpoints that
    ///   have `owner` in annotation key but value is not `sd` AND have
    ///   key/value `foo=bar`
    /// * `doesnotexist.foo=bar` returns an empty list. Note that endpoint
    ///   doesn't have a field called "doesnotexist". Since the filter does not
    ///   match any endpoints, it returns no results
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. The order to list results by.
    ///
    /// General `order_by` string syntax: `<field> (<asc|desc>) (,)`
    ///
    /// * `<field>` allows values: `name`, `address`, `port`
    /// * `<asc|desc>` ascending or descending order by `<field>`. If this is
    ///   left blank, `asc` is used
    ///
    /// Note that an empty `order_by` string results in default order, which is
    /// order by `name` in ascending order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEndpointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEndpointsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEndpointsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEndpointsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEndpointsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEndpointsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEndpointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ListEndpointsRequest"
    }
}

/// The response message for
/// [RegistrationService.ListEndpoints][google.cloud.servicedirectory.v1.RegistrationService.ListEndpoints].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.ListEndpoints]: crate::client::RegistrationService::list_endpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEndpointsResponse {
    /// The list of endpoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub endpoints: std::vec::Vec<crate::model::Endpoint>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEndpointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoints][crate::model::ListEndpointsResponse::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Endpoint>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEndpointsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEndpointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.ListEndpointsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEndpointsResponse {
    type PageItem = crate::model::Endpoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.endpoints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for
/// [RegistrationService.GetEndpoint][google.cloud.servicedirectory.v1.RegistrationService.GetEndpoint].
/// This should not be used to lookup endpoints at runtime. Instead, use
/// the `resolve` method.
///
/// [google.cloud.servicedirectory.v1.RegistrationService.GetEndpoint]: crate::client::RegistrationService::get_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEndpointRequest {
    /// Required. The name of the endpoint to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.GetEndpointRequest"
    }
}

/// The request message for
/// [RegistrationService.UpdateEndpoint][google.cloud.servicedirectory.v1.RegistrationService.UpdateEndpoint].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.UpdateEndpoint]: crate::client::RegistrationService::update_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEndpointRequest {
    /// Required. The updated endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    /// Required. List of fields to be updated in this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::UpdateEndpointRequest::endpoint].
    pub fn set_endpoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.endpoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoint][crate::model::UpdateEndpointRequest::endpoint].
    pub fn set_or_clear_endpoint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.endpoint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEndpointRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEndpointRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.UpdateEndpointRequest"
    }
}

/// The request message for
/// [RegistrationService.DeleteEndpoint][google.cloud.servicedirectory.v1.RegistrationService.DeleteEndpoint].
///
/// [google.cloud.servicedirectory.v1.RegistrationService.DeleteEndpoint]: crate::client::RegistrationService::delete_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEndpointRequest {
    /// Required. The name of the endpoint to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.DeleteEndpointRequest"
    }
}

/// An individual service. A service contains a name and optional metadata.
/// A service must exist before
/// [endpoints][google.cloud.servicedirectory.v1.Endpoint] can be
/// added to it.
///
/// [google.cloud.servicedirectory.v1.Endpoint]: crate::model::Endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Service {
    /// Immutable. The resource name for the service in the format
    /// `projects/*/locations/*/namespaces/*/services/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Annotations for the service. This data can be consumed by service
    /// clients.
    ///
    /// Restrictions:
    ///
    /// * The entire annotations dictionary may contain up to 2000 characters,
    ///   spread accoss all key-value pairs. Annotations that go beyond this
    ///   limit are rejected
    /// * Valid annotation keys have two segments: an optional prefix and name,
    ///   separated by a slash (/). The name segment is required and must be 63
    ///   characters or less, beginning and ending with an alphanumeric character
    ///   ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and
    ///   alphanumerics between. The prefix is optional. If specified, the prefix
    ///   must be a DNS subdomain: a series of DNS labels separated by dots (.),
    ///   not longer than 253 characters in total, followed by a slash (/).
    ///   Annotations that fails to meet these requirements are rejected
    ///
    /// Note: This field is equivalent to the `metadata` field in the v1beta1 API.
    /// They have the same syntax and read/write to the same location in Service
    /// Directory.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Endpoints associated with this service. Returned on
    /// [LookupService.ResolveService][google.cloud.servicedirectory.v1.LookupService.ResolveService].
    /// Control plane clients should use
    /// [RegistrationService.ListEndpoints][google.cloud.servicedirectory.v1.RegistrationService.ListEndpoints].
    ///
    /// [google.cloud.servicedirectory.v1.LookupService.ResolveService]: crate::client::LookupService::resolve_service
    /// [google.cloud.servicedirectory.v1.RegistrationService.ListEndpoints]: crate::client::RegistrationService::list_endpoints
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub endpoints: std::vec::Vec<crate::model::Endpoint>,

    /// Output only. The globally unique identifier of the service in the UUID4
    /// format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Service::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [endpoints][crate::model::Service::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Endpoint>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uid][crate::model::Service::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicedirectory.v1.Service"
    }
}
