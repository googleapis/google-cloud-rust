// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request for the `ListCertificateIssuanceConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificateIssuanceConfigsRequest {
    /// Required. The project and location from which the certificate should be
    /// listed, specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of certificate configs to return per call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListCertificateIssuanceConfigsResponse`.
    /// Indicates that this is a continuation of a prior
    /// `ListCertificateIssuanceConfigs` call, and that the system should return
    /// the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter expression to restrict the Certificates Configs returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A list of Certificate Config field names used to specify the order of the
    /// returned results. The default sorting order is ascending. To specify
    /// descending order for a field, add a suffix `" desc"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateIssuanceConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificateIssuanceConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificateIssuanceConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificateIssuanceConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificateIssuanceConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificateIssuanceConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificateIssuanceConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificateIssuanceConfigsRequest"
    }
}

/// Response for the `ListCertificateIssuanceConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificateIssuanceConfigsResponse {
    /// A list of certificate configs for the parent resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certificate_issuance_configs: std::vec::Vec<crate::model::CertificateIssuanceConfig>,

    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateIssuanceConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_issuance_configs][crate::model::ListCertificateIssuanceConfigsResponse::certificate_issuance_configs].
    pub fn set_certificate_issuance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertificateIssuanceConfig>,
    {
        use std::iter::Iterator;
        self.certificate_issuance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificateIssuanceConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificateIssuanceConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificateIssuanceConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificateIssuanceConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificateIssuanceConfigsResponse {
    type PageItem = crate::model::CertificateIssuanceConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificate_issuance_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetCertificateIssuanceConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCertificateIssuanceConfigRequest {
    /// Required. A name of the certificate issuance config to describe. Must be in
    /// the format `projects/*/locations/*/certificateIssuanceConfigs/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateIssuanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateIssuanceConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateIssuanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.GetCertificateIssuanceConfigRequest"
    }
}

/// Request for the `CreateCertificateIssuanceConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCertificateIssuanceConfigRequest {
    /// Required. The parent resource of the certificate issuance config. Must be
    /// in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A user-provided name of the certificate config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub certificate_issuance_config_id: std::string::String,

    /// Required. A definition of the certificate issuance config to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_issuance_config: std::option::Option<crate::model::CertificateIssuanceConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCertificateIssuanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCertificateIssuanceConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate_issuance_config_id][crate::model::CreateCertificateIssuanceConfigRequest::certificate_issuance_config_id].
    pub fn set_certificate_issuance_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_issuance_config_id = v.into();
        self
    }

    /// Sets the value of [certificate_issuance_config][crate::model::CreateCertificateIssuanceConfigRequest::certificate_issuance_config].
    pub fn set_certificate_issuance_config<
        T: std::convert::Into<std::option::Option<crate::model::CertificateIssuanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_issuance_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateCertificateIssuanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CreateCertificateIssuanceConfigRequest"
    }
}

/// Request for the `DeleteCertificateIssuanceConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCertificateIssuanceConfigRequest {
    /// Required. A name of the certificate issuance config to delete. Must be in
    /// the format `projects/*/locations/*/certificateIssuanceConfigs/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCertificateIssuanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCertificateIssuanceConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCertificateIssuanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.DeleteCertificateIssuanceConfigRequest"
    }
}

/// CertificateIssuanceConfig specifies how to issue and manage a certificate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateIssuanceConfig {
    /// A user-defined name of the certificate issuance config.
    /// CertificateIssuanceConfig names must be unique globally and match pattern
    /// `projects/*/locations/*/certificateIssuanceConfigs/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The creation timestamp of a CertificateIssuanceConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a CertificateIssuanceConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Set of labels associated with a CertificateIssuanceConfig.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// One or more paragraphs of text description of a CertificateIssuanceConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. The CA that issues the workload certificate. It includes the CA
    /// address, type, authentication to CA service, etc.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_authority_config:
        std::option::Option<crate::model::certificate_issuance_config::CertificateAuthorityConfig>,

    /// Required. Workload certificate lifetime requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lifetime: std::option::Option<wkt::Duration>,

    /// Required. Specifies the percentage of elapsed time of the certificate
    /// lifetime to wait before renewing the certificate. Must be a number between
    /// 1-99, inclusive.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub rotation_window_percentage: i32,

    /// Required. The key algorithm to use when generating the private key.
    pub key_algorithm: crate::model::certificate_issuance_config::KeyAlgorithm,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateIssuanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateIssuanceConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CertificateIssuanceConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CertificateIssuanceConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CertificateIssuanceConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::CertificateIssuanceConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [certificate_authority_config][crate::model::CertificateIssuanceConfig::certificate_authority_config].
    pub fn set_certificate_authority_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::certificate_issuance_config::CertificateAuthorityConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_authority_config = v.into();
        self
    }

    /// Sets the value of [lifetime][crate::model::CertificateIssuanceConfig::lifetime].
    pub fn set_lifetime<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifetime = v.into();
        self
    }

    /// Sets the value of [rotation_window_percentage][crate::model::CertificateIssuanceConfig::rotation_window_percentage].
    pub fn set_rotation_window_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rotation_window_percentage = v.into();
        self
    }

    /// Sets the value of [key_algorithm][crate::model::CertificateIssuanceConfig::key_algorithm].
    pub fn set_key_algorithm<
        T: std::convert::Into<crate::model::certificate_issuance_config::KeyAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_algorithm = v.into();
        self
    }
}

impl wkt::message::Message for CertificateIssuanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CertificateIssuanceConfig"
    }
}

/// Defines additional types related to [CertificateIssuanceConfig].
pub mod certificate_issuance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The CA that issues the workload certificate. It includes CA address, type,
    /// authentication to CA service, etc.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CertificateAuthorityConfig {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub kind: std::option::Option<
            crate::model::certificate_issuance_config::certificate_authority_config::Kind,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CertificateAuthorityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::certificate_issuance_config::CertificateAuthorityConfig::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::certificate_issuance_config::certificate_authority_config::Kind>>>(mut self, v: T) -> Self
        {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::certificate_issuance_config::CertificateAuthorityConfig::kind]
        /// if it holds a `CertificateAuthorityServiceConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn certificate_authority_service_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::certificate_issuance_config::certificate_authority_config::CertificateAuthorityServiceConfig>>{
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::certificate_issuance_config::certificate_authority_config::Kind::CertificateAuthorityServiceConfig(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::certificate_issuance_config::CertificateAuthorityConfig::kind]
        /// to hold a `CertificateAuthorityServiceConfig`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_certificate_authority_service_config<T: std::convert::Into<std::boxed::Box<crate::model::certificate_issuance_config::certificate_authority_config::CertificateAuthorityServiceConfig>>>(mut self, v: T) -> Self{
            self.kind = std::option::Option::Some(
                crate::model::certificate_issuance_config::certificate_authority_config::Kind::CertificateAuthorityServiceConfig(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for CertificateAuthorityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.CertificateIssuanceConfig.CertificateAuthorityConfig"
        }
    }

    /// Defines additional types related to [CertificateAuthorityConfig].
    pub mod certificate_authority_config {
        #[allow(unused_imports)]
        use super::*;

        /// Contains information required to contact CA service.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CertificateAuthorityServiceConfig {
            /// Required. A CA pool resource used to issue a certificate.
            /// The CA pool string has a relative resource path following the form
            /// "projects/{project}/locations/{location}/caPools/{ca_pool}".
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub ca_pool: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CertificateAuthorityServiceConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [ca_pool][crate::model::certificate_issuance_config::certificate_authority_config::CertificateAuthorityServiceConfig::ca_pool].
            pub fn set_ca_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.ca_pool = v.into();
                self
            }
        }

        impl wkt::message::Message for CertificateAuthorityServiceConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.certificatemanager.v1.CertificateIssuanceConfig.CertificateAuthorityConfig.CertificateAuthorityServiceConfig"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Kind {
            /// Defines a CertificateAuthorityServiceConfig.
            CertificateAuthorityServiceConfig(std::boxed::Box<crate::model::certificate_issuance_config::certificate_authority_config::CertificateAuthorityServiceConfig>),
        }
    }

    /// The type of keypair to generate.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeyAlgorithm {
        /// Unspecified key algorithm.
        Unspecified,
        /// Specifies RSA with a 2048-bit modulus.
        Rsa2048,
        /// Specifies ECDSA with curve P256.
        EcdsaP256,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeyAlgorithm::value] or
        /// [KeyAlgorithm::name].
        UnknownValue(key_algorithm::UnknownValue),
    }

    #[doc(hidden)]
    pub mod key_algorithm {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KeyAlgorithm {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rsa2048 => std::option::Option::Some(1),
                Self::EcdsaP256 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KEY_ALGORITHM_UNSPECIFIED"),
                Self::Rsa2048 => std::option::Option::Some("RSA_2048"),
                Self::EcdsaP256 => std::option::Option::Some("ECDSA_P256"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KeyAlgorithm {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KeyAlgorithm {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KeyAlgorithm {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rsa2048,
                4 => Self::EcdsaP256,
                _ => Self::UnknownValue(key_algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KeyAlgorithm {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEY_ALGORITHM_UNSPECIFIED" => Self::Unspecified,
                "RSA_2048" => Self::Rsa2048,
                "ECDSA_P256" => Self::EcdsaP256,
                _ => Self::UnknownValue(key_algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KeyAlgorithm {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rsa2048 => serializer.serialize_i32(1),
                Self::EcdsaP256 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KeyAlgorithm {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KeyAlgorithm>::new(
                ".google.cloud.certificatemanager.v1.CertificateIssuanceConfig.KeyAlgorithm",
            ))
        }
    }
}

/// Request for the `ListCertificates` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificatesRequest {
    /// Required. The project and location from which the certificate should be
    /// listed, specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of certificates to return per call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListCertificatesResponse`. Indicates that
    /// this is a continuation of a prior `ListCertificates` call, and that the
    /// system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter expression to restrict the Certificates returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A list of Certificate field names used to specify the order of the returned
    /// results. The default sorting order is ascending. To specify descending
    /// order for a field, add a suffix `" desc"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificatesRequest"
    }
}

/// Response for the `ListCertificates` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificatesResponse {
    /// A list of certificates for the parent resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certificates: std::vec::Vec<crate::model::Certificate>,

    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// A list of locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificates][crate::model::ListCertificatesResponse::certificates].
    pub fn set_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Certificate>,
    {
        use std::iter::Iterator;
        self.certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificatesResponse {
    type PageItem = crate::model::Certificate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetCertificate` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCertificateRequest {
    /// Required. A name of the certificate to describe. Must be in the format
    /// `projects/*/locations/*/certificates/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.GetCertificateRequest"
    }
}

/// Request for the `CreateCertificate` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCertificateRequest {
    /// Required. The parent resource of the certificate. Must be in the format
    /// `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A user-provided name of the certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub certificate_id: std::string::String,

    /// Required. A definition of the certificate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate: std::option::Option<crate::model::Certificate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCertificateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate_id][crate::model::CreateCertificateRequest::certificate_id].
    pub fn set_certificate_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.certificate_id = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::CreateCertificateRequest::certificate].
    pub fn set_certificate<
        T: std::convert::Into<std::option::Option<crate::model::Certificate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate = v.into();
        self
    }
}

impl wkt::message::Message for CreateCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CreateCertificateRequest"
    }
}

/// Request for the `UpdateCertificate` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCertificateRequest {
    /// Required. A definition of the certificate to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate: std::option::Option<crate::model::Certificate>,

    /// Required. The update mask applies to the resource. For the `FieldMask`
    /// definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate][crate::model::UpdateCertificateRequest::certificate].
    pub fn set_certificate<
        T: std::convert::Into<std::option::Option<crate::model::Certificate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCertificateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.UpdateCertificateRequest"
    }
}

/// Request for the `DeleteCertificate` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCertificateRequest {
    /// Required. A name of the certificate to delete. Must be in the format
    /// `projects/*/locations/*/certificates/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.DeleteCertificateRequest"
    }
}

/// Request for the `ListCertificateMaps` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificateMapsRequest {
    /// Required. The project and location from which the certificate maps should
    /// be listed, specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of certificate maps to return per call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListCertificateMapsResponse`. Indicates
    /// that this is a continuation of a prior `ListCertificateMaps` call, and that
    /// the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter expression to restrict the Certificates Maps returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A list of Certificate Map field names used to specify the order of the
    /// returned results. The default sorting order is ascending. To specify
    /// descending order for a field, add a suffix `" desc"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateMapsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificateMapsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificateMapsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificateMapsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificateMapsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificateMapsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificateMapsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificateMapsRequest"
    }
}

/// Response for the `ListCertificateMaps` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificateMapsResponse {
    /// A list of certificate maps for the parent resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certificate_maps: std::vec::Vec<crate::model::CertificateMap>,

    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateMapsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_maps][crate::model::ListCertificateMapsResponse::certificate_maps].
    pub fn set_certificate_maps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertificateMap>,
    {
        use std::iter::Iterator;
        self.certificate_maps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificateMapsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificateMapsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificateMapsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificateMapsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificateMapsResponse {
    type PageItem = crate::model::CertificateMap;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificate_maps
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetCertificateMap` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCertificateMapRequest {
    /// Required. A name of the certificate map to describe. Must be in the format
    /// `projects/*/locations/*/certificateMaps/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateMapRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.GetCertificateMapRequest"
    }
}

/// Request for the `CreateCertificateMap` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCertificateMapRequest {
    /// Required. The parent resource of the certificate map. Must be in the format
    /// `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A user-provided name of the certificate map.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub certificate_map_id: std::string::String,

    /// Required. A definition of the certificate map to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_map: std::option::Option<crate::model::CertificateMap>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCertificateMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCertificateMapRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate_map_id][crate::model::CreateCertificateMapRequest::certificate_map_id].
    pub fn set_certificate_map_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_map_id = v.into();
        self
    }

    /// Sets the value of [certificate_map][crate::model::CreateCertificateMapRequest::certificate_map].
    pub fn set_certificate_map<
        T: std::convert::Into<std::option::Option<crate::model::CertificateMap>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_map = v.into();
        self
    }
}

impl wkt::message::Message for CreateCertificateMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CreateCertificateMapRequest"
    }
}

/// Request for the `UpdateCertificateMap` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCertificateMapRequest {
    /// Required. A definition of the certificate map to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_map: std::option::Option<crate::model::CertificateMap>,

    /// Required. The update mask applies to the resource. For the `FieldMask`
    /// definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCertificateMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_map][crate::model::UpdateCertificateMapRequest::certificate_map].
    pub fn set_certificate_map<
        T: std::convert::Into<std::option::Option<crate::model::CertificateMap>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_map = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCertificateMapRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCertificateMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.UpdateCertificateMapRequest"
    }
}

/// Request for the `DeleteCertificateMap` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCertificateMapRequest {
    /// Required. A name of the certificate map to delete. Must be in the format
    /// `projects/*/locations/*/certificateMaps/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCertificateMapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCertificateMapRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCertificateMapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.DeleteCertificateMapRequest"
    }
}

/// Request for the `ListCertificateMapEntries` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificateMapEntriesRequest {
    /// Required. The project, location and certificate map from which the
    /// certificate map entries should be listed, specified in the format
    /// `projects/*/locations/*/certificateMaps/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of certificate map entries to return. The service may return
    /// fewer than this value.
    /// If unspecified, at most 50 certificate map entries will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListCertificateMapEntriesResponse`.
    /// Indicates that this is a continuation of a prior
    /// `ListCertificateMapEntries` call, and that the system should return the
    /// next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter expression to restrict the returned Certificate Map Entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A list of Certificate Map Entry field names used to specify
    /// the order of the returned results. The default sorting order is ascending.
    /// To specify descending order for a field, add a suffix `" desc"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateMapEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificateMapEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificateMapEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificateMapEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificateMapEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificateMapEntriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificateMapEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificateMapEntriesRequest"
    }
}

/// Response for the `ListCertificateMapEntries` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCertificateMapEntriesResponse {
    /// A list of certificate map entries for the parent resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certificate_map_entries: std::vec::Vec<crate::model::CertificateMapEntry>,

    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateMapEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_map_entries][crate::model::ListCertificateMapEntriesResponse::certificate_map_entries].
    pub fn set_certificate_map_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertificateMapEntry>,
    {
        use std::iter::Iterator;
        self.certificate_map_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificateMapEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificateMapEntriesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificateMapEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListCertificateMapEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificateMapEntriesResponse {
    type PageItem = crate::model::CertificateMapEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificate_map_entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetCertificateMapEntry` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCertificateMapEntryRequest {
    /// Required. A name of the certificate map entry to describe. Must be in the
    /// format `projects/*/locations/*/certificateMaps/*/certificateMapEntries/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateMapEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateMapEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateMapEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.GetCertificateMapEntryRequest"
    }
}

/// Request for the `CreateCertificateMapEntry` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCertificateMapEntryRequest {
    /// Required. The parent resource of the certificate map entry. Must be in the
    /// format `projects/*/locations/*/certificateMaps/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A user-provided name of the certificate map entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub certificate_map_entry_id: std::string::String,

    /// Required. A definition of the certificate map entry to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_map_entry: std::option::Option<crate::model::CertificateMapEntry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCertificateMapEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCertificateMapEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate_map_entry_id][crate::model::CreateCertificateMapEntryRequest::certificate_map_entry_id].
    pub fn set_certificate_map_entry_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_map_entry_id = v.into();
        self
    }

    /// Sets the value of [certificate_map_entry][crate::model::CreateCertificateMapEntryRequest::certificate_map_entry].
    pub fn set_certificate_map_entry<
        T: std::convert::Into<std::option::Option<crate::model::CertificateMapEntry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_map_entry = v.into();
        self
    }
}

impl wkt::message::Message for CreateCertificateMapEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CreateCertificateMapEntryRequest"
    }
}

/// Request for the `UpdateCertificateMapEntry` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCertificateMapEntryRequest {
    /// Required. A definition of the certificate map entry to create map entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_map_entry: std::option::Option<crate::model::CertificateMapEntry>,

    /// Required. The update mask applies to the resource. For the `FieldMask`
    /// definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCertificateMapEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_map_entry][crate::model::UpdateCertificateMapEntryRequest::certificate_map_entry].
    pub fn set_certificate_map_entry<
        T: std::convert::Into<std::option::Option<crate::model::CertificateMapEntry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_map_entry = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCertificateMapEntryRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCertificateMapEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.UpdateCertificateMapEntryRequest"
    }
}

/// Request for the `DeleteCertificateMapEntry` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCertificateMapEntryRequest {
    /// Required. A name of the certificate map entry to delete. Must be in the
    /// format `projects/*/locations/*/certificateMaps/*/certificateMapEntries/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCertificateMapEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCertificateMapEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCertificateMapEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.DeleteCertificateMapEntryRequest"
    }
}

/// Request for the `ListDnsAuthorizations` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDnsAuthorizationsRequest {
    /// Required. The project and location from which the dns authorizations should
    /// be listed, specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of dns authorizations to return per call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListDnsAuthorizationsResponse`. Indicates
    /// that this is a continuation of a prior `ListDnsAuthorizations` call, and
    /// that the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter expression to restrict the Dns Authorizations returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A list of Dns Authorization field names used to specify the order of the
    /// returned results. The default sorting order is ascending. To specify
    /// descending order for a field, add a suffix `" desc"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDnsAuthorizationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDnsAuthorizationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDnsAuthorizationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDnsAuthorizationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDnsAuthorizationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDnsAuthorizationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDnsAuthorizationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListDnsAuthorizationsRequest"
    }
}

/// Response for the `ListDnsAuthorizations` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDnsAuthorizationsResponse {
    /// A list of dns authorizations for the parent resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dns_authorizations: std::vec::Vec<crate::model::DnsAuthorization>,

    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDnsAuthorizationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dns_authorizations][crate::model::ListDnsAuthorizationsResponse::dns_authorizations].
    pub fn set_dns_authorizations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DnsAuthorization>,
    {
        use std::iter::Iterator;
        self.dns_authorizations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDnsAuthorizationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDnsAuthorizationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDnsAuthorizationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListDnsAuthorizationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDnsAuthorizationsResponse {
    type PageItem = crate::model::DnsAuthorization;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dns_authorizations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetDnsAuthorization` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDnsAuthorizationRequest {
    /// Required. A name of the dns authorization to describe. Must be in the
    /// format `projects/*/locations/*/dnsAuthorizations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDnsAuthorizationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDnsAuthorizationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDnsAuthorizationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.GetDnsAuthorizationRequest"
    }
}

/// Request for the `CreateDnsAuthorization` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDnsAuthorizationRequest {
    /// Required. The parent resource of the dns authorization. Must be in the
    /// format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A user-provided name of the dns authorization.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dns_authorization_id: std::string::String,

    /// Required. A definition of the dns authorization to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_authorization: std::option::Option<crate::model::DnsAuthorization>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDnsAuthorizationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDnsAuthorizationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dns_authorization_id][crate::model::CreateDnsAuthorizationRequest::dns_authorization_id].
    pub fn set_dns_authorization_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dns_authorization_id = v.into();
        self
    }

    /// Sets the value of [dns_authorization][crate::model::CreateDnsAuthorizationRequest::dns_authorization].
    pub fn set_dns_authorization<
        T: std::convert::Into<std::option::Option<crate::model::DnsAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dns_authorization = v.into();
        self
    }
}

impl wkt::message::Message for CreateDnsAuthorizationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CreateDnsAuthorizationRequest"
    }
}

/// Request for the `UpdateDnsAuthorization` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDnsAuthorizationRequest {
    /// Required. A definition of the dns authorization to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_authorization: std::option::Option<crate::model::DnsAuthorization>,

    /// Required. The update mask applies to the resource. For the `FieldMask`
    /// definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDnsAuthorizationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dns_authorization][crate::model::UpdateDnsAuthorizationRequest::dns_authorization].
    pub fn set_dns_authorization<
        T: std::convert::Into<std::option::Option<crate::model::DnsAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dns_authorization = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDnsAuthorizationRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDnsAuthorizationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.UpdateDnsAuthorizationRequest"
    }
}

/// Request for the `DeleteDnsAuthorization` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDnsAuthorizationRequest {
    /// Required. A name of the dns authorization to delete. Must be in the format
    /// `projects/*/locations/*/dnsAuthorizations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDnsAuthorizationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDnsAuthorizationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDnsAuthorizationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.DeleteDnsAuthorizationRequest"
    }
}

/// Represents the metadata of the long-running operation. Output only.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.OperationMetadata"
    }
}

/// Defines TLS certificate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Certificate {
    /// A user-defined name of the certificate. Certificate names must be unique
    /// globally and match pattern `projects/*/locations/*/certificates/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// One or more paragraphs of text description of a certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of a Certificate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a Certificate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Set of labels associated with a Certificate.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The list of Subject Alternative Names of dnsName type defined
    /// in the certificate (see RFC 5280 4.2.1.6). Managed certificates that
    /// haven't been provisioned yet have this field populated with a value of the
    /// managed.domains field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub san_dnsnames: std::vec::Vec<std::string::String>,

    /// Output only. The PEM-encoded certificate chain.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pem_certificate: std::string::String,

    /// Output only. The expiry timestamp of a Certificate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Immutable. The scope of the certificate.
    pub scope: crate::model::certificate::Scope,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::certificate::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Certificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Certificate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Certificate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Certificate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Certificate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Certificate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [san_dnsnames][crate::model::Certificate::san_dnsnames].
    pub fn set_san_dnsnames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.san_dnsnames = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pem_certificate][crate::model::Certificate::pem_certificate].
    pub fn set_pem_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem_certificate = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Certificate::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Certificate::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::certificate::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Certificate::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::certificate::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::Certificate::r#type]
    /// if it holds a `SelfManaged`, `None` if the field is not set or
    /// holds a different branch.
    pub fn self_managed(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::certificate::SelfManagedCertificate>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::certificate::Type::SelfManaged(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Certificate::r#type]
    /// to hold a `SelfManaged`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_self_managed<
        T: std::convert::Into<std::boxed::Box<crate::model::certificate::SelfManagedCertificate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::certificate::Type::SelfManaged(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Certificate::r#type]
    /// if it holds a `Managed`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::certificate::ManagedCertificate>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::certificate::Type::Managed(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Certificate::r#type]
    /// to hold a `Managed`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_managed<
        T: std::convert::Into<std::boxed::Box<crate::model::certificate::ManagedCertificate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::certificate::Type::Managed(v.into()));
        self
    }
}

impl wkt::message::Message for Certificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.Certificate"
    }
}

/// Defines additional types related to [Certificate].
pub mod certificate {
    #[allow(unused_imports)]
    use super::*;

    /// Certificate data for a SelfManaged Certificate.
    /// SelfManaged Certificates are uploaded by the user. Updating such
    /// certificates before they expire remains the user's responsibility.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelfManagedCertificate {
        /// Input only. The PEM-encoded certificate chain.
        /// Leaf certificate comes first, followed by intermediate ones if any.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pem_certificate: std::string::String,

        /// Input only. The PEM-encoded private key of the leaf certificate.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pem_private_key: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SelfManagedCertificate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pem_certificate][crate::model::certificate::SelfManagedCertificate::pem_certificate].
        pub fn set_pem_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pem_certificate = v.into();
            self
        }

        /// Sets the value of [pem_private_key][crate::model::certificate::SelfManagedCertificate::pem_private_key].
        pub fn set_pem_private_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pem_private_key = v.into();
            self
        }
    }

    impl wkt::message::Message for SelfManagedCertificate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.Certificate.SelfManagedCertificate"
        }
    }

    /// Configuration and state of a Managed Certificate.
    /// Certificate Manager provisions and renews Managed Certificates
    /// automatically, for as long as it's authorized to do so.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManagedCertificate {
        /// Immutable. The domains for which a managed SSL certificate will be
        /// generated. Wildcard domains are only supported with DNS challenge
        /// resolution.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub domains: std::vec::Vec<std::string::String>,

        /// Immutable. Authorizations that will be used for performing domain
        /// authorization.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub dns_authorizations: std::vec::Vec<std::string::String>,

        /// Immutable. The resource name for a
        /// [CertificateIssuanceConfig][google.cloud.certificatemanager.v1.CertificateIssuanceConfig]
        /// used to configure private PKI certificates in the format
        /// `projects/*/locations/*/certificateIssuanceConfigs/*`.
        /// If this field is not set, the certificates will instead be publicly
        /// signed as documented at
        /// <https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs#caa>.
        ///
        /// [google.cloud.certificatemanager.v1.CertificateIssuanceConfig]: crate::model::CertificateIssuanceConfig
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub issuance_config: std::string::String,

        /// Output only. State of the managed certificate resource.
        pub state: crate::model::certificate::managed_certificate::State,

        /// Output only. Information about issues with provisioning a Managed
        /// Certificate.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub provisioning_issue:
            std::option::Option<crate::model::certificate::managed_certificate::ProvisioningIssue>,

        /// Output only. Detailed state of the latest authorization attempt for each
        /// domain specified for managed certificate resource.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub authorization_attempt_info:
            std::vec::Vec<crate::model::certificate::managed_certificate::AuthorizationAttemptInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManagedCertificate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [domains][crate::model::certificate::ManagedCertificate::domains].
        pub fn set_domains<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.domains = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dns_authorizations][crate::model::certificate::ManagedCertificate::dns_authorizations].
        pub fn set_dns_authorizations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.dns_authorizations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [issuance_config][crate::model::certificate::ManagedCertificate::issuance_config].
        pub fn set_issuance_config<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.issuance_config = v.into();
            self
        }

        /// Sets the value of [state][crate::model::certificate::ManagedCertificate::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::certificate::managed_certificate::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [provisioning_issue][crate::model::certificate::ManagedCertificate::provisioning_issue].
        pub fn set_provisioning_issue<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::certificate::managed_certificate::ProvisioningIssue,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.provisioning_issue = v.into();
            self
        }

        /// Sets the value of [authorization_attempt_info][crate::model::certificate::ManagedCertificate::authorization_attempt_info].
        pub fn set_authorization_attempt_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::certificate::managed_certificate::AuthorizationAttemptInfo,
                >,
        {
            use std::iter::Iterator;
            self.authorization_attempt_info = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ManagedCertificate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.Certificate.ManagedCertificate"
        }
    }

    /// Defines additional types related to [ManagedCertificate].
    pub mod managed_certificate {
        #[allow(unused_imports)]
        use super::*;

        /// Information about issues with provisioning a Managed Certificate.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ProvisioningIssue {
            /// Output only. Reason for provisioning failures.
            pub reason: crate::model::certificate::managed_certificate::provisioning_issue::Reason,

            /// Output only. Human readable explanation about the issue. Provided to
            /// help address the configuration issues. Not guaranteed to be stable. For
            /// programmatic access use Reason enum.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub details: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ProvisioningIssue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [reason][crate::model::certificate::managed_certificate::ProvisioningIssue::reason].
            pub fn set_reason<
                T: std::convert::Into<
                        crate::model::certificate::managed_certificate::provisioning_issue::Reason,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.reason = v.into();
                self
            }

            /// Sets the value of [details][crate::model::certificate::managed_certificate::ProvisioningIssue::details].
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }
        }

        impl wkt::message::Message for ProvisioningIssue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.certificatemanager.v1.Certificate.ManagedCertificate.ProvisioningIssue"
            }
        }

        /// Defines additional types related to [ProvisioningIssue].
        pub mod provisioning_issue {
            #[allow(unused_imports)]
            use super::*;

            /// Reason for provisioning failures.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Reason {
                /// Reason is unspecified.
                Unspecified,
                /// Certificate provisioning failed due to an issue with one or more of
                /// the domains on the certificate.
                /// For details of which domains failed, consult the
                /// `authorization_attempt_info` field.
                AuthorizationIssue,
                /// Exceeded Certificate Authority quotas or internal rate limits of the
                /// system. Provisioning may take longer to complete.
                RateLimited,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Reason::value] or
                /// [Reason::name].
                UnknownValue(reason::UnknownValue),
            }

            #[doc(hidden)]
            pub mod reason {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Reason {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::AuthorizationIssue => std::option::Option::Some(1),
                        Self::RateLimited => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
                        Self::AuthorizationIssue => {
                            std::option::Option::Some("AUTHORIZATION_ISSUE")
                        }
                        Self::RateLimited => std::option::Option::Some("RATE_LIMITED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Reason {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Reason {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Reason {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::AuthorizationIssue,
                        2 => Self::RateLimited,
                        _ => Self::UnknownValue(reason::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Reason {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "REASON_UNSPECIFIED" => Self::Unspecified,
                        "AUTHORIZATION_ISSUE" => Self::AuthorizationIssue,
                        "RATE_LIMITED" => Self::RateLimited,
                        _ => Self::UnknownValue(reason::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Reason {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::AuthorizationIssue => serializer.serialize_i32(1),
                        Self::RateLimited => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Reason {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reason>::new(
                        ".google.cloud.certificatemanager.v1.Certificate.ManagedCertificate.ProvisioningIssue.Reason"))
                }
            }
        }

        /// State of the latest attempt to authorize a domain for certificate
        /// issuance.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AuthorizationAttemptInfo {

            /// Domain name of the authorization attempt.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub domain: std::string::String,

            /// Output only. State of the domain for managed certificate issuance.
            pub state: crate::model::certificate::managed_certificate::authorization_attempt_info::State,

            /// Output only. Reason for failure of the authorization attempt for the
            /// domain.
            pub failure_reason: crate::model::certificate::managed_certificate::authorization_attempt_info::FailureReason,

            /// Output only. Human readable explanation for reaching the state.
            /// Provided to help address the configuration issues. Not guaranteed to be
            /// stable. For programmatic access use FailureReason enum.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub details: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuthorizationAttemptInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [domain][crate::model::certificate::managed_certificate::AuthorizationAttemptInfo::domain].
            pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.domain = v.into();
                self
            }

            /// Sets the value of [state][crate::model::certificate::managed_certificate::AuthorizationAttemptInfo::state].
            pub fn set_state<T: std::convert::Into<crate::model::certificate::managed_certificate::authorization_attempt_info::State>>(mut self, v: T) -> Self{
                self.state = v.into();
                self
            }

            /// Sets the value of [failure_reason][crate::model::certificate::managed_certificate::AuthorizationAttemptInfo::failure_reason].
            pub fn set_failure_reason<T: std::convert::Into<crate::model::certificate::managed_certificate::authorization_attempt_info::FailureReason>>(mut self, v: T) -> Self{
                self.failure_reason = v.into();
                self
            }

            /// Sets the value of [details][crate::model::certificate::managed_certificate::AuthorizationAttemptInfo::details].
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }
        }

        impl wkt::message::Message for AuthorizationAttemptInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.certificatemanager.v1.Certificate.ManagedCertificate.AuthorizationAttemptInfo"
            }
        }

        /// Defines additional types related to [AuthorizationAttemptInfo].
        pub mod authorization_attempt_info {
            #[allow(unused_imports)]
            use super::*;

            /// State of the domain for managed certificate issuance.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum State {
                /// State is unspecified.
                Unspecified,
                /// Certificate provisioning for this domain is under way. Google Cloud
                /// will attempt to authorize the domain.
                Authorizing,
                /// A managed certificate can be provisioned, no issues for this domain.
                Authorized,
                /// Attempt to authorize the domain failed. This prevents the Managed
                /// Certificate from being issued.
                /// See `failure_reason` and `details` fields for more information.
                Failed,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [State::value] or
                /// [State::name].
                UnknownValue(state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl State {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Authorizing => std::option::Option::Some(1),
                        Self::Authorized => std::option::Option::Some(6),
                        Self::Failed => std::option::Option::Some(7),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                        Self::Authorizing => std::option::Option::Some("AUTHORIZING"),
                        Self::Authorized => std::option::Option::Some("AUTHORIZED"),
                        Self::Failed => std::option::Option::Some("FAILED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for State {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for State {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for State {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Authorizing,
                        6 => Self::Authorized,
                        7 => Self::Failed,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for State {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATE_UNSPECIFIED" => Self::Unspecified,
                        "AUTHORIZING" => Self::Authorizing,
                        "AUTHORIZED" => Self::Authorized,
                        "FAILED" => Self::Failed,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for State {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Authorizing => serializer.serialize_i32(1),
                        Self::Authorized => serializer.serialize_i32(6),
                        Self::Failed => serializer.serialize_i32(7),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for State {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                        ".google.cloud.certificatemanager.v1.Certificate.ManagedCertificate.AuthorizationAttemptInfo.State"))
                }
            }

            /// Reason for failure of the authorization attempt for the domain.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum FailureReason {
                /// FailureReason is unspecified.
                Unspecified,
                /// There was a problem with the user's DNS or load balancer
                /// configuration for this domain.
                Config,
                /// Certificate issuance forbidden by an explicit CAA record for the
                /// domain or a failure to check CAA records for the domain.
                Caa,
                /// Reached a CA or internal rate-limit for the domain,
                /// e.g. for certificates per top-level private domain.
                RateLimited,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [FailureReason::value] or
                /// [FailureReason::name].
                UnknownValue(failure_reason::UnknownValue),
            }

            #[doc(hidden)]
            pub mod failure_reason {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl FailureReason {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Config => std::option::Option::Some(1),
                        Self::Caa => std::option::Option::Some(2),
                        Self::RateLimited => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("FAILURE_REASON_UNSPECIFIED")
                        }
                        Self::Config => std::option::Option::Some("CONFIG"),
                        Self::Caa => std::option::Option::Some("CAA"),
                        Self::RateLimited => std::option::Option::Some("RATE_LIMITED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for FailureReason {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for FailureReason {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for FailureReason {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Config,
                        2 => Self::Caa,
                        3 => Self::RateLimited,
                        _ => Self::UnknownValue(failure_reason::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for FailureReason {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "FAILURE_REASON_UNSPECIFIED" => Self::Unspecified,
                        "CONFIG" => Self::Config,
                        "CAA" => Self::Caa,
                        "RATE_LIMITED" => Self::RateLimited,
                        _ => Self::UnknownValue(failure_reason::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for FailureReason {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Config => serializer.serialize_i32(1),
                        Self::Caa => serializer.serialize_i32(2),
                        Self::RateLimited => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for FailureReason {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureReason>::new(
                        ".google.cloud.certificatemanager.v1.Certificate.ManagedCertificate.AuthorizationAttemptInfo.FailureReason"))
                }
            }
        }

        /// State of the managed certificate resource.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State is unspecified.
            Unspecified,
            /// Certificate Manager attempts to provision or renew the certificate.
            /// If the process takes longer than expected, consult the
            /// `provisioning_issue` field.
            Provisioning,
            /// Multiple certificate provisioning attempts failed and Certificate
            /// Manager gave up. To try again, delete and create a new managed
            /// Certificate resource.
            /// For details see the `provisioning_issue` field.
            Failed,
            /// The certificate management is working, and a certificate has been
            /// provisioned.
            Active,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Provisioning => std::option::Option::Some(1),
                    Self::Failed => std::option::Option::Some(2),
                    Self::Active => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Provisioning,
                    2 => Self::Failed,
                    3 => Self::Active,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "PROVISIONING" => Self::Provisioning,
                    "FAILED" => Self::Failed,
                    "ACTIVE" => Self::Active,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Provisioning => serializer.serialize_i32(1),
                    Self::Failed => serializer.serialize_i32(2),
                    Self::Active => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.certificatemanager.v1.Certificate.ManagedCertificate.State",
                ))
            }
        }
    }

    /// Certificate scope.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Certificates with default scope are served from core Google data centers.
        /// If unsure, choose this option.
        Default,
        /// Certificates with scope EDGE_CACHE are special-purposed certificates,
        /// served from Edge Points of Presence.
        /// See <https://cloud.google.com/vpc/docs/edge-locations>.
        EdgeCache,
        /// Certificates with ALL_REGIONS scope are served from all Google Cloud
        /// regions. See <https://cloud.google.com/compute/docs/regions-zones>.
        AllRegions,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Default => std::option::Option::Some(0),
                Self::EdgeCache => std::option::Option::Some(1),
                Self::AllRegions => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::EdgeCache => std::option::Option::Some("EDGE_CACHE"),
                Self::AllRegions => std::option::Option::Some("ALL_REGIONS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Default,
                1 => Self::EdgeCache,
                2 => Self::AllRegions,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT" => Self::Default,
                "EDGE_CACHE" => Self::EdgeCache,
                "ALL_REGIONS" => Self::AllRegions,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Default => serializer.serialize_i32(0),
                Self::EdgeCache => serializer.serialize_i32(1),
                Self::AllRegions => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.certificatemanager.v1.Certificate.Scope",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// If set, defines data of a self-managed certificate.
        SelfManaged(std::boxed::Box<crate::model::certificate::SelfManagedCertificate>),
        /// If set, contains configuration and state of a managed certificate.
        Managed(std::boxed::Box<crate::model::certificate::ManagedCertificate>),
    }
}

/// Defines a collection of certificate configurations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateMap {
    /// A user-defined name of the Certificate Map. Certificate Map names must be
    /// unique globally and match pattern
    /// `projects/*/locations/*/certificateMaps/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// One or more paragraphs of text description of a certificate map.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of a Certificate Map.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update timestamp of a Certificate Map.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Set of labels associated with a Certificate Map.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. A list of GCLB targets that use this Certificate Map.
    /// A Target Proxy is only present on this list if it's attached to a
    /// Forwarding Rule.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub gclb_targets: std::vec::Vec<crate::model::certificate_map::GclbTarget>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateMap {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateMap::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CertificateMap::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CertificateMap::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CertificateMap::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CertificateMap::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [gclb_targets][crate::model::CertificateMap::gclb_targets].
    pub fn set_gclb_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::certificate_map::GclbTarget>,
    {
        use std::iter::Iterator;
        self.gclb_targets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CertificateMap {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CertificateMap"
    }
}

/// Defines additional types related to [CertificateMap].
pub mod certificate_map {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a Target Proxy that uses this Certificate Map.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GclbTarget {
        /// Output only. IP configurations for this Target Proxy where the
        /// Certificate Map is serving.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub ip_configs: std::vec::Vec<crate::model::certificate_map::gclb_target::IpConfig>,

        /// A Target Proxy to which this map is attached to.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub target_proxy:
            std::option::Option<crate::model::certificate_map::gclb_target::TargetProxy>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GclbTarget {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip_configs][crate::model::certificate_map::GclbTarget::ip_configs].
        pub fn set_ip_configs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::certificate_map::gclb_target::IpConfig>,
        {
            use std::iter::Iterator;
            self.ip_configs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [target_proxy][crate::model::certificate_map::GclbTarget::target_proxy].
        ///
        /// Note that all the setters affecting `target_proxy` are mutually
        /// exclusive.
        pub fn set_target_proxy<
            T: std::convert::Into<
                    std::option::Option<crate::model::certificate_map::gclb_target::TargetProxy>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target_proxy = v.into();
            self
        }

        /// The value of [target_proxy][crate::model::certificate_map::GclbTarget::target_proxy]
        /// if it holds a `TargetHttpsProxy`, `None` if the field is not set or
        /// holds a different branch.
        pub fn target_https_proxy(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.target_proxy.as_ref().and_then(|v| match v {
                crate::model::certificate_map::gclb_target::TargetProxy::TargetHttpsProxy(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target_proxy][crate::model::certificate_map::GclbTarget::target_proxy]
        /// to hold a `TargetHttpsProxy`.
        ///
        /// Note that all the setters affecting `target_proxy` are
        /// mutually exclusive.
        pub fn set_target_https_proxy<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_proxy = std::option::Option::Some(
                crate::model::certificate_map::gclb_target::TargetProxy::TargetHttpsProxy(v.into()),
            );
            self
        }

        /// The value of [target_proxy][crate::model::certificate_map::GclbTarget::target_proxy]
        /// if it holds a `TargetSslProxy`, `None` if the field is not set or
        /// holds a different branch.
        pub fn target_ssl_proxy(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.target_proxy.as_ref().and_then(|v| match v {
                crate::model::certificate_map::gclb_target::TargetProxy::TargetSslProxy(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target_proxy][crate::model::certificate_map::GclbTarget::target_proxy]
        /// to hold a `TargetSslProxy`.
        ///
        /// Note that all the setters affecting `target_proxy` are
        /// mutually exclusive.
        pub fn set_target_ssl_proxy<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_proxy = std::option::Option::Some(
                crate::model::certificate_map::gclb_target::TargetProxy::TargetSslProxy(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for GclbTarget {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.CertificateMap.GclbTarget"
        }
    }

    /// Defines additional types related to [GclbTarget].
    pub mod gclb_target {
        #[allow(unused_imports)]
        use super::*;

        /// Defines IP configuration where this Certificate Map is serving.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IpConfig {
            /// Output only. An external IP address.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub ip_address: std::string::String,

            /// Output only. Ports.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub ports: std::vec::Vec<u32>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IpConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [ip_address][crate::model::certificate_map::gclb_target::IpConfig::ip_address].
            pub fn set_ip_address<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.ip_address = v.into();
                self
            }

            /// Sets the value of [ports][crate::model::certificate_map::gclb_target::IpConfig::ports].
            pub fn set_ports<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<u32>,
            {
                use std::iter::Iterator;
                self.ports = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IpConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.certificatemanager.v1.CertificateMap.GclbTarget.IpConfig"
            }
        }

        /// A Target Proxy to which this map is attached to.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum TargetProxy {
            /// Output only. This field returns the resource name in the following
            /// format:
            /// `//compute.googleapis.com/projects/*/global/targetHttpsProxies/*`.
            TargetHttpsProxy(std::string::String),
            /// Output only. This field returns the resource name in the following
            /// format:
            /// `//compute.googleapis.com/projects/*/global/targetSslProxies/*`.
            TargetSslProxy(std::string::String),
        }
    }
}

/// Defines a certificate map entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateMapEntry {
    /// A user-defined name of the Certificate Map Entry. Certificate Map Entry
    /// names must be unique globally and match pattern
    /// `projects/*/locations/*/certificateMaps/*/certificateMapEntries/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// One or more paragraphs of text description of a certificate map entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of a Certificate Map Entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update timestamp of a Certificate Map Entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Set of labels associated with a Certificate Map Entry.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A set of Certificates defines for the given `hostname`. There can be
    /// defined up to four certificates in each Certificate Map Entry. Each
    /// certificate must match pattern `projects/*/locations/*/certificates/*`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certificates: std::vec::Vec<std::string::String>,

    /// Output only. A serving state of this Certificate Map Entry.
    pub state: crate::model::ServingState,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#match: std::option::Option<crate::model::certificate_map_entry::Match>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateMapEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateMapEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CertificateMapEntry::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CertificateMapEntry::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CertificateMapEntry::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CertificateMapEntry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [certificates][crate::model::CertificateMapEntry::certificates].
    pub fn set_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::CertificateMapEntry::state].
    pub fn set_state<T: std::convert::Into<crate::model::ServingState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#match][crate::model::CertificateMapEntry::match].
    ///
    /// Note that all the setters affecting `r#match` are mutually
    /// exclusive.
    pub fn set_match<
        T: std::convert::Into<std::option::Option<crate::model::certificate_map_entry::Match>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#match = v.into();
        self
    }

    /// The value of [r#match][crate::model::CertificateMapEntry::r#match]
    /// if it holds a `Hostname`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hostname(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.r#match.as_ref().and_then(|v| match v {
            crate::model::certificate_map_entry::Match::Hostname(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#match][crate::model::CertificateMapEntry::r#match]
    /// to hold a `Hostname`.
    ///
    /// Note that all the setters affecting `r#match` are
    /// mutually exclusive.
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#match = std::option::Option::Some(
            crate::model::certificate_map_entry::Match::Hostname(v.into()),
        );
        self
    }

    /// The value of [r#match][crate::model::CertificateMapEntry::r#match]
    /// if it holds a `Matcher`, `None` if the field is not set or
    /// holds a different branch.
    pub fn matcher(&self) -> std::option::Option<&crate::model::certificate_map_entry::Matcher> {
        #[allow(unreachable_patterns)]
        self.r#match.as_ref().and_then(|v| match v {
            crate::model::certificate_map_entry::Match::Matcher(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#match][crate::model::CertificateMapEntry::r#match]
    /// to hold a `Matcher`.
    ///
    /// Note that all the setters affecting `r#match` are
    /// mutually exclusive.
    pub fn set_matcher<T: std::convert::Into<crate::model::certificate_map_entry::Matcher>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#match = std::option::Option::Some(
            crate::model::certificate_map_entry::Match::Matcher(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CertificateMapEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CertificateMapEntry"
    }
}

/// Defines additional types related to [CertificateMapEntry].
pub mod certificate_map_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Defines predefined cases other than SNI-hostname match when this
    /// configuration should be applied.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Matcher {
        /// A matcher has't been recognized.
        Unspecified,
        /// A primary certificate that is served when SNI wasn't specified in the
        /// request or SNI couldn't be found in the map.
        Primary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Matcher::value] or
        /// [Matcher::name].
        UnknownValue(matcher::UnknownValue),
    }

    #[doc(hidden)]
    pub mod matcher {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Matcher {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MATCHER_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Matcher {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Matcher {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Matcher {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                _ => Self::UnknownValue(matcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Matcher {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MATCHER_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                _ => Self::UnknownValue(matcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Matcher {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Matcher {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Matcher>::new(
                ".google.cloud.certificatemanager.v1.CertificateMapEntry.Matcher",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Match {
        /// A Hostname (FQDN, e.g. `example.com`) or a wildcard hostname expression
        /// (`*.example.com`) for a set of hostnames with common suffix. Used as
        /// Server Name Indication (SNI) for selecting a proper certificate.
        Hostname(std::string::String),
        /// A predefined matcher for particular cases, other than SNI selection.
        Matcher(crate::model::certificate_map_entry::Matcher),
    }
}

/// A DnsAuthorization resource describes a way to perform domain authorization
/// for certificate issuance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DnsAuthorization {
    /// A user-defined name of the dns authorization. DnsAuthorization names must
    /// be unique globally and match pattern
    /// `projects/*/locations/*/dnsAuthorizations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The creation timestamp of a DnsAuthorization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a DnsAuthorization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Set of labels associated with a DnsAuthorization.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// One or more paragraphs of text description of a DnsAuthorization.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Immutable. A domain that is being authorized. A DnsAuthorization
    /// resource covers a single domain and its wildcard, e.g. authorization for
    /// `example.com` can be used to issue certificates for `example.com` and
    /// `*.example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// Output only. DNS Resource Record that needs to be added to DNS
    /// configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_resource_record:
        std::option::Option<crate::model::dns_authorization::DnsResourceRecord>,

    /// Immutable. Type of DnsAuthorization. If unset during resource creation the
    /// following default will be used:
    ///
    /// - in location global: FIXED_RECORD.
    #[serde(rename = "type")]
    pub r#type: crate::model::dns_authorization::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DnsAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DnsAuthorization::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DnsAuthorization::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DnsAuthorization::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DnsAuthorization::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::DnsAuthorization::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::DnsAuthorization::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [dns_resource_record][crate::model::DnsAuthorization::dns_resource_record].
    pub fn set_dns_resource_record<
        T: std::convert::Into<std::option::Option<crate::model::dns_authorization::DnsResourceRecord>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dns_resource_record = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DnsAuthorization::type].
    pub fn set_type<T: std::convert::Into<crate::model::dns_authorization::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for DnsAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.DnsAuthorization"
    }
}

/// Defines additional types related to [DnsAuthorization].
pub mod dns_authorization {
    #[allow(unused_imports)]
    use super::*;

    /// The structure describing the DNS Resource Record that needs to be added
    /// to DNS configuration for the authorization to be usable by
    /// certificate.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DnsResourceRecord {
        /// Output only. Fully qualified name of the DNS Resource Record.
        /// e.g. `_acme-challenge.example.com`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Output only. Type of the DNS Resource Record.
        /// Currently always set to "CNAME".
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        /// Output only. Data of the DNS Resource Record.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DnsResourceRecord {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::dns_authorization::DnsResourceRecord::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::dns_authorization::DnsResourceRecord::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [data][crate::model::dns_authorization::DnsResourceRecord::data].
        pub fn set_data<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data = v.into();
            self
        }
    }

    impl wkt::message::Message for DnsResourceRecord {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.DnsAuthorization.DnsResourceRecord"
        }
    }

    /// DnsAuthorization type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Type is unspecified.
        Unspecified,
        /// FIXED_RECORD DNS authorization uses DNS-01 validation method.
        FixedRecord,
        /// PER_PROJECT_RECORD DNS authorization allows for independent management
        /// of Google-managed certificates with DNS authorization across multiple
        /// projects.
        PerProjectRecord,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FixedRecord => std::option::Option::Some(1),
                Self::PerProjectRecord => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::FixedRecord => std::option::Option::Some("FIXED_RECORD"),
                Self::PerProjectRecord => std::option::Option::Some("PER_PROJECT_RECORD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FixedRecord,
                2 => Self::PerProjectRecord,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "FIXED_RECORD" => Self::FixedRecord,
                "PER_PROJECT_RECORD" => Self::PerProjectRecord,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FixedRecord => serializer.serialize_i32(1),
                Self::PerProjectRecord => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.certificatemanager.v1.DnsAuthorization.Type",
            ))
        }
    }
}

/// Request for the `ListTrustConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrustConfigsRequest {
    /// Required. The project and location from which the TrustConfigs should be
    /// listed, specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of TrustConfigs to return per call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListTrustConfigsResponse`. Indicates
    /// that this is a continuation of a prior `ListTrustConfigs` call, and that
    /// the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter expression to restrict the TrustConfigs returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A list of TrustConfig field names used to specify the order of the
    /// returned results. The default sorting order is ascending. To specify
    /// descending order for a field, add a suffix `" desc"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTrustConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTrustConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTrustConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTrustConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTrustConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTrustConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTrustConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListTrustConfigsRequest"
    }
}

/// Response for the `ListTrustConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrustConfigsResponse {
    /// A list of TrustConfigs for the parent resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trust_configs: std::vec::Vec<crate::model::TrustConfig>,

    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTrustConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trust_configs][crate::model::ListTrustConfigsResponse::trust_configs].
    pub fn set_trust_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrustConfig>,
    {
        use std::iter::Iterator;
        self.trust_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTrustConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTrustConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTrustConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.ListTrustConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTrustConfigsResponse {
    type PageItem = crate::model::TrustConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.trust_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `GetTrustConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTrustConfigRequest {
    /// Required. A name of the TrustConfig to describe. Must be in the format
    /// `projects/*/locations/*/trustConfigs/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTrustConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTrustConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTrustConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.GetTrustConfigRequest"
    }
}

/// Request for the `CreateTrustConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTrustConfigRequest {
    /// Required. The parent resource of the TrustConfig. Must be in the format
    /// `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A user-provided name of the TrustConfig. Must match the regexp
    /// `[a-z0-9-]{1,63}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trust_config_id: std::string::String,

    /// Required. A definition of the TrustConfig to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust_config: std::option::Option<crate::model::TrustConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTrustConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTrustConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [trust_config_id][crate::model::CreateTrustConfigRequest::trust_config_id].
    pub fn set_trust_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trust_config_id = v.into();
        self
    }

    /// Sets the value of [trust_config][crate::model::CreateTrustConfigRequest::trust_config].
    pub fn set_trust_config<
        T: std::convert::Into<std::option::Option<crate::model::TrustConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trust_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateTrustConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.CreateTrustConfigRequest"
    }
}

/// Request for the `UpdateTrustConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTrustConfigRequest {
    /// Required. A definition of the TrustConfig to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust_config: std::option::Option<crate::model::TrustConfig>,

    /// Required. The update mask applies to the resource. For the `FieldMask`
    /// definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTrustConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trust_config][crate::model::UpdateTrustConfigRequest::trust_config].
    pub fn set_trust_config<
        T: std::convert::Into<std::option::Option<crate::model::TrustConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trust_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTrustConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTrustConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.UpdateTrustConfigRequest"
    }
}

/// Request for the `DeleteTrustConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTrustConfigRequest {
    /// Required. A name of the TrustConfig to delete. Must be in the format
    /// `projects/*/locations/*/trustConfigs/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current etag of the TrustConfig.
    /// If an etag is provided and does not match the current etag of the resource,
    /// deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTrustConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTrustConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteTrustConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTrustConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.DeleteTrustConfigRequest"
    }
}

/// Defines a trust config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrustConfig {
    /// A user-defined name of the trust config. TrustConfig names must be
    /// unique globally and match pattern
    /// `projects/*/locations/*/trustConfigs/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The creation timestamp of a TrustConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a TrustConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Set of labels associated with a TrustConfig.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// One or more paragraphs of text description of a TrustConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Set of trust stores to perform validation against.
    ///
    /// This field is supported when TrustConfig is configured with Load Balancers,
    /// currently not supported for SPIFFE certificate validation.
    ///
    /// Only one TrustStore specified is currently allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trust_stores: std::vec::Vec<crate::model::trust_config::TrustStore>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrustConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TrustConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TrustConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TrustConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TrustConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::TrustConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TrustConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [trust_stores][crate::model::TrustConfig::trust_stores].
    pub fn set_trust_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::trust_config::TrustStore>,
    {
        use std::iter::Iterator;
        self.trust_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TrustConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.certificatemanager.v1.TrustConfig"
    }
}

/// Defines additional types related to [TrustConfig].
pub mod trust_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines a trust anchor.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrustAnchor {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub kind: std::option::Option<crate::model::trust_config::trust_anchor::Kind>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TrustAnchor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::trust_config::TrustAnchor::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::trust_config::trust_anchor::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::trust_config::TrustAnchor::kind]
        /// if it holds a `PemCertificate`, `None` if the field is not set or
        /// holds a different branch.
        pub fn pem_certificate(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::trust_config::trust_anchor::Kind::PemCertificate(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::trust_config::TrustAnchor::kind]
        /// to hold a `PemCertificate`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_pem_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::trust_config::trust_anchor::Kind::PemCertificate(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for TrustAnchor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.TrustConfig.TrustAnchor"
        }
    }

    /// Defines additional types related to [TrustAnchor].
    pub mod trust_anchor {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Kind {
            /// PEM root certificate of the PKI used for validation.
            ///
            /// Each certificate provided in PEM format may occupy up to 5kB.
            PemCertificate(std::string::String),
        }
    }

    /// Defines an intermediate CA.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IntermediateCA {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub kind: std::option::Option<crate::model::trust_config::intermediate_ca::Kind>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IntermediateCA {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::trust_config::IntermediateCA::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<
                    std::option::Option<crate::model::trust_config::intermediate_ca::Kind>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::trust_config::IntermediateCA::kind]
        /// if it holds a `PemCertificate`, `None` if the field is not set or
        /// holds a different branch.
        pub fn pem_certificate(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::trust_config::intermediate_ca::Kind::PemCertificate(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::trust_config::IntermediateCA::kind]
        /// to hold a `PemCertificate`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_pem_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::trust_config::intermediate_ca::Kind::PemCertificate(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for IntermediateCA {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.TrustConfig.IntermediateCA"
        }
    }

    /// Defines additional types related to [IntermediateCA].
    pub mod intermediate_ca {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Kind {
            /// PEM intermediate certificate used for building up paths
            /// for validation.
            ///
            /// Each certificate provided in PEM format may occupy up to 5kB.
            PemCertificate(std::string::String),
        }
    }

    /// Defines a trust store.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrustStore {
        /// List of Trust Anchors to be used while performing validation
        /// against a given TrustStore.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub trust_anchors: std::vec::Vec<crate::model::trust_config::TrustAnchor>,

        /// Set of intermediate CA certificates used for the path building
        /// phase of chain validation.
        ///
        /// The field is currently not supported if TrustConfig is used for the
        /// workload certificate feature.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub intermediate_cas: std::vec::Vec<crate::model::trust_config::IntermediateCA>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TrustStore {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trust_anchors][crate::model::trust_config::TrustStore::trust_anchors].
        pub fn set_trust_anchors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::trust_config::TrustAnchor>,
        {
            use std::iter::Iterator;
            self.trust_anchors = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [intermediate_cas][crate::model::trust_config::TrustStore::intermediate_cas].
        pub fn set_intermediate_cas<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::trust_config::IntermediateCA>,
        {
            use std::iter::Iterator;
            self.intermediate_cas = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TrustStore {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.certificatemanager.v1.TrustConfig.TrustStore"
        }
    }
}

/// Defines set of serving states associated with a resource.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ServingState {
    /// The status is undefined.
    Unspecified,
    /// The configuration is serving.
    Active,
    /// Update is in progress. Some frontends may serve this configuration.
    Pending,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ServingState::value] or
    /// [ServingState::name].
    UnknownValue(serving_state::UnknownValue),
}

#[doc(hidden)]
pub mod serving_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ServingState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::Pending => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SERVING_STATE_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ServingState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ServingState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ServingState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::Pending,
            _ => Self::UnknownValue(serving_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ServingState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SERVING_STATE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "PENDING" => Self::Pending,
            _ => Self::UnknownValue(serving_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ServingState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::Pending => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ServingState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServingState>::new(
            ".google.cloud.certificatemanager.v1.ServingState",
        ))
    }
}
