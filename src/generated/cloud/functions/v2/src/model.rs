// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes a Cloud Function that contains user computation executed in
/// response to an event. It encapsulates function and trigger configurations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Function {
    /// A user-defined name of the function. Function names must be unique
    /// globally and match pattern `projects/*/locations/*/functions/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User-provided description of a function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Describes the Build step of the function that builds a container from the
    /// given source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_config: std::option::Option<crate::model::BuildConfig>,

    /// Describes the Service being deployed. Currently deploys services to Cloud
    /// Run (fully managed).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_config: std::option::Option<crate::model::ServiceConfig>,

    /// An Eventarc trigger managed by Google Cloud Functions that fires events in
    /// response to a condition in another service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_trigger: std::option::Option<crate::model::EventTrigger>,

    /// Output only. State of the function.
    pub state: crate::model::function::State,

    /// Output only. The last update timestamp of a Cloud Function.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this Cloud Function.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State Messages for this Cloud Function.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub state_messages: std::vec::Vec<crate::model::StateMessage>,

    /// Describe whether the function is 1st Gen or 2nd Gen.
    pub environment: crate::model::Environment,

    /// Output only. The deployed url for the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt function resources.
    ///
    /// It must match the pattern
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. The create timestamp of a Cloud Function. This is only
    /// applicable to 2nd Gen functions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Function {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Function::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Function::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [build_config][crate::model::Function::build_config].
    pub fn set_build_config<
        T: std::convert::Into<std::option::Option<crate::model::BuildConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_config = v.into();
        self
    }

    /// Sets the value of [service_config][crate::model::Function::service_config].
    pub fn set_service_config<
        T: std::convert::Into<std::option::Option<crate::model::ServiceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_config = v.into();
        self
    }

    /// Sets the value of [event_trigger][crate::model::Function::event_trigger].
    pub fn set_event_trigger<
        T: std::convert::Into<std::option::Option<crate::model::EventTrigger>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event_trigger = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Function::state].
    pub fn set_state<T: std::convert::Into<crate::model::function::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Function::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::Function::environment].
    pub fn set_environment<T: std::convert::Into<crate::model::Environment>>(
        mut self,
        v: T,
    ) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [url][crate::model::Function::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Function::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Function::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Function::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [state_messages][crate::model::Function::state_messages].
    pub fn set_state_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StateMessage>,
    {
        use std::iter::Iterator;
        self.state_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Function::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Function {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.Function"
    }
}

/// Defines additional types related to [Function].
pub mod function {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the current state of the function.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified. Invalid state.
        Unspecified,
        /// Function has been successfully deployed and is serving.
        Active,
        /// Function deployment failed and the function is not serving.
        Failed,
        /// Function is being created or updated.
        Deploying,
        /// Function is being deleted.
        Deleting,
        /// Function deployment failed and the function serving state is undefined.
        /// The function should be updated or deleted to move it out of this state.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Deploying => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Unknown => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deploying => std::option::Option::Some("DEPLOYING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Failed,
                3 => Self::Deploying,
                4 => Self::Deleting,
                5 => Self::Unknown,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "FAILED" => Self::Failed,
                "DEPLOYING" => Self::Deploying,
                "DELETING" => Self::Deleting,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Deploying => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Unknown => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.functions.v2.Function.State",
            ))
        }
    }
}

/// Informational messages about the state of the Cloud Function or Operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StateMessage {
    /// Severity of the state message.
    pub severity: crate::model::state_message::Severity,

    /// One-word CamelCase type of the state message.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// The message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StateMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::StateMessage::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::state_message::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::StateMessage::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [message][crate::model::StateMessage::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for StateMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.StateMessage"
    }
}

/// Defines additional types related to [StateMessage].
pub mod state_message {
    #[allow(unused_imports)]
    use super::*;

    /// Severity of the state message.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Not specified. Invalid severity.
        Unspecified,
        /// ERROR-level severity.
        Error,
        /// WARNING-level severity.
        Warning,
        /// INFO-level severity.
        Info,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Error => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Info => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Error,
                2 => Self::Warning,
                3 => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "ERROR" => Self::Error,
                "WARNING" => Self::Warning,
                "INFO" => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Error => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Info => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.functions.v2.StateMessage.Severity",
            ))
        }
    }
}

/// Location of the source in an archive file in Google Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageSource {
    /// Google Cloud Storage bucket containing the source (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Google Cloud Storage object containing the source.
    ///
    /// This object must be a gzipped archive file (`.tar.gz`) containing source to
    /// build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// Google Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// When the specified storage bucket is a 1st gen function uploard url bucket,
    /// this field should be set as the generated upload url for 1st gen
    /// deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_upload_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSource::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSource::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [source_upload_url][crate::model::StorageSource::source_upload_url].
    pub fn set_source_upload_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_upload_url = v.into();
        self
    }
}

impl wkt::message::Message for StorageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.StorageSource"
    }
}

/// Location of the source in a Google Cloud Source Repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepoSource {
    /// ID of the project that owns the Cloud Source Repository. If omitted, the
    /// project ID requesting the build is assumed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Name of the Cloud Source Repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repo_name: std::string::String,

    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    /// eg. helloworld (no leading slash allowed)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dir: std::string::String,

    /// Only trigger a build if the revision regex does NOT match the revision
    /// regex.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub invert_regex: bool,

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub revision: std::option::Option<crate::model::repo_source::Revision>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepoSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RepoSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [repo_name][crate::model::RepoSource::repo_name].
    pub fn set_repo_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repo_name = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::RepoSource::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [invert_regex][crate::model::RepoSource::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::repo_source::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `BranchName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn branch_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::BranchName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `TagName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::TagName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `CommitSha`, `None` if the field is not set or
    /// holds a different branch.
    pub fn commit_sha(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::CommitSha(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `BranchName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_branch_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::BranchName(v.into()));
        self
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `TagName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_tag_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::TagName(v.into()));
        self
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `CommitSha`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::CommitSha(v.into()));
        self
    }
}

impl wkt::message::Message for RepoSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.RepoSource"
    }
}

/// Defines additional types related to [RepoSource].
pub mod repo_source {
    #[allow(unused_imports)]
    use super::*;

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Revision {
        /// Regex matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        BranchName(std::string::String),
        /// Regex matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        TagName(std::string::String),
        /// Explicit commit SHA to build.
        CommitSha(std::string::String),
    }
}

/// The location of the function source code.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Source {
    /// Location of the source.
    /// At least one source needs to be provided for the deployment to succeed.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::source::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::Source::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::source::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `StorageSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::StorageSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `RepoSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repo_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::RepoSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::RepoSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `GitUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::GitUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `StorageSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source::Source::StorageSource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `RepoSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repo_source<T: std::convert::Into<std::boxed::Box<crate::model::RepoSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::RepoSource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `GitUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_git_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::GitUri(v.into()));
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.Source"
    }
}

/// Defines additional types related to [Source].
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    /// Location of the source.
    /// At least one source needs to be provided for the deployment to succeed.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// If provided, get the source from this location in Google Cloud Storage.
        StorageSource(std::boxed::Box<crate::model::StorageSource>),
        /// If provided, get the source from this location in a Cloud Source
        /// Repository.
        RepoSource(std::boxed::Box<crate::model::RepoSource>),
        /// If provided, get the source from GitHub repository. This option is valid
        /// only for GCF 1st Gen function.
        /// Example: <https://github.com/>\<user\>/\<repo\>/blob/\<commit\>/\<path-to-code\>
        GitUri(std::string::String),
    }
}

/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceProvenance {
    /// A copy of the build's `source.storage_source`, if exists, with any
    /// generations resolved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_storage_source: std::option::Option<crate::model::StorageSource>,

    /// A copy of the build's `source.repo_source`, if exists, with any
    /// revisions resolved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_repo_source: std::option::Option<crate::model::RepoSource>,

    /// A copy of the build's `source.git_uri`, if exists, with any commits
    /// resolved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resolved_storage_source][crate::model::SourceProvenance::resolved_storage_source].
    pub fn set_resolved_storage_source<
        T: std::convert::Into<std::option::Option<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_storage_source = v.into();
        self
    }

    /// Sets the value of [resolved_repo_source][crate::model::SourceProvenance::resolved_repo_source].
    pub fn set_resolved_repo_source<
        T: std::convert::Into<std::option::Option<crate::model::RepoSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_repo_source = v.into();
        self
    }

    /// Sets the value of [git_uri][crate::model::SourceProvenance::git_uri].
    pub fn set_git_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_uri = v.into();
        self
    }
}

impl wkt::message::Message for SourceProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.SourceProvenance"
    }
}

/// Describes the Build step of the function that builds a container from the
/// given source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildConfig {
    /// Output only. The Cloud Build name of the latest successful deployment of
    /// the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub build: std::string::String,

    /// The runtime in which to run the function. Required when deploying a new
    /// function, optional when updating an existing function. For a complete
    /// list of possible choices, see the
    /// [`gcloud` command
    /// reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime: std::string::String,

    /// The name of the function (as defined in source code) that will be
    /// executed. Defaults to the resource name suffix, if not specified. For
    /// backward compatibility, if function with given name is not found, then the
    /// system will try to use function named "function".
    /// For Node.js this is name of a function exported by the module specified
    /// in `source_location`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_point: std::string::String,

    /// The location of the function source code.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Source>,

    /// Output only. A permanent fixed identifier for source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_provenance: std::option::Option<crate::model::SourceProvenance>,

    /// Name of the Cloud Build Custom Worker Pool that should be used to build the
    /// function. The format of this field is
    /// `projects/{project}/locations/{region}/workerPools/{workerPool}` where
    /// {project} and {region} are the project id and region respectively where the
    /// worker pool is defined and {workerPool} is the short name of the worker
    /// pool.
    ///
    /// If the project id is not the same as the function, then the Cloud
    /// Functions Service Agent
    /// (service-<project_number>@gcf-admin-robot.iam.gserviceaccount.com) must be
    /// granted the role Cloud Build Custom Workers Builder
    /// (roles/cloudbuild.customworkers.builder) in the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool: std::string::String,

    /// User-provided build-time environment variables for the function
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub environment_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Docker Registry to use for this deployment. This configuration is only
    /// applicable to 1st Gen functions, 2nd Gen functions can only use Artifact
    /// Registry.
    /// Deprecated: As of March 2025, `CONTAINER_REGISTRY` option is no longer
    /// available in response to Container Registry's deprecation:
    /// <https://cloud.google.com/artifact-registry/docs/transition/transition-from-gcr>
    /// Please use Artifact Registry instead, which is the default choice.
    ///
    /// If unspecified, it defaults to `ARTIFACT_REGISTRY`.
    /// If `docker_repository` field is specified, this field should either be left
    /// unspecified or set to `ARTIFACT_REGISTRY`.
    #[deprecated]
    pub docker_registry: crate::model::build_config::DockerRegistry,

    /// Repository in Artifact Registry to which the function docker image will be
    /// pushed after it is built by Cloud Build. If specified by user, it is
    /// created and managed by user with a customer managed encryption key.
    /// Otherwise, GCF will create and use a repository named 'gcf-artifacts'
    /// for every deployed region.
    ///
    /// It must match the pattern
    /// `projects/{project}/locations/{location}/repositories/{repository}`.
    /// Repository format must be 'DOCKER'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub docker_repository: std::string::String,

    /// Service account to be used for building the container. The format of this
    /// field is `projects/{projectId}/serviceAccounts/{serviceAccountEmail}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// This controls when security patches are applied to the runtime environment.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_update_policy: std::option::Option<crate::model::build_config::RuntimeUpdatePolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::BuildConfig::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [runtime][crate::model::BuildConfig::runtime].
    pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime = v.into();
        self
    }

    /// Sets the value of [entry_point][crate::model::BuildConfig::entry_point].
    pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_point = v.into();
        self
    }

    /// Sets the value of [source][crate::model::BuildConfig::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [source_provenance][crate::model::BuildConfig::source_provenance].
    pub fn set_source_provenance<
        T: std::convert::Into<std::option::Option<crate::model::SourceProvenance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_provenance = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::BuildConfig::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [docker_registry][crate::model::BuildConfig::docker_registry].
    #[deprecated]
    pub fn set_docker_registry<
        T: std::convert::Into<crate::model::build_config::DockerRegistry>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.docker_registry = v.into();
        self
    }

    /// Sets the value of [docker_repository][crate::model::BuildConfig::docker_repository].
    pub fn set_docker_repository<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.docker_repository = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::BuildConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [environment_variables][crate::model::BuildConfig::environment_variables].
    pub fn set_environment_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.environment_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [runtime_update_policy][crate::model::BuildConfig::runtime_update_policy].
    ///
    /// Note that all the setters affecting `runtime_update_policy` are mutually
    /// exclusive.
    pub fn set_runtime_update_policy<
        T: std::convert::Into<std::option::Option<crate::model::build_config::RuntimeUpdatePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_update_policy = v.into();
        self
    }

    /// The value of [runtime_update_policy][crate::model::BuildConfig::runtime_update_policy]
    /// if it holds a `AutomaticUpdatePolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automatic_update_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticUpdatePolicy>> {
        #[allow(unreachable_patterns)]
        self.runtime_update_policy.as_ref().and_then(|v| match v {
            crate::model::build_config::RuntimeUpdatePolicy::AutomaticUpdatePolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [runtime_update_policy][crate::model::BuildConfig::runtime_update_policy]
    /// if it holds a `OnDeployUpdatePolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn on_deploy_update_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OnDeployUpdatePolicy>> {
        #[allow(unreachable_patterns)]
        self.runtime_update_policy.as_ref().and_then(|v| match v {
            crate::model::build_config::RuntimeUpdatePolicy::OnDeployUpdatePolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime_update_policy][crate::model::BuildConfig::runtime_update_policy]
    /// to hold a `AutomaticUpdatePolicy`.
    ///
    /// Note that all the setters affecting `runtime_update_policy` are
    /// mutually exclusive.
    pub fn set_automatic_update_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::AutomaticUpdatePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_update_policy = std::option::Option::Some(
            crate::model::build_config::RuntimeUpdatePolicy::AutomaticUpdatePolicy(v.into()),
        );
        self
    }

    /// Sets the value of [runtime_update_policy][crate::model::BuildConfig::runtime_update_policy]
    /// to hold a `OnDeployUpdatePolicy`.
    ///
    /// Note that all the setters affecting `runtime_update_policy` are
    /// mutually exclusive.
    pub fn set_on_deploy_update_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::OnDeployUpdatePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_update_policy = std::option::Option::Some(
            crate::model::build_config::RuntimeUpdatePolicy::OnDeployUpdatePolicy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BuildConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.BuildConfig"
    }
}

/// Defines additional types related to [BuildConfig].
pub mod build_config {
    #[allow(unused_imports)]
    use super::*;

    /// Docker Registry to use for storing function Docker images.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DockerRegistry {
        /// Unspecified.
        Unspecified,
        /// Docker images will be stored in multi-regional Container Registry
        /// repositories named `gcf`.
        ContainerRegistry,
        /// Docker images will be stored in regional Artifact Registry repositories.
        /// By default, GCF will create and use repositories named `gcf-artifacts`
        /// in every region in which a function is deployed. But the repository to
        /// use can also be specified by the user using the `docker_repository`
        /// field.
        ArtifactRegistry,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DockerRegistry::value] or
        /// [DockerRegistry::name].
        UnknownValue(docker_registry::UnknownValue),
    }

    #[doc(hidden)]
    pub mod docker_registry {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DockerRegistry {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ContainerRegistry => std::option::Option::Some(1),
                Self::ArtifactRegistry => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DOCKER_REGISTRY_UNSPECIFIED"),
                Self::ContainerRegistry => std::option::Option::Some("CONTAINER_REGISTRY"),
                Self::ArtifactRegistry => std::option::Option::Some("ARTIFACT_REGISTRY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DockerRegistry {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DockerRegistry {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DockerRegistry {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ContainerRegistry,
                2 => Self::ArtifactRegistry,
                _ => Self::UnknownValue(docker_registry::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DockerRegistry {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DOCKER_REGISTRY_UNSPECIFIED" => Self::Unspecified,
                "CONTAINER_REGISTRY" => Self::ContainerRegistry,
                "ARTIFACT_REGISTRY" => Self::ArtifactRegistry,
                _ => Self::UnknownValue(docker_registry::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DockerRegistry {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ContainerRegistry => serializer.serialize_i32(1),
                Self::ArtifactRegistry => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DockerRegistry {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DockerRegistry>::new(
                ".google.cloud.functions.v2.BuildConfig.DockerRegistry",
            ))
        }
    }

    /// This controls when security patches are applied to the runtime environment.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RuntimeUpdatePolicy {
        AutomaticUpdatePolicy(std::boxed::Box<crate::model::AutomaticUpdatePolicy>),
        OnDeployUpdatePolicy(std::boxed::Box<crate::model::OnDeployUpdatePolicy>),
    }
}

/// Describes the Service being deployed.
/// Currently Supported : Cloud Run (fully managed).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceConfig {
    /// Output only. Name of the service associated with a Function.
    /// The format of this field is
    /// `projects/{project}/locations/{region}/services/{service}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    /// The function execution timeout. Execution is considered failed and
    /// can be terminated if the function is not completed at the end of the
    /// timeout period. Defaults to 60 seconds.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub timeout_seconds: i32,

    /// The amount of memory available for a function.
    /// Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is
    /// supplied the value is interpreted as bytes.
    /// See
    /// <https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go>
    /// a full description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub available_memory: std::string::String,

    /// The number of CPUs used in a single container instance.
    /// Default value is calculated from available memory.
    /// Supports the same values as Cloud Run, see
    /// <https://cloud.google.com/run/docs/reference/rest/v1/Container#resourcerequirements>
    /// Example: "1" indicates 1 vCPU
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub available_cpu: std::string::String,

    /// Environment variables that shall be available during function execution.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub environment_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// The limit on the maximum number of function instances that may coexist at a
    /// given time.
    ///
    /// In some cases, such as rapid traffic surges, Cloud Functions may, for a
    /// short period of time, create more instances than the specified max
    /// instances limit. If your function cannot tolerate this temporary behavior,
    /// you may want to factor in a safety margin and set a lower max instances
    /// value than your function can tolerate.
    ///
    /// See the [Max
    /// Instances](https://cloud.google.com/functions/docs/max-instances) Guide for
    /// more details.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_instance_count: i32,

    /// The limit on the minimum number of function instances that may coexist at a
    /// given time.
    ///
    /// Function instances are kept in idle state for a short period after they
    /// finished executing the request to reduce cold start time for subsequent
    /// requests. Setting a minimum instance count will ensure that the given
    /// number of instances are kept running in idle state always. This can help
    /// with cold start times when jump in incoming request count occurs after the
    /// idle instance would have been stopped in the default case.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_instance_count: i32,

    /// The Serverless VPC Access connector that this cloud function can connect
    /// to. The format of this field is `projects/*/locations/*/connectors/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_connector: std::string::String,

    /// The egress settings for the connector, controlling what traffic is diverted
    /// through it.
    pub vpc_connector_egress_settings: crate::model::service_config::VpcConnectorEgressSettings,

    /// The ingress settings for the function, controlling what traffic can reach
    /// it.
    pub ingress_settings: crate::model::service_config::IngressSettings,

    /// Output only. URI of the Service deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The email of the service's service account. If empty, defaults to
    /// `{project_number}-compute@developer.gserviceaccount.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email: std::string::String,

    /// Whether 100% of traffic is routed to the latest revision.
    /// On CreateFunction and UpdateFunction, when set to true, the revision being
    /// deployed will serve 100% of traffic, ignoring any traffic split settings,
    /// if any. On GetFunction, true will be returned if the latest revision is
    /// serving 100% of traffic.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub all_traffic_on_latest_revision: bool,

    /// Secret environment variables configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secret_environment_variables: std::vec::Vec<crate::model::SecretEnvVar>,

    /// Secret volumes configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secret_volumes: std::vec::Vec<crate::model::SecretVolume>,

    /// Output only. The name of service revision.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,

    /// Sets the maximum number of concurrent requests that each instance
    /// can receive. Defaults to 1.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_instance_request_concurrency: i32,

    /// Security level configure whether the function only accepts https.
    /// This configuration is only applicable to 1st Gen functions with Http
    /// trigger. By default https is optional for 1st Gen functions; 2nd Gen
    /// functions are https ONLY.
    pub security_level: crate::model::service_config::SecurityLevel,

    /// Optional. The binary authorization policy to be checked when deploying the
    /// Cloud Run service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub binary_authorization_policy: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::ServiceConfig::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [timeout_seconds][crate::model::ServiceConfig::timeout_seconds].
    pub fn set_timeout_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.timeout_seconds = v.into();
        self
    }

    /// Sets the value of [available_memory][crate::model::ServiceConfig::available_memory].
    pub fn set_available_memory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.available_memory = v.into();
        self
    }

    /// Sets the value of [available_cpu][crate::model::ServiceConfig::available_cpu].
    pub fn set_available_cpu<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.available_cpu = v.into();
        self
    }

    /// Sets the value of [max_instance_count][crate::model::ServiceConfig::max_instance_count].
    pub fn set_max_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instance_count = v.into();
        self
    }

    /// Sets the value of [min_instance_count][crate::model::ServiceConfig::min_instance_count].
    pub fn set_min_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instance_count = v.into();
        self
    }

    /// Sets the value of [vpc_connector][crate::model::ServiceConfig::vpc_connector].
    pub fn set_vpc_connector<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_connector = v.into();
        self
    }

    /// Sets the value of [vpc_connector_egress_settings][crate::model::ServiceConfig::vpc_connector_egress_settings].
    pub fn set_vpc_connector_egress_settings<
        T: std::convert::Into<crate::model::service_config::VpcConnectorEgressSettings>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_connector_egress_settings = v.into();
        self
    }

    /// Sets the value of [ingress_settings][crate::model::ServiceConfig::ingress_settings].
    pub fn set_ingress_settings<
        T: std::convert::Into<crate::model::service_config::IngressSettings>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ingress_settings = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ServiceConfig::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::ServiceConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [all_traffic_on_latest_revision][crate::model::ServiceConfig::all_traffic_on_latest_revision].
    pub fn set_all_traffic_on_latest_revision<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.all_traffic_on_latest_revision = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::ServiceConfig::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [max_instance_request_concurrency][crate::model::ServiceConfig::max_instance_request_concurrency].
    pub fn set_max_instance_request_concurrency<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_instance_request_concurrency = v.into();
        self
    }

    /// Sets the value of [security_level][crate::model::ServiceConfig::security_level].
    pub fn set_security_level<
        T: std::convert::Into<crate::model::service_config::SecurityLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.security_level = v.into();
        self
    }

    /// Sets the value of [binary_authorization_policy][crate::model::ServiceConfig::binary_authorization_policy].
    pub fn set_binary_authorization_policy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.binary_authorization_policy = v.into();
        self
    }

    /// Sets the value of [secret_environment_variables][crate::model::ServiceConfig::secret_environment_variables].
    pub fn set_secret_environment_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretEnvVar>,
    {
        use std::iter::Iterator;
        self.secret_environment_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_volumes][crate::model::ServiceConfig::secret_volumes].
    pub fn set_secret_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretVolume>,
    {
        use std::iter::Iterator;
        self.secret_volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [environment_variables][crate::model::ServiceConfig::environment_variables].
    pub fn set_environment_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.environment_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ServiceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.ServiceConfig"
    }
}

/// Defines additional types related to [ServiceConfig].
pub mod service_config {
    #[allow(unused_imports)]
    use super::*;

    /// Available egress settings.
    ///
    /// This controls what traffic is diverted through the VPC Access Connector
    /// resource. By default PRIVATE_RANGES_ONLY will be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VpcConnectorEgressSettings {
        /// Unspecified.
        Unspecified,
        /// Use the VPC Access Connector only for private IP space from RFC1918.
        PrivateRangesOnly,
        /// Force the use of VPC Access Connector for all egress traffic from the
        /// function.
        AllTraffic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VpcConnectorEgressSettings::value] or
        /// [VpcConnectorEgressSettings::name].
        UnknownValue(vpc_connector_egress_settings::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vpc_connector_egress_settings {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VpcConnectorEgressSettings {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PrivateRangesOnly => std::option::Option::Some(1),
                Self::AllTraffic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED")
                }
                Self::PrivateRangesOnly => std::option::Option::Some("PRIVATE_RANGES_ONLY"),
                Self::AllTraffic => std::option::Option::Some("ALL_TRAFFIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VpcConnectorEgressSettings {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VpcConnectorEgressSettings {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VpcConnectorEgressSettings {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PrivateRangesOnly,
                2 => Self::AllTraffic,
                _ => Self::UnknownValue(vpc_connector_egress_settings::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VpcConnectorEgressSettings {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED" => Self::Unspecified,
                "PRIVATE_RANGES_ONLY" => Self::PrivateRangesOnly,
                "ALL_TRAFFIC" => Self::AllTraffic,
                _ => Self::UnknownValue(vpc_connector_egress_settings::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VpcConnectorEgressSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PrivateRangesOnly => serializer.serialize_i32(1),
                Self::AllTraffic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VpcConnectorEgressSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<VpcConnectorEgressSettings>::new(
                    ".google.cloud.functions.v2.ServiceConfig.VpcConnectorEgressSettings",
                ),
            )
        }
    }

    /// Available ingress settings.
    ///
    /// This controls what traffic can reach the function.
    ///
    /// If unspecified, ALLOW_ALL will be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IngressSettings {
        /// Unspecified.
        Unspecified,
        /// Allow HTTP traffic from public and private sources.
        AllowAll,
        /// Allow HTTP traffic from only private VPC sources.
        AllowInternalOnly,
        /// Allow HTTP traffic from private VPC sources and through GCLB.
        AllowInternalAndGclb,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IngressSettings::value] or
        /// [IngressSettings::name].
        UnknownValue(ingress_settings::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ingress_settings {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IngressSettings {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllowAll => std::option::Option::Some(1),
                Self::AllowInternalOnly => std::option::Option::Some(2),
                Self::AllowInternalAndGclb => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INGRESS_SETTINGS_UNSPECIFIED"),
                Self::AllowAll => std::option::Option::Some("ALLOW_ALL"),
                Self::AllowInternalOnly => std::option::Option::Some("ALLOW_INTERNAL_ONLY"),
                Self::AllowInternalAndGclb => std::option::Option::Some("ALLOW_INTERNAL_AND_GCLB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IngressSettings {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IngressSettings {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IngressSettings {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllowAll,
                2 => Self::AllowInternalOnly,
                3 => Self::AllowInternalAndGclb,
                _ => Self::UnknownValue(ingress_settings::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IngressSettings {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INGRESS_SETTINGS_UNSPECIFIED" => Self::Unspecified,
                "ALLOW_ALL" => Self::AllowAll,
                "ALLOW_INTERNAL_ONLY" => Self::AllowInternalOnly,
                "ALLOW_INTERNAL_AND_GCLB" => Self::AllowInternalAndGclb,
                _ => Self::UnknownValue(ingress_settings::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IngressSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllowAll => serializer.serialize_i32(1),
                Self::AllowInternalOnly => serializer.serialize_i32(2),
                Self::AllowInternalAndGclb => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IngressSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IngressSettings>::new(
                ".google.cloud.functions.v2.ServiceConfig.IngressSettings",
            ))
        }
    }

    /// Available security level settings.
    ///
    /// This enforces security protocol on function URL.
    ///
    /// Security level is only configurable for 1st Gen functions, If unspecified,
    /// SECURE_OPTIONAL will be used. 2nd Gen functions are SECURE_ALWAYS ONLY.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SecurityLevel {
        /// Unspecified.
        Unspecified,
        /// Requests for a URL that match this handler that do not use HTTPS are
        /// automatically redirected to the HTTPS URL with the same path. Query
        /// parameters are reserved for the redirect.
        SecureAlways,
        /// Both HTTP and HTTPS requests with URLs that match the handler succeed
        /// without redirects. The application can examine the request to determine
        /// which protocol was used and respond accordingly.
        SecureOptional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SecurityLevel::value] or
        /// [SecurityLevel::name].
        UnknownValue(security_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod security_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SecurityLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SecureAlways => std::option::Option::Some(1),
                Self::SecureOptional => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SECURITY_LEVEL_UNSPECIFIED"),
                Self::SecureAlways => std::option::Option::Some("SECURE_ALWAYS"),
                Self::SecureOptional => std::option::Option::Some("SECURE_OPTIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SecurityLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SecurityLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SecurityLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SecureAlways,
                2 => Self::SecureOptional,
                _ => Self::UnknownValue(security_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SecurityLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SECURITY_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "SECURE_ALWAYS" => Self::SecureAlways,
                "SECURE_OPTIONAL" => Self::SecureOptional,
                _ => Self::UnknownValue(security_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SecurityLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SecureAlways => serializer.serialize_i32(1),
                Self::SecureOptional => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SecurityLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecurityLevel>::new(
                ".google.cloud.functions.v2.ServiceConfig.SecurityLevel",
            ))
        }
    }
}

/// Configuration for a secret environment variable. It has the information
/// necessary to fetch the secret value from secret manager and expose it as an
/// environment variable.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretEnvVar {
    /// Name of the environment variable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Project identifier (preferably project number but can also be the
    /// project ID) of the project that contains the secret. If not set, it is
    /// assumed that the secret is in the same project as the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Name of the secret in secret manager (not the full resource name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret: std::string::String,

    /// Version of the secret (version number or the string 'latest'). It is
    /// recommended to use a numeric version for secret environment variables as
    /// any updates to the secret value is not reflected until new instances
    /// start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretEnvVar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::SecretEnvVar::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::SecretEnvVar::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::SecretEnvVar::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SecretEnvVar::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SecretEnvVar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.SecretEnvVar"
    }
}

/// Configuration for a secret volume. It has the information necessary to fetch
/// the secret value from secret manager and make it available as files mounted
/// at the requested paths within the application container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretVolume {
    /// The path within the container to mount the secret volume. For example,
    /// setting the mount_path as `/etc/secrets` would mount the secret value files
    /// under the `/etc/secrets` directory. This directory will also be completely
    /// shadowed and unavailable to mount any other secrets.
    /// Recommended mount path: /etc/secrets
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mount_path: std::string::String,

    /// Project identifier (preferably project number but can also be the project
    /// ID) of the project that contains the secret. If not set, it is
    /// assumed that the secret is in the same project as the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Name of the secret in secret manager (not the full resource name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret: std::string::String,

    /// List of secret versions to mount for this secret. If empty, the `latest`
    /// version of the secret will be made available in a file named after the
    /// secret under the mount point.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::secret_volume::SecretVersion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretVolume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mount_path][crate::model::SecretVolume::mount_path].
    pub fn set_mount_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mount_path = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::SecretVolume::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::SecretVolume::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::SecretVolume::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::secret_volume::SecretVersion>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SecretVolume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.SecretVolume"
    }
}

/// Defines additional types related to [SecretVolume].
pub mod secret_volume {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for a single version.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SecretVersion {
        /// Version of the secret (version number or the string 'latest'). It is
        /// preferable to use `latest` version with secret volumes as secret value
        /// changes are reflected immediately.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub version: std::string::String,

        /// Relative path of the file under the mount path where the secret value for
        /// this version will be fetched and made available. For example, setting the
        /// mount_path as '/etc/secrets' and path as `secret_foo` would mount the
        /// secret value file at `/etc/secrets/secret_foo`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SecretVersion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [version][crate::model::secret_volume::SecretVersion::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }

        /// Sets the value of [path][crate::model::secret_volume::SecretVersion::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }
    }

    impl wkt::message::Message for SecretVersion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.functions.v2.SecretVolume.SecretVersion"
        }
    }
}

/// Describes EventTrigger, used to request events to be sent from another
/// service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventTrigger {
    /// Output only. The resource name of the Eventarc trigger. The format of this
    /// field is `projects/{project}/locations/{region}/triggers/{trigger}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger: std::string::String,

    /// The region that the trigger will be in. The trigger will only receive
    /// events originating in this region. It can be the same
    /// region as the function, a different region or multi-region, or the global
    /// region. If not provided, defaults to the same region as the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_region: std::string::String,

    /// Required. The type of event to observe. For example:
    /// `google.cloud.audit.log.v1.written` or
    /// `google.cloud.pubsub.topic.v1.messagePublished`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub event_type: std::string::String,

    /// Criteria used to filter events.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub event_filters: std::vec::Vec<crate::model::EventFilter>,

    /// Optional. The name of a Pub/Sub topic in the same project that will be used
    /// as the transport topic for the event delivery. Format:
    /// `projects/{project}/topics/{topic}`.
    ///
    /// This is only valid for events of type
    /// `google.cloud.pubsub.topic.v1.messagePublished`. The topic provided here
    /// will not be deleted at function deletion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pubsub_topic: std::string::String,

    /// Optional. The email of the trigger's service account. The service account
    /// must have permission to invoke Cloud Run services, the permission is
    /// `run.routes.invoke`.
    /// If empty, defaults to the Compute Engine default service account:
    /// `{project_number}-compute@developer.gserviceaccount.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email: std::string::String,

    /// Optional. If unset, then defaults to ignoring failures (i.e. not retrying
    /// them).
    pub retry_policy: crate::model::event_trigger::RetryPolicy,

    /// Optional. The name of the channel associated with the trigger in
    /// `projects/{project}/locations/{location}/channels/{channel}` format.
    /// You must provide a channel to receive events from Eventarc SaaS partners.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub channel: std::string::String,

    /// Optional. The hostname of the service that 1st Gen function should be
    /// observed.
    ///
    /// If no string is provided, the default service implementing the API will
    /// be used. For example, `storage.googleapis.com` is the default for all
    /// event types in the `google.storage` namespace.
    ///
    /// The field is only applicable to 1st Gen functions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventTrigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trigger][crate::model::EventTrigger::trigger].
    pub fn set_trigger<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [trigger_region][crate::model::EventTrigger::trigger_region].
    pub fn set_trigger_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_region = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::EventTrigger::event_type].
    pub fn set_event_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [pubsub_topic][crate::model::EventTrigger::pubsub_topic].
    pub fn set_pubsub_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pubsub_topic = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::EventTrigger::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [retry_policy][crate::model::EventTrigger::retry_policy].
    pub fn set_retry_policy<T: std::convert::Into<crate::model::event_trigger::RetryPolicy>>(
        mut self,
        v: T,
    ) -> Self {
        self.retry_policy = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::EventTrigger::channel].
    pub fn set_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [service][crate::model::EventTrigger::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [event_filters][crate::model::EventTrigger::event_filters].
    pub fn set_event_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventFilter>,
    {
        use std::iter::Iterator;
        self.event_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EventTrigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.EventTrigger"
    }
}

/// Defines additional types related to [EventTrigger].
pub mod event_trigger {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the retry policy in case of function's execution failure.
    /// Retried execution is charged as any other execution.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RetryPolicy {
        /// Not specified.
        Unspecified,
        /// Do not retry.
        DoNotRetry,
        /// Retry on any failure, retry up to 7 days with an exponential backoff
        /// (capped at 10 seconds).
        Retry,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RetryPolicy::value] or
        /// [RetryPolicy::name].
        UnknownValue(retry_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod retry_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RetryPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DoNotRetry => std::option::Option::Some(1),
                Self::Retry => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RETRY_POLICY_UNSPECIFIED"),
                Self::DoNotRetry => std::option::Option::Some("RETRY_POLICY_DO_NOT_RETRY"),
                Self::Retry => std::option::Option::Some("RETRY_POLICY_RETRY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RetryPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RetryPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RetryPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DoNotRetry,
                2 => Self::Retry,
                _ => Self::UnknownValue(retry_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RetryPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RETRY_POLICY_UNSPECIFIED" => Self::Unspecified,
                "RETRY_POLICY_DO_NOT_RETRY" => Self::DoNotRetry,
                "RETRY_POLICY_RETRY" => Self::Retry,
                _ => Self::UnknownValue(retry_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RetryPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DoNotRetry => serializer.serialize_i32(1),
                Self::Retry => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RetryPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RetryPolicy>::new(
                ".google.cloud.functions.v2.EventTrigger.RetryPolicy",
            ))
        }
    }
}

/// Filters events based on exact matches on the CloudEvents attributes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventFilter {
    /// Required. The name of a CloudEvents attribute.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribute: std::string::String,

    /// Required. The value for the attribute.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// Optional. The operator used for matching the events with the value of the
    /// filter. If not specified, only events that have an exact key-value pair
    /// specified in the filter are matched. The only allowed value is
    /// `match-path-pattern`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operator: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::EventFilter::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }

    /// Sets the value of [value][crate::model::EventFilter::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [operator][crate::model::EventFilter::operator].
    pub fn set_operator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operator = v.into();
        self
    }
}

impl wkt::message::Message for EventFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.EventFilter"
    }
}

/// Request for the `GetFunction` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFunctionRequest {
    /// Required. The name of the function which details should be obtained.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The optional version of the 1st gen function whose details should
    /// be obtained. The version of a 1st gen function is an integer that starts
    /// from 1 and gets incremented on redeployments. GCF may keep historical
    /// configs for old versions of 1st gen function. This field can be specified
    /// to fetch the historical configs. This field is valid only for GCF 1st gen
    /// function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFunctionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFunctionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GetFunctionRequest::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }
}

impl wkt::message::Message for GetFunctionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.GetFunctionRequest"
    }
}

/// Request for the `ListFunctions` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFunctionsRequest {
    /// Required. The project and location from which the function should be
    /// listed, specified in the format `projects/*/locations/*` If you want to
    /// list functions in all locations, use "-" in place of a location. When
    /// listing functions in all locations, if one or more location(s) are
    /// unreachable, the response will contain functions from all reachable
    /// locations along with the names of any unreachable locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of functions to return per call. The largest allowed
    /// page_size is 1,000, if the page_size is omitted or specified as greater
    /// than 1,000 then it will be replaced as 1,000. The size of the list
    /// response can be less than specified when used with filters.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last
    /// `ListFunctionsResponse`; indicates that
    /// this is a continuation of a prior `ListFunctions` call, and that the
    /// system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The filter for Functions that match the filter expression,
    /// following the syntax outlined in <https://google.aip.dev/160>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The sorting order of the resources returned. Value should be a comma
    /// separated list of fields. The default sorting order is ascending.
    /// See <https://google.aip.dev/132#ordering>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFunctionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFunctionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFunctionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFunctionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFunctionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFunctionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFunctionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.ListFunctionsRequest"
    }
}

/// Response for the `ListFunctions` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFunctionsResponse {
    /// The functions that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub functions: std::vec::Vec<crate::model::Function>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached. The response does not include any
    /// functions from these locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFunctionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFunctionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [functions][crate::model::ListFunctionsResponse::functions].
    pub fn set_functions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Function>,
    {
        use std::iter::Iterator;
        self.functions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListFunctionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFunctionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.ListFunctionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFunctionsResponse {
    type PageItem = crate::model::Function;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.functions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `CreateFunction` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFunctionRequest {
    /// Required. The project and location in which the function should be created,
    /// specified in the format `projects/*/locations/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Function to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub function: std::option::Option<crate::model::Function>,

    /// The ID to use for the function, which will become the final component of
    /// the function's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub function_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFunctionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFunctionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [function][crate::model::CreateFunctionRequest::function].
    pub fn set_function<T: std::convert::Into<std::option::Option<crate::model::Function>>>(
        mut self,
        v: T,
    ) -> Self {
        self.function = v.into();
        self
    }

    /// Sets the value of [function_id][crate::model::CreateFunctionRequest::function_id].
    pub fn set_function_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateFunctionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.CreateFunctionRequest"
    }
}

/// Request for the `UpdateFunction` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFunctionRequest {
    /// Required. New version of the function.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub function: std::option::Option<crate::model::Function>,

    /// The list of fields to be updated.
    /// If no field mask is provided, all fields will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFunctionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [function][crate::model::UpdateFunctionRequest::function].
    pub fn set_function<T: std::convert::Into<std::option::Option<crate::model::Function>>>(
        mut self,
        v: T,
    ) -> Self {
        self.function = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFunctionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFunctionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.UpdateFunctionRequest"
    }
}

/// Request for the `DeleteFunction` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFunctionRequest {
    /// Required. The name of the function which should be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFunctionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFunctionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFunctionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.DeleteFunctionRequest"
    }
}

/// Request of `GenerateSourceUploadUrl` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateUploadUrlRequest {
    /// Required. The project and location in which the Google Cloud Storage signed
    /// URL should be generated, specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Resource name of a KMS crypto key (managed by the user) used to
    /// encrypt/decrypt function source code objects in intermediate Cloud Storage
    /// buckets. When you generate an upload url and upload your source code, it
    /// gets copied to an intermediate Cloud Storage bucket. The source code is
    /// then copied to a versioned directory in the sources bucket in the consumer
    /// project during the function deployment.
    ///
    /// It must match the pattern
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    ///
    /// The Google Cloud Functions service account
    /// (service-{project_number}@gcf-admin-robot.iam.gserviceaccount.com) must be
    /// granted the role 'Cloud KMS CryptoKey Encrypter/Decrypter
    /// (roles/cloudkms.cryptoKeyEncrypterDecrypter)' on the
    /// Key/KeyRing/Project/Organization (least access preferred).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// The function environment the generated upload url will be used for.
    /// The upload url for 2nd Gen functions can also be used for 1st gen
    /// functions, but not vice versa. If not specified, 2nd generation-style
    /// upload URLs are generated.
    pub environment: crate::model::Environment,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateUploadUrlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GenerateUploadUrlRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::GenerateUploadUrlRequest::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::GenerateUploadUrlRequest::environment].
    pub fn set_environment<T: std::convert::Into<crate::model::Environment>>(
        mut self,
        v: T,
    ) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for GenerateUploadUrlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.GenerateUploadUrlRequest"
    }
}

/// Response of `GenerateSourceUploadUrl` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateUploadUrlResponse {
    /// The generated Google Cloud Storage signed URL that should be used for a
    /// function source code upload. The uploaded file should be a zip archive
    /// which contains a function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upload_url: std::string::String,

    /// The location of the source code in the upload bucket.
    ///
    /// Once the archive is uploaded using the `upload_url` use this field to
    /// set the `function.build_config.source.storage_source`
    /// during CreateFunction and UpdateFunction.
    ///
    /// Generation defaults to 0, as Cloud Storage provides a new generation only
    /// upon uploading a new object or version of an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_source: std::option::Option<crate::model::StorageSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateUploadUrlResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upload_url][crate::model::GenerateUploadUrlResponse::upload_url].
    pub fn set_upload_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upload_url = v.into();
        self
    }

    /// Sets the value of [storage_source][crate::model::GenerateUploadUrlResponse::storage_source].
    pub fn set_storage_source<
        T: std::convert::Into<std::option::Option<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_source = v.into();
        self
    }
}

impl wkt::message::Message for GenerateUploadUrlResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.GenerateUploadUrlResponse"
    }
}

/// Request of `GenerateDownloadUrl` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateDownloadUrlRequest {
    /// Required. The name of function for which source code Google Cloud Storage
    /// signed URL should be generated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateDownloadUrlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateDownloadUrlRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GenerateDownloadUrlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.GenerateDownloadUrlRequest"
    }
}

/// Response of `GenerateDownloadUrl` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateDownloadUrlResponse {
    /// The generated Google Cloud Storage signed URL that should be used for
    /// function source code download.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub download_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateDownloadUrlResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [download_url][crate::model::GenerateDownloadUrlResponse::download_url].
    pub fn set_download_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.download_url = v.into();
        self
    }
}

impl wkt::message::Message for GenerateDownloadUrlResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.GenerateDownloadUrlResponse"
    }
}

/// Request for the `ListRuntimes` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRuntimesRequest {
    /// Required. The project and location from which the runtimes should be
    /// listed, specified in the format `projects/*/locations/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter for Runtimes that match the filter expression,
    /// following the syntax outlined in <https://google.aip.dev/160>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRuntimesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRuntimesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRuntimesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.ListRuntimesRequest"
    }
}

/// Response for the `ListRuntimes` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRuntimesResponse {
    /// The runtimes that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub runtimes: std::vec::Vec<crate::model::list_runtimes_response::Runtime>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRuntimesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtimes][crate::model::ListRuntimesResponse::runtimes].
    pub fn set_runtimes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::list_runtimes_response::Runtime>,
    {
        use std::iter::Iterator;
        self.runtimes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRuntimesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.ListRuntimesResponse"
    }
}

/// Defines additional types related to [ListRuntimesResponse].
pub mod list_runtimes_response {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a runtime and any special information (e.g., deprecation status)
    /// related to it.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Runtime {
        /// The name of the runtime, e.g., 'go113', 'nodejs12', etc.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The user facing name, eg 'Go 1.13', 'Node.js 12', etc.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// The stage of life this runtime is in, e.g., BETA, GA, etc.
        pub stage: crate::model::list_runtimes_response::RuntimeStage,

        /// Warning messages, e.g., a deprecation warning.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub warnings: std::vec::Vec<std::string::String>,

        /// The environment for the runtime.
        pub environment: crate::model::Environment,

        /// Deprecation date for the runtime.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub deprecation_date: std::option::Option<gtype::model::Date>,

        /// Decommission date for the runtime.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub decommission_date: std::option::Option<gtype::model::Date>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Runtime {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::list_runtimes_response::Runtime::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::list_runtimes_response::Runtime::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [stage][crate::model::list_runtimes_response::Runtime::stage].
        pub fn set_stage<
            T: std::convert::Into<crate::model::list_runtimes_response::RuntimeStage>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.stage = v.into();
            self
        }

        /// Sets the value of [environment][crate::model::list_runtimes_response::Runtime::environment].
        pub fn set_environment<T: std::convert::Into<crate::model::Environment>>(
            mut self,
            v: T,
        ) -> Self {
            self.environment = v.into();
            self
        }

        /// Sets the value of [deprecation_date][crate::model::list_runtimes_response::Runtime::deprecation_date].
        pub fn set_deprecation_date<
            T: std::convert::Into<std::option::Option<gtype::model::Date>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.deprecation_date = v.into();
            self
        }

        /// Sets the value of [decommission_date][crate::model::list_runtimes_response::Runtime::decommission_date].
        pub fn set_decommission_date<
            T: std::convert::Into<std::option::Option<gtype::model::Date>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.decommission_date = v.into();
            self
        }

        /// Sets the value of [warnings][crate::model::list_runtimes_response::Runtime::warnings].
        pub fn set_warnings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.warnings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Runtime {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.functions.v2.ListRuntimesResponse.Runtime"
        }
    }

    /// The various stages that a runtime can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RuntimeStage {
        /// Not specified.
        Unspecified,
        /// The runtime is in development.
        Development,
        /// The runtime is in the Alpha stage.
        Alpha,
        /// The runtime is in the Beta stage.
        Beta,
        /// The runtime is generally available.
        Ga,
        /// The runtime is deprecated.
        Deprecated,
        /// The runtime is no longer supported.
        Decommissioned,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RuntimeStage::value] or
        /// [RuntimeStage::name].
        UnknownValue(runtime_stage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod runtime_stage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RuntimeStage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Development => std::option::Option::Some(1),
                Self::Alpha => std::option::Option::Some(2),
                Self::Beta => std::option::Option::Some(3),
                Self::Ga => std::option::Option::Some(4),
                Self::Deprecated => std::option::Option::Some(5),
                Self::Decommissioned => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RUNTIME_STAGE_UNSPECIFIED"),
                Self::Development => std::option::Option::Some("DEVELOPMENT"),
                Self::Alpha => std::option::Option::Some("ALPHA"),
                Self::Beta => std::option::Option::Some("BETA"),
                Self::Ga => std::option::Option::Some("GA"),
                Self::Deprecated => std::option::Option::Some("DEPRECATED"),
                Self::Decommissioned => std::option::Option::Some("DECOMMISSIONED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RuntimeStage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RuntimeStage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RuntimeStage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Development,
                2 => Self::Alpha,
                3 => Self::Beta,
                4 => Self::Ga,
                5 => Self::Deprecated,
                6 => Self::Decommissioned,
                _ => Self::UnknownValue(runtime_stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RuntimeStage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RUNTIME_STAGE_UNSPECIFIED" => Self::Unspecified,
                "DEVELOPMENT" => Self::Development,
                "ALPHA" => Self::Alpha,
                "BETA" => Self::Beta,
                "GA" => Self::Ga,
                "DEPRECATED" => Self::Deprecated,
                "DECOMMISSIONED" => Self::Decommissioned,
                _ => Self::UnknownValue(runtime_stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RuntimeStage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Development => serializer.serialize_i32(1),
                Self::Alpha => serializer.serialize_i32(2),
                Self::Beta => serializer.serialize_i32(3),
                Self::Ga => serializer.serialize_i32(4),
                Self::Deprecated => serializer.serialize_i32(5),
                Self::Decommissioned => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RuntimeStage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RuntimeStage>::new(
                ".google.cloud.functions.v2.ListRuntimesResponse.RuntimeStage",
            ))
        }
    }
}

/// Security patches are applied automatically to the runtime without requiring
/// the function to be redeployed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomaticUpdatePolicy {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomaticUpdatePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AutomaticUpdatePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.AutomaticUpdatePolicy"
    }
}

/// Security patches are only applied when a function is redeployed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OnDeployUpdatePolicy {
    /// Output only. contains the runtime version which was used during latest
    /// function deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OnDeployUpdatePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_version][crate::model::OnDeployUpdatePolicy::runtime_version].
    pub fn set_runtime_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_version = v.into();
        self
    }
}

impl wkt::message::Message for OnDeployUpdatePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.OnDeployUpdatePolicy"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_detail: std::string::String,

    /// Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub cancel_requested: bool,

    /// API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// The original request that started the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_resource: std::option::Option<wkt::Any>,

    /// Mechanism for reporting in-progress stages
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stages: std::vec::Vec<crate::model::Stage>,

    /// An identifier for Firebase function sources. Disclaimer: This field is only
    /// supported for Firebase function deployments.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_token: std::string::String,

    /// The build name of the function for create and update operations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub build_name: std::string::String,

    /// The operation type.
    pub operation_type: crate::model::OperationType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::OperationMetadata::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [cancel_requested][crate::model::OperationMetadata::cancel_requested].
    pub fn set_cancel_requested<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancel_requested = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [request_resource][crate::model::OperationMetadata::request_resource].
    pub fn set_request_resource<T: std::convert::Into<std::option::Option<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_resource = v.into();
        self
    }

    /// Sets the value of [source_token][crate::model::OperationMetadata::source_token].
    pub fn set_source_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_token = v.into();
        self
    }

    /// Sets the value of [build_name][crate::model::OperationMetadata::build_name].
    pub fn set_build_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_name = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::OperationMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::OperationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [stages][crate::model::OperationMetadata::stages].
    pub fn set_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Stage>,
    {
        use std::iter::Iterator;
        self.stages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.OperationMetadata"
    }
}

/// Extra GCF specific location information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// The Cloud Function environments this location supports.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub environments: std::vec::Vec<crate::model::Environment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environments][crate::model::LocationMetadata::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.LocationMetadata"
    }
}

/// Each Stage of the deployment process
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Stage {
    /// Name of the Stage. This will be unique for each Stage.
    pub name: crate::model::stage::Name,

    /// Message describing the Stage
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Current state of the Stage
    pub state: crate::model::stage::State,

    /// Resource of the Stage
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// Link to the current Stage resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uri: std::string::String,

    /// State messages from the current Stage.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub state_messages: std::vec::Vec<crate::model::StateMessage>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Stage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Stage::name].
    pub fn set_name<T: std::convert::Into<crate::model::stage::Name>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Stage::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Stage::state].
    pub fn set_state<T: std::convert::Into<crate::model::stage::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::Stage::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::Stage::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [state_messages][crate::model::Stage::state_messages].
    pub fn set_state_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StateMessage>,
    {
        use std::iter::Iterator;
        self.state_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Stage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.functions.v2.Stage"
    }
}

/// Defines additional types related to [Stage].
pub mod stage {
    #[allow(unused_imports)]
    use super::*;

    /// Possible names for a Stage
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Name {
        /// Not specified. Invalid name.
        Unspecified,
        /// Artifact Registry Stage
        ArtifactRegistry,
        /// Build Stage
        Build,
        /// Service Stage
        Service,
        /// Trigger Stage
        Trigger,
        /// Service Rollback Stage
        ServiceRollback,
        /// Trigger Rollback Stage
        TriggerRollback,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Name::value] or
        /// [Name::name].
        UnknownValue(name::UnknownValue),
    }

    #[doc(hidden)]
    pub mod name {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Name {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ArtifactRegistry => std::option::Option::Some(1),
                Self::Build => std::option::Option::Some(2),
                Self::Service => std::option::Option::Some(3),
                Self::Trigger => std::option::Option::Some(4),
                Self::ServiceRollback => std::option::Option::Some(5),
                Self::TriggerRollback => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NAME_UNSPECIFIED"),
                Self::ArtifactRegistry => std::option::Option::Some("ARTIFACT_REGISTRY"),
                Self::Build => std::option::Option::Some("BUILD"),
                Self::Service => std::option::Option::Some("SERVICE"),
                Self::Trigger => std::option::Option::Some("TRIGGER"),
                Self::ServiceRollback => std::option::Option::Some("SERVICE_ROLLBACK"),
                Self::TriggerRollback => std::option::Option::Some("TRIGGER_ROLLBACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Name {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Name {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Name {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ArtifactRegistry,
                2 => Self::Build,
                3 => Self::Service,
                4 => Self::Trigger,
                5 => Self::ServiceRollback,
                6 => Self::TriggerRollback,
                _ => Self::UnknownValue(name::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Name {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NAME_UNSPECIFIED" => Self::Unspecified,
                "ARTIFACT_REGISTRY" => Self::ArtifactRegistry,
                "BUILD" => Self::Build,
                "SERVICE" => Self::Service,
                "TRIGGER" => Self::Trigger,
                "SERVICE_ROLLBACK" => Self::ServiceRollback,
                "TRIGGER_ROLLBACK" => Self::TriggerRollback,
                _ => Self::UnknownValue(name::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Name {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ArtifactRegistry => serializer.serialize_i32(1),
                Self::Build => serializer.serialize_i32(2),
                Self::Service => serializer.serialize_i32(3),
                Self::Trigger => serializer.serialize_i32(4),
                Self::ServiceRollback => serializer.serialize_i32(5),
                Self::TriggerRollback => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Name {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Name>::new(
                ".google.cloud.functions.v2.Stage.Name",
            ))
        }
    }

    /// Possible states for a Stage
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified. Invalid state.
        Unspecified,
        /// Stage has not started.
        NotStarted,
        /// Stage is in progress.
        InProgress,
        /// Stage has completed.
        Complete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotStarted => std::option::Option::Some(1),
                Self::InProgress => std::option::Option::Some(2),
                Self::Complete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotStarted,
                2 => Self::InProgress,
                3 => Self::Complete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_STARTED" => Self::NotStarted,
                "IN_PROGRESS" => Self::InProgress,
                "COMPLETE" => Self::Complete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotStarted => serializer.serialize_i32(1),
                Self::InProgress => serializer.serialize_i32(2),
                Self::Complete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.functions.v2.Stage.State",
            ))
        }
    }
}

/// The type of the long running operation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationType {
    /// Unspecified
    OperationtypeUnspecified,
    /// CreateFunction
    CreateFunction,
    /// UpdateFunction
    UpdateFunction,
    /// DeleteFunction
    DeleteFunction,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationType::value] or
    /// [OperationType::name].
    UnknownValue(operation_type::UnknownValue),
}

#[doc(hidden)]
pub mod operation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::OperationtypeUnspecified => std::option::Option::Some(0),
            Self::CreateFunction => std::option::Option::Some(1),
            Self::UpdateFunction => std::option::Option::Some(2),
            Self::DeleteFunction => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::OperationtypeUnspecified => {
                std::option::Option::Some("OPERATIONTYPE_UNSPECIFIED")
            }
            Self::CreateFunction => std::option::Option::Some("CREATE_FUNCTION"),
            Self::UpdateFunction => std::option::Option::Some("UPDATE_FUNCTION"),
            Self::DeleteFunction => std::option::Option::Some("DELETE_FUNCTION"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::OperationtypeUnspecified,
            1 => Self::CreateFunction,
            2 => Self::UpdateFunction,
            3 => Self::DeleteFunction,
            _ => Self::UnknownValue(operation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATIONTYPE_UNSPECIFIED" => Self::OperationtypeUnspecified,
            "CREATE_FUNCTION" => Self::CreateFunction,
            "UPDATE_FUNCTION" => Self::UpdateFunction,
            "DELETE_FUNCTION" => Self::DeleteFunction,
            _ => Self::UnknownValue(operation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::OperationtypeUnspecified => serializer.serialize_i32(0),
            Self::CreateFunction => serializer.serialize_i32(1),
            Self::UpdateFunction => serializer.serialize_i32(2),
            Self::DeleteFunction => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationType>::new(
            ".google.cloud.functions.v2.OperationType",
        ))
    }
}

/// The environment the function is hosted on.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Environment {
    /// Unspecified
    Unspecified,
    /// Gen 1
    Gen1,
    /// Gen 2
    Gen2,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Environment::value] or
    /// [Environment::name].
    UnknownValue(environment::UnknownValue),
}

#[doc(hidden)]
pub mod environment {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Environment {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Gen1 => std::option::Option::Some(1),
            Self::Gen2 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENVIRONMENT_UNSPECIFIED"),
            Self::Gen1 => std::option::Option::Some("GEN_1"),
            Self::Gen2 => std::option::Option::Some("GEN_2"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Environment {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Environment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Environment {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Gen1,
            2 => Self::Gen2,
            _ => Self::UnknownValue(environment::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Environment {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENVIRONMENT_UNSPECIFIED" => Self::Unspecified,
            "GEN_1" => Self::Gen1,
            "GEN_2" => Self::Gen2,
            _ => Self::UnknownValue(environment::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Environment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Gen1 => serializer.serialize_i32(1),
            Self::Gen2 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Environment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Environment>::new(
            ".google.cloud.functions.v2.Environment",
        ))
    }
}
