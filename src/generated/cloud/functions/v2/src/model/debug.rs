// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::Function {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Function");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("build_config", &self.build_config);
        debug_struct.field("service_config", &self.service_config);
        debug_struct.field("event_trigger", &self.event_trigger);
        debug_struct.field("state", &self.state);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("state_messages", &self.state_messages);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("url", &self.url);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StateMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StateMessage");
        debug_struct.field("severity", &self.severity);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StorageSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageSource");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("source_upload_url", &self.source_upload_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RepoSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepoSource");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("repo_name", &self.repo_name);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("invert_regex", &self.invert_regex);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SourceProvenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceProvenance");
        debug_struct.field("resolved_storage_source", &self.resolved_storage_source);
        debug_struct.field("resolved_repo_source", &self.resolved_repo_source);
        debug_struct.field("git_uri", &self.git_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildConfig");
        debug_struct.field("build", &self.build);
        debug_struct.field("runtime", &self.runtime);
        debug_struct.field("entry_point", &self.entry_point);
        debug_struct.field("source", &self.source);
        debug_struct.field("source_provenance", &self.source_provenance);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("environment_variables", &self.environment_variables);
        debug_struct.field("docker_registry", &self.docker_registry);
        debug_struct.field("docker_repository", &self.docker_repository);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("runtime_update_policy", &self.runtime_update_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServiceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceConfig");
        debug_struct.field("service", &self.service);
        debug_struct.field("timeout_seconds", &self.timeout_seconds);
        debug_struct.field("available_memory", &self.available_memory);
        debug_struct.field("available_cpu", &self.available_cpu);
        debug_struct.field("environment_variables", &self.environment_variables);
        debug_struct.field("max_instance_count", &self.max_instance_count);
        debug_struct.field("min_instance_count", &self.min_instance_count);
        debug_struct.field("vpc_connector", &self.vpc_connector);
        debug_struct.field(
            "vpc_connector_egress_settings",
            &self.vpc_connector_egress_settings,
        );
        debug_struct.field("ingress_settings", &self.ingress_settings);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("service_account_email", &self.service_account_email);
        debug_struct.field(
            "all_traffic_on_latest_revision",
            &self.all_traffic_on_latest_revision,
        );
        debug_struct.field(
            "secret_environment_variables",
            &self.secret_environment_variables,
        );
        debug_struct.field("secret_volumes", &self.secret_volumes);
        debug_struct.field("revision", &self.revision);
        debug_struct.field(
            "max_instance_request_concurrency",
            &self.max_instance_request_concurrency,
        );
        debug_struct.field("security_level", &self.security_level);
        debug_struct.field(
            "binary_authorization_policy",
            &self.binary_authorization_policy,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretEnvVar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretEnvVar");
        debug_struct.field("key", &self.key);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("secret", &self.secret);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretVolume");
        debug_struct.field("mount_path", &self.mount_path);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("secret", &self.secret);
        debug_struct.field("versions", &self.versions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::secret_volume::SecretVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretVersion");
        debug_struct.field("version", &self.version);
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EventTrigger {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EventTrigger");
        debug_struct.field("trigger", &self.trigger);
        debug_struct.field("trigger_region", &self.trigger_region);
        debug_struct.field("event_type", &self.event_type);
        debug_struct.field("event_filters", &self.event_filters);
        debug_struct.field("pubsub_topic", &self.pubsub_topic);
        debug_struct.field("service_account_email", &self.service_account_email);
        debug_struct.field("retry_policy", &self.retry_policy);
        debug_struct.field("channel", &self.channel);
        debug_struct.field("service", &self.service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EventFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EventFilter");
        debug_struct.field("attribute", &self.attribute);
        debug_struct.field("value", &self.value);
        debug_struct.field("operator", &self.operator);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetFunctionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFunctionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListFunctionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFunctionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListFunctionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFunctionsResponse");
        debug_struct.field("functions", &self.functions);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateFunctionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateFunctionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("function", &self.function);
        debug_struct.field("function_id", &self.function_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateFunctionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateFunctionRequest");
        debug_struct.field("function", &self.function);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteFunctionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteFunctionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateUploadUrlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateUploadUrlRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateUploadUrlResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateUploadUrlResponse");
        debug_struct.field("upload_url", &self.upload_url);
        debug_struct.field("storage_source", &self.storage_source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateDownloadUrlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateDownloadUrlRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateDownloadUrlResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateDownloadUrlResponse");
        debug_struct.field("download_url", &self.download_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRuntimesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRuntimesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRuntimesResponse");
        debug_struct.field("runtimes", &self.runtimes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::list_runtimes_response::Runtime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Runtime");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("stage", &self.stage);
        debug_struct.field("warnings", &self.warnings);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("deprecation_date", &self.deprecation_date);
        debug_struct.field("decommission_date", &self.decommission_date);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutomaticUpdatePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomaticUpdatePolicy");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OnDeployUpdatePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OnDeployUpdatePolicy");
        debug_struct.field("runtime_version", &self.runtime_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_detail", &self.status_detail);
        debug_struct.field("cancel_requested", &self.cancel_requested);
        debug_struct.field("api_version", &self.api_version);
        debug_struct.field("request_resource", &self.request_resource);
        debug_struct.field("stages", &self.stages);
        debug_struct.field("source_token", &self.source_token);
        debug_struct.field("build_name", &self.build_name);
        debug_struct.field("operation_type", &self.operation_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LocationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationMetadata");
        debug_struct.field("environments", &self.environments);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Stage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Stage");
        debug_struct.field("name", &self.name);
        debug_struct.field("message", &self.message);
        debug_struct.field("state", &self.state);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("state_messages", &self.state_messages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
