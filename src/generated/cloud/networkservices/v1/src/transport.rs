// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [DepService](super::stub::DepService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct DepService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for DepService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DepService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl DepService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::DepService for DepService {
    async fn list_lb_traffic_extensions(
        &self,
        req: crate::model::ListLbTrafficExtensionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListLbTrafficExtensionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/lbTrafficExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("orderBy", &req.order_by)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_lb_traffic_extension(
        &self,
        req: crate::model::GetLbTrafficExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LbTrafficExtension>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbTrafficExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbTrafficExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/lbTrafficExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_lb_traffic_extension(
        &self,
        req: crate::model::CreateLbTrafficExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/lbTrafficExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("lbTrafficExtensionId", &req.lb_traffic_extension_id)]);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.lb_traffic_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_lb_traffic_extension(
        &self,
        req: crate::model::UpdateLbTrafficExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.lb_traffic_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbTrafficExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                let builder = builder.query(&[("requestId", &req.request_id)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.lb_traffic_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbTrafficExtensions/"), Segment::SingleWildcard],
                    "lb_traffic_extension.name",
                    "projects/*/locations/*/lbTrafficExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.lb_traffic_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_lb_traffic_extension(
        &self,
        req: crate::model::DeleteLbTrafficExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbTrafficExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbTrafficExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/lbTrafficExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_lb_route_extensions(
        &self,
        req: crate::model::ListLbRouteExtensionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListLbRouteExtensionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/lbRouteExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("orderBy", &req.order_by)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_lb_route_extension(
        &self,
        req: crate::model::GetLbRouteExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LbRouteExtension>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbRouteExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbRouteExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/lbRouteExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_lb_route_extension(
        &self,
        req: crate::model::CreateLbRouteExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/lbRouteExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("lbRouteExtensionId", &req.lb_route_extension_id)]);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.lb_route_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_lb_route_extension(
        &self,
        req: crate::model::UpdateLbRouteExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.lb_route_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbRouteExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                let builder = builder.query(&[("requestId", &req.request_id)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.lb_route_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbRouteExtensions/"), Segment::SingleWildcard],
                    "lb_route_extension.name",
                    "projects/*/locations/*/lbRouteExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.lb_route_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_lb_route_extension(
        &self,
        req: crate::model::DeleteLbRouteExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbRouteExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbRouteExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/lbRouteExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_lb_edge_extensions(
        &self,
        req: crate::model::ListLbEdgeExtensionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListLbEdgeExtensionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/lbEdgeExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("orderBy", &req.order_by)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_lb_edge_extension(
        &self,
        req: crate::model::GetLbEdgeExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LbEdgeExtension>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbEdgeExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbEdgeExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/lbEdgeExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_lb_edge_extension(
        &self,
        req: crate::model::CreateLbEdgeExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/lbEdgeExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("lbEdgeExtensionId", &req.lb_edge_extension_id)]);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.lb_edge_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_lb_edge_extension(
        &self,
        req: crate::model::UpdateLbEdgeExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.lb_edge_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbEdgeExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                let builder = builder.query(&[("requestId", &req.request_id)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.lb_edge_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbEdgeExtensions/"), Segment::SingleWildcard],
                    "lb_edge_extension.name",
                    "projects/*/locations/*/lbEdgeExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.lb_edge_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_lb_edge_extension(
        &self,
        req: crate::model::DeleteLbEdgeExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbEdgeExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/lbEdgeExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/lbEdgeExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_authz_extensions(
        &self,
        req: crate::model::ListAuthzExtensionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAuthzExtensionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/authzExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("orderBy", &req.order_by)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_authz_extension(
        &self,
        req: crate::model::GetAuthzExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AuthzExtension>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/authzExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/authzExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/authzExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_authz_extension(
        &self,
        req: crate::model::CreateAuthzExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/authzExtensions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("authzExtensionId", &req.authz_extension_id)]);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.authz_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_authz_extension(
        &self,
        req: crate::model::UpdateAuthzExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.authz_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/authzExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                let builder = builder.query(&[("requestId", &req.request_id)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.authz_extension.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/authzExtensions/"), Segment::SingleWildcard],
                    "authz_extension.name",
                    "projects/*/locations/*/authzExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.authz_extension, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_authz_extension(
        &self,
        req: crate::model::DeleteAuthzExtensionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/authzExtensions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("requestId", &req.request_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/authzExtensions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/authzExtensions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/locations",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard],
                    "name",
                    "projects/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheKeysets/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheOrigins/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheServices/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheKeysets/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheOrigins/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheServices/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheKeysets/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheOrigins/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheServices/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/operations",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/operations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/operations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:cancel",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/operations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NetworkServices](super::stub::NetworkServices) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct NetworkServices {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for NetworkServices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NetworkServices")
            .field("inner", &self.inner)
            .finish()
    }
}

impl NetworkServices {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::NetworkServices for NetworkServices {
    async fn list_endpoint_policies(
        &self,
        req: crate::model::ListEndpointPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEndpointPoliciesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/endpointPolicies",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_endpoint_policy(
        &self,
        req: crate::model::GetEndpointPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EndpointPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_endpoint_policy(
        &self,
        req: crate::model::CreateEndpointPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/endpointPolicies",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("endpointPolicyId", &req.endpoint_policy_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.endpoint_policy, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_endpoint_policy(
        &self,
        req: crate::model::UpdateEndpointPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.endpoint_policy.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.endpoint_policy.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "endpoint_policy.name",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.endpoint_policy, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_endpoint_policy(
        &self,
        req: crate::model::DeleteEndpointPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_wasm_plugin_versions(
        &self,
        req: crate::model::ListWasmPluginVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListWasmPluginVersionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/versions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*/wasmPlugins/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_wasm_plugin_version(
        &self,
        req: crate::model::GetWasmPluginVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WasmPluginVersion>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard, Segment::Literal("/versions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard, Segment::Literal("/versions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/wasmPlugins/*/versions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_wasm_plugin_version(
        &self,
        req: crate::model::CreateWasmPluginVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/versions",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("wasmPluginVersionId", &req.wasm_plugin_version_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*/wasmPlugins/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.wasm_plugin_version, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_wasm_plugin_version(
        &self,
        req: crate::model::DeleteWasmPluginVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard, Segment::Literal("/versions/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard, Segment::Literal("/versions/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/wasmPlugins/*/versions/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_wasm_plugins(
        &self,
        req: crate::model::ListWasmPluginsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListWasmPluginsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/wasmPlugins",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_wasm_plugin(
        &self,
        req: crate::model::GetWasmPluginRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WasmPlugin>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("view", &req.view)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/wasmPlugins/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_wasm_plugin(
        &self,
        req: crate::model::CreateWasmPluginRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/wasmPlugins",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("wasmPluginId", &req.wasm_plugin_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.wasm_plugin, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_wasm_plugin(
        &self,
        req: crate::model::UpdateWasmPluginRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.wasm_plugin.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.wasm_plugin.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard],
                    "wasm_plugin.name",
                    "projects/*/locations/*/wasmPlugins/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.wasm_plugin, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_wasm_plugin(
        &self,
        req: crate::model::DeleteWasmPluginRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/wasmPlugins/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/wasmPlugins/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_gateways(
        &self,
        req: crate::model::ListGatewaysRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGatewaysResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/gateways",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_gateway(
        &self,
        req: crate::model::GetGatewayRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Gateway>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_gateway(
        &self,
        req: crate::model::CreateGatewayRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/gateways",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("gatewayId", &req.gateway_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.gateway, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_gateway(
        &self,
        req: crate::model::UpdateGatewayRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.gateway.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.gateway.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "gateway.name",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.gateway, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_gateway(
        &self,
        req: crate::model::DeleteGatewayRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_grpc_routes(
        &self,
        req: crate::model::ListGrpcRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGrpcRoutesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/grpcRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_grpc_route(
        &self,
        req: crate::model::GetGrpcRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GrpcRoute>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/grpcRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/grpcRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/grpcRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_grpc_route(
        &self,
        req: crate::model::CreateGrpcRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/grpcRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("grpcRouteId", &req.grpc_route_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.grpc_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_grpc_route(
        &self,
        req: crate::model::UpdateGrpcRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.grpc_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/grpcRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.grpc_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/grpcRoutes/"), Segment::SingleWildcard],
                    "grpc_route.name",
                    "projects/*/locations/*/grpcRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.grpc_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_grpc_route(
        &self,
        req: crate::model::DeleteGrpcRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/grpcRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/grpcRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/grpcRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_http_routes(
        &self,
        req: crate::model::ListHttpRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListHttpRoutesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/httpRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_http_route(
        &self,
        req: crate::model::GetHttpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpRoute>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/httpRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/httpRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/httpRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_http_route(
        &self,
        req: crate::model::CreateHttpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/httpRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("httpRouteId", &req.http_route_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.http_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_http_route(
        &self,
        req: crate::model::UpdateHttpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.http_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/httpRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.http_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/httpRoutes/"), Segment::SingleWildcard],
                    "http_route.name",
                    "projects/*/locations/*/httpRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.http_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_http_route(
        &self,
        req: crate::model::DeleteHttpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/httpRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/httpRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/httpRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_tcp_routes(
        &self,
        req: crate::model::ListTcpRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTcpRoutesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/tcpRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_tcp_route(
        &self,
        req: crate::model::GetTcpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TcpRoute>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tcpRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tcpRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/tcpRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_tcp_route(
        &self,
        req: crate::model::CreateTcpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/tcpRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("tcpRouteId", &req.tcp_route_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.tcp_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_tcp_route(
        &self,
        req: crate::model::UpdateTcpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.tcp_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tcpRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.tcp_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tcpRoutes/"), Segment::SingleWildcard],
                    "tcp_route.name",
                    "projects/*/locations/*/tcpRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.tcp_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_tcp_route(
        &self,
        req: crate::model::DeleteTcpRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tcpRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tcpRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/tcpRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_tls_routes(
        &self,
        req: crate::model::ListTlsRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTlsRoutesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/tlsRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_tls_route(
        &self,
        req: crate::model::GetTlsRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TlsRoute>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tlsRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tlsRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/tlsRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_tls_route(
        &self,
        req: crate::model::CreateTlsRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/tlsRoutes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("tlsRouteId", &req.tls_route_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.tls_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_tls_route(
        &self,
        req: crate::model::UpdateTlsRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.tls_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tlsRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.tls_route.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tlsRoutes/"), Segment::SingleWildcard],
                    "tls_route.name",
                    "projects/*/locations/*/tlsRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.tls_route, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_tls_route(
        &self,
        req: crate::model::DeleteTlsRouteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tlsRoutes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/tlsRoutes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/tlsRoutes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_service_bindings(
        &self,
        req: crate::model::ListServiceBindingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServiceBindingsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/serviceBindings",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_service_binding(
        &self,
        req: crate::model::GetServiceBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceBinding>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_service_binding(
        &self,
        req: crate::model::CreateServiceBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/serviceBindings",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("serviceBindingId", &req.service_binding_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.service_binding, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_service_binding(
        &self,
        req: crate::model::UpdateServiceBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.service_binding.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.service_binding.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "service_binding.name",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.service_binding, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_service_binding(
        &self,
        req: crate::model::DeleteServiceBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_meshes(
        &self,
        req: crate::model::ListMeshesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMeshesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/meshes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_mesh(
        &self,
        req: crate::model::GetMeshRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Mesh>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_mesh(
        &self,
        req: crate::model::CreateMeshRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/meshes",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("meshId", &req.mesh_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.mesh, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_mesh(
        &self,
        req: crate::model::UpdateMeshRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.mesh.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.mesh.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "mesh.name",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.mesh, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_mesh(
        &self,
        req: crate::model::DeleteMeshRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_service_lb_policies(
        &self,
        req: crate::model::ListServiceLbPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServiceLbPoliciesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/serviceLbPolicies",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_service_lb_policy(
        &self,
        req: crate::model::GetServiceLbPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLbPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceLbPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceLbPolicies/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/serviceLbPolicies/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_service_lb_policy(
        &self,
        req: crate::model::CreateServiceLbPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/serviceLbPolicies",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("serviceLbPolicyId", &req.service_lb_policy_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.service_lb_policy, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_service_lb_policy(
        &self,
        req: crate::model::UpdateServiceLbPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).and_then(|m| m.service_lb_policy.as_ref()).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceLbPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = (|| {
                let builder = req.update_mask.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "updateMask") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).and_then(|m| m.service_lb_policy.as_ref()).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceLbPolicies/"), Segment::SingleWildcard],
                    "service_lb_policy.name",
                    "projects/*/locations/*/serviceLbPolicies/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.service_lb_policy, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_service_lb_policy(
        &self,
        req: crate::model::DeleteServiceLbPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceLbPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceLbPolicies/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/serviceLbPolicies/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_gateway_route_view(
        &self,
        req: crate::model::GetGatewayRouteViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GatewayRouteView>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard, Segment::Literal("/routeViews/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard, Segment::Literal("/routeViews/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/gateways/*/routeViews/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_mesh_route_view(
        &self,
        req: crate::model::GetMeshRouteViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MeshRouteView>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard, Segment::Literal("/routeViews/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard, Segment::Literal("/routeViews/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/meshes/*/routeViews/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_gateway_route_views(
        &self,
        req: crate::model::ListGatewayRouteViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGatewayRouteViewsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/routeViews",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_mesh_route_views(
        &self,
        req: crate::model::ListMeshRouteViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMeshRouteViewsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/routeViews",
                try_match(Some(&req).map(|m| &m.parent).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "parent",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/locations",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard],
                    "name",
                    "projects/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:setIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheKeysets/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheOrigins/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheServices/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:getIamPolicy",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "options") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheKeysets/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheOrigins/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheServices/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/{}:testIamPermissions",
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheKeysets/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheKeysets/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheOrigins/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheOrigins/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/edgeCacheServices/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/edgeCacheServices/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/endpointPolicies/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/endpointPolicies/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/serviceBindings/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/serviceBindings/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/meshes/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/meshes/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/gateways/"), Segment::SingleWildcard],
                    "resource",
                    "projects/*/locations/*/gateways/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}/operations",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/operations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/operations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:cancel",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/operations/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/operations/*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

