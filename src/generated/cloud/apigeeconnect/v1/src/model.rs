// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request for [ListConnections][Management.ListConnections].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent name of the form:
    /// `projects/{project_number or project_id}/endpoints/{endpoint}`.
    pub parent: std::string::String,

    /// The maximum number of connections to return. The service may return fewer
    /// than this value. If unspecified, at most 100 connections will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnections` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.ListConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ListConnections][Management.ListConnections].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// A list of clients.
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connections,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connections" => Ok(__FieldTag::__connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsResponse");
        debug_struct.field("connections", &self.connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Connection {
    /// The endpoint that the connection is made against.
    /// Format: `projects/{project_number}/endpoints/{endpoint}`
    pub endpoint: std::string::String,

    /// Cluster information.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// The count of streams.
    pub stream_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::Connection::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::Connection::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::Connection::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stream_count][crate::model::Connection::stream_count].
    pub fn set_stream_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.stream_count = v.into();
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Connection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Connection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint,
            __cluster,
            __stream_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "streamCount" => Ok(__FieldTag::__stream_count),
                            "stream_count" => Ok(__FieldTag::__stream_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Connection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__stream_count => {
                            if !fields.insert(__FieldTag::__stream_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Connection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !wkt::internal::is_default(&self.stream_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("streamCount", &__With(&self.stream_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Connection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connection");
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("stream_count", &self.stream_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// The name of the cluster.
    pub name: std::string::String,

    /// The region of the cluster.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::Cluster::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Cluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cluster");
        debug_struct.field("name", &self.name);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// gRPC request payload for tether.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EgressRequest {
    /// Unique identifier for the request.
    pub id: std::string::String,

    /// Actual payload to send to agent.
    pub payload: std::option::Option<crate::model::Payload>,

    /// Tether Endpoint.
    pub endpoint: crate::model::TetherEndpoint,

    /// GCP Project.
    /// Format: `projects/{project_number}`.
    pub project: std::string::String,

    /// Unique identifier for clients to trace their request/response.
    pub trace_id: std::string::String,

    /// Timeout for the HTTP request.
    pub timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EgressRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EgressRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::EgressRequest::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Payload>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::EgressRequest::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Payload>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpoint][crate::model::EgressRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<crate::model::TetherEndpoint>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [project][crate::model::EgressRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::EgressRequest::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::EgressRequest::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::EgressRequest::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EgressRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.EgressRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EgressRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __payload,
            __endpoint,
            __project,
            __trace_id,
            __timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EgressRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "payload" => Ok(__FieldTag::__payload),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "project" => Ok(__FieldTag::__project),
                            "traceId" => Ok(__FieldTag::__trace_id),
                            "trace_id" => Ok(__FieldTag::__trace_id),
                            "timeout" => Ok(__FieldTag::__timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EgressRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EgressRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload =
                                map.next_value::<std::option::Option<crate::model::Payload>>()?;
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<crate::model::TetherEndpoint>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trace_id => {
                            if !fields.insert(__FieldTag::__trace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trace_id",
                                ));
                            }
                            result.trace_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EgressRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !wkt::internal::is_default(&self.endpoint) {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.trace_id.is_empty() {
            state.serialize_entry("traceId", &self.trace_id)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EgressRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EgressRequest");
        debug_struct.field("id", &self.id);
        debug_struct.field("payload", &self.payload);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("project", &self.project);
        debug_struct.field("trace_id", &self.trace_id);
        debug_struct.field("timeout", &self.timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload for EgressRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Payload {
    /// The kind of payload.
    pub kind: std::option::Option<crate::model::payload::Kind>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Payload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Payload::kind].
    ///
    /// Note that all the setters affecting `kind` are mutually
    /// exclusive.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::payload::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `HttpRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_request(&self) -> std::option::Option<&std::boxed::Box<crate::model::HttpRequest>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::HttpRequest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `HttpRequest`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_http_request<T: std::convert::Into<std::boxed::Box<crate::model::HttpRequest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::HttpRequest(v.into()));
        self
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `StreamInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stream_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::StreamInfo>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::StreamInfo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `StreamInfo`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_stream_info<T: std::convert::Into<std::boxed::Box<crate::model::StreamInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::StreamInfo(v.into()));
        self
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `Action`, `None` if the field is not set or
    /// holds a different branch.
    pub fn action(&self) -> std::option::Option<&crate::model::Action> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::Action(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `Action`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_action<T: std::convert::Into<crate::model::Action>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::Action(v.into()));
        self
    }
}

impl wkt::message::Message for Payload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Payload"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Payload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_request,
            __stream_info,
            __action,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Payload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpRequest" => Ok(__FieldTag::__http_request),
                            "http_request" => Ok(__FieldTag::__http_request),
                            "streamInfo" => Ok(__FieldTag::__stream_info),
                            "stream_info" => Ok(__FieldTag::__stream_info),
                            "action" => Ok(__FieldTag::__action),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Payload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Payload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_request => {
                            if !fields.insert(__FieldTag::__http_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_request",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.apigeeconnect.v1.Payload.http_request, latest field was httpRequest",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::payload::Kind::HttpRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__stream_info => {
                            if !fields.insert(__FieldTag::__stream_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_info",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.apigeeconnect.v1.Payload.stream_info, latest field was streamInfo",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::payload::Kind::StreamInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StreamInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.apigeeconnect.v1.Payload.action, latest field was action",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::payload::Kind::Action(
                                    map.next_value::<std::option::Option<crate::model::Action>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Payload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.http_request() {
            state.serialize_entry("httpRequest", value)?;
        }
        if let Some(value) = self.stream_info() {
            state.serialize_entry("streamInfo", value)?;
        }
        if let Some(value) = self.action() {
            state.serialize_entry("action", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Payload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Payload");
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Payload].
pub mod payload {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of payload.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// The HttpRequest proto.
        HttpRequest(std::boxed::Box<crate::model::HttpRequest>),
        /// The information of stream.
        StreamInfo(std::boxed::Box<crate::model::StreamInfo>),
        /// The action taken by agent.
        Action(crate::model::Action),
    }
}

/// The Information of bi-directional stream.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamInfo {
    /// Unique identifier for the stream.
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::StreamInfo::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for StreamInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.StreamInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StreamInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamInfo");
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// gRPC response payload for tether.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EgressResponse {
    /// Unique identifier for the response. Matches the EgressRequest's id.
    pub id: std::string::String,

    /// HttpResponse.
    pub http_response: std::option::Option<crate::model::HttpResponse>,

    /// Errors from application when handling the http request.
    pub status: std::option::Option<rpc::model::Status>,

    /// GCP Project.
    /// Format: `projects/{project_number}`.
    pub project: std::string::String,

    /// Unique identifier for clients to trace their request/response. Matches the
    /// EgressRequest's trace id
    pub trace_id: std::string::String,

    /// Tether Endpoint.
    pub endpoint: crate::model::TetherEndpoint,

    /// Name is the full resource path of endpoint.
    /// Format: `projects/{project_number or project_id}/endpoints/{endpoint}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EgressResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EgressResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [http_response][crate::model::EgressResponse::http_response].
    pub fn set_http_response<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HttpResponse>,
    {
        self.http_response = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_response][crate::model::EgressResponse::http_response].
    pub fn set_or_clear_http_response<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HttpResponse>,
    {
        self.http_response = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::EgressResponse::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::EgressResponse::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [project][crate::model::EgressResponse::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::EgressResponse::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::EgressResponse::endpoint].
    pub fn set_endpoint<T: std::convert::Into<crate::model::TetherEndpoint>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [name][crate::model::EgressResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EgressResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.EgressResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EgressResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __http_response,
            __status,
            __project,
            __trace_id,
            __endpoint,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EgressResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "httpResponse" => Ok(__FieldTag::__http_response),
                            "http_response" => Ok(__FieldTag::__http_response),
                            "status" => Ok(__FieldTag::__status),
                            "project" => Ok(__FieldTag::__project),
                            "traceId" => Ok(__FieldTag::__trace_id),
                            "trace_id" => Ok(__FieldTag::__trace_id),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EgressResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EgressResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__http_response => {
                            if !fields.insert(__FieldTag::__http_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_response",
                                ));
                            }
                            result.http_response = map
                                .next_value::<std::option::Option<crate::model::HttpResponse>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trace_id => {
                            if !fields.insert(__FieldTag::__trace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trace_id",
                                ));
                            }
                            result.trace_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<crate::model::TetherEndpoint>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EgressResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.http_response.is_some() {
            state.serialize_entry("httpResponse", &self.http_response)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.trace_id.is_empty() {
            state.serialize_entry("traceId", &self.trace_id)?;
        }
        if !wkt::internal::is_default(&self.endpoint) {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EgressResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EgressResponse");
        debug_struct.field("id", &self.id);
        debug_struct.field("http_response", &self.http_response);
        debug_struct.field("status", &self.status);
        debug_struct.field("project", &self.project);
        debug_struct.field("trace_id", &self.trace_id);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The proto definition of http request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpRequest {
    /// A unique identifier for the request.
    pub id: std::string::String,

    /// The HTTP request method.
    /// Valid methods: "GET", "HEAD", "POST", "PUT", "PATCH","DELETE".
    pub method: std::string::String,

    /// The HTTP request URL.
    pub url: std::option::Option<crate::model::Url>,

    /// The HTTP request headers.
    pub headers: std::vec::Vec<crate::model::Header>,

    /// HTTP request body.
    pub body: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::HttpRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [method][crate::model::HttpRequest::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [url][crate::model::HttpRequest::url].
    pub fn set_url<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Url>,
    {
        self.url = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [url][crate::model::HttpRequest::url].
    pub fn set_or_clear_url<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Url>,
    {
        self.url = v.map(|x| x.into());
        self
    }

    /// Sets the value of [headers][crate::model::HttpRequest::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [body][crate::model::HttpRequest::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for HttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.HttpRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __method,
            __url,
            __headers,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "method" => Ok(__FieldTag::__method),
                            "url" => Ok(__FieldTag::__url),
                            "headers" => Ok(__FieldTag::__headers),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__method => {
                            if !fields.insert(__FieldTag::__method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method",
                                ));
                            }
                            result.method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url =
                                map.next_value::<std::option::Option<crate::model::Url>>()?;
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Header>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.body = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.method.is_empty() {
            state.serialize_entry("method", &self.method)?;
        }
        if self.url.is_some() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.body.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("body", &__With(&self.body))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HttpRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpRequest");
        debug_struct.field("id", &self.id);
        debug_struct.field("method", &self.method);
        debug_struct.field("url", &self.url);
        debug_struct.field("headers", &self.headers);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The proto definition of url.
/// A url represents a URL and the general form represented is:
///
/// `[scheme://][google.cloud.apigeeconnect.v1.Url.host][path]`
///
/// [google.cloud.apigeeconnect.v1.Url.host]: crate::model::Url::host
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Url {
    /// Scheme.
    pub scheme: crate::model::Scheme,

    /// Host or Host:Port.
    pub host: std::string::String,

    /// Path starts with `/`.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Url {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scheme][crate::model::Url::scheme].
    pub fn set_scheme<T: std::convert::Into<crate::model::Scheme>>(mut self, v: T) -> Self {
        self.scheme = v.into();
        self
    }

    /// Sets the value of [host][crate::model::Url::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Url::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Url {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Url"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Url {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scheme,
            __host,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Url")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scheme" => Ok(__FieldTag::__scheme),
                            "host" => Ok(__FieldTag::__host),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Url;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Url")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scheme => {
                            if !fields.insert(__FieldTag::__scheme) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheme",
                                ));
                            }
                            result.scheme = map
                                .next_value::<std::option::Option<crate::model::Scheme>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Url {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.scheme) {
            state.serialize_entry("scheme", &self.scheme)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Url {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Url");
        debug_struct.field("scheme", &self.scheme);
        debug_struct.field("host", &self.host);
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The http headers.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Header {
    pub key: std::string::String,

    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Header {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::Header::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::Header::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Header {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Header"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Header {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Header")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Header;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Header")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Header {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Header {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Header");
        debug_struct.field("key", &self.key);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The proto definition of http response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpResponse {
    /// A unique identifier that matches the request ID.
    pub id: std::string::String,

    /// Status of http response, e.g. "200 OK".
    pub status: std::string::String,

    /// Status code of http response, e.g. 200.
    pub status_code: i32,

    /// The HTTP 1.1 response body.
    pub body: ::bytes::Bytes,

    /// The HTTP response headers.
    pub headers: std::vec::Vec<crate::model::Header>,

    /// Content length records the length of the associated content. The
    /// value -1 indicates that the length is unknown. Unless http method
    /// is "HEAD", values >= 0 indicate that the given number of bytes may
    /// be read from Body.
    pub content_length: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::HttpResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::HttpResponse::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_code][crate::model::HttpResponse::status_code].
    pub fn set_status_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.status_code = v.into();
        self
    }

    /// Sets the value of [body][crate::model::HttpResponse::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpResponse::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_length][crate::model::HttpResponse::content_length].
    pub fn set_content_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.content_length = v.into();
        self
    }
}

impl wkt::message::Message for HttpResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.HttpResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __status,
            __status_code,
            __body,
            __headers,
            __content_length,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "status" => Ok(__FieldTag::__status),
                            "statusCode" => Ok(__FieldTag::__status_code),
                            "status_code" => Ok(__FieldTag::__status_code),
                            "body" => Ok(__FieldTag::__body),
                            "headers" => Ok(__FieldTag::__headers),
                            "contentLength" => Ok(__FieldTag::__content_length),
                            "content_length" => Ok(__FieldTag::__content_length),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_code => {
                            if !fields.insert(__FieldTag::__status_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.status_code = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.body = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Header>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__content_length => {
                            if !fields.insert(__FieldTag::__content_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content_length =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.status.is_empty() {
            state.serialize_entry("status", &self.status)?;
        }
        if !wkt::internal::is_default(&self.status_code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("statusCode", &__With(&self.status_code))?;
        }
        if !self.body.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("body", &__With(&self.body))?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !wkt::internal::is_default(&self.content_length) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contentLength", &__With(&self.content_length))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HttpResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpResponse");
        debug_struct.field("id", &self.id);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_code", &self.status_code);
        debug_struct.field("body", &self.body);
        debug_struct.field("headers", &self.headers);
        debug_struct.field("content_length", &self.content_length);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The action taken by agent.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Action {
    /// Unspecified Action.
    Unspecified,
    /// Indicates that agent should open a new stream.
    OpenNewStream,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Action::value] or
    /// [Action::name].
    UnknownValue(action::UnknownValue),
}

#[doc(hidden)]
pub mod action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Action {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::OpenNewStream => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
            Self::OpenNewStream => std::option::Option::Some("OPEN_NEW_STREAM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Action {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Action {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Action {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::OpenNewStream,
            _ => Self::UnknownValue(action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Action {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ACTION_UNSPECIFIED" => Self::Unspecified,
            "OPEN_NEW_STREAM" => Self::OpenNewStream,
            _ => Self::UnknownValue(action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Action {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::OpenNewStream => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Action {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
            ".google.cloud.apigeeconnect.v1.Action",
        ))
    }
}

/// Endpoint indicates where the messages will be delivered.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TetherEndpoint {
    /// Unspecified tether endpoint.
    Unspecified,
    /// Apigee MART endpoint.
    ApigeeMart,
    /// Apigee Runtime endpoint.
    ApigeeRuntime,
    /// Apigee Mint Rating endpoint.
    ApigeeMintRating,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TetherEndpoint::value] or
    /// [TetherEndpoint::name].
    UnknownValue(tether_endpoint::UnknownValue),
}

#[doc(hidden)]
pub mod tether_endpoint {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TetherEndpoint {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ApigeeMart => std::option::Option::Some(1),
            Self::ApigeeRuntime => std::option::Option::Some(2),
            Self::ApigeeMintRating => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TETHER_ENDPOINT_UNSPECIFIED"),
            Self::ApigeeMart => std::option::Option::Some("APIGEE_MART"),
            Self::ApigeeRuntime => std::option::Option::Some("APIGEE_RUNTIME"),
            Self::ApigeeMintRating => std::option::Option::Some("APIGEE_MINT_RATING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TetherEndpoint {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TetherEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TetherEndpoint {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ApigeeMart,
            2 => Self::ApigeeRuntime,
            3 => Self::ApigeeMintRating,
            _ => Self::UnknownValue(tether_endpoint::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TetherEndpoint {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TETHER_ENDPOINT_UNSPECIFIED" => Self::Unspecified,
            "APIGEE_MART" => Self::ApigeeMart,
            "APIGEE_RUNTIME" => Self::ApigeeRuntime,
            "APIGEE_MINT_RATING" => Self::ApigeeMintRating,
            _ => Self::UnknownValue(tether_endpoint::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TetherEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ApigeeMart => serializer.serialize_i32(1),
            Self::ApigeeRuntime => serializer.serialize_i32(2),
            Self::ApigeeMintRating => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TetherEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TetherEndpoint>::new(
            ".google.cloud.apigeeconnect.v1.TetherEndpoint",
        ))
    }
}

/// HTTP Scheme.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Scheme {
    /// Unspecified scheme.
    Unspecified,
    /// HTTPS protocol.
    Https,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Scheme::value] or
    /// [Scheme::name].
    UnknownValue(scheme::UnknownValue),
}

#[doc(hidden)]
pub mod scheme {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Scheme {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Https => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SCHEME_UNSPECIFIED"),
            Self::Https => std::option::Option::Some("HTTPS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Scheme {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Scheme {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Scheme {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Https,
            _ => Self::UnknownValue(scheme::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Scheme {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SCHEME_UNSPECIFIED" => Self::Unspecified,
            "HTTPS" => Self::Https,
            _ => Self::UnknownValue(scheme::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Scheme {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Https => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Scheme {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scheme>::new(
            ".google.cloud.apigeeconnect.v1.Scheme",
        ))
    }
}
