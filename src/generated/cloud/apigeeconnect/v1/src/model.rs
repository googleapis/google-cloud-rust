// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request for [ListConnections][Management.ListConnections].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent name of the form:
    /// `projects/{project_number or project_id}/endpoints/{endpoint}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of connections to return. The service may return fewer
    /// than this value. If unspecified, at most 100 connections will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnections` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.ListConnectionsRequest"
    }
}

/// The response for
/// [ListConnections][Management.ListConnections].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// A list of clients.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.ListConnectionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// The endpoint that the connection is made against.
    /// Format: `projects/{project_number}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Cluster information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// The count of streams.
    pub stream_count: i32,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::Connection::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::Connection::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [stream_count][crate::model::Connection::stream_count].
    pub fn set_stream_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.stream_count = v.into();
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Connection"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// The name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The region of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::Cluster::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Cluster"
    }
}

/// gRPC request payload for tether.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EgressRequest {
    /// Unique identifier for the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Actual payload to send to agent.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::model::Payload>,

    /// Tether Endpoint.
    pub endpoint: crate::model::TetherEndpoint,

    /// GCP Project.
    /// Format: `projects/{project_number}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Unique identifier for clients to trace their request/response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trace_id: std::string::String,

    /// Timeout for the HTTP request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,
}

impl EgressRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EgressRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::EgressRequest::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<crate::model::Payload>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::EgressRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<crate::model::TetherEndpoint>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [project][crate::model::EgressRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::EgressRequest::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::EgressRequest::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }
}

impl wkt::message::Message for EgressRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.EgressRequest"
    }
}

/// Payload for EgressRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Payload {
    /// The kind of payload.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub kind: std::option::Option<crate::model::payload::Kind>,
}

impl Payload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `kind`.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::payload::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `HttpRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_http_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpRequest>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::HttpRequest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `StreamInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_stream_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamInfo>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::StreamInfo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `Action`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_action(&self) -> std::option::Option<&crate::model::Action> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::Action(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `HttpRequest`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_http_request<T: std::convert::Into<std::boxed::Box<crate::model::HttpRequest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::HttpRequest(v.into()));
        self
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `StreamInfo`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_stream_info<T: std::convert::Into<std::boxed::Box<crate::model::StreamInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::StreamInfo(v.into()));
        self
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `Action`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_action<T: std::convert::Into<crate::model::Action>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::Action(v.into()));
        self
    }
}

impl wkt::message::Message for Payload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Payload"
    }
}

/// Defines additional types related to Payload
pub mod payload {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of payload.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Kind {
        /// The HttpRequest proto.
        HttpRequest(std::boxed::Box<crate::model::HttpRequest>),
        /// The information of stream.
        StreamInfo(std::boxed::Box<crate::model::StreamInfo>),
        /// The action taken by agent.
        Action(crate::model::Action),
    }
}

/// The Information of bi-directional stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamInfo {
    /// Unique identifier for the stream.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,
}

impl StreamInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::StreamInfo::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for StreamInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.StreamInfo"
    }
}

/// gRPC response payload for tether.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EgressResponse {
    /// Unique identifier for the response. Matches the EgressRequest's id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// HttpResponse.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_response: std::option::Option<crate::model::HttpResponse>,

    /// Errors from application when handling the http request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// GCP Project.
    /// Format: `projects/{project_number}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Unique identifier for clients to trace their request/response. Matches the
    /// EgressRequest's trace id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trace_id: std::string::String,

    /// Tether Endpoint.
    pub endpoint: crate::model::TetherEndpoint,

    /// Name is the full resource path of endpoint.
    /// Format: `projects/{project_number or project_id}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl EgressResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EgressResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [http_response][crate::model::EgressResponse::http_response].
    pub fn set_http_response<
        T: std::convert::Into<std::option::Option<crate::model::HttpResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.http_response = v.into();
        self
    }

    /// Sets the value of [status][crate::model::EgressResponse::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [project][crate::model::EgressResponse::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::EgressResponse::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::EgressResponse::endpoint].
    pub fn set_endpoint<T: std::convert::Into<crate::model::TetherEndpoint>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [name][crate::model::EgressResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EgressResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.EgressResponse"
    }
}

/// The proto definition of http request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpRequest {
    /// A unique identifier for the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The HTTP request method.
    /// Valid methods: "GET", "HEAD", "POST", "PUT", "PATCH","DELETE".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method: std::string::String,

    /// The HTTP request URL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub url: std::option::Option<crate::model::Url>,

    /// The HTTP request headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::Header>,

    /// HTTP request body.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub body: ::bytes::Bytes,
}

impl HttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::HttpRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [method][crate::model::HttpRequest::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [url][crate::model::HttpRequest::url].
    pub fn set_url<T: std::convert::Into<std::option::Option<crate::model::Url>>>(
        mut self,
        v: T,
    ) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [body][crate::model::HttpRequest::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpRequest::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.HttpRequest"
    }
}

/// The proto definition of url.
/// A url represents a URL and the general form represented is:
///
/// `[scheme://][google.cloud.apigeeconnect.v1.Url.host][path]`
///
/// [google.cloud.apigeeconnect.v1.Url.host]: crate::model::Url::host
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Url {
    /// Scheme.
    pub scheme: crate::model::Scheme,

    /// Host or Host:Port.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Path starts with `/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,
}

impl Url {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scheme][crate::model::Url::scheme].
    pub fn set_scheme<T: std::convert::Into<crate::model::Scheme>>(mut self, v: T) -> Self {
        self.scheme = v.into();
        self
    }

    /// Sets the value of [host][crate::model::Url::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Url::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Url {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Url"
    }
}

/// The http headers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Header {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,
}

impl Header {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::Header::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::Header::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Header {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Header"
    }
}

/// The proto definition of http response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpResponse {
    /// A unique identifier that matches the request ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Status of http response, e.g. "200 OK".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status: std::string::String,

    /// Status code of http response, e.g. 200.
    pub status_code: i32,

    /// The HTTP 1.1 response body.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub body: ::bytes::Bytes,

    /// The HTTP response headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::Header>,

    /// Content length records the length of the associated content. The
    /// value -1 indicates that the length is unknown. Unless http method
    /// is "HEAD", values >= 0 indicate that the given number of bytes may
    /// be read from Body.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub content_length: i64,
}

impl HttpResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::HttpResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::HttpResponse::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_code][crate::model::HttpResponse::status_code].
    pub fn set_status_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.status_code = v.into();
        self
    }

    /// Sets the value of [body][crate::model::HttpResponse::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [content_length][crate::model::HttpResponse::content_length].
    pub fn set_content_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.content_length = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpResponse::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HttpResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.HttpResponse"
    }
}

/// The action taken by agent.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Action(std::borrow::Cow<'static, str>);

impl Action {
    /// Creates a new Action instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [Action](Action)
pub mod action {
    use super::Action;

    /// Unspecified Action.
    pub const ACTION_UNSPECIFIED: Action = Action::new("ACTION_UNSPECIFIED");

    /// Indicates that agent should open a new stream.
    pub const OPEN_NEW_STREAM: Action = Action::new("OPEN_NEW_STREAM");
}

impl std::convert::From<std::string::String> for Action {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for Action {
    fn default() -> Self {
        action::ACTION_UNSPECIFIED
    }
}

/// Endpoint indicates where the messages will be delivered.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TetherEndpoint(std::borrow::Cow<'static, str>);

impl TetherEndpoint {
    /// Creates a new TetherEndpoint instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [TetherEndpoint](TetherEndpoint)
pub mod tether_endpoint {
    use super::TetherEndpoint;

    /// Unspecified tether endpoint.
    pub const TETHER_ENDPOINT_UNSPECIFIED: TetherEndpoint =
        TetherEndpoint::new("TETHER_ENDPOINT_UNSPECIFIED");

    /// Apigee MART endpoint.
    pub const APIGEE_MART: TetherEndpoint = TetherEndpoint::new("APIGEE_MART");

    /// Apigee Runtime endpoint.
    pub const APIGEE_RUNTIME: TetherEndpoint = TetherEndpoint::new("APIGEE_RUNTIME");

    /// Apigee Mint Rating endpoint.
    pub const APIGEE_MINT_RATING: TetherEndpoint = TetherEndpoint::new("APIGEE_MINT_RATING");
}

impl std::convert::From<std::string::String> for TetherEndpoint {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for TetherEndpoint {
    fn default() -> Self {
        tether_endpoint::TETHER_ENDPOINT_UNSPECIFIED
    }
}

/// HTTP Scheme.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Scheme(std::borrow::Cow<'static, str>);

impl Scheme {
    /// Creates a new Scheme instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [Scheme](Scheme)
pub mod scheme {
    use super::Scheme;

    /// Unspecified scheme.
    pub const SCHEME_UNSPECIFIED: Scheme = Scheme::new("SCHEME_UNSPECIFIED");

    /// HTTPS protocol.
    pub const HTTPS: Scheme = Scheme::new("HTTPS");
}

impl std::convert::From<std::string::String> for Scheme {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for Scheme {
    fn default() -> Self {
        scheme::SCHEME_UNSPECIFIED
    }
}
