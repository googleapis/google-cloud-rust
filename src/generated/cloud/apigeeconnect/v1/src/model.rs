// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request for [ListConnections][Management.ListConnections].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent name of the form:
    /// `projects/{project_number or project_id}/endpoints/{endpoint}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of connections to return. The service may return fewer
    /// than this value. If unspecified, at most 100 connections will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous `ListConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnections` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.ListConnectionsRequest"
    }
}

/// The response for
/// [ListConnections][Management.ListConnections].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// A list of clients.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// The endpoint that the connection is made against.
    /// Format: `projects/{project_number}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Cluster information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// The count of streams.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub stream_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::Connection::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::Connection::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [stream_count][crate::model::Connection::stream_count].
    pub fn set_stream_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.stream_count = v.into();
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Connection"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// The name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The region of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::Cluster::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Cluster"
    }
}

/// gRPC request payload for tether.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EgressRequest {
    /// Unique identifier for the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Actual payload to send to agent.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::model::Payload>,

    /// Tether Endpoint.
    pub endpoint: crate::model::TetherEndpoint,

    /// GCP Project.
    /// Format: `projects/{project_number}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Unique identifier for clients to trace their request/response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trace_id: std::string::String,

    /// Timeout for the HTTP request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EgressRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EgressRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::EgressRequest::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<crate::model::Payload>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::EgressRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<crate::model::TetherEndpoint>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [project][crate::model::EgressRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::EgressRequest::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::EgressRequest::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }
}

impl wkt::message::Message for EgressRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.EgressRequest"
    }
}

/// Payload for EgressRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Payload {
    /// The kind of payload.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub kind: std::option::Option<crate::model::payload::Kind>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Payload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Payload::kind].
    ///
    /// Note that all the setters affecting `kind` are mutually
    /// exclusive.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::payload::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `HttpRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_request(&self) -> std::option::Option<&std::boxed::Box<crate::model::HttpRequest>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::HttpRequest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `HttpRequest`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_http_request<T: std::convert::Into<std::boxed::Box<crate::model::HttpRequest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::HttpRequest(v.into()));
        self
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `StreamInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stream_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::StreamInfo>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::StreamInfo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `StreamInfo`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_stream_info<T: std::convert::Into<std::boxed::Box<crate::model::StreamInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::StreamInfo(v.into()));
        self
    }

    /// The value of [kind][crate::model::Payload::kind]
    /// if it holds a `Action`, `None` if the field is not set or
    /// holds a different branch.
    pub fn action(&self) -> std::option::Option<&crate::model::Action> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::payload::Kind::Action(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Payload::kind]
    /// to hold a `Action`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_action<T: std::convert::Into<crate::model::Action>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::payload::Kind::Action(v.into()));
        self
    }
}

impl wkt::message::Message for Payload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Payload"
    }
}

/// Defines additional types related to [Payload].
pub mod payload {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of payload.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Kind {
        /// The HttpRequest proto.
        HttpRequest(std::boxed::Box<crate::model::HttpRequest>),
        /// The information of stream.
        StreamInfo(std::boxed::Box<crate::model::StreamInfo>),
        /// The action taken by agent.
        Action(crate::model::Action),
    }
}

/// The Information of bi-directional stream.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamInfo {
    /// Unique identifier for the stream.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::StreamInfo::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for StreamInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.StreamInfo"
    }
}

/// gRPC response payload for tether.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EgressResponse {
    /// Unique identifier for the response. Matches the EgressRequest's id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// HttpResponse.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_response: std::option::Option<crate::model::HttpResponse>,

    /// Errors from application when handling the http request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// GCP Project.
    /// Format: `projects/{project_number}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Unique identifier for clients to trace their request/response. Matches the
    /// EgressRequest's trace id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trace_id: std::string::String,

    /// Tether Endpoint.
    pub endpoint: crate::model::TetherEndpoint,

    /// Name is the full resource path of endpoint.
    /// Format: `projects/{project_number or project_id}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EgressResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EgressResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [http_response][crate::model::EgressResponse::http_response].
    pub fn set_http_response<
        T: std::convert::Into<std::option::Option<crate::model::HttpResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.http_response = v.into();
        self
    }

    /// Sets the value of [status][crate::model::EgressResponse::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [project][crate::model::EgressResponse::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::EgressResponse::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::EgressResponse::endpoint].
    pub fn set_endpoint<T: std::convert::Into<crate::model::TetherEndpoint>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [name][crate::model::EgressResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EgressResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.EgressResponse"
    }
}

/// The proto definition of http request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpRequest {
    /// A unique identifier for the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The HTTP request method.
    /// Valid methods: "GET", "HEAD", "POST", "PUT", "PATCH","DELETE".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method: std::string::String,

    /// The HTTP request URL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub url: std::option::Option<crate::model::Url>,

    /// The HTTP request headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::Header>,

    /// HTTP request body.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub body: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::HttpRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [method][crate::model::HttpRequest::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [url][crate::model::HttpRequest::url].
    pub fn set_url<T: std::convert::Into<std::option::Option<crate::model::Url>>>(
        mut self,
        v: T,
    ) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpRequest::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [body][crate::model::HttpRequest::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for HttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.HttpRequest"
    }
}

/// The proto definition of url.
/// A url represents a URL and the general form represented is:
///
/// `[scheme://][google.cloud.apigeeconnect.v1.Url.host][path]`
///
/// [google.cloud.apigeeconnect.v1.Url.host]: crate::model::Url::host
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Url {
    /// Scheme.
    pub scheme: crate::model::Scheme,

    /// Host or Host:Port.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Path starts with `/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Url {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scheme][crate::model::Url::scheme].
    pub fn set_scheme<T: std::convert::Into<crate::model::Scheme>>(mut self, v: T) -> Self {
        self.scheme = v.into();
        self
    }

    /// Sets the value of [host][crate::model::Url::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Url::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Url {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Url"
    }
}

/// The http headers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Header {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Header {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::Header::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::Header::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Header {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.Header"
    }
}

/// The proto definition of http response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpResponse {
    /// A unique identifier that matches the request ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Status of http response, e.g. "200 OK".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status: std::string::String,

    /// Status code of http response, e.g. 200.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub status_code: i32,

    /// The HTTP 1.1 response body.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub body: ::bytes::Bytes,

    /// The HTTP response headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::Header>,

    /// Content length records the length of the associated content. The
    /// value -1 indicates that the length is unknown. Unless http method
    /// is "HEAD", values >= 0 indicate that the given number of bytes may
    /// be read from Body.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub content_length: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::HttpResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::HttpResponse::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_code][crate::model::HttpResponse::status_code].
    pub fn set_status_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.status_code = v.into();
        self
    }

    /// Sets the value of [body][crate::model::HttpResponse::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpResponse::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Header>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_length][crate::model::HttpResponse::content_length].
    pub fn set_content_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.content_length = v.into();
        self
    }
}

impl wkt::message::Message for HttpResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.apigeeconnect.v1.HttpResponse"
    }
}

/// The action taken by agent.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Action {
    /// Unspecified Action.
    Unspecified,
    /// Indicates that agent should open a new stream.
    OpenNewStream,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Action::value] or
    /// [Action::name].
    UnknownValue(action::UnknownValue),
}

#[doc(hidden)]
pub mod action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Action {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::OpenNewStream => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
            Self::OpenNewStream => std::option::Option::Some("OPEN_NEW_STREAM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Action {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Action {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Action {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::OpenNewStream,
            _ => Self::UnknownValue(action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Action {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ACTION_UNSPECIFIED" => Self::Unspecified,
            "OPEN_NEW_STREAM" => Self::OpenNewStream,
            _ => Self::UnknownValue(action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Action {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::OpenNewStream => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Action {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
            ".google.cloud.apigeeconnect.v1.Action",
        ))
    }
}

/// Endpoint indicates where the messages will be delivered.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TetherEndpoint {
    /// Unspecified tether endpoint.
    Unspecified,
    /// Apigee MART endpoint.
    ApigeeMart,
    /// Apigee Runtime endpoint.
    ApigeeRuntime,
    /// Apigee Mint Rating endpoint.
    ApigeeMintRating,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TetherEndpoint::value] or
    /// [TetherEndpoint::name].
    UnknownValue(tether_endpoint::UnknownValue),
}

#[doc(hidden)]
pub mod tether_endpoint {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TetherEndpoint {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ApigeeMart => std::option::Option::Some(1),
            Self::ApigeeRuntime => std::option::Option::Some(2),
            Self::ApigeeMintRating => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TETHER_ENDPOINT_UNSPECIFIED"),
            Self::ApigeeMart => std::option::Option::Some("APIGEE_MART"),
            Self::ApigeeRuntime => std::option::Option::Some("APIGEE_RUNTIME"),
            Self::ApigeeMintRating => std::option::Option::Some("APIGEE_MINT_RATING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TetherEndpoint {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TetherEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TetherEndpoint {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ApigeeMart,
            2 => Self::ApigeeRuntime,
            3 => Self::ApigeeMintRating,
            _ => Self::UnknownValue(tether_endpoint::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TetherEndpoint {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TETHER_ENDPOINT_UNSPECIFIED" => Self::Unspecified,
            "APIGEE_MART" => Self::ApigeeMart,
            "APIGEE_RUNTIME" => Self::ApigeeRuntime,
            "APIGEE_MINT_RATING" => Self::ApigeeMintRating,
            _ => Self::UnknownValue(tether_endpoint::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TetherEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ApigeeMart => serializer.serialize_i32(1),
            Self::ApigeeRuntime => serializer.serialize_i32(2),
            Self::ApigeeMintRating => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TetherEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TetherEndpoint>::new(
            ".google.cloud.apigeeconnect.v1.TetherEndpoint",
        ))
    }
}

/// HTTP Scheme.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Scheme {
    /// Unspecified scheme.
    Unspecified,
    /// HTTPS protocol.
    Https,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Scheme::value] or
    /// [Scheme::name].
    UnknownValue(scheme::UnknownValue),
}

#[doc(hidden)]
pub mod scheme {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Scheme {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Https => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SCHEME_UNSPECIFIED"),
            Self::Https => std::option::Option::Some("HTTPS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Scheme {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Scheme {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Scheme {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Https,
            _ => Self::UnknownValue(scheme::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Scheme {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SCHEME_UNSPECIFIED" => Self::Unspecified,
            "HTTPS" => Self::Https,
            _ => Self::UnknownValue(scheme::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Scheme {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Https => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Scheme {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scheme>::new(
            ".google.cloud.apigeeconnect.v1.Scheme",
        ))
    }
}
