// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the input to API methods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Document {
    /// Required. If the type is not set or is `TYPE_UNSPECIFIED`,
    /// returns an `INVALID_ARGUMENT` error.
    #[serde(rename = "type")]
    pub r#type: crate::model::document::Type,

    /// Optional. The language of the document (if not specified, the language is
    /// automatically detected). Both ISO and BCP-47 language codes are
    /// accepted.\<br\>
    /// [Language
    /// Support](https://cloud.google.com/natural-language/docs/languages) lists
    /// currently supported languages for each API method. If the language (either
    /// specified by the caller or automatically detected) is not supported by the
    /// called API method, an `INVALID_ARGUMENT` error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::document::Source>,
}

impl Document {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Document::type].
    pub fn set_type<T: std::convert::Into<crate::model::document::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Document::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_content(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `GcsContentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_content_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::GcsContentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(crate::model::document::Source::Content(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `GcsContentUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_content_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::document::Source::GcsContentUri(v.into()));
        self
    }
}

impl wkt::message::Message for Document {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Document"
    }
}

/// Defines additional types related to Document
pub mod document {
    #[allow(unused_imports)]
    use super::*;

    /// The document types enum.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Type(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// The content type is not specified.
        pub const TYPE_UNSPECIFIED: Type = Type::known("TYPE_UNSPECIFIED", 0);

        /// Plain text
        pub const PLAIN_TEXT: Type = Type::known("PLAIN_TEXT", 1);

        /// HTML
        pub const HTML: Type = Type::known("HTML", 2);
    }

    impl Type {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Type::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Type::from(val)),
                Enumeration::UnknownNum { str } => Ok(Type::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "TYPE_UNSPECIFIED" => r#type::TYPE_UNSPECIFIED,
                "PLAIN_TEXT" => r#type::PLAIN_TEXT,
                "HTML" => r#type::HTML,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => r#type::TYPE_UNSPECIFIED,
                1 => r#type::PLAIN_TEXT,
                2 => r#type::HTML,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The content of the input in string format.
        /// Cloud audit logging exempt since it is based on user data.
        Content(std::string::String),
        /// The Google Cloud Storage URI where the file content is located.
        /// This URI must be of the form: gs://bucket_name/object_name. For more
        /// details, see <https://cloud.google.com/storage/docs/reference-uris>.
        /// NOTE: Cloud Storage object versioning is not supported.
        GcsContentUri(std::string::String),
    }
}

/// Represents a sentence in the input document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sentence {
    /// The sentence text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub text: std::option::Option<crate::model::TextSpan>,

    /// For calls to [AnalyzeSentiment][] or if
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]
    /// is set to true, this field will contain the sentiment for the sentence.
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,
}

impl Sentence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::Sentence::text].
    pub fn set_text<T: std::convert::Into<std::option::Option<crate::model::TextSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::Sentence::sentiment].
    pub fn set_sentiment<T: std::convert::Into<std::option::Option<crate::model::Sentiment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }
}

impl wkt::message::Message for Sentence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentence"
    }
}

/// Represents a phrase in the text that is a known entity, such as
/// a person, an organization, or location. The API associates information, such
/// as probability and mentions, with entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entity {
    /// The representative name for the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The entity type.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity::Type,

    /// Metadata associated with the entity.
    ///
    /// For the metadata
    /// associated with other entity types, see the Type table below.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The mentions of this entity in the input document. The API currently
    /// supports proper noun mentions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mentions: std::vec::Vec<crate::model::EntityMention>,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the aggregate sentiment expressed
    /// for this entity in the provided document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,
}

impl Entity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_sentiment<T: std::convert::Into<std::option::Option<crate::model::Sentiment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }

    /// Sets the value of [mentions][crate::model::Entity::mentions].
    pub fn set_mentions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMention>,
    {
        use std::iter::Iterator;
        self.mentions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::Entity::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Entity"
    }
}

/// Defines additional types related to Entity
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the entity. The table
    /// below lists the associated fields for entities that have different
    /// metadata.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Type(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// Unknown
        pub const UNKNOWN: Type = Type::known("UNKNOWN", 0);

        /// Person
        pub const PERSON: Type = Type::known("PERSON", 1);

        /// Location
        pub const LOCATION: Type = Type::known("LOCATION", 2);

        /// Organization
        pub const ORGANIZATION: Type = Type::known("ORGANIZATION", 3);

        /// Event
        pub const EVENT: Type = Type::known("EVENT", 4);

        /// Artwork
        pub const WORK_OF_ART: Type = Type::known("WORK_OF_ART", 5);

        /// Consumer product
        pub const CONSUMER_GOOD: Type = Type::known("CONSUMER_GOOD", 6);

        /// Other types of entities
        pub const OTHER: Type = Type::known("OTHER", 7);

        /// Phone number
        ///
        /// The metadata lists the phone number, formatted according to local
        /// convention, plus whichever additional elements appear in the text:
        ///
        /// * `number` - the actual number, broken down into sections as per local
        ///   convention
        /// * `national_prefix` - country code, if detected
        /// * `area_code` - region or area code, if detected
        /// * `extension` - phone extension (to be dialed after connection), if
        ///   detected
        pub const PHONE_NUMBER: Type = Type::known("PHONE_NUMBER", 9);

        /// Address
        ///
        /// The metadata identifies the street number and locality plus whichever
        /// additional elements appear in the text:
        ///
        /// * `street_number` - street number
        /// * `locality` - city or town
        /// * `street_name` - street/route name, if detected
        /// * `postal_code` - postal code, if detected
        /// * `country` - country, if detected
        /// * `broad_region` - administrative area, such as the state, if detected
        /// * `narrow_region` - smaller administrative area, such as county, if
        ///   detected
        /// * `sublocality` - used in Asian addresses to demark a district within a
        ///   city, if detected
        pub const ADDRESS: Type = Type::known("ADDRESS", 10);

        /// Date
        ///
        /// The metadata identifies the components of the date:
        ///
        /// * `year` - four digit year, if detected
        /// * `month` - two digit month number, if detected
        /// * `day` - two digit day number, if detected
        pub const DATE: Type = Type::known("DATE", 11);

        /// Number
        ///
        /// The metadata is the number itself.
        pub const NUMBER: Type = Type::known("NUMBER", 12);

        /// Price
        ///
        /// The metadata identifies the `value` and `currency`.
        pub const PRICE: Type = Type::known("PRICE", 13);
    }

    impl Type {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Type::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Type::from(val)),
                Enumeration::UnknownNum { str } => Ok(Type::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "UNKNOWN" => r#type::UNKNOWN,
                "PERSON" => r#type::PERSON,
                "LOCATION" => r#type::LOCATION,
                "ORGANIZATION" => r#type::ORGANIZATION,
                "EVENT" => r#type::EVENT,
                "WORK_OF_ART" => r#type::WORK_OF_ART,
                "CONSUMER_GOOD" => r#type::CONSUMER_GOOD,
                "OTHER" => r#type::OTHER,
                "PHONE_NUMBER" => r#type::PHONE_NUMBER,
                "ADDRESS" => r#type::ADDRESS,
                "DATE" => r#type::DATE,
                "NUMBER" => r#type::NUMBER,
                "PRICE" => r#type::PRICE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => r#type::UNKNOWN,
                1 => r#type::PERSON,
                2 => r#type::LOCATION,
                3 => r#type::ORGANIZATION,
                4 => r#type::EVENT,
                5 => r#type::WORK_OF_ART,
                6 => r#type::CONSUMER_GOOD,
                7 => r#type::OTHER,
                9 => r#type::PHONE_NUMBER,
                10 => r#type::ADDRESS,
                11 => r#type::DATE,
                12 => r#type::NUMBER,
                13 => r#type::PRICE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Represents the feeling associated with the entire text or entities in
/// the text.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sentiment {
    /// A non-negative number in the [0, +inf) range, which represents
    /// the absolute magnitude of sentiment regardless of score (positive or
    /// negative).
    pub magnitude: f32,

    /// Sentiment score between -1.0 (negative sentiment) and 1.0
    /// (positive sentiment).
    pub score: f32,
}

impl Sentiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [magnitude][crate::model::Sentiment::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Sentiment::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for Sentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentiment"
    }
}

/// Represents a mention for an entity in the text. Currently, proper noun
/// mentions are supported.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMention {
    /// The mention text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub text: std::option::Option<crate::model::TextSpan>,

    /// The type of the entity mention.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity_mention::Type,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the sentiment expressed for this
    /// mention of the entity in the provided document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    /// Probability score associated with the entity.
    ///
    /// The score shows the probability of the entity mention being the entity
    /// type. The score is in (0, 1] range.
    pub probability: f32,
}

impl EntityMention {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::EntityMention::text].
    pub fn set_text<T: std::convert::Into<std::option::Option<crate::model::TextSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::EntityMention::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_mention::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::EntityMention::sentiment].
    pub fn set_sentiment<T: std::convert::Into<std::option::Option<crate::model::Sentiment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }

    /// Sets the value of [probability][crate::model::EntityMention::probability].
    pub fn set_probability<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.probability = v.into();
        self
    }
}

impl wkt::message::Message for EntityMention {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.EntityMention"
    }
}

/// Defines additional types related to EntityMention
pub mod entity_mention {
    #[allow(unused_imports)]
    use super::*;

    /// The supported types of mentions.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Type(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// Unknown
        pub const TYPE_UNKNOWN: Type = Type::known("TYPE_UNKNOWN", 0);

        /// Proper name
        pub const PROPER: Type = Type::known("PROPER", 1);

        /// Common noun (or noun compound)
        pub const COMMON: Type = Type::known("COMMON", 2);
    }

    impl Type {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Type::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Type::from(val)),
                Enumeration::UnknownNum { str } => Ok(Type::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "TYPE_UNKNOWN" => r#type::TYPE_UNKNOWN,
                "PROPER" => r#type::PROPER,
                "COMMON" => r#type::COMMON,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => r#type::TYPE_UNKNOWN,
                1 => r#type::PROPER,
                2 => r#type::COMMON,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Represents a text span in the input document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TextSpan {
    /// The content of the text span, which is a substring of the document.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// The API calculates the beginning offset of the content in the original
    /// document according to the
    /// [EncodingType][google.cloud.language.v2.EncodingType] specified in the API
    /// request.
    ///
    /// [google.cloud.language.v2.EncodingType]: crate::model::EncodingType
    pub begin_offset: i32,
}

impl TextSpan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::TextSpan::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [begin_offset][crate::model::TextSpan::begin_offset].
    pub fn set_begin_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.begin_offset = v.into();
        self
    }
}

impl wkt::message::Message for TextSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.TextSpan"
    }
}

/// Represents a category returned from the text classifier.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassificationCategory {
    /// The name of the category representing the document.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The classifier's confidence of the category. Number represents how certain
    /// the classifier is that this category represents the given text.
    pub confidence: f32,

    /// Optional. The classifier's severity of the category. This is only present
    /// when the ModerateTextRequest.ModelVersion is set to MODEL_VERSION_2, and
    /// the corresponding category has a severity score.
    pub severity: f32,
}

impl ClassificationCategory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ClassificationCategory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::ClassificationCategory::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::ClassificationCategory::severity].
    pub fn set_severity<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for ClassificationCategory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassificationCategory"
    }
}

/// The sentiment analysis request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeSentimentRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate sentence offsets.
    pub encoding_type: crate::model::EncodingType,
}

impl AnalyzeSentimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnalyzeSentimentRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeSentimentRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentRequest"
    }
}

/// The sentiment analysis response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeSentimentResponse {
    /// The overall sentiment of the input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// The sentiment for all the sentences in the document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl AnalyzeSentimentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document_sentiment][crate::model::AnalyzeSentimentResponse::document_sentiment].
    pub fn set_document_sentiment<
        T: std::convert::Into<std::option::Option<crate::model::Sentiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_sentiment = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::AnalyzeSentimentResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeSentimentResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [sentences][crate::model::AnalyzeSentimentResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentResponse"
    }
}

/// The entity analysis request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeEntitiesRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate offsets.
    pub encoding_type: crate::model::EncodingType,
}

impl AnalyzeEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnalyzeEntitiesRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeEntitiesRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesRequest"
    }
}

/// The entity analysis response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeEntitiesResponse {
    /// The recognized entities in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl AnalyzeEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::AnalyzeEntitiesResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeEntitiesResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::AnalyzeEntitiesResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesResponse"
    }
}

/// The document classification request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassifyTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,
}

impl ClassifyTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::ClassifyTextRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }
}

impl wkt::message::Message for ClassifyTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextRequest"
    }
}

/// The document classification response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassifyTextResponse {
    /// Categories representing the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl ClassifyTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::ClassifyTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ClassifyTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::ClassifyTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClassifyTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextResponse"
    }
}

/// The document moderation request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModerateTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// Optional. The model version to use for ModerateText.
    pub model_version: crate::model::moderate_text_request::ModelVersion,
}

impl ModerateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::ModerateTextRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [model_version][crate::model::ModerateTextRequest::model_version].
    pub fn set_model_version<
        T: std::convert::Into<crate::model::moderate_text_request::ModelVersion>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_version = v.into();
        self
    }
}

impl wkt::message::Message for ModerateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextRequest"
    }
}

/// Defines additional types related to ModerateTextRequest
pub mod moderate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// The model version to use for ModerateText.
    #[derive(Clone, Debug, PartialEq)]
    pub struct ModelVersion(wkt::enumerations::Enumeration);

    /// Useful constants to work with [ModelVersion](ModelVersion)
    pub mod model_version {
        use super::ModelVersion;

        /// The default model version.
        pub const MODEL_VERSION_UNSPECIFIED: ModelVersion =
            ModelVersion::known("MODEL_VERSION_UNSPECIFIED", 0);

        /// Use the v1 model, this model is used by default when not provided.
        /// The v1 model only returns probability (confidence) score for each
        /// category.
        pub const MODEL_VERSION_1: ModelVersion = ModelVersion::known("MODEL_VERSION_1", 1);

        /// Use the v2 model.
        /// The v2 model only returns probability (confidence) score for each
        /// category, and returns severity score for a subset of the categories.
        pub const MODEL_VERSION_2: ModelVersion = ModelVersion::known("MODEL_VERSION_2", 2);
    }

    impl ModelVersion {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for ModelVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(ModelVersion::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(ModelVersion::from(val)),
                Enumeration::UnknownNum { str } => Ok(ModelVersion::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for ModelVersion {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "MODEL_VERSION_UNSPECIFIED" => model_version::MODEL_VERSION_UNSPECIFIED,
                "MODEL_VERSION_1" => model_version::MODEL_VERSION_1,
                "MODEL_VERSION_2" => model_version::MODEL_VERSION_2,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for ModelVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => model_version::MODEL_VERSION_UNSPECIFIED,
                1 => model_version::MODEL_VERSION_1,
                2 => model_version::MODEL_VERSION_2,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for ModelVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// The document moderation response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModerateTextResponse {
    /// Harmful and sensitive categories representing the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl ModerateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::ModerateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ModerateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [moderation_categories][crate::model::ModerateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModerateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextResponse"
    }
}

/// The request message for the text annotation API, which can perform multiple
/// analysis types in one call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// Required. The enabled features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub features: std::option::Option<crate::model::annotate_text_request::Features>,

    /// The encoding type used by the API to calculate offsets.
    pub encoding_type: crate::model::EncodingType,
}

impl AnnotateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnnotateTextRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [features][crate::model::AnnotateTextRequest::features].
    pub fn set_features<
        T: std::convert::Into<std::option::Option<crate::model::annotate_text_request::Features>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.features = v.into();
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnnotateTextRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnnotateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest"
    }
}

/// Defines additional types related to AnnotateTextRequest
pub mod annotate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// All available features.
    /// Setting each one to true will enable that specific analysis for the input.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Features {
        /// Optional. Extract entities.
        pub extract_entities: bool,

        /// Optional. Extract document-level sentiment.
        pub extract_document_sentiment: bool,

        /// Optional. Classify the full document into categories.
        pub classify_text: bool,

        /// Optional. Moderate the document for harmful and sensitive categories.
        pub moderate_text: bool,
    }

    impl Features {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [extract_entities][crate::model::annotate_text_request::Features::extract_entities].
        pub fn set_extract_entities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_entities = v.into();
            self
        }

        /// Sets the value of [extract_document_sentiment][crate::model::annotate_text_request::Features::extract_document_sentiment].
        pub fn set_extract_document_sentiment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_document_sentiment = v.into();
            self
        }

        /// Sets the value of [classify_text][crate::model::annotate_text_request::Features::classify_text].
        pub fn set_classify_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.classify_text = v.into();
            self
        }

        /// Sets the value of [moderate_text][crate::model::annotate_text_request::Features::moderate_text].
        pub fn set_moderate_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.moderate_text = v.into();
            self
        }
    }

    impl wkt::message::Message for Features {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest.Features"
        }
    }
}

/// The text annotations response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateTextResponse {
    /// Sentences in the input document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Entities, along with their semantic information, in the input document.
    /// Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]
    /// or
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]: crate::model::annotate_text_request::Features::extract_entities
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The overall sentiment for the document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Categories identified in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Harmful and sensitive categories identified in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Whether the language is officially supported by all requested features.
    /// The API may still return a response when the language is not supported, but
    /// it is on a best effort basis.
    pub language_supported: bool,
}

impl AnnotateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document_sentiment][crate::model::AnnotateTextResponse::document_sentiment].
    pub fn set_document_sentiment<
        T: std::convert::Into<std::option::Option<crate::model::Sentiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_sentiment = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::AnnotateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnnotateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [sentences][crate::model::AnnotateTextResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entities][crate::model::AnnotateTextResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [categories][crate::model::AnnotateTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [moderation_categories][crate::model::AnnotateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextResponse"
    }
}

/// Represents the text encoding that the caller uses to process the output.
/// Providing an `EncodingType` is recommended because the API provides the
/// beginning offsets for various outputs, such as tokens and mentions, and
/// languages that natively use different text encodings may access offsets
/// differently.
#[derive(Clone, Debug, PartialEq)]
pub struct EncodingType(wkt::enumerations::Enumeration);

/// Useful constants to work with [EncodingType](EncodingType)
pub mod encoding_type {
    use super::EncodingType;

    /// If `EncodingType` is not specified, encoding-dependent information (such as
    /// `begin_offset`) will be set at `-1`.
    pub const NONE: EncodingType = EncodingType::known("NONE", 0);

    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-8 encoding of the input. C++ and Go are examples of languages
    /// that use this encoding natively.
    pub const UTF8: EncodingType = EncodingType::known("UTF8", 1);

    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-16 encoding of the input. Java and JavaScript are examples of
    /// languages that use this encoding natively.
    pub const UTF16: EncodingType = EncodingType::known("UTF16", 2);

    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-32 encoding of the input. Python is an example of a language
    /// that uses this encoding natively.
    pub const UTF32: EncodingType = EncodingType::known("UTF32", 3);
}

impl EncodingType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for EncodingType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for EncodingType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(EncodingType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(EncodingType::from(val)),
            Enumeration::UnknownNum { str } => Ok(EncodingType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for EncodingType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "NONE" => encoding_type::NONE,
            "UTF8" => encoding_type::UTF8,
            "UTF16" => encoding_type::UTF16,
            "UTF32" => encoding_type::UTF32,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for EncodingType {
    fn from(value: i32) -> Self {
        match value {
            0 => encoding_type::NONE,
            1 => encoding_type::UTF8,
            2 => encoding_type::UTF16,
            3 => encoding_type::UTF32,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for EncodingType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}
