// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::invalid_html_tags)]
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the input to API methods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Document {
    /// Required. If the type is not set or is `TYPE_UNSPECIFIED`,
    /// returns an `INVALID_ARGUMENT` error.
    #[serde(rename = "type")]
    pub r#type: crate::model::document::Type,

    /// Optional. The language of the document (if not specified, the language is
    /// automatically detected). Both ISO and BCP-47 language codes are
    /// accepted.\<br\>
    /// [Language
    /// Support](https://cloud.google.com/natural-language/docs/languages) lists
    /// currently supported languages for each API method. If the language (either
    /// specified by the caller or automatically detected) is not supported by the
    /// called API method, an `INVALID_ARGUMENT` error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::document::Source>,
}

impl Document {
    /// Sets the value of [r#type][crate::model::Document::type].
    pub fn set_type<T: std::convert::Into<crate::model::document::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Document::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for Document {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Document"
    }
}

/// Defines additional types related to Document
pub mod document {
    #[allow(unused_imports)]
    use super::*;

    /// The document types enum.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::string::String);

    impl Type {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {

        /// The content type is not specified.
        pub const TYPE_UNSPECIFIED: &str = "TYPE_UNSPECIFIED";

        /// Plain text
        pub const PLAIN_TEXT: &str = "PLAIN_TEXT";

        /// HTML
        pub const HTML: &str = "HTML";
    }

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The content of the input in string format.
        /// Cloud audit logging exempt since it is based on user data.
        Content(std::string::String),
        /// The Google Cloud Storage URI where the file content is located.
        /// This URI must be of the form: gs://bucket_name/object_name. For more
        /// details, see <https://cloud.google.com/storage/docs/reference-uris>.
        /// NOTE: Cloud Storage object versioning is not supported.
        GcsContentUri(std::string::String),
    }
}

/// Represents a sentence in the input document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sentence {
    /// The sentence text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub text: std::option::Option<crate::model::TextSpan>,

    /// For calls to [AnalyzeSentiment][] or if
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]
    /// is set to true, this field will contain the sentiment for the sentence.
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,
}

impl Sentence {
    /// Sets the value of [text][crate::model::Sentence::text].
    pub fn set_text<T: std::convert::Into<std::option::Option<crate::model::TextSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::Sentence::sentiment].
    pub fn set_sentiment<T: std::convert::Into<std::option::Option<crate::model::Sentiment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }
}

impl wkt::message::Message for Sentence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentence"
    }
}

/// Represents a phrase in the text that is a known entity, such as
/// a person, an organization, or location. The API associates information, such
/// as probability and mentions, with entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entity {
    /// The representative name for the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The entity type.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity::Type,

    /// Metadata associated with the entity.
    ///
    /// For the metadata
    /// associated with other entity types, see the Type table below.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The mentions of this entity in the input document. The API currently
    /// supports proper noun mentions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mentions: std::vec::Vec<crate::model::EntityMention>,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the aggregate sentiment expressed
    /// for this entity in the provided document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,
}

impl Entity {
    /// Sets the value of [name][crate::model::Entity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_sentiment<T: std::convert::Into<std::option::Option<crate::model::Sentiment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }

    /// Sets the value of [mentions][crate::model::Entity::mentions].
    pub fn set_mentions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMention>,
    {
        use std::iter::Iterator;
        self.mentions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::Entity::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Entity"
    }
}

/// Defines additional types related to Entity
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the entity. The table
    /// below lists the associated fields for entities that have different
    /// metadata.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::string::String);

    impl Type {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {

        /// Unknown
        pub const UNKNOWN: &str = "UNKNOWN";

        /// Person
        pub const PERSON: &str = "PERSON";

        /// Location
        pub const LOCATION: &str = "LOCATION";

        /// Organization
        pub const ORGANIZATION: &str = "ORGANIZATION";

        /// Event
        pub const EVENT: &str = "EVENT";

        /// Artwork
        pub const WORK_OF_ART: &str = "WORK_OF_ART";

        /// Consumer product
        pub const CONSUMER_GOOD: &str = "CONSUMER_GOOD";

        /// Other types of entities
        pub const OTHER: &str = "OTHER";

        /// Phone number
        ///
        /// The metadata lists the phone number, formatted according to local
        /// convention, plus whichever additional elements appear in the text:
        ///
        /// * `number` - the actual number, broken down into sections as per local
        ///   convention
        /// * `national_prefix` - country code, if detected
        /// * `area_code` - region or area code, if detected
        /// * `extension` - phone extension (to be dialed after connection), if
        ///   detected
        pub const PHONE_NUMBER: &str = "PHONE_NUMBER";

        /// Address
        ///
        /// The metadata identifies the street number and locality plus whichever
        /// additional elements appear in the text:
        ///
        /// * `street_number` - street number
        /// * `locality` - city or town
        /// * `street_name` - street/route name, if detected
        /// * `postal_code` - postal code, if detected
        /// * `country` - country, if detected
        /// * `broad_region` - administrative area, such as the state, if detected
        /// * `narrow_region` - smaller administrative area, such as county, if
        ///   detected
        /// * `sublocality` - used in Asian addresses to demark a district within a
        ///   city, if detected
        pub const ADDRESS: &str = "ADDRESS";

        /// Date
        ///
        /// The metadata identifies the components of the date:
        ///
        /// * `year` - four digit year, if detected
        /// * `month` - two digit month number, if detected
        /// * `day` - two digit day number, if detected
        pub const DATE: &str = "DATE";

        /// Number
        ///
        /// The metadata is the number itself.
        pub const NUMBER: &str = "NUMBER";

        /// Price
        ///
        /// The metadata identifies the `value` and `currency`.
        pub const PRICE: &str = "PRICE";
    }
}

/// Represents the feeling associated with the entire text or entities in
/// the text.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sentiment {
    /// A non-negative number in the [0, +inf) range, which represents
    /// the absolute magnitude of sentiment regardless of score (positive or
    /// negative).
    pub magnitude: f32,

    /// Sentiment score between -1.0 (negative sentiment) and 1.0
    /// (positive sentiment).
    pub score: f32,
}

impl Sentiment {
    /// Sets the value of [magnitude][crate::model::Sentiment::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Sentiment::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for Sentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentiment"
    }
}

/// Represents a mention for an entity in the text. Currently, proper noun
/// mentions are supported.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMention {
    /// The mention text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub text: std::option::Option<crate::model::TextSpan>,

    /// The type of the entity mention.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity_mention::Type,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the sentiment expressed for this
    /// mention of the entity in the provided document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    /// Probability score associated with the entity.
    ///
    /// The score shows the probability of the entity mention being the entity
    /// type. The score is in (0, 1] range.
    pub probability: f32,
}

impl EntityMention {
    /// Sets the value of [text][crate::model::EntityMention::text].
    pub fn set_text<T: std::convert::Into<std::option::Option<crate::model::TextSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::EntityMention::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_mention::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::EntityMention::sentiment].
    pub fn set_sentiment<T: std::convert::Into<std::option::Option<crate::model::Sentiment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }

    /// Sets the value of [probability][crate::model::EntityMention::probability].
    pub fn set_probability<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.probability = v.into();
        self
    }
}

impl wkt::message::Message for EntityMention {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.EntityMention"
    }
}

/// Defines additional types related to EntityMention
pub mod entity_mention {
    #[allow(unused_imports)]
    use super::*;

    /// The supported types of mentions.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::string::String);

    impl Type {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {

        /// Unknown
        pub const TYPE_UNKNOWN: &str = "TYPE_UNKNOWN";

        /// Proper name
        pub const PROPER: &str = "PROPER";

        /// Common noun (or noun compound)
        pub const COMMON: &str = "COMMON";
    }
}

/// Represents a text span in the input document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TextSpan {
    /// The content of the text span, which is a substring of the document.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// The API calculates the beginning offset of the content in the original
    /// document according to the
    /// [EncodingType][google.cloud.language.v2.EncodingType] specified in the API
    /// request.
    ///
    /// [google.cloud.language.v2.EncodingType]: crate::model::EncodingType
    pub begin_offset: i32,
}

impl TextSpan {
    /// Sets the value of [content][crate::model::TextSpan::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [begin_offset][crate::model::TextSpan::begin_offset].
    pub fn set_begin_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.begin_offset = v.into();
        self
    }
}

impl wkt::message::Message for TextSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.TextSpan"
    }
}

/// Represents a category returned from the text classifier.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassificationCategory {
    /// The name of the category representing the document.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The classifier's confidence of the category. Number represents how certain
    /// the classifier is that this category represents the given text.
    pub confidence: f32,

    /// Optional. The classifier's severity of the category. This is only present
    /// when the ModerateTextRequest.ModelVersion is set to MODEL_VERSION_2, and
    /// the corresponding category has a severity score.
    pub severity: f32,
}

impl ClassificationCategory {
    /// Sets the value of [name][crate::model::ClassificationCategory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::ClassificationCategory::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::ClassificationCategory::severity].
    pub fn set_severity<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for ClassificationCategory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassificationCategory"
    }
}

/// The sentiment analysis request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeSentimentRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate sentence offsets.
    pub encoding_type: crate::model::EncodingType,
}

impl AnalyzeSentimentRequest {
    /// Sets the value of [document][crate::model::AnalyzeSentimentRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeSentimentRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentRequest"
    }
}

/// The sentiment analysis response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeSentimentResponse {
    /// The overall sentiment of the input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// The sentiment for all the sentences in the document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl AnalyzeSentimentResponse {
    /// Sets the value of [document_sentiment][crate::model::AnalyzeSentimentResponse::document_sentiment].
    pub fn set_document_sentiment<
        T: std::convert::Into<std::option::Option<crate::model::Sentiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_sentiment = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::AnalyzeSentimentResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeSentimentResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [sentences][crate::model::AnalyzeSentimentResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentResponse"
    }
}

/// The entity analysis request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeEntitiesRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate offsets.
    pub encoding_type: crate::model::EncodingType,
}

impl AnalyzeEntitiesRequest {
    /// Sets the value of [document][crate::model::AnalyzeEntitiesRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeEntitiesRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesRequest"
    }
}

/// The entity analysis response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeEntitiesResponse {
    /// The recognized entities in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl AnalyzeEntitiesResponse {
    /// Sets the value of [language_code][crate::model::AnalyzeEntitiesResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeEntitiesResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::AnalyzeEntitiesResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesResponse"
    }
}

/// The document classification request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassifyTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,
}

impl ClassifyTextRequest {
    /// Sets the value of [document][crate::model::ClassifyTextRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }
}

impl wkt::message::Message for ClassifyTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextRequest"
    }
}

/// The document classification response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassifyTextResponse {
    /// Categories representing the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl ClassifyTextResponse {
    /// Sets the value of [language_code][crate::model::ClassifyTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ClassifyTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::ClassifyTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClassifyTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextResponse"
    }
}

/// The document moderation request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModerateTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// Optional. The model version to use for ModerateText.
    pub model_version: crate::model::moderate_text_request::ModelVersion,
}

impl ModerateTextRequest {
    /// Sets the value of [document][crate::model::ModerateTextRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [model_version][crate::model::ModerateTextRequest::model_version].
    pub fn set_model_version<
        T: std::convert::Into<crate::model::moderate_text_request::ModelVersion>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_version = v.into();
        self
    }
}

impl wkt::message::Message for ModerateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextRequest"
    }
}

/// Defines additional types related to ModerateTextRequest
pub mod moderate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// The model version to use for ModerateText.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ModelVersion(std::string::String);

    impl ModelVersion {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ModelVersion](ModelVersion)
    pub mod model_version {

        /// The default model version.
        pub const MODEL_VERSION_UNSPECIFIED: &str = "MODEL_VERSION_UNSPECIFIED";

        /// Use the v1 model, this model is used by default when not provided.
        /// The v1 model only returns probability (confidence) score for each
        /// category.
        pub const MODEL_VERSION_1: &str = "MODEL_VERSION_1";

        /// Use the v2 model.
        /// The v2 model only returns probability (confidence) score for each
        /// category, and returns severity score for a subset of the categories.
        pub const MODEL_VERSION_2: &str = "MODEL_VERSION_2";
    }
}

/// The document moderation response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModerateTextResponse {
    /// Harmful and sensitive categories representing the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,
}

impl ModerateTextResponse {
    /// Sets the value of [language_code][crate::model::ModerateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ModerateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [moderation_categories][crate::model::ModerateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModerateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextResponse"
    }
}

/// The request message for the text annotation API, which can perform multiple
/// analysis types in one call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// Required. The enabled features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub features: std::option::Option<crate::model::annotate_text_request::Features>,

    /// The encoding type used by the API to calculate offsets.
    pub encoding_type: crate::model::EncodingType,
}

impl AnnotateTextRequest {
    /// Sets the value of [document][crate::model::AnnotateTextRequest::document].
    pub fn set_document<T: std::convert::Into<std::option::Option<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.document = v.into();
        self
    }

    /// Sets the value of [features][crate::model::AnnotateTextRequest::features].
    pub fn set_features<
        T: std::convert::Into<std::option::Option<crate::model::annotate_text_request::Features>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.features = v.into();
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnnotateTextRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnnotateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest"
    }
}

/// Defines additional types related to AnnotateTextRequest
pub mod annotate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// All available features.
    /// Setting each one to true will enable that specific analysis for the input.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Features {
        /// Optional. Extract entities.
        pub extract_entities: bool,

        /// Optional. Extract document-level sentiment.
        pub extract_document_sentiment: bool,

        /// Optional. Classify the full document into categories.
        pub classify_text: bool,

        /// Optional. Moderate the document for harmful and sensitive categories.
        pub moderate_text: bool,
    }

    impl Features {
        /// Sets the value of [extract_entities][crate::model::annotate_text_request::Features::extract_entities].
        pub fn set_extract_entities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_entities = v.into();
            self
        }

        /// Sets the value of [extract_document_sentiment][crate::model::annotate_text_request::Features::extract_document_sentiment].
        pub fn set_extract_document_sentiment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_document_sentiment = v.into();
            self
        }

        /// Sets the value of [classify_text][crate::model::annotate_text_request::Features::classify_text].
        pub fn set_classify_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.classify_text = v.into();
            self
        }

        /// Sets the value of [moderate_text][crate::model::annotate_text_request::Features::moderate_text].
        pub fn set_moderate_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.moderate_text = v.into();
            self
        }
    }

    impl wkt::message::Message for Features {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest.Features"
        }
    }
}

/// The text annotations response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateTextResponse {
    /// Sentences in the input document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Entities, along with their semantic information, in the input document.
    /// Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]
    /// or
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]: crate::model::annotate_text_request::Features::extract_entities
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The overall sentiment for the document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Categories identified in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Harmful and sensitive categories identified in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Whether the language is officially supported by all requested features.
    /// The API may still return a response when the language is not supported, but
    /// it is on a best effort basis.
    pub language_supported: bool,
}

impl AnnotateTextResponse {
    /// Sets the value of [document_sentiment][crate::model::AnnotateTextResponse::document_sentiment].
    pub fn set_document_sentiment<
        T: std::convert::Into<std::option::Option<crate::model::Sentiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_sentiment = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::AnnotateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnnotateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }

    /// Sets the value of [sentences][crate::model::AnnotateTextResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entities][crate::model::AnnotateTextResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [categories][crate::model::AnnotateTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [moderation_categories][crate::model::AnnotateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextResponse"
    }
}

/// Represents the text encoding that the caller uses to process the output.
/// Providing an `EncodingType` is recommended because the API provides the
/// beginning offsets for various outputs, such as tokens and mentions, and
/// languages that natively use different text encodings may access offsets
/// differently.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct EncodingType(std::string::String);

impl EncodingType {
    /// Sets the enum value.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.0 = v.into();
        self
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [EncodingType](EncodingType)
pub mod encoding_type {

    /// If `EncodingType` is not specified, encoding-dependent information (such as
    /// `begin_offset`) will be set at `-1`.
    pub const NONE: &str = "NONE";

    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-8 encoding of the input. C++ and Go are examples of languages
    /// that use this encoding natively.
    pub const UTF8: &str = "UTF8";

    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-16 encoding of the input. Java and JavaScript are examples of
    /// languages that use this encoding natively.
    pub const UTF16: &str = "UTF16";

    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-32 encoding of the input. Python is an example of a language
    /// that uses this encoding natively.
    pub const UTF32: &str = "UTF32";
}
