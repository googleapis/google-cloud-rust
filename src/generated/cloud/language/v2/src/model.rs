// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the input to API methods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Document {
    /// Required. If the type is not set or is `TYPE_UNSPECIFIED`,
    /// returns an `INVALID_ARGUMENT` error.
    pub r#type: crate::model::document::Type,

    /// Optional. The language of the document (if not specified, the language is
    /// automatically detected). Both ISO and BCP-47 language codes are
    /// accepted.\<br\>
    /// [Language
    /// Support](https://cloud.google.com/natural-language/docs/languages) lists
    /// currently supported languages for each API method. If the language (either
    /// specified by the caller or automatically detected) is not supported by the
    /// called API method, an `INVALID_ARGUMENT` error is returned.
    pub language_code: std::string::String,

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    pub source: std::option::Option<crate::model::document::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Document {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Document::type].
    pub fn set_type<T: std::convert::Into<crate::model::document::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Document::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Document::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(crate::model::document::Source::Content(v.into()));
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `GcsContentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_content_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::GcsContentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `GcsContentUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_content_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::document::Source::GcsContentUri(v.into()));
        self
    }
}

impl wkt::message::Message for Document {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Document"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Document {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __content,
            __gcs_content_uri,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Document")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "content" => Ok(__FieldTag::__content),
                            "gcsContentUri" => Ok(__FieldTag::__gcs_content_uri),
                            "gcs_content_uri" => Ok(__FieldTag::__gcs_content_uri),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Document;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Document")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::document::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.language.v2.Document.content, latest field was content",
                                ));
                            }
                            result.source =
                                std::option::Option::Some(crate::model::document::Source::Content(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__gcs_content_uri => {
                            if !fields.insert(__FieldTag::__gcs_content_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_content_uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.language.v2.Document.gcs_content_uri, latest field was gcsContentUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::document::Source::GcsContentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Document {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.content() {
            state.serialize_entry("content", value)?;
        }
        if let Some(value) = self.gcs_content_uri() {
            state.serialize_entry("gcsContentUri", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Document {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Document");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("source", &self.source);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Document].
pub mod document {
    #[allow(unused_imports)]
    use super::*;

    /// The document types enum.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The content type is not specified.
        Unspecified,
        /// Plain text
        PlainText,
        /// HTML
        Html,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PlainText => std::option::Option::Some(1),
                Self::Html => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::PlainText => std::option::Option::Some("PLAIN_TEXT"),
                Self::Html => std::option::Option::Some("HTML"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PlainText,
                2 => Self::Html,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PLAIN_TEXT" => Self::PlainText,
                "HTML" => Self::Html,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PlainText => serializer.serialize_i32(1),
                Self::Html => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.language.v2.Document.Type",
            ))
        }
    }

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The content of the input in string format.
        /// Cloud audit logging exempt since it is based on user data.
        Content(std::string::String),
        /// The Google Cloud Storage URI where the file content is located.
        /// This URI must be of the form: gs://bucket_name/object_name. For more
        /// details, see <https://cloud.google.com/storage/docs/reference-uris>.
        /// NOTE: Cloud Storage object versioning is not supported.
        GcsContentUri(std::string::String),
    }
}

/// Represents a sentence in the input document.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Sentence {
    /// The sentence text.
    pub text: std::option::Option<crate::model::TextSpan>,

    /// For calls to [AnalyzeSentiment][] or if
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]
    /// is set to true, this field will contain the sentiment for the sentence.
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sentence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::Sentence::text].
    pub fn set_text<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [text][crate::model::Sentence::text].
    pub fn set_or_clear_text<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sentiment][crate::model::Sentence::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::Sentence::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Sentence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Sentence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sentence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "sentiment" => Ok(__FieldTag::__sentiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Sentence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sentence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text =
                                map.next_value::<std::option::Option<crate::model::TextSpan>>()?;
                        }
                        __FieldTag::__sentiment => {
                            if !fields.insert(__FieldTag::__sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment",
                                ));
                            }
                            result.sentiment =
                                map.next_value::<std::option::Option<crate::model::Sentiment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Sentence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.text.is_some() {
            state.serialize_entry("text", &self.text)?;
        }
        if self.sentiment.is_some() {
            state.serialize_entry("sentiment", &self.sentiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Sentence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Sentence");
        debug_struct.field("text", &self.text);
        debug_struct.field("sentiment", &self.sentiment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a phrase in the text that is a known entity, such as
/// a person, an organization, or location. The API associates information, such
/// as probability and mentions, with entities.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Entity {
    /// The representative name for the entity.
    pub name: std::string::String,

    /// The entity type.
    pub r#type: crate::model::entity::Type,

    /// Metadata associated with the entity.
    ///
    /// For the metadata
    /// associated with other entity types, see the Type table below.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The mentions of this entity in the input document. The API currently
    /// supports proper noun mentions.
    pub mentions: std::vec::Vec<crate::model::EntityMention>,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the aggregate sentiment expressed
    /// for this entity in the provided document.
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Entity::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [mentions][crate::model::Entity::mentions].
    pub fn set_mentions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMention>,
    {
        use std::iter::Iterator;
        self.mentions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Entity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __metadata,
            __mentions,
            __sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "mentions" => Ok(__FieldTag::__mentions),
                            "sentiment" => Ok(__FieldTag::__sentiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::entity::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mentions => {
                            if !fields.insert(__FieldTag::__mentions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mentions",
                                ));
                            }
                            result.mentions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityMention>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sentiment => {
                            if !fields.insert(__FieldTag::__sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment",
                                ));
                            }
                            result.sentiment =
                                map.next_value::<std::option::Option<crate::model::Sentiment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.mentions.is_empty() {
            state.serialize_entry("mentions", &self.mentions)?;
        }
        if self.sentiment.is_some() {
            state.serialize_entry("sentiment", &self.sentiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Entity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entity");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("mentions", &self.mentions);
        debug_struct.field("sentiment", &self.sentiment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Entity].
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the entity. The table
    /// below lists the associated fields for entities that have different
    /// metadata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unknown
        Unknown,
        /// Person
        Person,
        /// Location
        Location,
        /// Organization
        Organization,
        /// Event
        Event,
        /// Artwork
        WorkOfArt,
        /// Consumer product
        ConsumerGood,
        /// Other types of entities
        Other,
        /// Phone number
        ///
        /// The metadata lists the phone number, formatted according to local
        /// convention, plus whichever additional elements appear in the text:
        ///
        /// * `number` - the actual number, broken down into sections as per local
        ///   convention
        /// * `national_prefix` - country code, if detected
        /// * `area_code` - region or area code, if detected
        /// * `extension` - phone extension (to be dialed after connection), if
        ///   detected
        PhoneNumber,
        /// Address
        ///
        /// The metadata identifies the street number and locality plus whichever
        /// additional elements appear in the text:
        ///
        /// * `street_number` - street number
        /// * `locality` - city or town
        /// * `street_name` - street/route name, if detected
        /// * `postal_code` - postal code, if detected
        /// * `country` - country, if detected
        /// * `broad_region` - administrative area, such as the state, if detected
        /// * `narrow_region` - smaller administrative area, such as county, if
        ///   detected
        /// * `sublocality` - used in Asian addresses to demark a district within a
        ///   city, if detected
        Address,
        /// Date
        ///
        /// The metadata identifies the components of the date:
        ///
        /// * `year` - four digit year, if detected
        /// * `month` - two digit month number, if detected
        /// * `day` - two digit day number, if detected
        Date,
        /// Number
        ///
        /// The metadata is the number itself.
        Number,
        /// Price
        ///
        /// The metadata identifies the `value` and `currency`.
        Price,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Person => std::option::Option::Some(1),
                Self::Location => std::option::Option::Some(2),
                Self::Organization => std::option::Option::Some(3),
                Self::Event => std::option::Option::Some(4),
                Self::WorkOfArt => std::option::Option::Some(5),
                Self::ConsumerGood => std::option::Option::Some(6),
                Self::Other => std::option::Option::Some(7),
                Self::PhoneNumber => std::option::Option::Some(9),
                Self::Address => std::option::Option::Some(10),
                Self::Date => std::option::Option::Some(11),
                Self::Number => std::option::Option::Some(12),
                Self::Price => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Person => std::option::Option::Some("PERSON"),
                Self::Location => std::option::Option::Some("LOCATION"),
                Self::Organization => std::option::Option::Some("ORGANIZATION"),
                Self::Event => std::option::Option::Some("EVENT"),
                Self::WorkOfArt => std::option::Option::Some("WORK_OF_ART"),
                Self::ConsumerGood => std::option::Option::Some("CONSUMER_GOOD"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::PhoneNumber => std::option::Option::Some("PHONE_NUMBER"),
                Self::Address => std::option::Option::Some("ADDRESS"),
                Self::Date => std::option::Option::Some("DATE"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Price => std::option::Option::Some("PRICE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Person,
                2 => Self::Location,
                3 => Self::Organization,
                4 => Self::Event,
                5 => Self::WorkOfArt,
                6 => Self::ConsumerGood,
                7 => Self::Other,
                9 => Self::PhoneNumber,
                10 => Self::Address,
                11 => Self::Date,
                12 => Self::Number,
                13 => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "PERSON" => Self::Person,
                "LOCATION" => Self::Location,
                "ORGANIZATION" => Self::Organization,
                "EVENT" => Self::Event,
                "WORK_OF_ART" => Self::WorkOfArt,
                "CONSUMER_GOOD" => Self::ConsumerGood,
                "OTHER" => Self::Other,
                "PHONE_NUMBER" => Self::PhoneNumber,
                "ADDRESS" => Self::Address,
                "DATE" => Self::Date,
                "NUMBER" => Self::Number,
                "PRICE" => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Person => serializer.serialize_i32(1),
                Self::Location => serializer.serialize_i32(2),
                Self::Organization => serializer.serialize_i32(3),
                Self::Event => serializer.serialize_i32(4),
                Self::WorkOfArt => serializer.serialize_i32(5),
                Self::ConsumerGood => serializer.serialize_i32(6),
                Self::Other => serializer.serialize_i32(7),
                Self::PhoneNumber => serializer.serialize_i32(9),
                Self::Address => serializer.serialize_i32(10),
                Self::Date => serializer.serialize_i32(11),
                Self::Number => serializer.serialize_i32(12),
                Self::Price => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.language.v2.Entity.Type",
            ))
        }
    }
}

/// Represents the feeling associated with the entire text or entities in
/// the text.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Sentiment {
    /// A non-negative number in the [0, +inf) range, which represents
    /// the absolute magnitude of sentiment regardless of score (positive or
    /// negative).
    pub magnitude: f32,

    /// Sentiment score between -1.0 (negative sentiment) and 1.0
    /// (positive sentiment).
    pub score: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sentiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [magnitude][crate::model::Sentiment::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Sentiment::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for Sentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentiment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Sentiment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __magnitude,
            __score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sentiment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "magnitude" => Ok(__FieldTag::__magnitude),
                            "score" => Ok(__FieldTag::__score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Sentiment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sentiment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__magnitude => {
                            if !fields.insert(__FieldTag::__magnitude) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for magnitude",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.magnitude = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Sentiment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.magnitude) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("magnitude", &__With(&self.magnitude))?;
        }
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Sentiment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Sentiment");
        debug_struct.field("magnitude", &self.magnitude);
        debug_struct.field("score", &self.score);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a mention for an entity in the text. Currently, proper noun
/// mentions are supported.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityMention {
    /// The mention text.
    pub text: std::option::Option<crate::model::TextSpan>,

    /// The type of the entity mention.
    pub r#type: crate::model::entity_mention::Type,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the sentiment expressed for this
    /// mention of the entity in the provided document.
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    /// Probability score associated with the entity.
    ///
    /// The score shows the probability of the entity mention being the entity
    /// type. The score is in (0, 1] range.
    pub probability: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMention {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::EntityMention::text].
    pub fn set_text<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [text][crate::model::EntityMention::text].
    pub fn set_or_clear_text<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::EntityMention::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_mention::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::EntityMention::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::EntityMention::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [probability][crate::model::EntityMention::probability].
    pub fn set_probability<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.probability = v.into();
        self
    }
}

impl wkt::message::Message for EntityMention {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.EntityMention"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityMention {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __type,
            __sentiment,
            __probability,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityMention")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "type" => Ok(__FieldTag::__type),
                            "sentiment" => Ok(__FieldTag::__sentiment),
                            "probability" => Ok(__FieldTag::__probability),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityMention;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityMention")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text =
                                map.next_value::<std::option::Option<crate::model::TextSpan>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::entity_mention::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sentiment => {
                            if !fields.insert(__FieldTag::__sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment",
                                ));
                            }
                            result.sentiment =
                                map.next_value::<std::option::Option<crate::model::Sentiment>>()?;
                        }
                        __FieldTag::__probability => {
                            if !fields.insert(__FieldTag::__probability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for probability",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.probability = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityMention {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.text.is_some() {
            state.serialize_entry("text", &self.text)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.sentiment.is_some() {
            state.serialize_entry("sentiment", &self.sentiment)?;
        }
        if !wkt::internal::is_default(&self.probability) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("probability", &__With(&self.probability))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityMention {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMention");
        debug_struct.field("text", &self.text);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("sentiment", &self.sentiment);
        debug_struct.field("probability", &self.probability);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EntityMention].
pub mod entity_mention {
    #[allow(unused_imports)]
    use super::*;

    /// The supported types of mentions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unknown
        Unknown,
        /// Proper name
        Proper,
        /// Common noun (or noun compound)
        Common,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Proper => std::option::Option::Some(1),
                Self::Common => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("TYPE_UNKNOWN"),
                Self::Proper => std::option::Option::Some("PROPER"),
                Self::Common => std::option::Option::Some("COMMON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Proper,
                2 => Self::Common,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNKNOWN" => Self::Unknown,
                "PROPER" => Self::Proper,
                "COMMON" => Self::Common,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Proper => serializer.serialize_i32(1),
                Self::Common => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.language.v2.EntityMention.Type",
            ))
        }
    }
}

/// Represents a text span in the input document.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TextSpan {
    /// The content of the text span, which is a substring of the document.
    pub content: std::string::String,

    /// The API calculates the beginning offset of the content in the original
    /// document according to the
    /// [EncodingType][google.cloud.language.v2.EncodingType] specified in the API
    /// request.
    ///
    /// [google.cloud.language.v2.EncodingType]: crate::model::EncodingType
    pub begin_offset: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextSpan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::TextSpan::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [begin_offset][crate::model::TextSpan::begin_offset].
    pub fn set_begin_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.begin_offset = v.into();
        self
    }
}

impl wkt::message::Message for TextSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.TextSpan"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextSpan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __begin_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextSpan")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "beginOffset" => Ok(__FieldTag::__begin_offset),
                            "begin_offset" => Ok(__FieldTag::__begin_offset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextSpan;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextSpan")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__begin_offset => {
                            if !fields.insert(__FieldTag::__begin_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for begin_offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.begin_offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TextSpan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.begin_offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("beginOffset", &__With(&self.begin_offset))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TextSpan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextSpan");
        debug_struct.field("content", &self.content);
        debug_struct.field("begin_offset", &self.begin_offset);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a category returned from the text classifier.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClassificationCategory {
    /// The name of the category representing the document.
    pub name: std::string::String,

    /// The classifier's confidence of the category. Number represents how certain
    /// the classifier is that this category represents the given text.
    pub confidence: f32,

    /// Optional. The classifier's severity of the category. This is only present
    /// when the ModerateTextRequest.ModelVersion is set to MODEL_VERSION_2, and
    /// the corresponding category has a severity score.
    pub severity: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClassificationCategory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ClassificationCategory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::ClassificationCategory::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::ClassificationCategory::severity].
    pub fn set_severity<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for ClassificationCategory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassificationCategory"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClassificationCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __confidence,
            __severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClassificationCategory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "severity" => Ok(__FieldTag::__severity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClassificationCategory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClassificationCategory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.severity = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClassificationCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !wkt::internal::is_default(&self.severity) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("severity", &__With(&self.severity))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClassificationCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClassificationCategory");
        debug_struct.field("name", &self.name);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("severity", &self.severity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The sentiment analysis request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeSentimentRequest {
    /// Required. Input document.
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate sentence offsets.
    pub encoding_type: crate::model::EncodingType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeSentimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnalyzeSentimentRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::AnalyzeSentimentRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeSentimentRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeSentimentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __encoding_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeSentimentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "encodingType" => Ok(__FieldTag::__encoding_type),
                            "encoding_type" => Ok(__FieldTag::__encoding_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeSentimentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeSentimentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__encoding_type => {
                            if !fields.insert(__FieldTag::__encoding_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding_type",
                                ));
                            }
                            result.encoding_type = map
                                .next_value::<std::option::Option<crate::model::EncodingType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeSentimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !wkt::internal::is_default(&self.encoding_type) {
            state.serialize_entry("encodingType", &self.encoding_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeSentimentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeSentimentRequest");
        debug_struct.field("document", &self.document);
        debug_struct.field("encoding_type", &self.encoding_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The sentiment analysis response message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeSentimentResponse {
    /// The overall sentiment of the input document.
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    pub language_code: std::string::String,

    /// The sentiment for all the sentences in the document.
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeSentimentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document_sentiment][crate::model::AnalyzeSentimentResponse::document_sentiment].
    pub fn set_document_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_sentiment][crate::model::AnalyzeSentimentResponse::document_sentiment].
    pub fn set_or_clear_document_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::AnalyzeSentimentResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [sentences][crate::model::AnalyzeSentimentResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeSentimentResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeSentimentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document_sentiment,
            __language_code,
            __sentences,
            __language_supported,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeSentimentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documentSentiment" => Ok(__FieldTag::__document_sentiment),
                            "document_sentiment" => Ok(__FieldTag::__document_sentiment),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "sentences" => Ok(__FieldTag::__sentences),
                            "languageSupported" => Ok(__FieldTag::__language_supported),
                            "language_supported" => Ok(__FieldTag::__language_supported),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeSentimentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeSentimentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document_sentiment => {
                            if !fields.insert(__FieldTag::__document_sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_sentiment",
                                ));
                            }
                            result.document_sentiment =
                                map.next_value::<std::option::Option<crate::model::Sentiment>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sentences => {
                            if !fields.insert(__FieldTag::__sentences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentences",
                                ));
                            }
                            result.sentences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Sentence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__language_supported => {
                            if !fields.insert(__FieldTag::__language_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_supported",
                                ));
                            }
                            result.language_supported = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeSentimentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document_sentiment.is_some() {
            state.serialize_entry("documentSentiment", &self.document_sentiment)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.sentences.is_empty() {
            state.serialize_entry("sentences", &self.sentences)?;
        }
        if !wkt::internal::is_default(&self.language_supported) {
            state.serialize_entry("languageSupported", &self.language_supported)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeSentimentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeSentimentResponse");
        debug_struct.field("document_sentiment", &self.document_sentiment);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("sentences", &self.sentences);
        debug_struct.field("language_supported", &self.language_supported);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The entity analysis request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeEntitiesRequest {
    /// Required. Input document.
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate offsets.
    pub encoding_type: crate::model::EncodingType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnalyzeEntitiesRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::AnalyzeEntitiesRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeEntitiesRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __encoding_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "encodingType" => Ok(__FieldTag::__encoding_type),
                            "encoding_type" => Ok(__FieldTag::__encoding_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__encoding_type => {
                            if !fields.insert(__FieldTag::__encoding_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding_type",
                                ));
                            }
                            result.encoding_type = map
                                .next_value::<std::option::Option<crate::model::EncodingType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !wkt::internal::is_default(&self.encoding_type) {
            state.serialize_entry("encodingType", &self.encoding_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeEntitiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeEntitiesRequest");
        debug_struct.field("document", &self.document);
        debug_struct.field("encoding_type", &self.encoding_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The entity analysis response message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeEntitiesResponse {
    /// The recognized entities in the input document.
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entities][crate::model::AnalyzeEntitiesResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::AnalyzeEntitiesResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeEntitiesResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeEntitiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entities,
            __language_code,
            __language_supported,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeEntitiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entities" => Ok(__FieldTag::__entities),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "languageSupported" => Ok(__FieldTag::__language_supported),
                            "language_supported" => Ok(__FieldTag::__language_supported),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeEntitiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeEntitiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entity>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_supported => {
                            if !fields.insert(__FieldTag::__language_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_supported",
                                ));
                            }
                            result.language_supported = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeEntitiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.language_supported) {
            state.serialize_entry("languageSupported", &self.language_supported)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalyzeEntitiesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalyzeEntitiesResponse");
        debug_struct.field("entities", &self.entities);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("language_supported", &self.language_supported);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The document classification request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClassifyTextRequest {
    /// Required. Input document.
    pub document: std::option::Option<crate::model::Document>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClassifyTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::ClassifyTextRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::ClassifyTextRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClassifyTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClassifyTextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClassifyTextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClassifyTextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClassifyTextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClassifyTextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClassifyTextRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClassifyTextRequest");
        debug_struct.field("document", &self.document);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The document classification response message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClassifyTextResponse {
    /// Categories representing the input document.
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClassifyTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [categories][crate::model::ClassifyTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::ClassifyTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ClassifyTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for ClassifyTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClassifyTextResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __categories,
            __language_code,
            __language_supported,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClassifyTextResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "categories" => Ok(__FieldTag::__categories),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "languageSupported" => Ok(__FieldTag::__language_supported),
                            "language_supported" => Ok(__FieldTag::__language_supported),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClassifyTextResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClassifyTextResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClassificationCategory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_supported => {
                            if !fields.insert(__FieldTag::__language_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_supported",
                                ));
                            }
                            result.language_supported = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClassifyTextResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.language_supported) {
            state.serialize_entry("languageSupported", &self.language_supported)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClassifyTextResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClassifyTextResponse");
        debug_struct.field("categories", &self.categories);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("language_supported", &self.language_supported);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The document moderation request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModerateTextRequest {
    /// Required. Input document.
    pub document: std::option::Option<crate::model::Document>,

    /// Optional. The model version to use for ModerateText.
    pub model_version: crate::model::moderate_text_request::ModelVersion,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModerateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::ModerateTextRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::ModerateTextRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_version][crate::model::ModerateTextRequest::model_version].
    pub fn set_model_version<
        T: std::convert::Into<crate::model::moderate_text_request::ModelVersion>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_version = v.into();
        self
    }
}

impl wkt::message::Message for ModerateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModerateTextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __model_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModerateTextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "modelVersion" => Ok(__FieldTag::__model_version),
                            "model_version" => Ok(__FieldTag::__model_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModerateTextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModerateTextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__model_version => {
                            if !fields.insert(__FieldTag::__model_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_version",
                                ));
                            }
                            result.model_version = map
                                .next_value::<std::option::Option<
                                    crate::model::moderate_text_request::ModelVersion,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModerateTextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !wkt::internal::is_default(&self.model_version) {
            state.serialize_entry("modelVersion", &self.model_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ModerateTextRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModerateTextRequest");
        debug_struct.field("document", &self.document);
        debug_struct.field("model_version", &self.model_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ModerateTextRequest].
pub mod moderate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// The model version to use for ModerateText.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelVersion {
        /// The default model version.
        Unspecified,
        /// Use the v1 model, this model is used by default when not provided.
        /// The v1 model only returns probability (confidence) score for each
        /// category.
        ModelVersion1,
        /// Use the v2 model.
        /// The v2 model only returns probability (confidence) score for each
        /// category, and returns severity score for a subset of the categories.
        ModelVersion2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelVersion::value] or
        /// [ModelVersion::name].
        UnknownValue(model_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ModelVersion1 => std::option::Option::Some(1),
                Self::ModelVersion2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_VERSION_UNSPECIFIED"),
                Self::ModelVersion1 => std::option::Option::Some("MODEL_VERSION_1"),
                Self::ModelVersion2 => std::option::Option::Some("MODEL_VERSION_2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ModelVersion1,
                2 => Self::ModelVersion2,
                _ => Self::UnknownValue(model_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_VERSION_UNSPECIFIED" => Self::Unspecified,
                "MODEL_VERSION_1" => Self::ModelVersion1,
                "MODEL_VERSION_2" => Self::ModelVersion2,
                _ => Self::UnknownValue(model_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ModelVersion1 => serializer.serialize_i32(1),
                Self::ModelVersion2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelVersion>::new(
                ".google.cloud.language.v2.ModerateTextRequest.ModelVersion",
            ))
        }
    }
}

/// The document moderation response message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModerateTextResponse {
    /// Harmful and sensitive categories representing the input document.
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    pub language_supported: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModerateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [moderation_categories][crate::model::ModerateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::ModerateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ModerateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for ModerateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModerateTextResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __moderation_categories,
            __language_code,
            __language_supported,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModerateTextResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "moderationCategories" => Ok(__FieldTag::__moderation_categories),
                            "moderation_categories" => Ok(__FieldTag::__moderation_categories),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "languageSupported" => Ok(__FieldTag::__language_supported),
                            "language_supported" => Ok(__FieldTag::__language_supported),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModerateTextResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModerateTextResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__moderation_categories => {
                            if !fields.insert(__FieldTag::__moderation_categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for moderation_categories",
                                ));
                            }
                            result.moderation_categories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClassificationCategory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_supported => {
                            if !fields.insert(__FieldTag::__language_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_supported",
                                ));
                            }
                            result.language_supported = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModerateTextResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.moderation_categories.is_empty() {
            state.serialize_entry("moderationCategories", &self.moderation_categories)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.language_supported) {
            state.serialize_entry("languageSupported", &self.language_supported)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ModerateTextResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModerateTextResponse");
        debug_struct.field("moderation_categories", &self.moderation_categories);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("language_supported", &self.language_supported);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request message for the text annotation API, which can perform multiple
/// analysis types in one call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateTextRequest {
    /// Required. Input document.
    pub document: std::option::Option<crate::model::Document>,

    /// Required. The enabled features.
    pub features: std::option::Option<crate::model::annotate_text_request::Features>,

    /// The encoding type used by the API to calculate offsets.
    pub encoding_type: crate::model::EncodingType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnnotateTextRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::AnnotateTextRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [features][crate::model::AnnotateTextRequest::features].
    pub fn set_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::annotate_text_request::Features>,
    {
        self.features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [features][crate::model::AnnotateTextRequest::features].
    pub fn set_or_clear_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::annotate_text_request::Features>,
    {
        self.features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnnotateTextRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnnotateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateTextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __features,
            __encoding_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateTextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "features" => Ok(__FieldTag::__features),
                            "encodingType" => Ok(__FieldTag::__encoding_type),
                            "encoding_type" => Ok(__FieldTag::__encoding_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateTextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateTextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for features",
                                ));
                            }
                            result.features = map.next_value::<std::option::Option<
                                crate::model::annotate_text_request::Features,
                            >>()?;
                        }
                        __FieldTag::__encoding_type => {
                            if !fields.insert(__FieldTag::__encoding_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding_type",
                                ));
                            }
                            result.encoding_type = map
                                .next_value::<std::option::Option<crate::model::EncodingType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateTextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if self.features.is_some() {
            state.serialize_entry("features", &self.features)?;
        }
        if !wkt::internal::is_default(&self.encoding_type) {
            state.serialize_entry("encodingType", &self.encoding_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotateTextRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotateTextRequest");
        debug_struct.field("document", &self.document);
        debug_struct.field("features", &self.features);
        debug_struct.field("encoding_type", &self.encoding_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnnotateTextRequest].
pub mod annotate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// All available features.
    /// Setting each one to true will enable that specific analysis for the input.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Features {
        /// Optional. Extract entities.
        pub extract_entities: bool,

        /// Optional. Extract document-level sentiment.
        pub extract_document_sentiment: bool,

        /// Optional. Classify the full document into categories.
        pub classify_text: bool,

        /// Optional. Moderate the document for harmful and sensitive categories.
        pub moderate_text: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Features {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [extract_entities][crate::model::annotate_text_request::Features::extract_entities].
        pub fn set_extract_entities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_entities = v.into();
            self
        }

        /// Sets the value of [extract_document_sentiment][crate::model::annotate_text_request::Features::extract_document_sentiment].
        pub fn set_extract_document_sentiment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_document_sentiment = v.into();
            self
        }

        /// Sets the value of [classify_text][crate::model::annotate_text_request::Features::classify_text].
        pub fn set_classify_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.classify_text = v.into();
            self
        }

        /// Sets the value of [moderate_text][crate::model::annotate_text_request::Features::moderate_text].
        pub fn set_moderate_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.moderate_text = v.into();
            self
        }
    }

    impl wkt::message::Message for Features {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest.Features"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Features {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __extract_entities,
                __extract_document_sentiment,
                __classify_text,
                __moderate_text,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Features")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "extractEntities" => Ok(__FieldTag::__extract_entities),
                                "extract_entities" => Ok(__FieldTag::__extract_entities),
                                "extractDocumentSentiment" => {
                                    Ok(__FieldTag::__extract_document_sentiment)
                                }
                                "extract_document_sentiment" => {
                                    Ok(__FieldTag::__extract_document_sentiment)
                                }
                                "classifyText" => Ok(__FieldTag::__classify_text),
                                "classify_text" => Ok(__FieldTag::__classify_text),
                                "moderateText" => Ok(__FieldTag::__moderate_text),
                                "moderate_text" => Ok(__FieldTag::__moderate_text),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Features;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Features")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__extract_entities => {
                                if !fields.insert(__FieldTag::__extract_entities) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for extract_entities",
                                    ));
                                }
                                result.extract_entities = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__extract_document_sentiment => {
                                if !fields.insert(__FieldTag::__extract_document_sentiment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for extract_document_sentiment",
                                    ));
                                }
                                result.extract_document_sentiment = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__classify_text => {
                                if !fields.insert(__FieldTag::__classify_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for classify_text",
                                    ));
                                }
                                result.classify_text = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__moderate_text => {
                                if !fields.insert(__FieldTag::__moderate_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for moderate_text",
                                    ));
                                }
                                result.moderate_text = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Features {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.extract_entities) {
                state.serialize_entry("extractEntities", &self.extract_entities)?;
            }
            if !wkt::internal::is_default(&self.extract_document_sentiment) {
                state.serialize_entry(
                    "extractDocumentSentiment",
                    &self.extract_document_sentiment,
                )?;
            }
            if !wkt::internal::is_default(&self.classify_text) {
                state.serialize_entry("classifyText", &self.classify_text)?;
            }
            if !wkt::internal::is_default(&self.moderate_text) {
                state.serialize_entry("moderateText", &self.moderate_text)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Features {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Features");
            debug_struct.field("extract_entities", &self.extract_entities);
            debug_struct.field(
                "extract_document_sentiment",
                &self.extract_document_sentiment,
            );
            debug_struct.field("classify_text", &self.classify_text);
            debug_struct.field("moderate_text", &self.moderate_text);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The text annotations response message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateTextResponse {
    /// Sentences in the input document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Entities, along with their semantic information, in the input document.
    /// Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]
    /// or
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]: crate::model::annotate_text_request::Features::extract_entities
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The overall sentiment for the document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    pub language_code: std::string::String,

    /// Categories identified in the input document.
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Harmful and sensitive categories identified in the input document.
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Whether the language is officially supported by all requested features.
    /// The API may still return a response when the language is not supported, but
    /// it is on a best effort basis.
    pub language_supported: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sentences][crate::model::AnnotateTextResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entities][crate::model::AnnotateTextResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [document_sentiment][crate::model::AnnotateTextResponse::document_sentiment].
    pub fn set_document_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_sentiment][crate::model::AnnotateTextResponse::document_sentiment].
    pub fn set_or_clear_document_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::AnnotateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::AnnotateTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [moderation_categories][crate::model::AnnotateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnnotateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for AnnotateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateTextResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sentences,
            __entities,
            __document_sentiment,
            __language_code,
            __categories,
            __moderation_categories,
            __language_supported,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateTextResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sentences" => Ok(__FieldTag::__sentences),
                            "entities" => Ok(__FieldTag::__entities),
                            "documentSentiment" => Ok(__FieldTag::__document_sentiment),
                            "document_sentiment" => Ok(__FieldTag::__document_sentiment),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "categories" => Ok(__FieldTag::__categories),
                            "moderationCategories" => Ok(__FieldTag::__moderation_categories),
                            "moderation_categories" => Ok(__FieldTag::__moderation_categories),
                            "languageSupported" => Ok(__FieldTag::__language_supported),
                            "language_supported" => Ok(__FieldTag::__language_supported),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateTextResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateTextResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sentences => {
                            if !fields.insert(__FieldTag::__sentences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentences",
                                ));
                            }
                            result.sentences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Sentence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entity>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__document_sentiment => {
                            if !fields.insert(__FieldTag::__document_sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_sentiment",
                                ));
                            }
                            result.document_sentiment =
                                map.next_value::<std::option::Option<crate::model::Sentiment>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClassificationCategory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__moderation_categories => {
                            if !fields.insert(__FieldTag::__moderation_categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for moderation_categories",
                                ));
                            }
                            result.moderation_categories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClassificationCategory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_supported => {
                            if !fields.insert(__FieldTag::__language_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_supported",
                                ));
                            }
                            result.language_supported = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateTextResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sentences.is_empty() {
            state.serialize_entry("sentences", &self.sentences)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if self.document_sentiment.is_some() {
            state.serialize_entry("documentSentiment", &self.document_sentiment)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if !self.moderation_categories.is_empty() {
            state.serialize_entry("moderationCategories", &self.moderation_categories)?;
        }
        if !wkt::internal::is_default(&self.language_supported) {
            state.serialize_entry("languageSupported", &self.language_supported)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotateTextResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotateTextResponse");
        debug_struct.field("sentences", &self.sentences);
        debug_struct.field("entities", &self.entities);
        debug_struct.field("document_sentiment", &self.document_sentiment);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("categories", &self.categories);
        debug_struct.field("moderation_categories", &self.moderation_categories);
        debug_struct.field("language_supported", &self.language_supported);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the text encoding that the caller uses to process the output.
/// Providing an `EncodingType` is recommended because the API provides the
/// beginning offsets for various outputs, such as tokens and mentions, and
/// languages that natively use different text encodings may access offsets
/// differently.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncodingType {
    /// If `EncodingType` is not specified, encoding-dependent information (such as
    /// `begin_offset`) will be set at `-1`.
    None,
    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-8 encoding of the input. C++ and Go are examples of languages
    /// that use this encoding natively.
    Utf8,
    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-16 encoding of the input. Java and JavaScript are examples of
    /// languages that use this encoding natively.
    Utf16,
    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-32 encoding of the input. Python is an example of a language
    /// that uses this encoding natively.
    Utf32,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncodingType::value] or
    /// [EncodingType::name].
    UnknownValue(encoding_type::UnknownValue),
}

#[doc(hidden)]
pub mod encoding_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncodingType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::None => std::option::Option::Some(0),
            Self::Utf8 => std::option::Option::Some(1),
            Self::Utf16 => std::option::Option::Some(2),
            Self::Utf32 => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::None => std::option::Option::Some("NONE"),
            Self::Utf8 => std::option::Option::Some("UTF8"),
            Self::Utf16 => std::option::Option::Some("UTF16"),
            Self::Utf32 => std::option::Option::Some("UTF32"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncodingType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncodingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncodingType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::None,
            1 => Self::Utf8,
            2 => Self::Utf16,
            3 => Self::Utf32,
            _ => Self::UnknownValue(encoding_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncodingType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NONE" => Self::None,
            "UTF8" => Self::Utf8,
            "UTF16" => Self::Utf16,
            "UTF32" => Self::Utf32,
            _ => Self::UnknownValue(encoding_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncodingType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::None => serializer.serialize_i32(0),
            Self::Utf8 => serializer.serialize_i32(1),
            Self::Utf16 => serializer.serialize_i32(2),
            Self::Utf32 => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncodingType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncodingType>::new(
            ".google.cloud.language.v2.EncodingType",
        ))
    }
}
