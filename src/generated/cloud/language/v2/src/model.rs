// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the input to API methods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Document {
    /// Required. If the type is not set or is `TYPE_UNSPECIFIED`,
    /// returns an `INVALID_ARGUMENT` error.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::document::Type,

    /// Optional. The language of the document (if not specified, the language is
    /// automatically detected). Both ISO and BCP-47 language codes are
    /// accepted.\<br\>
    /// [Language
    /// Support](https://cloud.google.com/natural-language/docs/languages) lists
    /// currently supported languages for each API method. If the language (either
    /// specified by the caller or automatically detected) is not supported by the
    /// called API method, an `INVALID_ARGUMENT` error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_code: std::string::String,

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::document::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Document {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Document::type].
    pub fn set_type<T: std::convert::Into<crate::model::document::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Document::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Document::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(crate::model::document::Source::Content(v.into()));
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `GcsContentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_content_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::GcsContentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `GcsContentUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_content_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::document::Source::GcsContentUri(v.into()));
        self
    }
}

impl wkt::message::Message for Document {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Document"
    }
}

/// Defines additional types related to [Document].
pub mod document {
    #[allow(unused_imports)]
    use super::*;

    /// The document types enum.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The content type is not specified.
        Unspecified,
        /// Plain text
        PlainText,
        /// HTML
        Html,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PlainText => std::option::Option::Some(1),
                Self::Html => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::PlainText => std::option::Option::Some("PLAIN_TEXT"),
                Self::Html => std::option::Option::Some("HTML"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PlainText,
                2 => Self::Html,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PLAIN_TEXT" => Self::PlainText,
                "HTML" => Self::Html,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PlainText => serializer.serialize_i32(1),
                Self::Html => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.language.v2.Document.Type",
            ))
        }
    }

    /// The source of the document: a string containing the content or a
    /// Google Cloud Storage URI.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The content of the input in string format.
        /// Cloud audit logging exempt since it is based on user data.
        Content(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// The Google Cloud Storage URI where the file content is located.
        /// This URI must be of the form: gs://bucket_name/object_name. For more
        /// details, see <https://cloud.google.com/storage/docs/reference-uris>.
        /// NOTE: Cloud Storage object versioning is not supported.
        GcsContentUri(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// Represents a sentence in the input document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sentence {
    /// The sentence text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub text: std::option::Option<crate::model::TextSpan>,

    /// For calls to [AnalyzeSentiment][] or if
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]
    /// is set to true, this field will contain the sentiment for the sentence.
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sentence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::Sentence::text].
    pub fn set_text<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [text][crate::model::Sentence::text].
    pub fn set_or_clear_text<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sentiment][crate::model::Sentence::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::Sentence::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Sentence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentence"
    }
}

/// Represents a phrase in the text that is a known entity, such as
/// a person, an organization, or location. The API associates information, such
/// as probability and mentions, with entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entity {
    /// The representative name for the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The entity type.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::entity::Type,

    /// Metadata associated with the entity.
    ///
    /// For the metadata
    /// associated with other entity types, see the Type table below.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The mentions of this entity in the input document. The API currently
    /// supports proper noun mentions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub mentions: std::vec::Vec<crate::model::EntityMention>,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the aggregate sentiment expressed
    /// for this entity in the provided document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Entity::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [mentions][crate::model::Entity::mentions].
    pub fn set_mentions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMention>,
    {
        use std::iter::Iterator;
        self.mentions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Entity"
    }
}

/// Defines additional types related to [Entity].
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the entity. The table
    /// below lists the associated fields for entities that have different
    /// metadata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unknown
        Unknown,
        /// Person
        Person,
        /// Location
        Location,
        /// Organization
        Organization,
        /// Event
        Event,
        /// Artwork
        WorkOfArt,
        /// Consumer product
        ConsumerGood,
        /// Other types of entities
        Other,
        /// Phone number
        ///
        /// The metadata lists the phone number, formatted according to local
        /// convention, plus whichever additional elements appear in the text:
        ///
        /// * `number` - the actual number, broken down into sections as per local
        ///   convention
        /// * `national_prefix` - country code, if detected
        /// * `area_code` - region or area code, if detected
        /// * `extension` - phone extension (to be dialed after connection), if
        ///   detected
        PhoneNumber,
        /// Address
        ///
        /// The metadata identifies the street number and locality plus whichever
        /// additional elements appear in the text:
        ///
        /// * `street_number` - street number
        /// * `locality` - city or town
        /// * `street_name` - street/route name, if detected
        /// * `postal_code` - postal code, if detected
        /// * `country` - country, if detected
        /// * `broad_region` - administrative area, such as the state, if detected
        /// * `narrow_region` - smaller administrative area, such as county, if
        ///   detected
        /// * `sublocality` - used in Asian addresses to demark a district within a
        ///   city, if detected
        Address,
        /// Date
        ///
        /// The metadata identifies the components of the date:
        ///
        /// * `year` - four digit year, if detected
        /// * `month` - two digit month number, if detected
        /// * `day` - two digit day number, if detected
        Date,
        /// Number
        ///
        /// The metadata is the number itself.
        Number,
        /// Price
        ///
        /// The metadata identifies the `value` and `currency`.
        Price,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Person => std::option::Option::Some(1),
                Self::Location => std::option::Option::Some(2),
                Self::Organization => std::option::Option::Some(3),
                Self::Event => std::option::Option::Some(4),
                Self::WorkOfArt => std::option::Option::Some(5),
                Self::ConsumerGood => std::option::Option::Some(6),
                Self::Other => std::option::Option::Some(7),
                Self::PhoneNumber => std::option::Option::Some(9),
                Self::Address => std::option::Option::Some(10),
                Self::Date => std::option::Option::Some(11),
                Self::Number => std::option::Option::Some(12),
                Self::Price => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Person => std::option::Option::Some("PERSON"),
                Self::Location => std::option::Option::Some("LOCATION"),
                Self::Organization => std::option::Option::Some("ORGANIZATION"),
                Self::Event => std::option::Option::Some("EVENT"),
                Self::WorkOfArt => std::option::Option::Some("WORK_OF_ART"),
                Self::ConsumerGood => std::option::Option::Some("CONSUMER_GOOD"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::PhoneNumber => std::option::Option::Some("PHONE_NUMBER"),
                Self::Address => std::option::Option::Some("ADDRESS"),
                Self::Date => std::option::Option::Some("DATE"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Price => std::option::Option::Some("PRICE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Person,
                2 => Self::Location,
                3 => Self::Organization,
                4 => Self::Event,
                5 => Self::WorkOfArt,
                6 => Self::ConsumerGood,
                7 => Self::Other,
                9 => Self::PhoneNumber,
                10 => Self::Address,
                11 => Self::Date,
                12 => Self::Number,
                13 => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "PERSON" => Self::Person,
                "LOCATION" => Self::Location,
                "ORGANIZATION" => Self::Organization,
                "EVENT" => Self::Event,
                "WORK_OF_ART" => Self::WorkOfArt,
                "CONSUMER_GOOD" => Self::ConsumerGood,
                "OTHER" => Self::Other,
                "PHONE_NUMBER" => Self::PhoneNumber,
                "ADDRESS" => Self::Address,
                "DATE" => Self::Date,
                "NUMBER" => Self::Number,
                "PRICE" => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Person => serializer.serialize_i32(1),
                Self::Location => serializer.serialize_i32(2),
                Self::Organization => serializer.serialize_i32(3),
                Self::Event => serializer.serialize_i32(4),
                Self::WorkOfArt => serializer.serialize_i32(5),
                Self::ConsumerGood => serializer.serialize_i32(6),
                Self::Other => serializer.serialize_i32(7),
                Self::PhoneNumber => serializer.serialize_i32(9),
                Self::Address => serializer.serialize_i32(10),
                Self::Date => serializer.serialize_i32(11),
                Self::Number => serializer.serialize_i32(12),
                Self::Price => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.language.v2.Entity.Type",
            ))
        }
    }
}

/// Represents the feeling associated with the entire text or entities in
/// the text.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sentiment {
    /// A non-negative number in the [0, +inf) range, which represents
    /// the absolute magnitude of sentiment regardless of score (positive or
    /// negative).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub magnitude: f32,

    /// Sentiment score between -1.0 (negative sentiment) and 1.0
    /// (positive sentiment).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub score: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sentiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [magnitude][crate::model::Sentiment::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Sentiment::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for Sentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.Sentiment"
    }
}

/// Represents a mention for an entity in the text. Currently, proper noun
/// mentions are supported.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMention {
    /// The mention text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub text: std::option::Option<crate::model::TextSpan>,

    /// The type of the entity mention.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::entity_mention::Type,

    /// For calls to [AnalyzeEntitySentiment][] or if
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment]
    /// is set to true, this field will contain the sentiment expressed for this
    /// mention of the entity in the provided document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::Sentiment>,

    /// Probability score associated with the entity.
    ///
    /// The score shows the probability of the entity mention being the entity
    /// type. The score is in (0, 1] range.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub probability: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMention {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::EntityMention::text].
    pub fn set_text<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [text][crate::model::EntityMention::text].
    pub fn set_or_clear_text<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextSpan>,
    {
        self.text = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::EntityMention::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_mention::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::EntityMention::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::EntityMention::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [probability][crate::model::EntityMention::probability].
    pub fn set_probability<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.probability = v.into();
        self
    }
}

impl wkt::message::Message for EntityMention {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.EntityMention"
    }
}

/// Defines additional types related to [EntityMention].
pub mod entity_mention {
    #[allow(unused_imports)]
    use super::*;

    /// The supported types of mentions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unknown
        Unknown,
        /// Proper name
        Proper,
        /// Common noun (or noun compound)
        Common,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Proper => std::option::Option::Some(1),
                Self::Common => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("TYPE_UNKNOWN"),
                Self::Proper => std::option::Option::Some("PROPER"),
                Self::Common => std::option::Option::Some("COMMON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Proper,
                2 => Self::Common,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNKNOWN" => Self::Unknown,
                "PROPER" => Self::Proper,
                "COMMON" => Self::Common,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Proper => serializer.serialize_i32(1),
                Self::Common => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.language.v2.EntityMention.Type",
            ))
        }
    }
}

/// Represents a text span in the input document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TextSpan {
    /// The content of the text span, which is a substring of the document.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub content: std::string::String,

    /// The API calculates the beginning offset of the content in the original
    /// document according to the
    /// [EncodingType][google.cloud.language.v2.EncodingType] specified in the API
    /// request.
    ///
    /// [google.cloud.language.v2.EncodingType]: crate::model::EncodingType
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub begin_offset: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextSpan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::TextSpan::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [begin_offset][crate::model::TextSpan::begin_offset].
    pub fn set_begin_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.begin_offset = v.into();
        self
    }
}

impl wkt::message::Message for TextSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.TextSpan"
    }
}

/// Represents a category returned from the text classifier.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassificationCategory {
    /// The name of the category representing the document.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The classifier's confidence of the category. Number represents how certain
    /// the classifier is that this category represents the given text.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub confidence: f32,

    /// Optional. The classifier's severity of the category. This is only present
    /// when the ModerateTextRequest.ModelVersion is set to MODEL_VERSION_2, and
    /// the corresponding category has a severity score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F32>")]
    pub severity: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClassificationCategory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ClassificationCategory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::ClassificationCategory::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::ClassificationCategory::severity].
    pub fn set_severity<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for ClassificationCategory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassificationCategory"
    }
}

/// The sentiment analysis request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeSentimentRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate sentence offsets.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub encoding_type: crate::model::EncodingType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeSentimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnalyzeSentimentRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::AnalyzeSentimentRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeSentimentRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentRequest"
    }
}

/// The sentiment analysis response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeSentimentResponse {
    /// The overall sentiment of the input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_code: std::string::String,

    /// The sentiment for all the sentences in the document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_supported: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeSentimentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document_sentiment][crate::model::AnalyzeSentimentResponse::document_sentiment].
    pub fn set_document_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_sentiment][crate::model::AnalyzeSentimentResponse::document_sentiment].
    pub fn set_or_clear_document_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::AnalyzeSentimentResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [sentences][crate::model::AnalyzeSentimentResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeSentimentResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeSentimentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeSentimentResponse"
    }
}

/// The entity analysis request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeEntitiesRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// The encoding type used by the API to calculate offsets.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub encoding_type: crate::model::EncodingType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnalyzeEntitiesRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::AnalyzeEntitiesRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnalyzeEntitiesRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesRequest"
    }
}

/// The entity analysis response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeEntitiesResponse {
    /// The recognized entities in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_supported: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entities][crate::model::AnalyzeEntitiesResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::AnalyzeEntitiesResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnalyzeEntitiesResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for AnalyzeEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnalyzeEntitiesResponse"
    }
}

/// The document classification request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassifyTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClassifyTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::ClassifyTextRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::ClassifyTextRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClassifyTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextRequest"
    }
}

/// The document classification response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClassifyTextResponse {
    /// Categories representing the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_supported: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClassifyTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [categories][crate::model::ClassifyTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::ClassifyTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ClassifyTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for ClassifyTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ClassifyTextResponse"
    }
}

/// The document moderation request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModerateTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// Optional. The model version to use for ModerateText.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub model_version: crate::model::moderate_text_request::ModelVersion,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModerateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::ModerateTextRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::ModerateTextRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_version][crate::model::ModerateTextRequest::model_version].
    pub fn set_model_version<
        T: std::convert::Into<crate::model::moderate_text_request::ModelVersion>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_version = v.into();
        self
    }
}

impl wkt::message::Message for ModerateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextRequest"
    }
}

/// Defines additional types related to [ModerateTextRequest].
pub mod moderate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// The model version to use for ModerateText.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelVersion {
        /// The default model version.
        Unspecified,
        /// Use the v1 model, this model is used by default when not provided.
        /// The v1 model only returns probability (confidence) score for each
        /// category.
        ModelVersion1,
        /// Use the v2 model.
        /// The v2 model only returns probability (confidence) score for each
        /// category, and returns severity score for a subset of the categories.
        ModelVersion2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelVersion::value] or
        /// [ModelVersion::name].
        UnknownValue(model_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ModelVersion1 => std::option::Option::Some(1),
                Self::ModelVersion2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_VERSION_UNSPECIFIED"),
                Self::ModelVersion1 => std::option::Option::Some("MODEL_VERSION_1"),
                Self::ModelVersion2 => std::option::Option::Some("MODEL_VERSION_2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ModelVersion1,
                2 => Self::ModelVersion2,
                _ => Self::UnknownValue(model_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_VERSION_UNSPECIFIED" => Self::Unspecified,
                "MODEL_VERSION_1" => Self::ModelVersion1,
                "MODEL_VERSION_2" => Self::ModelVersion2,
                _ => Self::UnknownValue(model_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ModelVersion1 => serializer.serialize_i32(1),
                Self::ModelVersion2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelVersion>::new(
                ".google.cloud.language.v2.ModerateTextRequest.ModelVersion",
            ))
        }
    }
}

/// The document moderation response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModerateTextResponse {
    /// Harmful and sensitive categories representing the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_code: std::string::String,

    /// Whether the language is officially supported. The API may still return a
    /// response when the language is not supported, but it is on a best effort
    /// basis.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_supported: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModerateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [moderation_categories][crate::model::ModerateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::ModerateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [language_supported][crate::model::ModerateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for ModerateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.ModerateTextResponse"
    }
}

/// The request message for the text annotation API, which can perform multiple
/// analysis types in one call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateTextRequest {
    /// Required. Input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// Required. The enabled features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub features: std::option::Option<crate::model::annotate_text_request::Features>,

    /// The encoding type used by the API to calculate offsets.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub encoding_type: crate::model::EncodingType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::AnnotateTextRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::AnnotateTextRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [features][crate::model::AnnotateTextRequest::features].
    pub fn set_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::annotate_text_request::Features>,
    {
        self.features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [features][crate::model::AnnotateTextRequest::features].
    pub fn set_or_clear_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::annotate_text_request::Features>,
    {
        self.features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encoding_type][crate::model::AnnotateTextRequest::encoding_type].
    pub fn set_encoding_type<T: std::convert::Into<crate::model::EncodingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encoding_type = v.into();
        self
    }
}

impl wkt::message::Message for AnnotateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest"
    }
}

/// Defines additional types related to [AnnotateTextRequest].
pub mod annotate_text_request {
    #[allow(unused_imports)]
    use super::*;

    /// All available features.
    /// Setting each one to true will enable that specific analysis for the input.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Features {
        /// Optional. Extract entities.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub extract_entities: bool,

        /// Optional. Extract document-level sentiment.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub extract_document_sentiment: bool,

        /// Optional. Classify the full document into categories.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub classify_text: bool,

        /// Optional. Moderate the document for harmful and sensitive categories.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub moderate_text: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Features {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [extract_entities][crate::model::annotate_text_request::Features::extract_entities].
        pub fn set_extract_entities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_entities = v.into();
            self
        }

        /// Sets the value of [extract_document_sentiment][crate::model::annotate_text_request::Features::extract_document_sentiment].
        pub fn set_extract_document_sentiment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extract_document_sentiment = v.into();
            self
        }

        /// Sets the value of [classify_text][crate::model::annotate_text_request::Features::classify_text].
        pub fn set_classify_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.classify_text = v.into();
            self
        }

        /// Sets the value of [moderate_text][crate::model::annotate_text_request::Features::moderate_text].
        pub fn set_moderate_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.moderate_text = v.into();
            self
        }
    }

    impl wkt::message::Message for Features {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.language.v2.AnnotateTextRequest.Features"
        }
    }
}

/// The text annotations response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateTextResponse {
    /// Sentences in the input document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub sentences: std::vec::Vec<crate::model::Sentence>,

    /// Entities, along with their semantic information, in the input document.
    /// Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]
    /// or
    /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_entity_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_entities]: crate::model::annotate_text_request::Features::extract_entities
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// The overall sentiment for the document. Populated if the user enables
    /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment].
    ///
    /// [google.cloud.language.v2.AnnotateTextRequest.Features.extract_document_sentiment]: crate::model::annotate_text_request::Features::extract_document_sentiment
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_sentiment: std::option::Option<crate::model::Sentiment>,

    /// The language of the text, which will be the same as the language specified
    /// in the request or, if not specified, the automatically-detected language.
    /// See [Document.language][] field for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_code: std::string::String,

    /// Categories identified in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Harmful and sensitive categories identified in the input document.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub moderation_categories: std::vec::Vec<crate::model::ClassificationCategory>,

    /// Whether the language is officially supported by all requested features.
    /// The API may still return a response when the language is not supported, but
    /// it is on a best effort basis.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_supported: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sentences][crate::model::AnnotateTextResponse::sentences].
    pub fn set_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sentence>,
    {
        use std::iter::Iterator;
        self.sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entities][crate::model::AnnotateTextResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [document_sentiment][crate::model::AnnotateTextResponse::document_sentiment].
    pub fn set_document_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_sentiment][crate::model::AnnotateTextResponse::document_sentiment].
    pub fn set_or_clear_document_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.document_sentiment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::AnnotateTextResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::AnnotateTextResponse::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [moderation_categories][crate::model::AnnotateTextResponse::moderation_categories].
    pub fn set_moderation_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClassificationCategory>,
    {
        use std::iter::Iterator;
        self.moderation_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_supported][crate::model::AnnotateTextResponse::language_supported].
    pub fn set_language_supported<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.language_supported = v.into();
        self
    }
}

impl wkt::message::Message for AnnotateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.language.v2.AnnotateTextResponse"
    }
}

/// Represents the text encoding that the caller uses to process the output.
/// Providing an `EncodingType` is recommended because the API provides the
/// beginning offsets for various outputs, such as tokens and mentions, and
/// languages that natively use different text encodings may access offsets
/// differently.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncodingType {
    /// If `EncodingType` is not specified, encoding-dependent information (such as
    /// `begin_offset`) will be set at `-1`.
    None,
    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-8 encoding of the input. C++ and Go are examples of languages
    /// that use this encoding natively.
    Utf8,
    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-16 encoding of the input. Java and JavaScript are examples of
    /// languages that use this encoding natively.
    Utf16,
    /// Encoding-dependent information (such as `begin_offset`) is calculated based
    /// on the UTF-32 encoding of the input. Python is an example of a language
    /// that uses this encoding natively.
    Utf32,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncodingType::value] or
    /// [EncodingType::name].
    UnknownValue(encoding_type::UnknownValue),
}

#[doc(hidden)]
pub mod encoding_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncodingType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::None => std::option::Option::Some(0),
            Self::Utf8 => std::option::Option::Some(1),
            Self::Utf16 => std::option::Option::Some(2),
            Self::Utf32 => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::None => std::option::Option::Some("NONE"),
            Self::Utf8 => std::option::Option::Some("UTF8"),
            Self::Utf16 => std::option::Option::Some("UTF16"),
            Self::Utf32 => std::option::Option::Some("UTF32"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncodingType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncodingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncodingType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::None,
            1 => Self::Utf8,
            2 => Self::Utf16,
            3 => Self::Utf32,
            _ => Self::UnknownValue(encoding_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncodingType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NONE" => Self::None,
            "UTF8" => Self::Utf8,
            "UTF16" => Self::Utf16,
            "UTF32" => Self::Utf32,
            _ => Self::UnknownValue(encoding_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncodingType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::None => serializer.serialize_i32(0),
            Self::Utf8 => serializer.serialize_i32(1),
            Self::Utf16 => serializer.serialize_i32(2),
            Self::Utf32 => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncodingType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncodingType>::new(
            ".google.cloud.language.v2.EncodingType",
        ))
    }
}
