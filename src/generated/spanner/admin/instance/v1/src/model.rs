// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Encapsulates progress related information for a Cloud Spanner long
/// running instance operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationProgress {
    /// Percent completion of the operation.
    /// Values are between 0 and 100 inclusive.
    pub progress_percent: i32,

    /// Time the request was received.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation failed or was completed
    /// successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationProgress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_percent][crate::model::OperationProgress::progress_percent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// let x = OperationProgress::new().set_progress_percent(42);
    /// ```
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OperationProgress::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// use wkt::Timestamp;
    /// let x = OperationProgress::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::OperationProgress::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// use wkt::Timestamp;
    /// let x = OperationProgress::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = OperationProgress::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationProgress::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// use wkt::Timestamp;
    /// let x = OperationProgress::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationProgress::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// use wkt::Timestamp;
    /// let x = OperationProgress::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = OperationProgress::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationProgress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.OperationProgress"
    }
}

/// ReplicaSelection identifies replicas with common properties.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaSelection {
    /// Required. Name of the location of the replicas (e.g., "us-central1").
    pub location: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaSelection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ReplicaSelection::location].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaSelection;
    /// let x = ReplicaSelection::new().set_location("example");
    /// ```
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaSelection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaSelection"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaInfo {
    /// The location of the serving resources, e.g., "us-central1".
    pub location: std::string::String,

    /// The type of replica.
    pub r#type: crate::model::replica_info::ReplicaType,

    /// If true, this location is designated as the default leader location where
    /// leader replicas are placed. See the [region types
    /// documentation](https://cloud.google.com/spanner/docs/instances#region_types)
    /// for more details.
    pub default_leader_location: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ReplicaInfo::location].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaInfo;
    /// let x = ReplicaInfo::new().set_location("example");
    /// ```
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ReplicaInfo::type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaInfo;
    /// use google_cloud_spanner_admin_instance_v1::model::replica_info::ReplicaType;
    /// let x0 = ReplicaInfo::new().set_type(ReplicaType::ReadWrite);
    /// let x1 = ReplicaInfo::new().set_type(ReplicaType::ReadOnly);
    /// let x2 = ReplicaInfo::new().set_type(ReplicaType::Witness);
    /// ```
    pub fn set_type<T: std::convert::Into<crate::model::replica_info::ReplicaType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [default_leader_location][crate::model::ReplicaInfo::default_leader_location].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaInfo;
    /// let x = ReplicaInfo::new().set_default_leader_location(true);
    /// ```
    pub fn set_default_leader_location<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_leader_location = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaInfo"
    }
}

/// Defines additional types related to [ReplicaInfo].
pub mod replica_info {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of replica.  See the [replica types
    /// documentation](https://cloud.google.com/spanner/docs/replication#replica_types)
    /// for more details.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicaType {
        /// Not specified.
        TypeUnspecified,
        /// Read-write replicas support both reads and writes. These replicas:
        ///
        /// * Maintain a full copy of your data.
        /// * Serve reads.
        /// * Can vote whether to commit a write.
        /// * Participate in leadership election.
        /// * Are eligible to become a leader.
        ReadWrite,
        /// Read-only replicas only support reads (not writes). Read-only replicas:
        ///
        /// * Maintain a full copy of your data.
        /// * Serve reads.
        /// * Do not participate in voting to commit writes.
        /// * Are not eligible to become a leader.
        ReadOnly,
        /// Witness replicas don't support reads but do participate in voting to
        /// commit writes. Witness replicas:
        ///
        /// * Do not maintain a full copy of data.
        /// * Do not serve reads.
        /// * Vote whether to commit writes.
        /// * Participate in leader election but are not eligible to become leader.
        Witness,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplicaType::value] or
        /// [ReplicaType::name].
        UnknownValue(replica_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod replica_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReplicaType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some(0),
                Self::ReadWrite => std::option::Option::Some(1),
                Self::ReadOnly => std::option::Option::Some(2),
                Self::Witness => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::Witness => std::option::Option::Some("WITNESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReplicaType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReplicaType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReplicaType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::TypeUnspecified,
                1 => Self::ReadWrite,
                2 => Self::ReadOnly,
                3 => Self::Witness,
                _ => Self::UnknownValue(replica_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReplicaType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::TypeUnspecified,
                "READ_WRITE" => Self::ReadWrite,
                "READ_ONLY" => Self::ReadOnly,
                "WITNESS" => Self::Witness,
                _ => Self::UnknownValue(replica_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReplicaType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::TypeUnspecified => serializer.serialize_i32(0),
                Self::ReadWrite => serializer.serialize_i32(1),
                Self::ReadOnly => serializer.serialize_i32(2),
                Self::Witness => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReplicaType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicaType>::new(
                ".google.spanner.admin.instance.v1.ReplicaInfo.ReplicaType",
            ))
        }
    }
}

/// A possible configuration for a Cloud Spanner instance. Configurations
/// define the geographic placement of nodes and their replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceConfig {
    /// A unique identifier for the instance configuration.  Values
    /// are of the form
    /// `projects/<project>/instanceConfigs/[a-z][-a-z0-9]*`.
    ///
    /// User instance configuration must start with `custom-`.
    pub name: std::string::String,

    /// The name of this instance configuration as it appears in UIs.
    pub display_name: std::string::String,

    /// Output only. Whether this instance configuration is a Google-managed or
    /// user-managed configuration.
    pub config_type: crate::model::instance_config::Type,

    /// The geographic placement of nodes in this instance configuration and their
    /// replication properties.
    ///
    /// To create user-managed configurations, input
    /// `replicas` must include all replicas in `replicas` of the `base_config`
    /// and include one or more replicas in the `optional_replicas` of the
    /// `base_config`.
    pub replicas: std::vec::Vec<crate::model::ReplicaInfo>,

    /// Output only. The available optional replicas to choose from for
    /// user-managed configurations. Populated for Google-managed configurations.
    pub optional_replicas: std::vec::Vec<crate::model::ReplicaInfo>,

    /// Base configuration name, e.g. projects/<project_name>/instanceConfigs/nam3,
    /// based on which this configuration is created. Only set for user-managed
    /// configurations. `base_config` must refer to a configuration of type
    /// `GOOGLE_MANAGED` in the same project as this configuration.
    pub base_config: std::string::String,

    /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. Cloud Labels can be used to filter collections of
    /// resources. They can be used to control how resource metrics are aggregated.
    /// And they can be used as arguments to policy management rules (e.g. route,
    /// firewall, load balancing, etc.).
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform
    ///   to the regular expression `[a-z0-9_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    ///
    /// If you plan to use labels in your own code, please note that additional
    /// characters may be allowed in the future. Therefore, you are advised to use
    /// an internal label representation, such as JSON, which doesn't rely upon
    /// specific characters being disallowed.  For example, representing labels
    /// as the string:  name + "_" + value  would prove problematic if we were to
    /// allow "_" in a future release.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// etag is used for optimistic concurrency control as a way
    /// to help prevent simultaneous updates of a instance configuration from
    /// overwriting each other. It is strongly suggested that systems make use of
    /// the etag in the read-modify-write cycle to perform instance configuration
    /// updates in order to avoid race conditions: An etag is returned in the
    /// response which contains instance configurations, and systems are expected
    /// to put that etag in the request to update instance configuration to ensure
    /// that their change is applied to the same version of the instance
    /// configuration. If no etag is provided in the call to update the instance
    /// configuration, then the existing instance configuration is overwritten
    /// blindly.
    pub etag: std::string::String,

    /// Allowed values of the "default_leader" schema option for databases in
    /// instances that use this instance configuration.
    pub leader_options: std::vec::Vec<std::string::String>,

    /// Output only. If true, the instance configuration is being created or
    /// updated. If false, there are no ongoing operations for the instance
    /// configuration.
    pub reconciling: bool,

    /// Output only. The current instance configuration state. Applicable only for
    /// `USER_MANAGED` configurations.
    pub state: crate::model::instance_config::State,

    /// Output only. Describes whether free instances are available to be created
    /// in this instance configuration.
    pub free_instance_availability: crate::model::instance_config::FreeInstanceAvailability,

    /// Output only. The `QuorumType` of the instance configuration.
    pub quorum_type: crate::model::instance_config::QuorumType,

    /// Output only. The storage limit in bytes per processing unit.
    pub storage_limit_per_processing_unit: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceConfig::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InstanceConfig::display_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [config_type][crate::model::InstanceConfig::config_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::instance_config::Type;
    /// let x0 = InstanceConfig::new().set_config_type(Type::GoogleManaged);
    /// let x1 = InstanceConfig::new().set_config_type(Type::UserManaged);
    /// ```
    pub fn set_config_type<T: std::convert::Into<crate::model::instance_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_type = v.into();
        self
    }

    /// Sets the value of [replicas][crate::model::InstanceConfig::replicas].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::ReplicaInfo;
    /// let x = InstanceConfig::new()
    ///     .set_replicas([
    ///         ReplicaInfo::default()/* use setters */,
    ///         ReplicaInfo::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaInfo>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [optional_replicas][crate::model::InstanceConfig::optional_replicas].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::ReplicaInfo;
    /// let x = InstanceConfig::new()
    ///     .set_optional_replicas([
    ///         ReplicaInfo::default()/* use setters */,
    ///         ReplicaInfo::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_optional_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaInfo>,
    {
        use std::iter::Iterator;
        self.optional_replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [base_config][crate::model::InstanceConfig::base_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_base_config("example");
    /// ```
    pub fn set_base_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::InstanceConfig::labels].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::InstanceConfig::etag].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [leader_options][crate::model::InstanceConfig::leader_options].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_leader_options(["a", "b", "c"]);
    /// ```
    pub fn set_leader_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.leader_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reconciling][crate::model::InstanceConfig::reconciling].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_reconciling(true);
    /// ```
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [state][crate::model::InstanceConfig::state].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::instance_config::State;
    /// let x0 = InstanceConfig::new().set_state(State::Creating);
    /// let x1 = InstanceConfig::new().set_state(State::Ready);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::instance_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [free_instance_availability][crate::model::InstanceConfig::free_instance_availability].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::instance_config::FreeInstanceAvailability;
    /// let x0 = InstanceConfig::new().set_free_instance_availability(FreeInstanceAvailability::Available);
    /// let x1 = InstanceConfig::new().set_free_instance_availability(FreeInstanceAvailability::Unsupported);
    /// let x2 = InstanceConfig::new().set_free_instance_availability(FreeInstanceAvailability::Disabled);
    /// ```
    pub fn set_free_instance_availability<
        T: std::convert::Into<crate::model::instance_config::FreeInstanceAvailability>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.free_instance_availability = v.into();
        self
    }

    /// Sets the value of [quorum_type][crate::model::InstanceConfig::quorum_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::instance_config::QuorumType;
    /// let x0 = InstanceConfig::new().set_quorum_type(QuorumType::Region);
    /// let x1 = InstanceConfig::new().set_quorum_type(QuorumType::DualRegion);
    /// let x2 = InstanceConfig::new().set_quorum_type(QuorumType::MultiRegion);
    /// ```
    pub fn set_quorum_type<T: std::convert::Into<crate::model::instance_config::QuorumType>>(
        mut self,
        v: T,
    ) -> Self {
        self.quorum_type = v.into();
        self
    }

    /// Sets the value of [storage_limit_per_processing_unit][crate::model::InstanceConfig::storage_limit_per_processing_unit].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = InstanceConfig::new().set_storage_limit_per_processing_unit(42);
    /// ```
    pub fn set_storage_limit_per_processing_unit<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_limit_per_processing_unit = v.into();
        self
    }
}

impl wkt::message::Message for InstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.InstanceConfig"
    }
}

/// Defines additional types related to [InstanceConfig].
pub mod instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of this configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified.
        Unspecified,
        /// Google-managed configuration.
        GoogleManaged,
        /// User-managed configuration.
        UserManaged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleManaged => std::option::Option::Some(1),
                Self::UserManaged => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::GoogleManaged => std::option::Option::Some("GOOGLE_MANAGED"),
                Self::UserManaged => std::option::Option::Some("USER_MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleManaged,
                2 => Self::UserManaged,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_MANAGED" => Self::GoogleManaged,
                "USER_MANAGED" => Self::UserManaged,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleManaged => serializer.serialize_i32(1),
                Self::UserManaged => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.spanner.admin.instance.v1.InstanceConfig.Type",
            ))
        }
    }

    /// Indicates the current state of the instance configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The instance configuration is still being created.
        Creating,
        /// The instance configuration is fully created and ready to be used to
        /// create instances.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.spanner.admin.instance.v1.InstanceConfig.State",
            ))
        }
    }

    /// Describes the availability for free instances to be created in an instance
    /// configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FreeInstanceAvailability {
        /// Not specified.
        Unspecified,
        /// Indicates that free instances are available to be created in this
        /// instance configuration.
        Available,
        /// Indicates that free instances are not supported in this instance
        /// configuration.
        Unsupported,
        /// Indicates that free instances are currently not available to be created
        /// in this instance configuration.
        Disabled,
        /// Indicates that additional free instances cannot be created in this
        /// instance configuration because the project has reached its limit of free
        /// instances.
        QuotaExceeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FreeInstanceAvailability::value] or
        /// [FreeInstanceAvailability::name].
        UnknownValue(free_instance_availability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod free_instance_availability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FreeInstanceAvailability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Available => std::option::Option::Some(1),
                Self::Unsupported => std::option::Option::Some(2),
                Self::Disabled => std::option::Option::Some(3),
                Self::QuotaExceeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("FREE_INSTANCE_AVAILABILITY_UNSPECIFIED")
                }
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Unsupported => std::option::Option::Some("UNSUPPORTED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::QuotaExceeded => std::option::Option::Some("QUOTA_EXCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FreeInstanceAvailability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FreeInstanceAvailability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FreeInstanceAvailability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Available,
                2 => Self::Unsupported,
                3 => Self::Disabled,
                4 => Self::QuotaExceeded,
                _ => Self::UnknownValue(free_instance_availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FreeInstanceAvailability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FREE_INSTANCE_AVAILABILITY_UNSPECIFIED" => Self::Unspecified,
                "AVAILABLE" => Self::Available,
                "UNSUPPORTED" => Self::Unsupported,
                "DISABLED" => Self::Disabled,
                "QUOTA_EXCEEDED" => Self::QuotaExceeded,
                _ => Self::UnknownValue(free_instance_availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FreeInstanceAvailability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Available => serializer.serialize_i32(1),
                Self::Unsupported => serializer.serialize_i32(2),
                Self::Disabled => serializer.serialize_i32(3),
                Self::QuotaExceeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FreeInstanceAvailability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<FreeInstanceAvailability>::new(
                    ".google.spanner.admin.instance.v1.InstanceConfig.FreeInstanceAvailability",
                ),
            )
        }
    }

    /// Indicates the quorum type of this instance configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum QuorumType {
        /// Quorum type not specified.
        Unspecified,
        /// An instance configuration tagged with `REGION` quorum type forms a write
        /// quorum in a single region.
        Region,
        /// An instance configuration tagged with the `DUAL_REGION` quorum type forms
        /// a write quorum with exactly two read-write regions in a multi-region
        /// configuration.
        ///
        /// This instance configuration requires failover in the event of
        /// regional failures.
        DualRegion,
        /// An instance configuration tagged with the `MULTI_REGION` quorum type
        /// forms a write quorum from replicas that are spread across more than one
        /// region in a multi-region configuration.
        MultiRegion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [QuorumType::value] or
        /// [QuorumType::name].
        UnknownValue(quorum_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod quorum_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl QuorumType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Region => std::option::Option::Some(1),
                Self::DualRegion => std::option::Option::Some(2),
                Self::MultiRegion => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("QUORUM_TYPE_UNSPECIFIED"),
                Self::Region => std::option::Option::Some("REGION"),
                Self::DualRegion => std::option::Option::Some("DUAL_REGION"),
                Self::MultiRegion => std::option::Option::Some("MULTI_REGION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for QuorumType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for QuorumType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for QuorumType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Region,
                2 => Self::DualRegion,
                3 => Self::MultiRegion,
                _ => Self::UnknownValue(quorum_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for QuorumType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "QUORUM_TYPE_UNSPECIFIED" => Self::Unspecified,
                "REGION" => Self::Region,
                "DUAL_REGION" => Self::DualRegion,
                "MULTI_REGION" => Self::MultiRegion,
                _ => Self::UnknownValue(quorum_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for QuorumType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Region => serializer.serialize_i32(1),
                Self::DualRegion => serializer.serialize_i32(2),
                Self::MultiRegion => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for QuorumType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuorumType>::new(
                ".google.spanner.admin.instance.v1.InstanceConfig.QuorumType",
            ))
        }
    }
}

/// ReplicaComputeCapacity describes the amount of server resources that are
/// allocated to each replica identified by the replica selection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaComputeCapacity {
    /// Required. Identifies replicas by specified properties.
    /// All replicas in the selection have the same amount of compute capacity.
    pub replica_selection: std::option::Option<crate::model::ReplicaSelection>,

    /// Compute capacity allocated to each replica identified by the specified
    /// selection.
    /// The unit is selected based on the unit used to specify the instance size
    /// for non-autoscaling instances, or the unit used in autoscaling limit for
    /// autoscaling instances.
    pub compute_capacity:
        std::option::Option<crate::model::replica_compute_capacity::ComputeCapacity>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaComputeCapacity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replica_selection][crate::model::ReplicaComputeCapacity::replica_selection].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaComputeCapacity;
    /// use google_cloud_spanner_admin_instance_v1::model::ReplicaSelection;
    /// let x = ReplicaComputeCapacity::new().set_replica_selection(ReplicaSelection::default()/* use setters */);
    /// ```
    pub fn set_replica_selection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicaSelection>,
    {
        self.replica_selection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replica_selection][crate::model::ReplicaComputeCapacity::replica_selection].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaComputeCapacity;
    /// use google_cloud_spanner_admin_instance_v1::model::ReplicaSelection;
    /// let x = ReplicaComputeCapacity::new().set_or_clear_replica_selection(Some(ReplicaSelection::default()/* use setters */));
    /// let x = ReplicaComputeCapacity::new().set_or_clear_replica_selection(None::<ReplicaSelection>);
    /// ```
    pub fn set_or_clear_replica_selection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicaSelection>,
    {
        self.replica_selection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity].
    ///
    /// Note that all the setters affecting `compute_capacity` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaComputeCapacity;
    /// use google_cloud_spanner_admin_instance_v1::model::replica_compute_capacity::ComputeCapacity;
    /// let x = ReplicaComputeCapacity::new().set_compute_capacity(Some(ComputeCapacity::NodeCount(42)));
    /// ```
    pub fn set_compute_capacity<
        T: std::convert::Into<
                std::option::Option<crate::model::replica_compute_capacity::ComputeCapacity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_capacity = v.into();
        self
    }

    /// The value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// if it holds a `NodeCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn node_count(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::replica_compute_capacity::ComputeCapacity::NodeCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// to hold a `NodeCount`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaComputeCapacity;
    /// let x = ReplicaComputeCapacity::new().set_node_count(42);
    /// assert!(x.node_count().is_some());
    /// assert!(x.processing_units().is_none());
    /// ```
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::replica_compute_capacity::ComputeCapacity::NodeCount(v.into()),
        );
        self
    }

    /// The value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// if it holds a `ProcessingUnits`, `None` if the field is not set or
    /// holds a different branch.
    pub fn processing_units(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::replica_compute_capacity::ComputeCapacity::ProcessingUnits(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// to hold a `ProcessingUnits`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ReplicaComputeCapacity;
    /// let x = ReplicaComputeCapacity::new().set_processing_units(42);
    /// assert!(x.processing_units().is_some());
    /// assert!(x.node_count().is_none());
    /// ```
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::replica_compute_capacity::ComputeCapacity::ProcessingUnits(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplicaComputeCapacity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaComputeCapacity"
    }
}

/// Defines additional types related to [ReplicaComputeCapacity].
pub mod replica_compute_capacity {
    #[allow(unused_imports)]
    use super::*;

    /// Compute capacity allocated to each replica identified by the specified
    /// selection.
    /// The unit is selected based on the unit used to specify the instance size
    /// for non-autoscaling instances, or the unit used in autoscaling limit for
    /// autoscaling instances.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComputeCapacity {
        /// The number of nodes allocated to each replica.
        ///
        /// This may be zero in API responses for instances that are not yet in
        /// state `READY`.
        NodeCount(i32),
        /// The number of processing units allocated to each replica.
        ///
        /// This may be zero in API responses for instances that are not yet in
        /// state `READY`.
        ProcessingUnits(i32),
    }
}

/// Autoscaling configuration for an instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoscalingConfig {
    /// Required. Autoscaling limits for an instance.
    pub autoscaling_limits:
        std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,

    /// Required. The autoscaling targets for an instance.
    pub autoscaling_targets:
        std::option::Option<crate::model::autoscaling_config::AutoscalingTargets>,

    /// Optional. Optional asymmetric autoscaling options.
    /// Replicas matching the replica selection criteria will be autoscaled
    /// independently from other replicas. The autoscaler will scale the replicas
    /// based on the utilization of replicas identified by the replica selection.
    /// Replica selections should not overlap with each other.
    ///
    /// Other replicas (those do not match any replica selection) will be
    /// autoscaled together and will have the same compute capacity allocated to
    /// them.
    pub asymmetric_autoscaling_options:
        std::vec::Vec<crate::model::autoscaling_config::AsymmetricAutoscalingOption>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autoscaling_limits][crate::model::AutoscalingConfig::autoscaling_limits].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
    /// let x = AutoscalingConfig::new().set_autoscaling_limits(AutoscalingLimits::default()/* use setters */);
    /// ```
    pub fn set_autoscaling_limits<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
    {
        self.autoscaling_limits = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_limits][crate::model::AutoscalingConfig::autoscaling_limits].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
    /// let x = AutoscalingConfig::new().set_or_clear_autoscaling_limits(Some(AutoscalingLimits::default()/* use setters */));
    /// let x = AutoscalingConfig::new().set_or_clear_autoscaling_limits(None::<AutoscalingLimits>);
    /// ```
    pub fn set_or_clear_autoscaling_limits<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
    {
        self.autoscaling_limits = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoscaling_targets][crate::model::AutoscalingConfig::autoscaling_targets].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingTargets;
    /// let x = AutoscalingConfig::new().set_autoscaling_targets(AutoscalingTargets::default()/* use setters */);
    /// ```
    pub fn set_autoscaling_targets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingTargets>,
    {
        self.autoscaling_targets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_targets][crate::model::AutoscalingConfig::autoscaling_targets].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingTargets;
    /// let x = AutoscalingConfig::new().set_or_clear_autoscaling_targets(Some(AutoscalingTargets::default()/* use setters */));
    /// let x = AutoscalingConfig::new().set_or_clear_autoscaling_targets(None::<AutoscalingTargets>);
    /// ```
    pub fn set_or_clear_autoscaling_targets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingTargets>,
    {
        self.autoscaling_targets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asymmetric_autoscaling_options][crate::model::AutoscalingConfig::asymmetric_autoscaling_options].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AsymmetricAutoscalingOption;
    /// let x = AutoscalingConfig::new()
    ///     .set_asymmetric_autoscaling_options([
    ///         AsymmetricAutoscalingOption::default()/* use setters */,
    ///         AsymmetricAutoscalingOption::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_asymmetric_autoscaling_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::autoscaling_config::AsymmetricAutoscalingOption>,
    {
        use std::iter::Iterator;
        self.asymmetric_autoscaling_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutoscalingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig"
    }
}

/// Defines additional types related to [AutoscalingConfig].
pub mod autoscaling_config {
    #[allow(unused_imports)]
    use super::*;

    /// The autoscaling limits for the instance. Users can define the minimum and
    /// maximum compute capacity allocated to the instance, and the autoscaler will
    /// only scale within that range. Users can either use nodes or processing
    /// units to specify the limits, but should use the same unit to set both the
    /// min_limit and max_limit.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutoscalingLimits {
        /// The minimum compute capacity for the instance.
        pub min_limit:
            std::option::Option<crate::model::autoscaling_config::autoscaling_limits::MinLimit>,

        /// The maximum compute capacity for the instance. The maximum compute
        /// capacity should be less than or equal to 10X the minimum compute
        /// capacity.
        pub max_limit:
            std::option::Option<crate::model::autoscaling_config::autoscaling_limits::MaxLimit>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoscalingLimits {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit].
        ///
        /// Note that all the setters affecting `min_limit` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
        /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::autoscaling_limits::MinLimit;
        /// let x = AutoscalingLimits::new().set_min_limit(Some(MinLimit::MinNodes(42)));
        /// ```
        pub fn set_min_limit<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::autoscaling_config::autoscaling_limits::MinLimit,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_limit = v.into();
            self
        }

        /// The value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// if it holds a `MinNodes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn min_nodes(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.min_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinNodes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// to hold a `MinNodes`.
        ///
        /// Note that all the setters affecting `min_limit` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
        /// let x = AutoscalingLimits::new().set_min_nodes(42);
        /// assert!(x.min_nodes().is_some());
        /// assert!(x.min_processing_units().is_none());
        /// ```
        pub fn set_min_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinNodes(v.into()),
            );
            self
        }

        /// The value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// if it holds a `MinProcessingUnits`, `None` if the field is not set or
        /// holds a different branch.
        pub fn min_processing_units(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.min_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinProcessingUnits(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// to hold a `MinProcessingUnits`.
        ///
        /// Note that all the setters affecting `min_limit` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
        /// let x = AutoscalingLimits::new().set_min_processing_units(42);
        /// assert!(x.min_processing_units().is_some());
        /// assert!(x.min_nodes().is_none());
        /// ```
        pub fn set_min_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinProcessingUnits(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit].
        ///
        /// Note that all the setters affecting `max_limit` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
        /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::autoscaling_limits::MaxLimit;
        /// let x = AutoscalingLimits::new().set_max_limit(Some(MaxLimit::MaxNodes(42)));
        /// ```
        pub fn set_max_limit<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::autoscaling_config::autoscaling_limits::MaxLimit,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_limit = v.into();
            self
        }

        /// The value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// if it holds a `MaxNodes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn max_nodes(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.max_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxNodes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// to hold a `MaxNodes`.
        ///
        /// Note that all the setters affecting `max_limit` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
        /// let x = AutoscalingLimits::new().set_max_nodes(42);
        /// assert!(x.max_nodes().is_some());
        /// assert!(x.max_processing_units().is_none());
        /// ```
        pub fn set_max_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxNodes(v.into()),
            );
            self
        }

        /// The value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// if it holds a `MaxProcessingUnits`, `None` if the field is not set or
        /// holds a different branch.
        pub fn max_processing_units(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.max_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxProcessingUnits(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// to hold a `MaxProcessingUnits`.
        ///
        /// Note that all the setters affecting `max_limit` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
        /// let x = AutoscalingLimits::new().set_max_processing_units(42);
        /// assert!(x.max_processing_units().is_some());
        /// assert!(x.max_nodes().is_none());
        /// ```
        pub fn set_max_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxProcessingUnits(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for AutoscalingLimits {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingLimits"
        }
    }

    /// Defines additional types related to [AutoscalingLimits].
    pub mod autoscaling_limits {
        #[allow(unused_imports)]
        use super::*;

        /// The minimum compute capacity for the instance.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MinLimit {
            /// Minimum number of nodes allocated to the instance. If set, this number
            /// should be greater than or equal to 1.
            MinNodes(i32),
            /// Minimum number of processing units allocated to the instance. If set,
            /// this number should be multiples of 1000.
            MinProcessingUnits(i32),
        }

        /// The maximum compute capacity for the instance. The maximum compute
        /// capacity should be less than or equal to 10X the minimum compute
        /// capacity.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MaxLimit {
            /// Maximum number of nodes allocated to the instance. If set, this number
            /// should be greater than or equal to min_nodes.
            MaxNodes(i32),
            /// Maximum number of processing units allocated to the instance. If set,
            /// this number should be multiples of 1000 and be greater than or equal to
            /// min_processing_units.
            MaxProcessingUnits(i32),
        }
    }

    /// The autoscaling targets for an instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutoscalingTargets {
        /// Required. The target high priority cpu utilization percentage that the
        /// autoscaler should be trying to achieve for the instance. This number is
        /// on a scale from 0 (no utilization) to 100 (full utilization). The valid
        /// range is [10, 90] inclusive.
        pub high_priority_cpu_utilization_percent: i32,

        /// Required. The target storage utilization percentage that the autoscaler
        /// should be trying to achieve for the instance. This number is on a scale
        /// from 0 (no utilization) to 100 (full utilization). The valid range is
        /// [10, 99] inclusive.
        pub storage_utilization_percent: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoscalingTargets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [high_priority_cpu_utilization_percent][crate::model::autoscaling_config::AutoscalingTargets::high_priority_cpu_utilization_percent].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingTargets;
        /// let x = AutoscalingTargets::new().set_high_priority_cpu_utilization_percent(42);
        /// ```
        pub fn set_high_priority_cpu_utilization_percent<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.high_priority_cpu_utilization_percent = v.into();
            self
        }

        /// Sets the value of [storage_utilization_percent][crate::model::autoscaling_config::AutoscalingTargets::storage_utilization_percent].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingTargets;
        /// let x = AutoscalingTargets::new().set_storage_utilization_percent(42);
        /// ```
        pub fn set_storage_utilization_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.storage_utilization_percent = v.into();
            self
        }
    }

    impl wkt::message::Message for AutoscalingTargets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingTargets"
        }
    }

    /// AsymmetricAutoscalingOption specifies the scaling of replicas identified by
    /// the given selection.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AsymmetricAutoscalingOption {
    
        /// Required. Selects the replicas to which this AsymmetricAutoscalingOption
        /// applies. Only read-only replicas are supported.
        pub replica_selection: std::option::Option<crate::model::ReplicaSelection>,
    
        /// Optional. Overrides applied to the top-level autoscaling configuration
        /// for the selected replicas.
        pub overrides: std::option::Option<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>,
    
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AsymmetricAutoscalingOption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [replica_selection][crate::model::autoscaling_config::AsymmetricAutoscalingOption::replica_selection].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AsymmetricAutoscalingOption;
        /// use google_cloud_spanner_admin_instance_v1::model::ReplicaSelection;
        /// let x = AsymmetricAutoscalingOption::new().set_replica_selection(ReplicaSelection::default()/* use setters */);
        /// ```
        pub fn set_replica_selection<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ReplicaSelection>,
        {
            self.replica_selection = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [replica_selection][crate::model::autoscaling_config::AsymmetricAutoscalingOption::replica_selection].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AsymmetricAutoscalingOption;
        /// use google_cloud_spanner_admin_instance_v1::model::ReplicaSelection;
        /// let x = AsymmetricAutoscalingOption::new().set_or_clear_replica_selection(Some(ReplicaSelection::default()/* use setters */));
        /// let x = AsymmetricAutoscalingOption::new().set_or_clear_replica_selection(None::<ReplicaSelection>);
        /// ```
        pub fn set_or_clear_replica_selection<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ReplicaSelection>,
        {
            self.replica_selection = v.map(|x| x.into());
            self
        }

        /// Sets the value of [overrides][crate::model::autoscaling_config::AsymmetricAutoscalingOption::overrides].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AsymmetricAutoscalingOption;
        /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides;
        /// let x = AsymmetricAutoscalingOption::new().set_overrides(AutoscalingConfigOverrides::default()/* use setters */);
        /// ```
        pub fn set_overrides<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>
        {
            self.overrides = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [overrides][crate::model::autoscaling_config::AsymmetricAutoscalingOption::overrides].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AsymmetricAutoscalingOption;
        /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides;
        /// let x = AsymmetricAutoscalingOption::new().set_or_clear_overrides(Some(AutoscalingConfigOverrides::default()/* use setters */));
        /// let x = AsymmetricAutoscalingOption::new().set_or_clear_overrides(None::<AutoscalingConfigOverrides>);
        /// ```
        pub fn set_or_clear_overrides<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>
        {
            self.overrides = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AsymmetricAutoscalingOption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AsymmetricAutoscalingOption"
        }
    }

    /// Defines additional types related to [AsymmetricAutoscalingOption].
    pub mod asymmetric_autoscaling_option {
        #[allow(unused_imports)]
        use super::*;

        /// Overrides the top-level autoscaling configuration for the replicas
        /// identified by `replica_selection`. All fields in this message are
        /// optional. Any unspecified fields will use the corresponding values from
        /// the top-level autoscaling configuration.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AutoscalingConfigOverrides {
            /// Optional. If specified, overrides the min/max limit in the top-level
            /// autoscaling configuration for the selected replicas.
            pub autoscaling_limits:
                std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,

            /// Optional. If specified, overrides the autoscaling target
            /// high_priority_cpu_utilization_percent in the top-level autoscaling
            /// configuration for the selected replicas.
            pub autoscaling_target_high_priority_cpu_utilization_percent: i32,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AutoscalingConfigOverrides {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [autoscaling_limits][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_limits].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides;
            /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
            /// let x = AutoscalingConfigOverrides::new().set_autoscaling_limits(AutoscalingLimits::default()/* use setters */);
            /// ```
            pub fn set_autoscaling_limits<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
            {
                self.autoscaling_limits = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [autoscaling_limits][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_limits].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides;
            /// use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::AutoscalingLimits;
            /// let x = AutoscalingConfigOverrides::new().set_or_clear_autoscaling_limits(Some(AutoscalingLimits::default()/* use setters */));
            /// let x = AutoscalingConfigOverrides::new().set_or_clear_autoscaling_limits(None::<AutoscalingLimits>);
            /// ```
            pub fn set_or_clear_autoscaling_limits<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
            {
                self.autoscaling_limits = v.map(|x| x.into());
                self
            }

            /// Sets the value of [autoscaling_target_high_priority_cpu_utilization_percent][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_target_high_priority_cpu_utilization_percent].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_spanner_admin_instance_v1::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides;
            /// let x = AutoscalingConfigOverrides::new().set_autoscaling_target_high_priority_cpu_utilization_percent(42);
            /// ```
            pub fn set_autoscaling_target_high_priority_cpu_utilization_percent<
                T: std::convert::Into<i32>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.autoscaling_target_high_priority_cpu_utilization_percent = v.into();
                self
            }
        }

        impl wkt::message::Message for AutoscalingConfigOverrides {
            fn typename() -> &'static str {
                "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AsymmetricAutoscalingOption.AutoscalingConfigOverrides"
            }
        }
    }
}

/// An isolated set of Cloud Spanner resources on which databases can be hosted.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Required. A unique identifier for the instance, which cannot be changed
    /// after the instance is created. Values are of the form
    /// `projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]`. The final
    /// segment of the name must be between 2 and 64 characters in length.
    pub name: std::string::String,

    /// Required. The name of the instance's configuration. Values are of the form
    /// `projects/<project>/instanceConfigs/<configuration>`. See
    /// also [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    pub config: std::string::String,

    /// Required. The descriptive name for this instance as it appears in UIs.
    /// Must be unique per project and between 4 and 30 characters in length.
    pub display_name: std::string::String,

    /// The number of nodes allocated to this instance. At most, one of either
    /// `node_count` or `processing_units` should be present in the message.
    ///
    /// Users can set the `node_count` field to specify the target number of nodes
    /// allocated to the instance.
    ///
    /// If autoscaling is enabled, `node_count` is treated as an `OUTPUT_ONLY`
    /// field and reflects the current number of nodes allocated to the instance.
    ///
    /// This might be zero in API responses for instances that are not yet in the
    /// `READY` state.
    ///
    /// For more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub node_count: i32,

    /// The number of processing units allocated to this instance. At most, one of
    /// either `processing_units` or `node_count` should be present in the message.
    ///
    /// Users can set the `processing_units` field to specify the target number of
    /// processing units allocated to the instance.
    ///
    /// If autoscaling is enabled, `processing_units` is treated as an
    /// `OUTPUT_ONLY` field and reflects the current number of processing units
    /// allocated to the instance.
    ///
    /// This might be zero in API responses for instances that are not yet in the
    /// `READY` state.
    ///
    /// For more information, see
    /// [Compute capacity, nodes and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub processing_units: i32,

    /// Output only. Lists the compute capacity per ReplicaSelection. A replica
    /// selection identifies a set of replicas with common properties. Replicas
    /// identified by a ReplicaSelection are scaled with the same compute capacity.
    pub replica_compute_capacity: std::vec::Vec<crate::model::ReplicaComputeCapacity>,

    /// Optional. The autoscaling configuration. Autoscaling is enabled if this
    /// field is set. When autoscaling is enabled, node_count and processing_units
    /// are treated as OUTPUT_ONLY fields and reflect the current compute capacity
    /// allocated to the instance.
    pub autoscaling_config: std::option::Option<crate::model::AutoscalingConfig>,

    /// Output only. The current instance state. For
    /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance],
    /// the state must be either omitted or set to `CREATING`. For
    /// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance],
    /// the state must be either omitted or set to `READY`.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
    pub state: crate::model::instance::State,

    /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. Cloud Labels can be used to filter collections of
    /// resources. They can be used to control how resource metrics are aggregated.
    /// And they can be used as arguments to policy management rules (e.g. route,
    /// firewall, load balancing, etc.).
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform
    ///   to the regular expression `[a-z0-9_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    ///
    /// If you plan to use labels in your own code, please note that additional
    /// characters may be allowed in the future. And so you are advised to use an
    /// internal label representation, such as JSON, which doesn't rely upon
    /// specific characters being disallowed.  For example, representing labels
    /// as the string:  name + "_" + value  would prove problematic if we were to
    /// allow "_" in a future release.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The `InstanceType` of the current instance.
    pub instance_type: crate::model::instance::InstanceType,

    /// Deprecated. This field is not populated.
    pub endpoint_uris: std::vec::Vec<std::string::String>,

    /// Output only. The time at which the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the instance was most recently updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Free instance metadata. Only populated for free instances.
    pub free_instance_metadata: std::option::Option<crate::model::FreeInstanceMetadata>,

    /// Optional. The `Edition` of the current instance.
    pub edition: crate::model::instance::Edition,

    /// Optional. Controls the default backup schedule behavior for new databases
    /// within the instance. By default, a backup schedule is created automatically
    /// when a new database is created in a new instance.
    ///
    /// Note that the `AUTOMATIC` value isn't permitted for free instances,
    /// as backups and backup schedules aren't supported for free instances.
    ///
    /// In the `GetInstance` or `ListInstances` response, if the value of
    /// `default_backup_schedule_type` isn't set, or set to `NONE`, Spanner doesn't
    /// create a default backup schedule for new databases in the instance.
    pub default_backup_schedule_type: crate::model::instance::DefaultBackupScheduleType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = Instance::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Instance::config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = Instance::new().set_config("example");
    /// ```
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = Instance::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::Instance::node_count].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = Instance::new().set_node_count(42);
    /// ```
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [processing_units][crate::model::Instance::processing_units].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = Instance::new().set_processing_units(42);
    /// ```
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.processing_units = v.into();
        self
    }

    /// Sets the value of [replica_compute_capacity][crate::model::Instance::replica_compute_capacity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::ReplicaComputeCapacity;
    /// let x = Instance::new()
    ///     .set_replica_compute_capacity([
    ///         ReplicaComputeCapacity::default()/* use setters */,
    ///         ReplicaComputeCapacity::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_replica_compute_capacity<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaComputeCapacity>,
    {
        use std::iter::Iterator;
        self.replica_compute_capacity = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autoscaling_config][crate::model::Instance::autoscaling_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// let x = Instance::new().set_autoscaling_config(AutoscalingConfig::default()/* use setters */);
    /// ```
    pub fn set_autoscaling_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_config][crate::model::Instance::autoscaling_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// let x = Instance::new().set_or_clear_autoscaling_config(Some(AutoscalingConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_autoscaling_config(None::<AutoscalingConfig>);
    /// ```
    pub fn set_or_clear_autoscaling_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::instance::State;
    /// let x0 = Instance::new().set_state(State::Creating);
    /// let x1 = Instance::new().set_state(State::Ready);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = Instance::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [instance_type][crate::model::Instance::instance_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::instance::InstanceType;
    /// let x0 = Instance::new().set_instance_type(InstanceType::Provisioned);
    /// let x1 = Instance::new().set_instance_type(InstanceType::FreeInstance);
    /// ```
    pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [endpoint_uris][crate::model::Instance::endpoint_uris].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = Instance::new().set_endpoint_uris(["a", "b", "c"]);
    /// ```
    pub fn set_endpoint_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoint_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [free_instance_metadata][crate::model::Instance::free_instance_metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::FreeInstanceMetadata;
    /// let x = Instance::new().set_free_instance_metadata(FreeInstanceMetadata::default()/* use setters */);
    /// ```
    pub fn set_free_instance_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FreeInstanceMetadata>,
    {
        self.free_instance_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [free_instance_metadata][crate::model::Instance::free_instance_metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::FreeInstanceMetadata;
    /// let x = Instance::new().set_or_clear_free_instance_metadata(Some(FreeInstanceMetadata::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_free_instance_metadata(None::<FreeInstanceMetadata>);
    /// ```
    pub fn set_or_clear_free_instance_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FreeInstanceMetadata>,
    {
        self.free_instance_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [edition][crate::model::Instance::edition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::instance::Edition;
    /// let x0 = Instance::new().set_edition(Edition::Standard);
    /// let x1 = Instance::new().set_edition(Edition::Enterprise);
    /// let x2 = Instance::new().set_edition(Edition::EnterprisePlus);
    /// ```
    pub fn set_edition<T: std::convert::Into<crate::model::instance::Edition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [default_backup_schedule_type][crate::model::Instance::default_backup_schedule_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// use google_cloud_spanner_admin_instance_v1::model::instance::DefaultBackupScheduleType;
    /// let x0 = Instance::new().set_default_backup_schedule_type(DefaultBackupScheduleType::None);
    /// let x1 = Instance::new().set_default_backup_schedule_type(DefaultBackupScheduleType::Automatic);
    /// ```
    pub fn set_default_backup_schedule_type<
        T: std::convert::Into<crate::model::instance::DefaultBackupScheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_backup_schedule_type = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The instance is still being created. Resources may not be
        /// available yet, and operations such as database creation may not
        /// work.
        Creating,
        /// The instance is fully created and ready to do work such as
        /// creating databases.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.spanner.admin.instance.v1.Instance.State",
            ))
        }
    }

    /// The type of this instance. The type can be used to distinguish product
    /// variants, that can affect aspects like: usage restrictions, quotas and
    /// billing. Currently this is used to distinguish FREE_INSTANCE vs PROVISIONED
    /// instances.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceType {
        /// Not specified.
        Unspecified,
        /// Provisioned instances have dedicated resources, standard usage limits and
        /// support.
        Provisioned,
        /// Free instances provide no guarantee for dedicated resources,
        /// [node_count, processing_units] should be 0. They come
        /// with stricter usage limits and limited support.
        FreeInstance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceType::value] or
        /// [InstanceType::name].
        UnknownValue(instance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioned => std::option::Option::Some(1),
                Self::FreeInstance => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_TYPE_UNSPECIFIED"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::FreeInstance => std::option::Option::Some("FREE_INSTANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioned,
                2 => Self::FreeInstance,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONED" => Self::Provisioned,
                "FREE_INSTANCE" => Self::FreeInstance,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioned => serializer.serialize_i32(1),
                Self::FreeInstance => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceType>::new(
                ".google.spanner.admin.instance.v1.Instance.InstanceType",
            ))
        }
    }

    /// The edition selected for this instance. Different editions provide
    /// different capabilities at different price points.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Edition {
        /// Edition not specified.
        Unspecified,
        /// Standard edition.
        Standard,
        /// Enterprise edition.
        Enterprise,
        /// Enterprise Plus edition.
        EnterprisePlus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Edition::value] or
        /// [Edition::name].
        UnknownValue(edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Edition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Enterprise => std::option::Option::Some(2),
                Self::EnterprisePlus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EDITION_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::EnterprisePlus => std::option::Option::Some("ENTERPRISE_PLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Edition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Enterprise,
                3 => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Edition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "ENTERPRISE" => Self::Enterprise,
                "ENTERPRISE_PLUS" => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Edition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::EnterprisePlus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Edition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Edition>::new(
                ".google.spanner.admin.instance.v1.Instance.Edition",
            ))
        }
    }

    /// Indicates the
    /// [default backup
    /// schedule](https://cloud.google.com/spanner/docs/backup#default-backup-schedules)
    /// behavior for new databases within the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DefaultBackupScheduleType {
        /// Not specified.
        Unspecified,
        /// A default backup schedule isn't created automatically when a new database
        /// is created in the instance.
        None,
        /// A default backup schedule is created automatically when a new database
        /// is created in the instance. The default backup schedule creates a full
        /// backup every 24 hours. These full backups are retained for 7 days.
        /// You can edit or delete the default backup schedule once it's created.
        Automatic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DefaultBackupScheduleType::value] or
        /// [DefaultBackupScheduleType::name].
        UnknownValue(default_backup_schedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod default_backup_schedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DefaultBackupScheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Automatic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED")
                }
                Self::None => std::option::Option::Some("NONE"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DefaultBackupScheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DefaultBackupScheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DefaultBackupScheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Automatic,
                _ => Self::UnknownValue(default_backup_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DefaultBackupScheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "AUTOMATIC" => Self::Automatic,
                _ => Self::UnknownValue(default_backup_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DefaultBackupScheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Automatic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DefaultBackupScheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<DefaultBackupScheduleType>::new(
                    ".google.spanner.admin.instance.v1.Instance.DefaultBackupScheduleType",
                ),
            )
        }
    }
}

/// The request for
/// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigsRequest {
    /// Required. The name of the project for which a list of supported instance
    /// configurations is requested. Values are of the form
    /// `projects/<project>`.
    pub parent: std::string::String,

    /// Number of instance configurations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]
    /// from a previous
    /// [ListInstanceConfigsResponse][google.spanner.admin.instance.v1.ListInstanceConfigsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstanceConfigsResponse]: crate::model::ListInstanceConfigsResponse
    /// [google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]: crate::model::ListInstanceConfigsResponse::next_page_token
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstanceConfigsRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigsRequest;
    /// let x = ListInstanceConfigsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstanceConfigsRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigsRequest;
    /// let x = ListInstanceConfigsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstanceConfigsRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigsRequest;
    /// let x = ListInstanceConfigsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigsRequest"
    }
}

/// The response for
/// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigsResponse {
    /// The list of requested instance configurations.
    pub instance_configs: std::vec::Vec<crate::model::InstanceConfig>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]
    /// call to fetch more of the matching instance configurations.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_configs][crate::model::ListInstanceConfigsResponse::instance_configs].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigsResponse;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = ListInstanceConfigsResponse::new()
    ///     .set_instance_configs([
    ///         InstanceConfig::default()/* use setters */,
    ///         InstanceConfig::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_instance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceConfig>,
    {
        use std::iter::Iterator;
        self.instance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstanceConfigsResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigsResponse;
    /// let x = ListInstanceConfigsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstanceConfigsResponse {
    type PageItem = crate::model::InstanceConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instance_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [GetInstanceConfigRequest][google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig]: crate::client::InstanceAdmin::get_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceConfigRequest {
    /// Required. The name of the requested instance configuration. Values are of
    /// the form `projects/<project>/instanceConfigs/<config>`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceConfigRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::GetInstanceConfigRequest;
    /// let x = GetInstanceConfigRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstanceConfigRequest"
    }
}

/// The request for
/// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceConfigRequest {
    /// Required. The name of the project in which to create the instance
    /// configuration. Values are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// Required. The ID of the instance configuration to create. Valid identifiers
    /// are of the form `custom-[-a-z0-9]*[a-z0-9]` and must be between 2 and 64
    /// characters in length. The `custom-` prefix is required to avoid name
    /// conflicts with Google-managed configurations.
    pub instance_config_id: std::string::String,

    /// Required. The `InstanceConfig` proto of the configuration to create.
    /// `instance_config.name` must be
    /// `<parent>/instanceConfigs/<instance_config_id>`.
    /// `instance_config.base_config` must be a Google-managed configuration name,
    /// e.g. \<parent\>/instanceConfigs/us-east1, \<parent\>/instanceConfigs/nam3.
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceConfigRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigRequest;
    /// let x = CreateInstanceConfigRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_config_id][crate::model::CreateInstanceConfigRequest::instance_config_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigRequest;
    /// let x = CreateInstanceConfigRequest::new().set_instance_config_id("example");
    /// ```
    pub fn set_instance_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config_id = v.into();
        self
    }

    /// Sets the value of [instance_config][crate::model::CreateInstanceConfigRequest::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = CreateInstanceConfigRequest::new().set_instance_config(InstanceConfig::default()/* use setters */);
    /// ```
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::CreateInstanceConfigRequest::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = CreateInstanceConfigRequest::new().set_or_clear_instance_config(Some(InstanceConfig::default()/* use setters */));
    /// let x = CreateInstanceConfigRequest::new().set_or_clear_instance_config(None::<InstanceConfig>);
    /// ```
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateInstanceConfigRequest::validate_only].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigRequest;
    /// let x = CreateInstanceConfigRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigRequest"
    }
}

/// The request for
/// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceConfigRequest {
    /// Required. The user instance configuration to update, which must always
    /// include the instance configuration name. Otherwise, only fields mentioned
    /// in
    /// [update_mask][google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask]
    /// need be included. To prevent conflicts of concurrent updates,
    /// [etag][google.spanner.admin.instance.v1.InstanceConfig.reconciling] can
    /// be used.
    ///
    /// [google.spanner.admin.instance.v1.InstanceConfig.reconciling]: crate::model::InstanceConfig::reconciling
    /// [google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask]: crate::model::UpdateInstanceConfigRequest::update_mask
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// Required. A mask specifying which fields in
    /// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] should be
    /// updated. The field mask must always be specified; this prevents any future
    /// fields in [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig]
    /// from being erased accidentally by clients that do not know about them. Only
    /// display_name and labels can be updated.
    ///
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::UpdateInstanceConfigRequest::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = UpdateInstanceConfigRequest::new().set_instance_config(InstanceConfig::default()/* use setters */);
    /// ```
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::UpdateInstanceConfigRequest::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = UpdateInstanceConfigRequest::new().set_or_clear_instance_config(Some(InstanceConfig::default()/* use setters */));
    /// let x = UpdateInstanceConfigRequest::new().set_or_clear_instance_config(None::<InstanceConfig>);
    /// ```
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceConfigRequest::update_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstanceConfigRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceConfigRequest::update_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstanceConfigRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateInstanceConfigRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInstanceConfigRequest::validate_only].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigRequest;
    /// let x = UpdateInstanceConfigRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceConfigRequest"
    }
}

/// The request for
/// [DeleteInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstanceConfig]: crate::client::InstanceAdmin::delete_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceConfigRequest {
    /// Required. The name of the instance configuration to be deleted.
    /// Values are of the form
    /// `projects/<project>/instanceConfigs/<instance_config>`
    pub name: std::string::String,

    /// Used for optimistic concurrency control as a way to help prevent
    /// simultaneous deletes of an instance configuration from overwriting each
    /// other. If not empty, the API
    /// only deletes the instance configuration when the etag provided matches the
    /// current status of the requested instance configuration. Otherwise, deletes
    /// the instance configuration without checking the current status of the
    /// requested instance configuration.
    pub etag: std::string::String,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceConfigRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::DeleteInstanceConfigRequest;
    /// let x = DeleteInstanceConfigRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstanceConfigRequest::etag].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::DeleteInstanceConfigRequest;
    /// let x = DeleteInstanceConfigRequest::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteInstanceConfigRequest::validate_only].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::DeleteInstanceConfigRequest;
    /// let x = DeleteInstanceConfigRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstanceConfigRequest"
    }
}

/// The request for
/// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigOperationsRequest {
    /// Required. The project of the instance configuration operations.
    /// Values are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// An expression that filters the list of returned operations.
    ///
    /// A filter expression consists of a field name, a
    /// comparison operator, and a value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the Operation are eligible for filtering:
    ///
    /// * `name` - The name of the long-running operation
    /// * `done` - False if the operation is in progress, else true.
    /// * `metadata.@type` - the type of metadata. For example, the type string
    ///   for
    ///   [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata]
    ///   is
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata`.
    /// * `metadata.<field_name>` - any field in metadata.value.
    ///   `metadata.@type` must be specified first, if filtering on metadata
    ///   fields.
    /// * `error` - Error associated with the long-running operation.
    /// * `response.@type` - the type of response.
    /// * `response.<field_name>` - any field in response.value.
    ///
    /// You can combine multiple expressions by enclosing each expression in
    /// parentheses. By default, expressions are combined with AND logic. However,
    /// you can specify AND, OR, and NOT logic explicitly.
    ///
    /// Here are a few examples:
    ///
    /// * `done:true` - The operation is complete.
    /// * `(metadata.@type=` \
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata)
    ///   AND` \
    ///   `(metadata.instance_config.name:custom-config) AND` \
    ///   `(metadata.progress.start_time < \"2021-03-28T14:50:00Z\") AND` \
    ///   `(error:*)` - Return operations where:
    ///   * The operation's metadata type is
    ///     [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
    ///   * The instance configuration name contains "custom-config".
    ///   * The operation started before 2021-03-28T14:50:00Z.
    ///   * The operation resulted in an error.
    ///
    /// [google.spanner.admin.instance.v1.CreateInstanceConfigMetadata]: crate::model::CreateInstanceConfigMetadata
    pub filter: std::string::String,

    /// Number of operations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token]
    /// from a previous
    /// [ListInstanceConfigOperationsResponse][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse]
    /// to the same `parent` and with the same `filter`.
    ///
    /// [google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse]: crate::model::ListInstanceConfigOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token]: crate::model::ListInstanceConfigOperationsResponse::next_page_token
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstanceConfigOperationsRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigOperationsRequest;
    /// let x = ListInstanceConfigOperationsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstanceConfigOperationsRequest::filter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigOperationsRequest;
    /// let x = ListInstanceConfigOperationsRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstanceConfigOperationsRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigOperationsRequest;
    /// let x = ListInstanceConfigOperationsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstanceConfigOperationsRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigOperationsRequest;
    /// let x = ListInstanceConfigOperationsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest"
    }
}

/// The response for
/// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigOperationsResponse {
    /// The list of matching instance configuration long-running operations. Each
    /// operation's name will be
    /// prefixed by the name of the instance configuration. The operation's
    /// metadata field type
    /// `metadata.type_url` describes the type of the metadata.
    pub operations: std::vec::Vec<longrunning::model::Operation>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]
    /// call to fetch more of the matching metadata.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::ListInstanceConfigOperationsResponse::operations].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigOperationsResponse;
    /// use longrunning::model::Operation;
    /// let x = ListInstanceConfigOperationsResponse::new()
    ///     .set_operations([
    ///         Operation::default()/* use setters */,
    ///         Operation::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<longrunning::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstanceConfigOperationsResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstanceConfigOperationsResponse;
    /// let x = ListInstanceConfigOperationsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstanceConfigOperationsResponse {
    type PageItem = longrunning::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [GetInstance][google.spanner.admin.instance.v1.InstanceAdmin.GetInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstance]: crate::client::InstanceAdmin::get_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the requested instance. Values are of the form
    /// `projects/<project>/instances/<instance>`.
    pub name: std::string::String,

    /// If field_mask is present, specifies the subset of
    /// [Instance][google.spanner.admin.instance.v1.Instance] fields that should be
    /// returned. If absent, all
    /// [Instance][google.spanner.admin.instance.v1.Instance] fields are returned.
    ///
    /// [google.spanner.admin.instance.v1.Instance]: crate::model::Instance
    pub field_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::GetInstanceRequest;
    /// let x = GetInstanceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::GetInstanceRequest::field_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::GetInstanceRequest;
    /// use wkt::FieldMask;
    /// let x = GetInstanceRequest::new().set_field_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::GetInstanceRequest::field_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::GetInstanceRequest;
    /// use wkt::FieldMask;
    /// let x = GetInstanceRequest::new().set_or_clear_field_mask(Some(FieldMask::default()/* use setters */));
    /// let x = GetInstanceRequest::new().set_or_clear_field_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstanceRequest"
    }
}

/// The request for
/// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The name of the project in which to create the instance. Values
    /// are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// Required. The ID of the instance to create.  Valid identifiers are of the
    /// form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64 characters in
    /// length.
    pub instance_id: std::string::String,

    /// Required. The instance to create.  The name may be omitted, but if
    /// specified must be `<parent>/instances/<instance_id>`.
    pub instance: std::option::Option<crate::model::Instance>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceRequest;
    /// let x = CreateInstanceRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceRequest;
    /// let x = CreateInstanceRequest::new().set_instance_id("example");
    /// ```
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = CreateInstanceRequest::new().set_instance(Instance::default()/* use setters */);
    /// ```
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = CreateInstanceRequest::new().set_or_clear_instance(Some(Instance::default()/* use setters */));
    /// let x = CreateInstanceRequest::new().set_or_clear_instance(None::<Instance>);
    /// ```
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceRequest"
    }
}

/// The request for
/// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The name of the project for which a list of instances is
    /// requested. Values are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// Number of instances to be returned in the response. If 0 or less, defaults
    /// to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token]
    /// from a previous
    /// [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesResponse]: crate::model::ListInstancesResponse
    /// [google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token]: crate::model::ListInstancesResponse::next_page_token
    pub page_token: std::string::String,

    /// An expression for filtering the results of the request. Filter rules are
    /// case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `display_name`
    /// * `labels.key` where key is the name of a label
    ///
    /// Some examples of using filters are:
    ///
    /// * `name:*` --> The instance has a name.
    /// * `name:Howl` --> The instance's name contains the string "howl".
    /// * `name:HOWL` --> Equivalent to above.
    /// * `NAME:howl` --> Equivalent to above.
    /// * `labels.env:*` --> The instance has the label "env".
    /// * `labels.env:dev` --> The instance has the label "env" and the value of
    ///   the label contains the string "dev".
    /// * `name:howl labels.env:dev` --> The instance's name contains "howl" and
    ///   it has the label "env" with its value
    ///   containing "dev".
    pub filter: std::string::String,

    /// Deadline used while retrieving metadata for instances.
    /// Instances whose metadata cannot be retrieved within this deadline will be
    /// added to
    /// [unreachable][google.spanner.admin.instance.v1.ListInstancesResponse.unreachable]
    /// in
    /// [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesResponse]: crate::model::ListInstancesResponse
    /// [google.spanner.admin.instance.v1.ListInstancesResponse.unreachable]: crate::model::ListInstancesResponse::unreachable
    pub instance_deadline: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [instance_deadline][crate::model::ListInstancesRequest::instance_deadline].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesRequest;
    /// use wkt::Timestamp;
    /// let x = ListInstancesRequest::new().set_instance_deadline(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_instance_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_deadline][crate::model::ListInstancesRequest::instance_deadline].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesRequest;
    /// use wkt::Timestamp;
    /// let x = ListInstancesRequest::new().set_or_clear_instance_deadline(Some(Timestamp::default()/* use setters */));
    /// let x = ListInstancesRequest::new().set_or_clear_instance_deadline(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_instance_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_deadline = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancesRequest"
    }
}

/// The response for
/// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of requested instances.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]
    /// call to fetch more of the matching instances.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
    pub next_page_token: std::string::String,

    /// The list of unreachable instances.
    /// It includes the names of instances whose metadata could not be retrieved
    /// within
    /// [instance_deadline][google.spanner.admin.instance.v1.ListInstancesRequest.instance_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesRequest.instance_deadline]: crate::model::ListInstancesRequest::instance_deadline
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesResponse;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = ListInstancesResponse::new()
    ///     .set_instances([
    ///         Instance::default()/* use setters */,
    ///         Instance::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesResponse;
    /// let x = ListInstancesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancesResponse;
    /// let x = ListInstancesResponse::new().set_unreachable(["a", "b", "c"]);
    /// ```
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. The instance to update, which must always include the instance
    /// name.  Otherwise, only fields mentioned in
    /// [field_mask][google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask]
    /// need be included.
    ///
    /// [google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask]: crate::model::UpdateInstanceRequest::field_mask
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. A mask specifying which fields in
    /// [Instance][google.spanner.admin.instance.v1.Instance] should be updated.
    /// The field mask must always be specified; this prevents any future fields in
    /// [Instance][google.spanner.admin.instance.v1.Instance] from being erased
    /// accidentally by clients that do not know about them.
    ///
    /// [google.spanner.admin.instance.v1.Instance]: crate::model::Instance
    pub field_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = UpdateInstanceRequest::new().set_instance(Instance::default()/* use setters */);
    /// ```
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = UpdateInstanceRequest::new().set_or_clear_instance(Some(Instance::default()/* use setters */));
    /// let x = UpdateInstanceRequest::new().set_or_clear_instance(None::<Instance>);
    /// ```
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_mask][crate::model::UpdateInstanceRequest::field_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstanceRequest::new().set_field_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::UpdateInstanceRequest::field_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstanceRequest::new().set_or_clear_field_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateInstanceRequest::new().set_or_clear_field_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceRequest"
    }
}

/// The request for
/// [DeleteInstance][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance]: crate::client::InstanceAdmin::delete_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the instance to be deleted. Values are of the form
    /// `projects/<project>/instances/<instance>`
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::DeleteInstanceRequest;
    /// let x = DeleteInstanceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstanceRequest"
    }
}

/// Metadata type for the operation returned by
/// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceMetadata {
    /// The instance being created.
    pub instance: std::option::Option<crate::model::Instance>,

    /// The time at which the
    /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The expected fulfillment period of this create operation.
    pub expected_fulfillment_period: crate::model::FulfillmentPeriod,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::CreateInstanceMetadata::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = CreateInstanceMetadata::new().set_instance(Instance::default()/* use setters */);
    /// ```
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceMetadata::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = CreateInstanceMetadata::new().set_or_clear_instance(Some(Instance::default()/* use setters */));
    /// let x = CreateInstanceMetadata::new().set_or_clear_instance(None::<Instance>);
    /// ```
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::CreateInstanceMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceMetadata::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CreateInstanceMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceMetadata::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = CreateInstanceMetadata::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstanceMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceMetadata::new().set_cancel_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::CreateInstanceMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceMetadata::new().set_or_clear_cancel_time(Some(Timestamp::default()/* use setters */));
    /// let x = CreateInstanceMetadata::new().set_or_clear_cancel_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateInstanceMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceMetadata::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateInstanceMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceMetadata::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = CreateInstanceMetadata::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expected_fulfillment_period][crate::model::CreateInstanceMetadata::expected_fulfillment_period].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::FulfillmentPeriod;
    /// let x0 = CreateInstanceMetadata::new().set_expected_fulfillment_period(FulfillmentPeriod::Normal);
    /// let x1 = CreateInstanceMetadata::new().set_expected_fulfillment_period(FulfillmentPeriod::Extended);
    /// ```
    pub fn set_expected_fulfillment_period<
        T: std::convert::Into<crate::model::FulfillmentPeriod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_fulfillment_period = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceMetadata"
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceMetadata {
    /// The desired end state of the update.
    pub instance: std::option::Option<crate::model::Instance>,

    /// The time at which
    /// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The expected fulfillment period of this update operation.
    pub expected_fulfillment_period: crate::model::FulfillmentPeriod,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceMetadata::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = UpdateInstanceMetadata::new().set_instance(Instance::default()/* use setters */);
    /// ```
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceMetadata::instance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::Instance;
    /// let x = UpdateInstanceMetadata::new().set_or_clear_instance(Some(Instance::default()/* use setters */));
    /// let x = UpdateInstanceMetadata::new().set_or_clear_instance(None::<Instance>);
    /// ```
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateInstanceMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceMetadata::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpdateInstanceMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceMetadata::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = UpdateInstanceMetadata::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstanceMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceMetadata::new().set_cancel_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::UpdateInstanceMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceMetadata::new().set_or_clear_cancel_time(Some(Timestamp::default()/* use setters */));
    /// let x = UpdateInstanceMetadata::new().set_or_clear_cancel_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateInstanceMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceMetadata::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpdateInstanceMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceMetadata::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = UpdateInstanceMetadata::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expected_fulfillment_period][crate::model::UpdateInstanceMetadata::expected_fulfillment_period].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::FulfillmentPeriod;
    /// let x0 = UpdateInstanceMetadata::new().set_expected_fulfillment_period(FulfillmentPeriod::Normal);
    /// let x1 = UpdateInstanceMetadata::new().set_expected_fulfillment_period(FulfillmentPeriod::Extended);
    /// ```
    pub fn set_expected_fulfillment_period<
        T: std::convert::Into<crate::model::FulfillmentPeriod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_fulfillment_period = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceMetadata"
    }
}

/// Free instance specific metadata that is kept even after an instance has been
/// upgraded for tracking purposes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FreeInstanceMetadata {
    /// Output only. Timestamp after which the instance will either be upgraded or
    /// scheduled for deletion after a grace period. ExpireBehavior is used to
    /// choose between upgrading or scheduling the free instance for deletion. This
    /// timestamp is set during the creation of a free instance.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. If present, the timestamp at which the free instance was
    /// upgraded to a provisioned instance.
    pub upgrade_time: std::option::Option<wkt::Timestamp>,

    /// Specifies the expiration behavior of a free instance. The default of
    /// ExpireBehavior is `REMOVE_AFTER_GRACE_PERIOD`. This can be modified during
    /// or after creation, and before expiration.
    pub expire_behavior: crate::model::free_instance_metadata::ExpireBehavior,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FreeInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expire_time][crate::model::FreeInstanceMetadata::expire_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::FreeInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = FreeInstanceMetadata::new().set_expire_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::FreeInstanceMetadata::expire_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::FreeInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = FreeInstanceMetadata::new().set_or_clear_expire_time(Some(Timestamp::default()/* use setters */));
    /// let x = FreeInstanceMetadata::new().set_or_clear_expire_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upgrade_time][crate::model::FreeInstanceMetadata::upgrade_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::FreeInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = FreeInstanceMetadata::new().set_upgrade_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_upgrade_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.upgrade_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_time][crate::model::FreeInstanceMetadata::upgrade_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::FreeInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = FreeInstanceMetadata::new().set_or_clear_upgrade_time(Some(Timestamp::default()/* use setters */));
    /// let x = FreeInstanceMetadata::new().set_or_clear_upgrade_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_upgrade_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.upgrade_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_behavior][crate::model::FreeInstanceMetadata::expire_behavior].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::FreeInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::free_instance_metadata::ExpireBehavior;
    /// let x0 = FreeInstanceMetadata::new().set_expire_behavior(ExpireBehavior::FreeToProvisioned);
    /// let x1 = FreeInstanceMetadata::new().set_expire_behavior(ExpireBehavior::RemoveAfterGracePeriod);
    /// ```
    pub fn set_expire_behavior<
        T: std::convert::Into<crate::model::free_instance_metadata::ExpireBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expire_behavior = v.into();
        self
    }
}

impl wkt::message::Message for FreeInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.FreeInstanceMetadata"
    }
}

/// Defines additional types related to [FreeInstanceMetadata].
pub mod free_instance_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Allows users to change behavior when a free instance expires.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExpireBehavior {
        /// Not specified.
        Unspecified,
        /// When the free instance expires, upgrade the instance to a provisioned
        /// instance.
        FreeToProvisioned,
        /// When the free instance expires, disable the instance, and delete it
        /// after the grace period passes if it has not been upgraded.
        RemoveAfterGracePeriod,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExpireBehavior::value] or
        /// [ExpireBehavior::name].
        UnknownValue(expire_behavior::UnknownValue),
    }

    #[doc(hidden)]
    pub mod expire_behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExpireBehavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FreeToProvisioned => std::option::Option::Some(1),
                Self::RemoveAfterGracePeriod => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXPIRE_BEHAVIOR_UNSPECIFIED"),
                Self::FreeToProvisioned => std::option::Option::Some("FREE_TO_PROVISIONED"),
                Self::RemoveAfterGracePeriod => {
                    std::option::Option::Some("REMOVE_AFTER_GRACE_PERIOD")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExpireBehavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExpireBehavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExpireBehavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FreeToProvisioned,
                2 => Self::RemoveAfterGracePeriod,
                _ => Self::UnknownValue(expire_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExpireBehavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXPIRE_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "FREE_TO_PROVISIONED" => Self::FreeToProvisioned,
                "REMOVE_AFTER_GRACE_PERIOD" => Self::RemoveAfterGracePeriod,
                _ => Self::UnknownValue(expire_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExpireBehavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FreeToProvisioned => serializer.serialize_i32(1),
                Self::RemoveAfterGracePeriod => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExpireBehavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExpireBehavior>::new(
                ".google.spanner.admin.instance.v1.FreeInstanceMetadata.ExpireBehavior",
            ))
        }
    }
}

/// Metadata type for the operation returned by
/// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceConfigMetadata {
    /// The target instance configuration end state.
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// The progress of the
    /// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]
    /// operation.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceConfigMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::CreateInstanceConfigMetadata::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = CreateInstanceConfigMetadata::new().set_instance_config(InstanceConfig::default()/* use setters */);
    /// ```
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::CreateInstanceConfigMetadata::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = CreateInstanceConfigMetadata::new().set_or_clear_instance_config(Some(InstanceConfig::default()/* use setters */));
    /// let x = CreateInstanceConfigMetadata::new().set_or_clear_instance_config(None::<InstanceConfig>);
    /// ```
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::CreateInstanceConfigMetadata::progress].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// let x = CreateInstanceConfigMetadata::new().set_progress(OperationProgress::default()/* use setters */);
    /// ```
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::CreateInstanceConfigMetadata::progress].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// let x = CreateInstanceConfigMetadata::new().set_or_clear_progress(Some(OperationProgress::default()/* use setters */));
    /// let x = CreateInstanceConfigMetadata::new().set_or_clear_progress(None::<OperationProgress>);
    /// ```
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstanceConfigMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceConfigMetadata::new().set_cancel_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::CreateInstanceConfigMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstanceConfigMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstanceConfigMetadata::new().set_or_clear_cancel_time(Some(Timestamp::default()/* use setters */));
    /// let x = CreateInstanceConfigMetadata::new().set_or_clear_cancel_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstanceConfigMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata"
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceConfigMetadata {
    /// The desired instance configuration after updating.
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// The progress of the
    /// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]
    /// operation.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceConfigMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::UpdateInstanceConfigMetadata::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = UpdateInstanceConfigMetadata::new().set_instance_config(InstanceConfig::default()/* use setters */);
    /// ```
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::UpdateInstanceConfigMetadata::instance_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstanceConfig;
    /// let x = UpdateInstanceConfigMetadata::new().set_or_clear_instance_config(Some(InstanceConfig::default()/* use setters */));
    /// let x = UpdateInstanceConfigMetadata::new().set_or_clear_instance_config(None::<InstanceConfig>);
    /// ```
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::UpdateInstanceConfigMetadata::progress].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// let x = UpdateInstanceConfigMetadata::new().set_progress(OperationProgress::default()/* use setters */);
    /// ```
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::UpdateInstanceConfigMetadata::progress].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// let x = UpdateInstanceConfigMetadata::new().set_or_clear_progress(Some(OperationProgress::default()/* use setters */));
    /// let x = UpdateInstanceConfigMetadata::new().set_or_clear_progress(None::<OperationProgress>);
    /// ```
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstanceConfigMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceConfigMetadata::new().set_cancel_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::UpdateInstanceConfigMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstanceConfigMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstanceConfigMetadata::new().set_or_clear_cancel_time(Some(Timestamp::default()/* use setters */));
    /// let x = UpdateInstanceConfigMetadata::new().set_or_clear_cancel_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstanceConfigMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata"
    }
}

/// An isolated set of Cloud Spanner resources that databases can define
/// placements on.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancePartition {
    /// Required. A unique identifier for the instance partition. Values are of the
    /// form
    /// `projects/<project>/instances/<instance>/instancePartitions/[a-z][-a-z0-9]*[a-z0-9]`.
    /// The final segment of the name must be between 2 and 64 characters in
    /// length. An instance partition's name cannot be changed after the instance
    /// partition is created.
    pub name: std::string::String,

    /// Required. The name of the instance partition's configuration. Values are of
    /// the form `projects/<project>/instanceConfigs/<configuration>`. See also
    /// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    pub config: std::string::String,

    /// Required. The descriptive name for this instance partition as it appears in
    /// UIs. Must be unique per project and between 4 and 30 characters in length.
    pub display_name: std::string::String,

    /// Optional. The autoscaling configuration. Autoscaling is enabled if this
    /// field is set. When autoscaling is enabled, fields in compute_capacity are
    /// treated as OUTPUT_ONLY fields and reflect the current compute capacity
    /// allocated to the instance partition.
    pub autoscaling_config: std::option::Option<crate::model::AutoscalingConfig>,

    /// Output only. The current instance partition state.
    pub state: crate::model::instance_partition::State,

    /// Output only. The time at which the instance partition was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the instance partition was most recently
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The names of the databases that reference this
    /// instance partition. Referencing databases should share the parent instance.
    /// The existence of any referencing database prevents the instance partition
    /// from being deleted.
    pub referencing_databases: std::vec::Vec<std::string::String>,

    /// Output only. Deprecated: This field is not populated.
    /// Output only. The names of the backups that reference this instance
    /// partition. Referencing backups should share the parent instance. The
    /// existence of any referencing backup prevents the instance partition from
    /// being deleted.
    #[deprecated]
    pub referencing_backups: std::vec::Vec<std::string::String>,

    /// Used for optimistic concurrency control as a way
    /// to help prevent simultaneous updates of a instance partition from
    /// overwriting each other. It is strongly suggested that systems make use of
    /// the etag in the read-modify-write cycle to perform instance partition
    /// updates in order to avoid race conditions: An etag is returned in the
    /// response which contains instance partitions, and systems are expected to
    /// put that etag in the request to update instance partitions to ensure that
    /// their change will be applied to the same version of the instance partition.
    /// If no etag is provided in the call to update instance partition, then the
    /// existing instance partition is overwritten blindly.
    pub etag: std::string::String,

    /// Compute capacity defines amount of server and storage resources that are
    /// available to the databases in an instance partition. At most, one of either
    /// `node_count` or` processing_units` should be present in the message. For
    /// more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub compute_capacity: std::option::Option<crate::model::instance_partition::ComputeCapacity>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancePartition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstancePartition::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::InstancePartition::config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_config("example");
    /// ```
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InstancePartition::display_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [autoscaling_config][crate::model::InstancePartition::autoscaling_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// let x = InstancePartition::new().set_autoscaling_config(AutoscalingConfig::default()/* use setters */);
    /// ```
    pub fn set_autoscaling_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_config][crate::model::InstancePartition::autoscaling_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use google_cloud_spanner_admin_instance_v1::model::AutoscalingConfig;
    /// let x = InstancePartition::new().set_or_clear_autoscaling_config(Some(AutoscalingConfig::default()/* use setters */));
    /// let x = InstancePartition::new().set_or_clear_autoscaling_config(None::<AutoscalingConfig>);
    /// ```
    pub fn set_or_clear_autoscaling_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::InstancePartition::state].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use google_cloud_spanner_admin_instance_v1::model::instance_partition::State;
    /// let x0 = InstancePartition::new().set_state(State::Creating);
    /// let x1 = InstancePartition::new().set_state(State::Ready);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::instance_partition::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::InstancePartition::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use wkt::Timestamp;
    /// let x = InstancePartition::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::InstancePartition::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use wkt::Timestamp;
    /// let x = InstancePartition::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = InstancePartition::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::InstancePartition::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use wkt::Timestamp;
    /// let x = InstancePartition::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::InstancePartition::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use wkt::Timestamp;
    /// let x = InstancePartition::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = InstancePartition::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [referencing_databases][crate::model::InstancePartition::referencing_databases].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_referencing_databases(["a", "b", "c"]);
    /// ```
    pub fn set_referencing_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.referencing_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [referencing_backups][crate::model::InstancePartition::referencing_backups].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_referencing_backups(["a", "b", "c"]);
    /// ```
    #[deprecated]
    pub fn set_referencing_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.referencing_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::InstancePartition::etag].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity].
    ///
    /// Note that all the setters affecting `compute_capacity` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// use google_cloud_spanner_admin_instance_v1::model::instance_partition::ComputeCapacity;
    /// let x = InstancePartition::new().set_compute_capacity(Some(ComputeCapacity::NodeCount(42)));
    /// ```
    pub fn set_compute_capacity<
        T: std::convert::Into<std::option::Option<crate::model::instance_partition::ComputeCapacity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_capacity = v.into();
        self
    }

    /// The value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// if it holds a `NodeCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn node_count(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::instance_partition::ComputeCapacity::NodeCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// to hold a `NodeCount`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_node_count(42);
    /// assert!(x.node_count().is_some());
    /// assert!(x.processing_units().is_none());
    /// ```
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::instance_partition::ComputeCapacity::NodeCount(v.into()),
        );
        self
    }

    /// The value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// if it holds a `ProcessingUnits`, `None` if the field is not set or
    /// holds a different branch.
    pub fn processing_units(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::instance_partition::ComputeCapacity::ProcessingUnits(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// to hold a `ProcessingUnits`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = InstancePartition::new().set_processing_units(42);
    /// assert!(x.processing_units().is_some());
    /// assert!(x.node_count().is_none());
    /// ```
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::instance_partition::ComputeCapacity::ProcessingUnits(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InstancePartition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.InstancePartition"
    }
}

/// Defines additional types related to [InstancePartition].
pub mod instance_partition {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the instance partition.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The instance partition is still being created. Resources may not be
        /// available yet, and operations such as creating placements using this
        /// instance partition may not work.
        Creating,
        /// The instance partition is fully created and ready to do work such as
        /// creating placements and using in databases.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.spanner.admin.instance.v1.InstancePartition.State",
            ))
        }
    }

    /// Compute capacity defines amount of server and storage resources that are
    /// available to the databases in an instance partition. At most, one of either
    /// `node_count` or` processing_units` should be present in the message. For
    /// more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComputeCapacity {
        /// The number of nodes allocated to this instance partition.
        ///
        /// Users can set the `node_count` field to specify the target number of
        /// nodes allocated to the instance partition.
        ///
        /// This may be zero in API responses for instance partitions that are not
        /// yet in state `READY`.
        NodeCount(i32),
        /// The number of processing units allocated to this instance partition.
        ///
        /// Users can set the `processing_units` field to specify the target number
        /// of processing units allocated to the instance partition.
        ///
        /// This might be zero in API responses for instance partitions that are not
        /// yet in the `READY` state.
        ProcessingUnits(i32),
    }
}

/// Metadata type for the operation returned by
/// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstancePartitionMetadata {
    /// The instance partition being created.
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// The time at which the
    /// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstancePartitionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::CreateInstancePartitionMetadata::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = CreateInstancePartitionMetadata::new().set_instance_partition(InstancePartition::default()/* use setters */);
    /// ```
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::CreateInstancePartitionMetadata::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_instance_partition(Some(InstancePartition::default()/* use setters */));
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_instance_partition(None::<InstancePartition>);
    /// ```
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::CreateInstancePartitionMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstancePartitionMetadata::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CreateInstancePartitionMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstancePartitionMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstancePartitionMetadata::new().set_cancel_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::CreateInstancePartitionMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_cancel_time(Some(Timestamp::default()/* use setters */));
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_cancel_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateInstancePartitionMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstancePartitionMetadata::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateInstancePartitionMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = CreateInstancePartitionMetadata::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstancePartitionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata"
    }
}

/// The request for
/// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstancePartitionRequest {
    /// Required. The name of the instance in which to create the instance
    /// partition. Values are of the form
    /// `projects/<project>/instances/<instance>`.
    pub parent: std::string::String,

    /// Required. The ID of the instance partition to create. Valid identifiers are
    /// of the form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64
    /// characters in length.
    pub instance_partition_id: std::string::String,

    /// Required. The instance partition to create. The instance_partition.name may
    /// be omitted, but if specified must be
    /// `<parent>/instancePartitions/<instance_partition_id>`.
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstancePartitionRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionRequest;
    /// let x = CreateInstancePartitionRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_partition_id][crate::model::CreateInstancePartitionRequest::instance_partition_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionRequest;
    /// let x = CreateInstancePartitionRequest::new().set_instance_partition_id("example");
    /// ```
    pub fn set_instance_partition_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition_id = v.into();
        self
    }

    /// Sets the value of [instance_partition][crate::model::CreateInstancePartitionRequest::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = CreateInstancePartitionRequest::new().set_instance_partition(InstancePartition::default()/* use setters */);
    /// ```
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::CreateInstancePartitionRequest::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::CreateInstancePartitionRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = CreateInstancePartitionRequest::new().set_or_clear_instance_partition(Some(InstancePartition::default()/* use setters */));
    /// let x = CreateInstancePartitionRequest::new().set_or_clear_instance_partition(None::<InstancePartition>);
    /// ```
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionRequest"
    }
}

/// The request for
/// [DeleteInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstancePartition]: crate::client::InstanceAdmin::delete_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstancePartitionRequest {
    /// Required. The name of the instance partition to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`
    pub name: std::string::String,

    /// Optional. If not empty, the API only deletes the instance partition when
    /// the etag provided matches the current status of the requested instance
    /// partition. Otherwise, deletes the instance partition without checking the
    /// current status of the requested instance partition.
    pub etag: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstancePartitionRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::DeleteInstancePartitionRequest;
    /// let x = DeleteInstancePartitionRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstancePartitionRequest::etag].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::DeleteInstancePartitionRequest;
    /// let x = DeleteInstancePartitionRequest::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstancePartitionRequest"
    }
}

/// The request for
/// [GetInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.GetInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstancePartition]: crate::client::InstanceAdmin::get_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstancePartitionRequest {
    /// Required. The name of the requested instance partition. Values are of
    /// the form
    /// `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstancePartitionRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::GetInstancePartitionRequest;
    /// let x = GetInstancePartitionRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstancePartitionRequest"
    }
}

/// The request for
/// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstancePartitionRequest {
    /// Required. The instance partition to update, which must always include the
    /// instance partition name. Otherwise, only fields mentioned in
    /// [field_mask][google.spanner.admin.instance.v1.UpdateInstancePartitionRequest.field_mask]
    /// need be included.
    ///
    /// [google.spanner.admin.instance.v1.UpdateInstancePartitionRequest.field_mask]: crate::model::UpdateInstancePartitionRequest::field_mask
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// Required. A mask specifying which fields in
    /// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
    /// should be updated. The field mask must always be specified; this prevents
    /// any future fields in
    /// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
    /// from being erased accidentally by clients that do not know about them.
    ///
    /// [google.spanner.admin.instance.v1.InstancePartition]: crate::model::InstancePartition
    pub field_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::UpdateInstancePartitionRequest::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = UpdateInstancePartitionRequest::new().set_instance_partition(InstancePartition::default()/* use setters */);
    /// ```
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::UpdateInstancePartitionRequest::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionRequest;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = UpdateInstancePartitionRequest::new().set_or_clear_instance_partition(Some(InstancePartition::default()/* use setters */));
    /// let x = UpdateInstancePartitionRequest::new().set_or_clear_instance_partition(None::<InstancePartition>);
    /// ```
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_mask][crate::model::UpdateInstancePartitionRequest::field_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstancePartitionRequest::new().set_field_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::UpdateInstancePartitionRequest::field_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstancePartitionRequest::new().set_or_clear_field_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateInstancePartitionRequest::new().set_or_clear_field_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstancePartitionRequest"
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstancePartitionMetadata {
    /// The desired end state of the update.
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// The time at which
    /// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstancePartitionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::UpdateInstancePartitionMetadata::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = UpdateInstancePartitionMetadata::new().set_instance_partition(InstancePartition::default()/* use setters */);
    /// ```
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::UpdateInstancePartitionMetadata::instance_partition].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_instance_partition(Some(InstancePartition::default()/* use setters */));
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_instance_partition(None::<InstancePartition>);
    /// ```
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateInstancePartitionMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstancePartitionMetadata::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpdateInstancePartitionMetadata::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstancePartitionMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstancePartitionMetadata::new().set_cancel_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::UpdateInstancePartitionMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_cancel_time(Some(Timestamp::default()/* use setters */));
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_cancel_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateInstancePartitionMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstancePartitionMetadata::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpdateInstancePartitionMetadata::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::UpdateInstancePartitionMetadata;
    /// use wkt::Timestamp;
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = UpdateInstancePartitionMetadata::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstancePartitionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata"
    }
}

/// The request for
/// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionsRequest {
    /// Required. The instance whose instance partitions should be listed. Values
    /// are of the form `projects/<project>/instances/<instance>`. Use `{instance}
    /// = '-'` to list instance partitions for all Instances in a project, e.g.,
    /// `projects/myproject/instances/-`.
    pub parent: std::string::String,

    /// Number of instance partitions to be returned in the response. If 0 or less,
    /// defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.next_page_token]
    /// from a previous
    /// [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse]: crate::model::ListInstancePartitionsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse.next_page_token]: crate::model::ListInstancePartitionsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Deadline used while retrieving metadata for instance partitions.
    /// Instance partitions whose metadata cannot be retrieved within this deadline
    /// will be added to
    /// [unreachable][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.unreachable]
    /// in
    /// [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse]: crate::model::ListInstancePartitionsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse.unreachable]: crate::model::ListInstancePartitionsResponse::unreachable
    pub instance_partition_deadline: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancePartitionsRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsRequest;
    /// let x = ListInstancePartitionsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancePartitionsRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsRequest;
    /// let x = ListInstancePartitionsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancePartitionsRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsRequest;
    /// let x = ListInstancePartitionsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [instance_partition_deadline][crate::model::ListInstancePartitionsRequest::instance_partition_deadline].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsRequest;
    /// use wkt::Timestamp;
    /// let x = ListInstancePartitionsRequest::new().set_instance_partition_deadline(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_instance_partition_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition_deadline][crate::model::ListInstancePartitionsRequest::instance_partition_deadline].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsRequest;
    /// use wkt::Timestamp;
    /// let x = ListInstancePartitionsRequest::new().set_or_clear_instance_partition_deadline(Some(Timestamp::default()/* use setters */));
    /// let x = ListInstancePartitionsRequest::new().set_or_clear_instance_partition_deadline(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_instance_partition_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListInstancePartitionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionsRequest"
    }
}

/// The response for
/// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionsResponse {
    /// The list of requested instancePartitions.
    pub instance_partitions: std::vec::Vec<crate::model::InstancePartition>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]
    /// call to fetch more of the matching instance partitions.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
    pub next_page_token: std::string::String,

    /// The list of unreachable instances or instance partitions.
    /// It includes the names of instances or instance partitions whose metadata
    /// could not be retrieved within
    /// [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionsRequest.instance_partition_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsRequest.instance_partition_deadline]: crate::model::ListInstancePartitionsRequest::instance_partition_deadline
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partitions][crate::model::ListInstancePartitionsResponse::instance_partitions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsResponse;
    /// use google_cloud_spanner_admin_instance_v1::model::InstancePartition;
    /// let x = ListInstancePartitionsResponse::new()
    ///     .set_instance_partitions([
    ///         InstancePartition::default()/* use setters */,
    ///         InstancePartition::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_instance_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstancePartition>,
    {
        use std::iter::Iterator;
        self.instance_partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancePartitionsResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsResponse;
    /// let x = ListInstancePartitionsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancePartitionsResponse::unreachable].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionsResponse;
    /// let x = ListInstancePartitionsResponse::new().set_unreachable(["a", "b", "c"]);
    /// ```
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancePartitionsResponse {
    type PageItem = crate::model::InstancePartition;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instance_partitions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionOperationsRequest {
    /// Required. The parent instance of the instance partition operations.
    /// Values are of the form `projects/<project>/instances/<instance>`.
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of returned operations.
    ///
    /// A filter expression consists of a field name, a
    /// comparison operator, and a value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the Operation are eligible for filtering:
    ///
    /// * `name` - The name of the long-running operation
    /// * `done` - False if the operation is in progress, else true.
    /// * `metadata.@type` - the type of metadata. For example, the type string
    ///   for
    ///   [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata]
    ///   is
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata`.
    /// * `metadata.<field_name>` - any field in metadata.value.
    ///   `metadata.@type` must be specified first, if filtering on metadata
    ///   fields.
    /// * `error` - Error associated with the long-running operation.
    /// * `response.@type` - the type of response.
    /// * `response.<field_name>` - any field in response.value.
    ///
    /// You can combine multiple expressions by enclosing each expression in
    /// parentheses. By default, expressions are combined with AND logic. However,
    /// you can specify AND, OR, and NOT logic explicitly.
    ///
    /// Here are a few examples:
    ///
    /// * `done:true` - The operation is complete.
    /// * `(metadata.@type=` \
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata)
    ///   AND` \
    ///   `(metadata.instance_partition.name:custom-instance-partition) AND` \
    ///   `(metadata.start_time < \"2021-03-28T14:50:00Z\") AND` \
    ///   `(error:*)` - Return operations where:
    ///   * The operation's metadata type is
    ///     [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
    ///   * The instance partition name contains "custom-instance-partition".
    ///   * The operation started before 2021-03-28T14:50:00Z.
    ///   * The operation resulted in an error.
    ///
    /// [google.spanner.admin.instance.v1.CreateInstancePartitionMetadata]: crate::model::CreateInstancePartitionMetadata
    pub filter: std::string::String,

    /// Optional. Number of operations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// Optional. If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.next_page_token]
    /// from a previous
    /// [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]
    /// to the same `parent` and with the same `filter`.
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]: crate::model::ListInstancePartitionOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.next_page_token]: crate::model::ListInstancePartitionOperationsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Deadline used while retrieving metadata for instance partition
    /// operations. Instance partitions whose operation metadata cannot be
    /// retrieved within this deadline will be added to
    /// [unreachable_instance_partitions][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.unreachable_instance_partitions]
    /// in
    /// [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]: crate::model::ListInstancePartitionOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.unreachable_instance_partitions]: crate::model::ListInstancePartitionOperationsResponse::unreachable_instance_partitions
    pub instance_partition_deadline: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancePartitionOperationsRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsRequest;
    /// let x = ListInstancePartitionOperationsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancePartitionOperationsRequest::filter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsRequest;
    /// let x = ListInstancePartitionOperationsRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancePartitionOperationsRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsRequest;
    /// let x = ListInstancePartitionOperationsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancePartitionOperationsRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsRequest;
    /// let x = ListInstancePartitionOperationsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [instance_partition_deadline][crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsRequest;
    /// use wkt::Timestamp;
    /// let x = ListInstancePartitionOperationsRequest::new().set_instance_partition_deadline(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_instance_partition_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition_deadline][crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsRequest;
    /// use wkt::Timestamp;
    /// let x = ListInstancePartitionOperationsRequest::new().set_or_clear_instance_partition_deadline(Some(Timestamp::default()/* use setters */));
    /// let x = ListInstancePartitionOperationsRequest::new().set_or_clear_instance_partition_deadline(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_instance_partition_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListInstancePartitionOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest"
    }
}

/// The response for
/// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionOperationsResponse {
    /// The list of matching instance partition long-running operations. Each
    /// operation's name will be
    /// prefixed by the instance partition's name. The operation's
    /// metadata field type
    /// `metadata.type_url` describes the type of the metadata.
    pub operations: std::vec::Vec<longrunning::model::Operation>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]
    /// call to fetch more of the matching metadata.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
    pub next_page_token: std::string::String,

    /// The list of unreachable instance partitions.
    /// It includes the names of instance partitions whose operation metadata could
    /// not be retrieved within
    /// [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.instance_partition_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.instance_partition_deadline]: crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline
    pub unreachable_instance_partitions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::ListInstancePartitionOperationsResponse::operations].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsResponse;
    /// use longrunning::model::Operation;
    /// let x = ListInstancePartitionOperationsResponse::new()
    ///     .set_operations([
    ///         Operation::default()/* use setters */,
    ///         Operation::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<longrunning::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancePartitionOperationsResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsResponse;
    /// let x = ListInstancePartitionOperationsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_instance_partitions][crate::model::ListInstancePartitionOperationsResponse::unreachable_instance_partitions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::ListInstancePartitionOperationsResponse;
    /// let x = ListInstancePartitionOperationsResponse::new().set_unreachable_instance_partitions(["a", "b", "c"]);
    /// ```
    pub fn set_unreachable_instance_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_instance_partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancePartitionOperationsResponse {
    type PageItem = longrunning::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveInstanceRequest {
    /// Required. The instance to move.
    /// Values are of the form `projects/<project>/instances/<instance>`.
    pub name: std::string::String,

    /// Required. The target instance configuration where to move the instance.
    /// Values are of the form `projects/<project>/instanceConfigs/<config>`.
    pub target_config: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MoveInstanceRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::MoveInstanceRequest;
    /// let x = MoveInstanceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_config][crate::model::MoveInstanceRequest::target_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::MoveInstanceRequest;
    /// let x = MoveInstanceRequest::new().set_target_config("example");
    /// ```
    pub fn set_target_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_config = v.into();
        self
    }
}

impl wkt::message::Message for MoveInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceRequest"
    }
}

/// The response for
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveInstanceResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MoveInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceResponse"
    }
}

/// Metadata type for the operation returned by
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveInstanceMetadata {
    /// The target instance configuration where to move the instance.
    /// Values are of the form `projects/<project>/instanceConfigs/<config>`.
    pub target_config: std::string::String,

    /// The progress of the
    /// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]
    /// operation.
    /// [progress_percent][google.spanner.admin.instance.v1.OperationProgress.progress_percent]
    /// is reset when cancellation is requested.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
    /// [google.spanner.admin.instance.v1.OperationProgress.progress_percent]: crate::model::OperationProgress::progress_percent
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_config][crate::model::MoveInstanceMetadata::target_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::MoveInstanceMetadata;
    /// let x = MoveInstanceMetadata::new().set_target_config("example");
    /// ```
    pub fn set_target_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_config = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::MoveInstanceMetadata::progress].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::MoveInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// let x = MoveInstanceMetadata::new().set_progress(OperationProgress::default()/* use setters */);
    /// ```
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::MoveInstanceMetadata::progress].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::MoveInstanceMetadata;
    /// use google_cloud_spanner_admin_instance_v1::model::OperationProgress;
    /// let x = MoveInstanceMetadata::new().set_or_clear_progress(Some(OperationProgress::default()/* use setters */));
    /// let x = MoveInstanceMetadata::new().set_or_clear_progress(None::<OperationProgress>);
    /// ```
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::MoveInstanceMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::MoveInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = MoveInstanceMetadata::new().set_cancel_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::MoveInstanceMetadata::cancel_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_spanner_admin_instance_v1::model::MoveInstanceMetadata;
    /// use wkt::Timestamp;
    /// let x = MoveInstanceMetadata::new().set_or_clear_cancel_time(Some(Timestamp::default()/* use setters */));
    /// let x = MoveInstanceMetadata::new().set_or_clear_cancel_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MoveInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceMetadata"
    }
}

/// Indicates the expected fulfillment period of an operation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FulfillmentPeriod {
    /// Not specified.
    Unspecified,
    /// Normal fulfillment period. The operation is expected to complete within
    /// minutes.
    Normal,
    /// Extended fulfillment period. It can take up to an hour for the operation
    /// to complete.
    Extended,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FulfillmentPeriod::value] or
    /// [FulfillmentPeriod::name].
    UnknownValue(fulfillment_period::UnknownValue),
}

#[doc(hidden)]
pub mod fulfillment_period {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FulfillmentPeriod {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Normal => std::option::Option::Some(1),
            Self::Extended => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FULFILLMENT_PERIOD_UNSPECIFIED"),
            Self::Normal => std::option::Option::Some("FULFILLMENT_PERIOD_NORMAL"),
            Self::Extended => std::option::Option::Some("FULFILLMENT_PERIOD_EXTENDED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FulfillmentPeriod {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FulfillmentPeriod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FulfillmentPeriod {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Normal,
            2 => Self::Extended,
            _ => Self::UnknownValue(fulfillment_period::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FulfillmentPeriod {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FULFILLMENT_PERIOD_UNSPECIFIED" => Self::Unspecified,
            "FULFILLMENT_PERIOD_NORMAL" => Self::Normal,
            "FULFILLMENT_PERIOD_EXTENDED" => Self::Extended,
            _ => Self::UnknownValue(fulfillment_period::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FulfillmentPeriod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Normal => serializer.serialize_i32(1),
            Self::Extended => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FulfillmentPeriod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FulfillmentPeriod>::new(
            ".google.spanner.admin.instance.v1.FulfillmentPeriod",
        ))
    }
}
