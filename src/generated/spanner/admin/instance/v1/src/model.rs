// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Encapsulates progress related information for a Cloud Spanner long
/// running instance operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationProgress {
    /// Percent completion of the operation.
    /// Values are between 0 and 100 inclusive.
    pub progress_percent: i32,

    /// Time the request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation failed or was completed
    /// successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationProgress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_percent][crate::model::OperationProgress::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OperationProgress::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationProgress::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for OperationProgress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.OperationProgress"
    }
}

/// ReplicaSelection identifies replicas with common properties.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaSelection {
    /// Required. Name of the location of the replicas (e.g., "us-central1").
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaSelection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ReplicaSelection::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaSelection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaSelection"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaInfo {
    /// The location of the serving resources, e.g., "us-central1".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The type of replica.
    #[serde(rename = "type")]
    pub r#type: crate::model::replica_info::ReplicaType,

    /// If true, this location is designated as the default leader location where
    /// leader replicas are placed. See the [region types
    /// documentation](https://cloud.google.com/spanner/docs/instances#region_types)
    /// for more details.
    pub default_leader_location: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ReplicaInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ReplicaInfo::type].
    pub fn set_type<T: std::convert::Into<crate::model::replica_info::ReplicaType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [default_leader_location][crate::model::ReplicaInfo::default_leader_location].
    pub fn set_default_leader_location<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_leader_location = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaInfo"
    }
}

/// Defines additional types related to [ReplicaInfo].
pub mod replica_info {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of replica.  See the [replica types
    /// documentation](https://cloud.google.com/spanner/docs/replication#replica_types)
    /// for more details.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ReplicaType(i32);

    impl ReplicaType {
        /// Not specified.
        pub const TYPE_UNSPECIFIED: ReplicaType = ReplicaType::new(0);

        /// Read-write replicas support both reads and writes. These replicas:
        ///
        /// * Maintain a full copy of your data.
        /// * Serve reads.
        /// * Can vote whether to commit a write.
        /// * Participate in leadership election.
        /// * Are eligible to become a leader.
        pub const READ_WRITE: ReplicaType = ReplicaType::new(1);

        /// Read-only replicas only support reads (not writes). Read-only replicas:
        ///
        /// * Maintain a full copy of your data.
        /// * Serve reads.
        /// * Do not participate in voting to commit writes.
        /// * Are not eligible to become a leader.
        pub const READ_ONLY: ReplicaType = ReplicaType::new(2);

        /// Witness replicas don't support reads but do participate in voting to
        /// commit writes. Witness replicas:
        ///
        /// * Do not maintain a full copy of data.
        /// * Do not serve reads.
        /// * Vote whether to commit writes.
        /// * Participate in leader election but are not eligible to become leader.
        pub const WITNESS: ReplicaType = ReplicaType::new(3);

        /// Creates a new ReplicaType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("READ_WRITE"),
                2 => std::borrow::Cow::Borrowed("READ_ONLY"),
                3 => std::borrow::Cow::Borrowed("WITNESS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "READ_WRITE" => std::option::Option::Some(Self::READ_WRITE),
                "READ_ONLY" => std::option::Option::Some(Self::READ_ONLY),
                "WITNESS" => std::option::Option::Some(Self::WITNESS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ReplicaType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ReplicaType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A possible configuration for a Cloud Spanner instance. Configurations
/// define the geographic placement of nodes and their replication.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceConfig {
    /// A unique identifier for the instance configuration.  Values
    /// are of the form
    /// `projects/<project>/instanceConfigs/[a-z][-a-z0-9]*`.
    ///
    /// User instance configuration must start with `custom-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of this instance configuration as it appears in UIs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Whether this instance configuration is a Google-managed or
    /// user-managed configuration.
    pub config_type: crate::model::instance_config::Type,

    /// The geographic placement of nodes in this instance configuration and their
    /// replication properties.
    ///
    /// To create user-managed configurations, input
    /// `replicas` must include all replicas in `replicas` of the `base_config`
    /// and include one or more replicas in the `optional_replicas` of the
    /// `base_config`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replicas: std::vec::Vec<crate::model::ReplicaInfo>,

    /// Output only. The available optional replicas to choose from for
    /// user-managed configurations. Populated for Google-managed configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub optional_replicas: std::vec::Vec<crate::model::ReplicaInfo>,

    /// Base configuration name, e.g. projects/<project_name>/instanceConfigs/nam3,
    /// based on which this configuration is created. Only set for user-managed
    /// configurations. `base_config` must refer to a configuration of type
    /// `GOOGLE_MANAGED` in the same project as this configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_config: std::string::String,

    /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. Cloud Labels can be used to filter collections of
    /// resources. They can be used to control how resource metrics are aggregated.
    /// And they can be used as arguments to policy management rules (e.g. route,
    /// firewall, load balancing, etc.).
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform
    ///   to the regular expression `[a-z0-9_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    ///
    /// If you plan to use labels in your own code, please note that additional
    /// characters may be allowed in the future. Therefore, you are advised to use
    /// an internal label representation, such as JSON, which doesn't rely upon
    /// specific characters being disallowed.  For example, representing labels
    /// as the string:  name + "_" + value  would prove problematic if we were to
    /// allow "_" in a future release.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// etag is used for optimistic concurrency control as a way
    /// to help prevent simultaneous updates of a instance configuration from
    /// overwriting each other. It is strongly suggested that systems make use of
    /// the etag in the read-modify-write cycle to perform instance configuration
    /// updates in order to avoid race conditions: An etag is returned in the
    /// response which contains instance configurations, and systems are expected
    /// to put that etag in the request to update instance configuration to ensure
    /// that their change is applied to the same version of the instance
    /// configuration. If no etag is provided in the call to update the instance
    /// configuration, then the existing instance configuration is overwritten
    /// blindly.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Allowed values of the "default_leader" schema option for databases in
    /// instances that use this instance configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub leader_options: std::vec::Vec<std::string::String>,

    /// Output only. If true, the instance configuration is being created or
    /// updated. If false, there are no ongoing operations for the instance
    /// configuration.
    pub reconciling: bool,

    /// Output only. The current instance configuration state. Applicable only for
    /// `USER_MANAGED` configurations.
    pub state: crate::model::instance_config::State,

    /// Output only. Describes whether free instances are available to be created
    /// in this instance configuration.
    pub free_instance_availability: crate::model::instance_config::FreeInstanceAvailability,

    /// Output only. The `QuorumType` of the instance configuration.
    pub quorum_type: crate::model::instance_config::QuorumType,

    /// Output only. The storage limit in bytes per processing unit.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub storage_limit_per_processing_unit: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InstanceConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [config_type][crate::model::InstanceConfig::config_type].
    pub fn set_config_type<T: std::convert::Into<crate::model::instance_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_type = v.into();
        self
    }

    /// Sets the value of [base_config][crate::model::InstanceConfig::base_config].
    pub fn set_base_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_config = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::InstanceConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::InstanceConfig::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [state][crate::model::InstanceConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [free_instance_availability][crate::model::InstanceConfig::free_instance_availability].
    pub fn set_free_instance_availability<
        T: std::convert::Into<crate::model::instance_config::FreeInstanceAvailability>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.free_instance_availability = v.into();
        self
    }

    /// Sets the value of [quorum_type][crate::model::InstanceConfig::quorum_type].
    pub fn set_quorum_type<T: std::convert::Into<crate::model::instance_config::QuorumType>>(
        mut self,
        v: T,
    ) -> Self {
        self.quorum_type = v.into();
        self
    }

    /// Sets the value of [storage_limit_per_processing_unit][crate::model::InstanceConfig::storage_limit_per_processing_unit].
    pub fn set_storage_limit_per_processing_unit<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_limit_per_processing_unit = v.into();
        self
    }

    /// Sets the value of [replicas][crate::model::InstanceConfig::replicas].
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaInfo>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [optional_replicas][crate::model::InstanceConfig::optional_replicas].
    pub fn set_optional_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaInfo>,
    {
        use std::iter::Iterator;
        self.optional_replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [leader_options][crate::model::InstanceConfig::leader_options].
    pub fn set_leader_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.leader_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::InstanceConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.InstanceConfig"
    }
}

/// Defines additional types related to [InstanceConfig].
pub mod instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of this configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Unspecified.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// Google-managed configuration.
        pub const GOOGLE_MANAGED: Type = Type::new(1);

        /// User-managed configuration.
        pub const USER_MANAGED: Type = Type::new(2);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GOOGLE_MANAGED"),
                2 => std::borrow::Cow::Borrowed("USER_MANAGED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "GOOGLE_MANAGED" => std::option::Option::Some(Self::GOOGLE_MANAGED),
                "USER_MANAGED" => std::option::Option::Some(Self::USER_MANAGED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the current state of the instance configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not specified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The instance configuration is still being created.
        pub const CREATING: State = State::new(1);

        /// The instance configuration is fully created and ready to be used to
        /// create instances.
        pub const READY: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Describes the availability for free instances to be created in an instance
    /// configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FreeInstanceAvailability(i32);

    impl FreeInstanceAvailability {
        /// Not specified.
        pub const FREE_INSTANCE_AVAILABILITY_UNSPECIFIED: FreeInstanceAvailability =
            FreeInstanceAvailability::new(0);

        /// Indicates that free instances are available to be created in this
        /// instance configuration.
        pub const AVAILABLE: FreeInstanceAvailability = FreeInstanceAvailability::new(1);

        /// Indicates that free instances are not supported in this instance
        /// configuration.
        pub const UNSUPPORTED: FreeInstanceAvailability = FreeInstanceAvailability::new(2);

        /// Indicates that free instances are currently not available to be created
        /// in this instance configuration.
        pub const DISABLED: FreeInstanceAvailability = FreeInstanceAvailability::new(3);

        /// Indicates that additional free instances cannot be created in this
        /// instance configuration because the project has reached its limit of free
        /// instances.
        pub const QUOTA_EXCEEDED: FreeInstanceAvailability = FreeInstanceAvailability::new(4);

        /// Creates a new FreeInstanceAvailability instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FREE_INSTANCE_AVAILABILITY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("AVAILABLE"),
                2 => std::borrow::Cow::Borrowed("UNSUPPORTED"),
                3 => std::borrow::Cow::Borrowed("DISABLED"),
                4 => std::borrow::Cow::Borrowed("QUOTA_EXCEEDED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FREE_INSTANCE_AVAILABILITY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FREE_INSTANCE_AVAILABILITY_UNSPECIFIED)
                }
                "AVAILABLE" => std::option::Option::Some(Self::AVAILABLE),
                "UNSUPPORTED" => std::option::Option::Some(Self::UNSUPPORTED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "QUOTA_EXCEEDED" => std::option::Option::Some(Self::QUOTA_EXCEEDED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FreeInstanceAvailability {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FreeInstanceAvailability {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the quorum type of this instance configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct QuorumType(i32);

    impl QuorumType {
        /// Quorum type not specified.
        pub const QUORUM_TYPE_UNSPECIFIED: QuorumType = QuorumType::new(0);

        /// An instance configuration tagged with `REGION` quorum type forms a write
        /// quorum in a single region.
        pub const REGION: QuorumType = QuorumType::new(1);

        /// An instance configuration tagged with the `DUAL_REGION` quorum type forms
        /// a write quorum with exactly two read-write regions in a multi-region
        /// configuration.
        ///
        /// This instance configuration requires failover in the event of
        /// regional failures.
        pub const DUAL_REGION: QuorumType = QuorumType::new(2);

        /// An instance configuration tagged with the `MULTI_REGION` quorum type
        /// forms a write quorum from replicas that are spread across more than one
        /// region in a multi-region configuration.
        pub const MULTI_REGION: QuorumType = QuorumType::new(3);

        /// Creates a new QuorumType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("QUORUM_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("REGION"),
                2 => std::borrow::Cow::Borrowed("DUAL_REGION"),
                3 => std::borrow::Cow::Borrowed("MULTI_REGION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "QUORUM_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::QUORUM_TYPE_UNSPECIFIED)
                }
                "REGION" => std::option::Option::Some(Self::REGION),
                "DUAL_REGION" => std::option::Option::Some(Self::DUAL_REGION),
                "MULTI_REGION" => std::option::Option::Some(Self::MULTI_REGION),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for QuorumType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for QuorumType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// ReplicaComputeCapacity describes the amount of server resources that are
/// allocated to each replica identified by the replica selection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaComputeCapacity {
    /// Required. Identifies replicas by specified properties.
    /// All replicas in the selection have the same amount of compute capacity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_selection: std::option::Option<crate::model::ReplicaSelection>,

    /// Compute capacity allocated to each replica identified by the specified
    /// selection.
    /// The unit is selected based on the unit used to specify the instance size
    /// for non-autoscaling instances, or the unit used in autoscaling limit for
    /// autoscaling instances.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub compute_capacity:
        std::option::Option<crate::model::replica_compute_capacity::ComputeCapacity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaComputeCapacity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replica_selection][crate::model::ReplicaComputeCapacity::replica_selection].
    pub fn set_replica_selection<
        T: std::convert::Into<std::option::Option<crate::model::ReplicaSelection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replica_selection = v.into();
        self
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity].
    ///
    /// Note that all the setters affecting `compute_capacity` are mutually
    /// exclusive.
    pub fn set_compute_capacity<
        T: std::convert::Into<
                std::option::Option<crate::model::replica_compute_capacity::ComputeCapacity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_capacity = v.into();
        self
    }

    /// The value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// if it holds a `NodeCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn node_count(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::replica_compute_capacity::ComputeCapacity::NodeCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// if it holds a `ProcessingUnits`, `None` if the field is not set or
    /// holds a different branch.
    pub fn processing_units(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::replica_compute_capacity::ComputeCapacity::ProcessingUnits(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// to hold a `NodeCount`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::replica_compute_capacity::ComputeCapacity::NodeCount(v.into()),
        );
        self
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// to hold a `ProcessingUnits`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::replica_compute_capacity::ComputeCapacity::ProcessingUnits(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplicaComputeCapacity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaComputeCapacity"
    }
}

/// Defines additional types related to [ReplicaComputeCapacity].
pub mod replica_compute_capacity {
    #[allow(unused_imports)]
    use super::*;

    /// Compute capacity allocated to each replica identified by the specified
    /// selection.
    /// The unit is selected based on the unit used to specify the instance size
    /// for non-autoscaling instances, or the unit used in autoscaling limit for
    /// autoscaling instances.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ComputeCapacity {
        /// The number of nodes allocated to each replica.
        ///
        /// This may be zero in API responses for instances that are not yet in
        /// state `READY`.
        NodeCount(i32),
        /// The number of processing units allocated to each replica.
        ///
        /// This may be zero in API responses for instances that are not yet in
        /// state `READY`.
        ProcessingUnits(i32),
    }
}

/// Autoscaling configuration for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingConfig {
    /// Required. Autoscaling limits for an instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_limits:
        std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,

    /// Required. The autoscaling targets for an instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_targets:
        std::option::Option<crate::model::autoscaling_config::AutoscalingTargets>,

    /// Optional. Optional asymmetric autoscaling options.
    /// Replicas matching the replica selection criteria will be autoscaled
    /// independently from other replicas. The autoscaler will scale the replicas
    /// based on the utilization of replicas identified by the replica selection.
    /// Replica selections should not overlap with each other.
    ///
    /// Other replicas (those do not match any replica selection) will be
    /// autoscaled together and will have the same compute capacity allocated to
    /// them.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub asymmetric_autoscaling_options:
        std::vec::Vec<crate::model::autoscaling_config::AsymmetricAutoscalingOption>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autoscaling_limits][crate::model::AutoscalingConfig::autoscaling_limits].
    pub fn set_autoscaling_limits<
        T: std::convert::Into<
                std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_limits = v.into();
        self
    }

    /// Sets the value of [autoscaling_targets][crate::model::AutoscalingConfig::autoscaling_targets].
    pub fn set_autoscaling_targets<
        T: std::convert::Into<
                std::option::Option<crate::model::autoscaling_config::AutoscalingTargets>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_targets = v.into();
        self
    }

    /// Sets the value of [asymmetric_autoscaling_options][crate::model::AutoscalingConfig::asymmetric_autoscaling_options].
    pub fn set_asymmetric_autoscaling_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::autoscaling_config::AsymmetricAutoscalingOption>,
    {
        use std::iter::Iterator;
        self.asymmetric_autoscaling_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutoscalingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig"
    }
}

/// Defines additional types related to [AutoscalingConfig].
pub mod autoscaling_config {
    #[allow(unused_imports)]
    use super::*;

    /// The autoscaling limits for the instance. Users can define the minimum and
    /// maximum compute capacity allocated to the instance, and the autoscaler will
    /// only scale within that range. Users can either use nodes or processing
    /// units to specify the limits, but should use the same unit to set both the
    /// min_limit and max_limit.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutoscalingLimits {
        /// The minimum compute capacity for the instance.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub min_limit:
            std::option::Option<crate::model::autoscaling_config::autoscaling_limits::MinLimit>,

        /// The maximum compute capacity for the instance. The maximum compute
        /// capacity should be less than or equal to 10X the minimum compute
        /// capacity.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub max_limit:
            std::option::Option<crate::model::autoscaling_config::autoscaling_limits::MaxLimit>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoscalingLimits {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit].
        ///
        /// Note that all the setters affecting `min_limit` are mutually
        /// exclusive.
        pub fn set_min_limit<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::autoscaling_config::autoscaling_limits::MinLimit,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_limit = v.into();
            self
        }

        /// The value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// if it holds a `MinNodes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn min_nodes(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.min_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinNodes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// if it holds a `MinProcessingUnits`, `None` if the field is not set or
        /// holds a different branch.
        pub fn min_processing_units(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.min_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinProcessingUnits(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// to hold a `MinNodes`.
        ///
        /// Note that all the setters affecting `min_limit` are
        /// mutually exclusive.
        pub fn set_min_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinNodes(v.into()),
            );
            self
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// to hold a `MinProcessingUnits`.
        ///
        /// Note that all the setters affecting `min_limit` are
        /// mutually exclusive.
        pub fn set_min_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinProcessingUnits(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit].
        ///
        /// Note that all the setters affecting `max_limit` are mutually
        /// exclusive.
        pub fn set_max_limit<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::autoscaling_config::autoscaling_limits::MaxLimit,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_limit = v.into();
            self
        }

        /// The value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// if it holds a `MaxNodes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn max_nodes(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.max_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxNodes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// if it holds a `MaxProcessingUnits`, `None` if the field is not set or
        /// holds a different branch.
        pub fn max_processing_units(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.max_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxProcessingUnits(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// to hold a `MaxNodes`.
        ///
        /// Note that all the setters affecting `max_limit` are
        /// mutually exclusive.
        pub fn set_max_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxNodes(v.into()),
            );
            self
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// to hold a `MaxProcessingUnits`.
        ///
        /// Note that all the setters affecting `max_limit` are
        /// mutually exclusive.
        pub fn set_max_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxProcessingUnits(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for AutoscalingLimits {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingLimits"
        }
    }

    /// Defines additional types related to [AutoscalingLimits].
    pub mod autoscaling_limits {
        #[allow(unused_imports)]
        use super::*;

        /// The minimum compute capacity for the instance.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum MinLimit {
            /// Minimum number of nodes allocated to the instance. If set, this number
            /// should be greater than or equal to 1.
            MinNodes(i32),
            /// Minimum number of processing units allocated to the instance. If set,
            /// this number should be multiples of 1000.
            MinProcessingUnits(i32),
        }

        /// The maximum compute capacity for the instance. The maximum compute
        /// capacity should be less than or equal to 10X the minimum compute
        /// capacity.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum MaxLimit {
            /// Maximum number of nodes allocated to the instance. If set, this number
            /// should be greater than or equal to min_nodes.
            MaxNodes(i32),
            /// Maximum number of processing units allocated to the instance. If set,
            /// this number should be multiples of 1000 and be greater than or equal to
            /// min_processing_units.
            MaxProcessingUnits(i32),
        }
    }

    /// The autoscaling targets for an instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutoscalingTargets {
        /// Required. The target high priority cpu utilization percentage that the
        /// autoscaler should be trying to achieve for the instance. This number is
        /// on a scale from 0 (no utilization) to 100 (full utilization). The valid
        /// range is [10, 90] inclusive.
        pub high_priority_cpu_utilization_percent: i32,

        /// Required. The target storage utilization percentage that the autoscaler
        /// should be trying to achieve for the instance. This number is on a scale
        /// from 0 (no utilization) to 100 (full utilization). The valid range is
        /// [10, 99] inclusive.
        pub storage_utilization_percent: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoscalingTargets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [high_priority_cpu_utilization_percent][crate::model::autoscaling_config::AutoscalingTargets::high_priority_cpu_utilization_percent].
        pub fn set_high_priority_cpu_utilization_percent<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.high_priority_cpu_utilization_percent = v.into();
            self
        }

        /// Sets the value of [storage_utilization_percent][crate::model::autoscaling_config::AutoscalingTargets::storage_utilization_percent].
        pub fn set_storage_utilization_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.storage_utilization_percent = v.into();
            self
        }
    }

    impl wkt::message::Message for AutoscalingTargets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingTargets"
        }
    }

    /// AsymmetricAutoscalingOption specifies the scaling of replicas identified by
    /// the given selection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AsymmetricAutoscalingOption {

        /// Required. Selects the replicas to which this AsymmetricAutoscalingOption
        /// applies. Only read-only replicas are supported.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub replica_selection: std::option::Option<crate::model::ReplicaSelection>,

        /// Optional. Overrides applied to the top-level autoscaling configuration
        /// for the selected replicas.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub overrides: std::option::Option<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AsymmetricAutoscalingOption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [replica_selection][crate::model::autoscaling_config::AsymmetricAutoscalingOption::replica_selection].
        pub fn set_replica_selection<
            T: std::convert::Into<std::option::Option<crate::model::ReplicaSelection>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.replica_selection = v.into();
            self
        }

        /// Sets the value of [overrides][crate::model::autoscaling_config::AsymmetricAutoscalingOption::overrides].
        pub fn set_overrides<T: std::convert::Into<std::option::Option<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>>>(mut self, v: T) -> Self{
            self.overrides = v.into();
            self
        }
    }

    impl wkt::message::Message for AsymmetricAutoscalingOption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AsymmetricAutoscalingOption"
        }
    }

    /// Defines additional types related to [AsymmetricAutoscalingOption].
    pub mod asymmetric_autoscaling_option {
        #[allow(unused_imports)]
        use super::*;

        /// Overrides the top-level autoscaling configuration for the replicas
        /// identified by `replica_selection`. All fields in this message are
        /// optional. Any unspecified fields will use the corresponding values from
        /// the top-level autoscaling configuration.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AutoscalingConfigOverrides {
            /// Optional. If specified, overrides the min/max limit in the top-level
            /// autoscaling configuration for the selected replicas.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub autoscaling_limits:
                std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,

            /// Optional. If specified, overrides the autoscaling target
            /// high_priority_cpu_utilization_percent in the top-level autoscaling
            /// configuration for the selected replicas.
            pub autoscaling_target_high_priority_cpu_utilization_percent: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AutoscalingConfigOverrides {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [autoscaling_limits][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_limits].
            pub fn set_autoscaling_limits<
                T: std::convert::Into<
                        std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.autoscaling_limits = v.into();
                self
            }

            /// Sets the value of [autoscaling_target_high_priority_cpu_utilization_percent][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_target_high_priority_cpu_utilization_percent].
            pub fn set_autoscaling_target_high_priority_cpu_utilization_percent<
                T: std::convert::Into<i32>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.autoscaling_target_high_priority_cpu_utilization_percent = v.into();
                self
            }
        }

        impl wkt::message::Message for AutoscalingConfigOverrides {
            fn typename() -> &'static str {
                "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AsymmetricAutoscalingOption.AutoscalingConfigOverrides"
            }
        }
    }
}

/// An isolated set of Cloud Spanner resources on which databases can be hosted.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Required. A unique identifier for the instance, which cannot be changed
    /// after the instance is created. Values are of the form
    /// `projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]`. The final
    /// segment of the name must be between 2 and 64 characters in length.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The name of the instance's configuration. Values are of the form
    /// `projects/<project>/instanceConfigs/<configuration>`. See
    /// also [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config: std::string::String,

    /// Required. The descriptive name for this instance as it appears in UIs.
    /// Must be unique per project and between 4 and 30 characters in length.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The number of nodes allocated to this instance. At most, one of either
    /// `node_count` or `processing_units` should be present in the message.
    ///
    /// Users can set the `node_count` field to specify the target number of nodes
    /// allocated to the instance.
    ///
    /// If autoscaling is enabled, `node_count` is treated as an `OUTPUT_ONLY`
    /// field and reflects the current number of nodes allocated to the instance.
    ///
    /// This might be zero in API responses for instances that are not yet in the
    /// `READY` state.
    ///
    /// For more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub node_count: i32,

    /// The number of processing units allocated to this instance. At most, one of
    /// either `processing_units` or `node_count` should be present in the message.
    ///
    /// Users can set the `processing_units` field to specify the target number of
    /// processing units allocated to the instance.
    ///
    /// If autoscaling is enabled, `processing_units` is treated as an
    /// `OUTPUT_ONLY` field and reflects the current number of processing units
    /// allocated to the instance.
    ///
    /// This might be zero in API responses for instances that are not yet in the
    /// `READY` state.
    ///
    /// For more information, see
    /// [Compute capacity, nodes and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub processing_units: i32,

    /// Output only. Lists the compute capacity per ReplicaSelection. A replica
    /// selection identifies a set of replicas with common properties. Replicas
    /// identified by a ReplicaSelection are scaled with the same compute capacity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replica_compute_capacity: std::vec::Vec<crate::model::ReplicaComputeCapacity>,

    /// Optional. The autoscaling configuration. Autoscaling is enabled if this
    /// field is set. When autoscaling is enabled, node_count and processing_units
    /// are treated as OUTPUT_ONLY fields and reflect the current compute capacity
    /// allocated to the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_config: std::option::Option<crate::model::AutoscalingConfig>,

    /// Output only. The current instance state. For
    /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance],
    /// the state must be either omitted or set to `CREATING`. For
    /// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance],
    /// the state must be either omitted or set to `READY`.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
    pub state: crate::model::instance::State,

    /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. Cloud Labels can be used to filter collections of
    /// resources. They can be used to control how resource metrics are aggregated.
    /// And they can be used as arguments to policy management rules (e.g. route,
    /// firewall, load balancing, etc.).
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform
    ///   to the regular expression `[a-z0-9_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    ///
    /// If you plan to use labels in your own code, please note that additional
    /// characters may be allowed in the future. And so you are advised to use an
    /// internal label representation, such as JSON, which doesn't rely upon
    /// specific characters being disallowed.  For example, representing labels
    /// as the string:  name + "_" + value  would prove problematic if we were to
    /// allow "_" in a future release.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The `InstanceType` of the current instance.
    pub instance_type: crate::model::instance::InstanceType,

    /// Deprecated. This field is not populated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub endpoint_uris: std::vec::Vec<std::string::String>,

    /// Output only. The time at which the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the instance was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Free instance metadata. Only populated for free instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub free_instance_metadata: std::option::Option<crate::model::FreeInstanceMetadata>,

    /// Optional. The `Edition` of the current instance.
    pub edition: crate::model::instance::Edition,

    /// Optional. Controls the default backup schedule behavior for new databases
    /// within the instance. By default, a backup schedule is created automatically
    /// when a new database is created in a new instance.
    ///
    /// Note that the `AUTOMATIC` value isn't permitted for free instances,
    /// as backups and backup schedules aren't supported for free instances.
    ///
    /// In the `GetInstance` or `ListInstances` response, if the value of
    /// `default_backup_schedule_type` isn't set, or set to `NONE`, Spanner doesn't
    /// create a default backup schedule for new databases in the instance.
    pub default_backup_schedule_type: crate::model::instance::DefaultBackupScheduleType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Instance::config].
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::Instance::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [processing_units][crate::model::Instance::processing_units].
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.processing_units = v.into();
        self
    }

    /// Sets the value of [autoscaling_config][crate::model::Instance::autoscaling_config].
    pub fn set_autoscaling_config<
        T: std::convert::Into<std::option::Option<crate::model::AutoscalingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_config = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::Instance::instance_type].
    pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [free_instance_metadata][crate::model::Instance::free_instance_metadata].
    pub fn set_free_instance_metadata<
        T: std::convert::Into<std::option::Option<crate::model::FreeInstanceMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.free_instance_metadata = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::Instance::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::instance::Edition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [default_backup_schedule_type][crate::model::Instance::default_backup_schedule_type].
    pub fn set_default_backup_schedule_type<
        T: std::convert::Into<crate::model::instance::DefaultBackupScheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_backup_schedule_type = v.into();
        self
    }

    /// Sets the value of [replica_compute_capacity][crate::model::Instance::replica_compute_capacity].
    pub fn set_replica_compute_capacity<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaComputeCapacity>,
    {
        use std::iter::Iterator;
        self.replica_compute_capacity = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [endpoint_uris][crate::model::Instance::endpoint_uris].
    pub fn set_endpoint_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoint_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not specified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The instance is still being created. Resources may not be
        /// available yet, and operations such as database creation may not
        /// work.
        pub const CREATING: State = State::new(1);

        /// The instance is fully created and ready to do work such as
        /// creating databases.
        pub const READY: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The type of this instance. The type can be used to distinguish product
    /// variants, that can affect aspects like: usage restrictions, quotas and
    /// billing. Currently this is used to distinguish FREE_INSTANCE vs PROVISIONED
    /// instances.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct InstanceType(i32);

    impl InstanceType {
        /// Not specified.
        pub const INSTANCE_TYPE_UNSPECIFIED: InstanceType = InstanceType::new(0);

        /// Provisioned instances have dedicated resources, standard usage limits and
        /// support.
        pub const PROVISIONED: InstanceType = InstanceType::new(1);

        /// Free instances provide no guarantee for dedicated resources,
        /// [node_count, processing_units] should be 0. They come
        /// with stricter usage limits and limited support.
        pub const FREE_INSTANCE: InstanceType = InstanceType::new(2);

        /// Creates a new InstanceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INSTANCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONED"),
                2 => std::borrow::Cow::Borrowed("FREE_INSTANCE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INSTANCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::INSTANCE_TYPE_UNSPECIFIED)
                }
                "PROVISIONED" => std::option::Option::Some(Self::PROVISIONED),
                "FREE_INSTANCE" => std::option::Option::Some(Self::FREE_INSTANCE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The edition selected for this instance. Different editions provide
    /// different capabilities at different price points.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Edition(i32);

    impl Edition {
        /// Edition not specified.
        pub const EDITION_UNSPECIFIED: Edition = Edition::new(0);

        /// Standard edition.
        pub const STANDARD: Edition = Edition::new(1);

        /// Enterprise edition.
        pub const ENTERPRISE: Edition = Edition::new(2);

        /// Enterprise Plus edition.
        pub const ENTERPRISE_PLUS: Edition = Edition::new(3);

        /// Creates a new Edition instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EDITION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STANDARD"),
                2 => std::borrow::Cow::Borrowed("ENTERPRISE"),
                3 => std::borrow::Cow::Borrowed("ENTERPRISE_PLUS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EDITION_UNSPECIFIED" => std::option::Option::Some(Self::EDITION_UNSPECIFIED),
                "STANDARD" => std::option::Option::Some(Self::STANDARD),
                "ENTERPRISE" => std::option::Option::Some(Self::ENTERPRISE),
                "ENTERPRISE_PLUS" => std::option::Option::Some(Self::ENTERPRISE_PLUS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the
    /// [default backup
    /// schedule](https://cloud.google.com/spanner/docs/backup#default-backup-schedules)
    /// behavior for new databases within the instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DefaultBackupScheduleType(i32);

    impl DefaultBackupScheduleType {
        /// Not specified.
        pub const DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED: DefaultBackupScheduleType =
            DefaultBackupScheduleType::new(0);

        /// A default backup schedule isn't created automatically when a new database
        /// is created in the instance.
        pub const NONE: DefaultBackupScheduleType = DefaultBackupScheduleType::new(1);

        /// A default backup schedule is created automatically when a new database
        /// is created in the instance. The default backup schedule creates a full
        /// backup every 24 hours. These full backups are retained for 7 days.
        /// You can edit or delete the default backup schedule once it's created.
        pub const AUTOMATIC: DefaultBackupScheduleType = DefaultBackupScheduleType::new(2);

        /// Creates a new DefaultBackupScheduleType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NONE"),
                2 => std::borrow::Cow::Borrowed("AUTOMATIC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED)
                }
                "NONE" => std::option::Option::Some(Self::NONE),
                "AUTOMATIC" => std::option::Option::Some(Self::AUTOMATIC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DefaultBackupScheduleType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DefaultBackupScheduleType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The request for
/// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstanceConfigsRequest {
    /// Required. The name of the project for which a list of supported instance
    /// configurations is requested. Values are of the form
    /// `projects/<project>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of instance configurations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]
    /// from a previous
    /// [ListInstanceConfigsResponse][google.spanner.admin.instance.v1.ListInstanceConfigsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstanceConfigsResponse]: crate::model::ListInstanceConfigsResponse
    /// [google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]: crate::model::ListInstanceConfigsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstanceConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstanceConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstanceConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigsRequest"
    }
}

/// The response for
/// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstanceConfigsResponse {
    /// The list of requested instance configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_configs: std::vec::Vec<crate::model::InstanceConfig>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]
    /// call to fetch more of the matching instance configurations.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstanceConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instance_configs][crate::model::ListInstanceConfigsResponse::instance_configs].
    pub fn set_instance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceConfig>,
    {
        use std::iter::Iterator;
        self.instance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstanceConfigsResponse {
    type PageItem = crate::model::InstanceConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instance_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [GetInstanceConfigRequest][google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig]: crate::client::InstanceAdmin::get_instance_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceConfigRequest {
    /// Required. The name of the requested instance configuration. Values are of
    /// the form `projects/<project>/instanceConfigs/<config>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstanceConfigRequest"
    }
}

/// The request for
/// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceConfigRequest {
    /// Required. The name of the project in which to create the instance
    /// configuration. Values are of the form `projects/<project>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the instance configuration to create. Valid identifiers
    /// are of the form `custom-[-a-z0-9]*[a-z0-9]` and must be between 2 and 64
    /// characters in length. The `custom-` prefix is required to avoid name
    /// conflicts with Google-managed configurations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_config_id: std::string::String,

    /// Required. The `InstanceConfig` proto of the configuration to create.
    /// `instance_config.name` must be
    /// `<parent>/instanceConfigs/<instance_config_id>`.
    /// `instance_config.base_config` must be a Google-managed configuration name,
    /// e.g. \<parent\>/instanceConfigs/us-east1, \<parent\>/instanceConfigs/nam3.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_config_id][crate::model::CreateInstanceConfigRequest::instance_config_id].
    pub fn set_instance_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config_id = v.into();
        self
    }

    /// Sets the value of [instance_config][crate::model::CreateInstanceConfigRequest::instance_config].
    pub fn set_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateInstanceConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigRequest"
    }
}

/// The request for
/// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceConfigRequest {
    /// Required. The user instance configuration to update, which must always
    /// include the instance configuration name. Otherwise, only fields mentioned
    /// in
    /// [update_mask][google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask]
    /// need be included. To prevent conflicts of concurrent updates,
    /// [etag][google.spanner.admin.instance.v1.InstanceConfig.reconciling] can
    /// be used.
    ///
    /// [google.spanner.admin.instance.v1.InstanceConfig.reconciling]: crate::model::InstanceConfig::reconciling
    /// [google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask]: crate::model::UpdateInstanceConfigRequest::update_mask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// Required. A mask specifying which fields in
    /// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] should be
    /// updated. The field mask must always be specified; this prevents any future
    /// fields in [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig]
    /// from being erased accidentally by clients that do not know about them. Only
    /// display_name and labels can be updated.
    ///
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::UpdateInstanceConfigRequest::instance_config].
    pub fn set_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInstanceConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceConfigRequest"
    }
}

/// The request for
/// [DeleteInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstanceConfig]: crate::client::InstanceAdmin::delete_instance_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceConfigRequest {
    /// Required. The name of the instance configuration to be deleted.
    /// Values are of the form
    /// `projects/<project>/instanceConfigs/<instance_config>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Used for optimistic concurrency control as a way to help prevent
    /// simultaneous deletes of an instance configuration from overwriting each
    /// other. If not empty, the API
    /// only deletes the instance configuration when the etag provided matches the
    /// current status of the requested instance configuration. Otherwise, deletes
    /// the instance configuration without checking the current status of the
    /// requested instance configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstanceConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteInstanceConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstanceConfigRequest"
    }
}

/// The request for
/// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstanceConfigOperationsRequest {
    /// Required. The project of the instance configuration operations.
    /// Values are of the form `projects/<project>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression that filters the list of returned operations.
    ///
    /// A filter expression consists of a field name, a
    /// comparison operator, and a value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the Operation are eligible for filtering:
    ///
    /// * `name` - The name of the long-running operation
    /// * `done` - False if the operation is in progress, else true.
    /// * `metadata.@type` - the type of metadata. For example, the type string
    ///   for
    ///   [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata]
    ///   is
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata`.
    /// * `metadata.<field_name>` - any field in metadata.value.
    ///   `metadata.@type` must be specified first, if filtering on metadata
    ///   fields.
    /// * `error` - Error associated with the long-running operation.
    /// * `response.@type` - the type of response.
    /// * `response.<field_name>` - any field in response.value.
    ///
    /// You can combine multiple expressions by enclosing each expression in
    /// parentheses. By default, expressions are combined with AND logic. However,
    /// you can specify AND, OR, and NOT logic explicitly.
    ///
    /// Here are a few examples:
    ///
    /// * `done:true` - The operation is complete.
    /// * `(metadata.@type=` \
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata)
    ///   AND` \
    ///   `(metadata.instance_config.name:custom-config) AND` \
    ///   `(metadata.progress.start_time < \"2021-03-28T14:50:00Z\") AND` \
    ///   `(error:*)` - Return operations where:
    ///   * The operation's metadata type is
    ///     [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
    ///   * The instance configuration name contains "custom-config".
    ///   * The operation started before 2021-03-28T14:50:00Z.
    ///   * The operation resulted in an error.
    ///
    /// [google.spanner.admin.instance.v1.CreateInstanceConfigMetadata]: crate::model::CreateInstanceConfigMetadata
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Number of operations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token]
    /// from a previous
    /// [ListInstanceConfigOperationsResponse][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse]
    /// to the same `parent` and with the same `filter`.
    ///
    /// [google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse]: crate::model::ListInstanceConfigOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token]: crate::model::ListInstanceConfigOperationsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstanceConfigOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstanceConfigOperationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstanceConfigOperationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstanceConfigOperationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest"
    }
}

/// The response for
/// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstanceConfigOperationsResponse {
    /// The list of matching instance configuration long-running operations. Each
    /// operation's name will be
    /// prefixed by the name of the instance configuration. The operation's
    /// metadata field type
    /// `metadata.type_url` describes the type of the metadata.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub operations: std::vec::Vec<longrunning::model::Operation>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]
    /// call to fetch more of the matching metadata.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstanceConfigOperationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [operations][crate::model::ListInstanceConfigOperationsResponse::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<longrunning::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstanceConfigOperationsResponse {
    type PageItem = longrunning::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [GetInstance][google.spanner.admin.instance.v1.InstanceAdmin.GetInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstance]: crate::client::InstanceAdmin::get_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the requested instance. Values are of the form
    /// `projects/<project>/instances/<instance>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If field_mask is present, specifies the subset of
    /// [Instance][google.spanner.admin.instance.v1.Instance] fields that should be
    /// returned. If absent, all
    /// [Instance][google.spanner.admin.instance.v1.Instance] fields are returned.
    ///
    /// [google.spanner.admin.instance.v1.Instance]: crate::model::Instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::GetInstanceRequest::field_mask].
    pub fn set_field_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_mask = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstanceRequest"
    }
}

/// The request for
/// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The name of the project in which to create the instance. Values
    /// are of the form `projects/<project>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the instance to create.  Valid identifiers are of the
    /// form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64 characters in
    /// length.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The instance to create.  The name may be omitted, but if
    /// specified must be `<parent>/instances/<instance_id>`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceRequest"
    }
}

/// The request for
/// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The name of the project for which a list of instances is
    /// requested. Values are of the form `projects/<project>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of instances to be returned in the response. If 0 or less, defaults
    /// to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token]
    /// from a previous
    /// [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesResponse]: crate::model::ListInstancesResponse
    /// [google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token]: crate::model::ListInstancesResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// An expression for filtering the results of the request. Filter rules are
    /// case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `display_name`
    /// * `labels.key` where key is the name of a label
    ///
    /// Some examples of using filters are:
    ///
    /// * `name:*` --> The instance has a name.
    /// * `name:Howl` --> The instance's name contains the string "howl".
    /// * `name:HOWL` --> Equivalent to above.
    /// * `NAME:howl` --> Equivalent to above.
    /// * `labels.env:*` --> The instance has the label "env".
    /// * `labels.env:dev` --> The instance has the label "env" and the value of
    ///   the label contains the string "dev".
    /// * `name:howl labels.env:dev` --> The instance's name contains "howl" and
    ///   it has the label "env" with its value
    ///   containing "dev".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Deadline used while retrieving metadata for instances.
    /// Instances whose metadata cannot be retrieved within this deadline will be
    /// added to
    /// [unreachable][google.spanner.admin.instance.v1.ListInstancesResponse.unreachable]
    /// in
    /// [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesResponse]: crate::model::ListInstancesResponse
    /// [google.spanner.admin.instance.v1.ListInstancesResponse.unreachable]: crate::model::ListInstancesResponse::unreachable
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_deadline: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [instance_deadline][crate::model::ListInstancesRequest::instance_deadline].
    pub fn set_instance_deadline<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_deadline = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancesRequest"
    }
}

/// The response for
/// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of requested instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]
    /// call to fetch more of the matching instances.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The list of unreachable instances.
    /// It includes the names of instances whose metadata could not be retrieved
    /// within
    /// [instance_deadline][google.spanner.admin.instance.v1.ListInstancesRequest.instance_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesRequest.instance_deadline]: crate::model::ListInstancesRequest::instance_deadline
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. The instance to update, which must always include the instance
    /// name.  Otherwise, only fields mentioned in
    /// [field_mask][google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask]
    /// need be included.
    ///
    /// [google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask]: crate::model::UpdateInstanceRequest::field_mask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. A mask specifying which fields in
    /// [Instance][google.spanner.admin.instance.v1.Instance] should be updated.
    /// The field mask must always be specified; this prevents any future fields in
    /// [Instance][google.spanner.admin.instance.v1.Instance] from being erased
    /// accidentally by clients that do not know about them.
    ///
    /// [google.spanner.admin.instance.v1.Instance]: crate::model::Instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::UpdateInstanceRequest::field_mask].
    pub fn set_field_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceRequest"
    }
}

/// The request for
/// [DeleteInstance][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance]: crate::client::InstanceAdmin::delete_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the instance to be deleted. Values are of the form
    /// `projects/<project>/instances/<instance>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstanceRequest"
    }
}

/// Metadata type for the operation returned by
/// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceMetadata {
    /// The instance being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// The time at which the
    /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The expected fulfillment period of this create operation.
    pub expected_fulfillment_period: crate::model::FulfillmentPeriod,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::CreateInstanceMetadata::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CreateInstanceMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstanceMetadata::cancel_time].
    pub fn set_cancel_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cancel_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CreateInstanceMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [expected_fulfillment_period][crate::model::CreateInstanceMetadata::expected_fulfillment_period].
    pub fn set_expected_fulfillment_period<
        T: std::convert::Into<crate::model::FulfillmentPeriod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_fulfillment_period = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceMetadata"
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceMetadata {
    /// The desired end state of the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// The time at which
    /// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The expected fulfillment period of this update operation.
    pub expected_fulfillment_period: crate::model::FulfillmentPeriod,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceMetadata::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateInstanceMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstanceMetadata::cancel_time].
    pub fn set_cancel_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cancel_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateInstanceMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [expected_fulfillment_period][crate::model::UpdateInstanceMetadata::expected_fulfillment_period].
    pub fn set_expected_fulfillment_period<
        T: std::convert::Into<crate::model::FulfillmentPeriod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_fulfillment_period = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceMetadata"
    }
}

/// Free instance specific metadata that is kept even after an instance has been
/// upgraded for tracking purposes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FreeInstanceMetadata {
    /// Output only. Timestamp after which the instance will either be upgraded or
    /// scheduled for deletion after a grace period. ExpireBehavior is used to
    /// choose between upgrading or scheduling the free instance for deletion. This
    /// timestamp is set during the creation of a free instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. If present, the timestamp at which the free instance was
    /// upgraded to a provisioned instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upgrade_time: std::option::Option<wkt::Timestamp>,

    /// Specifies the expiration behavior of a free instance. The default of
    /// ExpireBehavior is `REMOVE_AFTER_GRACE_PERIOD`. This can be modified during
    /// or after creation, and before expiration.
    pub expire_behavior: crate::model::free_instance_metadata::ExpireBehavior,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FreeInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expire_time][crate::model::FreeInstanceMetadata::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [upgrade_time][crate::model::FreeInstanceMetadata::upgrade_time].
    pub fn set_upgrade_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.upgrade_time = v.into();
        self
    }

    /// Sets the value of [expire_behavior][crate::model::FreeInstanceMetadata::expire_behavior].
    pub fn set_expire_behavior<
        T: std::convert::Into<crate::model::free_instance_metadata::ExpireBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expire_behavior = v.into();
        self
    }
}

impl wkt::message::Message for FreeInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.FreeInstanceMetadata"
    }
}

/// Defines additional types related to [FreeInstanceMetadata].
pub mod free_instance_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Allows users to change behavior when a free instance expires.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ExpireBehavior(i32);

    impl ExpireBehavior {
        /// Not specified.
        pub const EXPIRE_BEHAVIOR_UNSPECIFIED: ExpireBehavior = ExpireBehavior::new(0);

        /// When the free instance expires, upgrade the instance to a provisioned
        /// instance.
        pub const FREE_TO_PROVISIONED: ExpireBehavior = ExpireBehavior::new(1);

        /// When the free instance expires, disable the instance, and delete it
        /// after the grace period passes if it has not been upgraded.
        pub const REMOVE_AFTER_GRACE_PERIOD: ExpireBehavior = ExpireBehavior::new(2);

        /// Creates a new ExpireBehavior instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EXPIRE_BEHAVIOR_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FREE_TO_PROVISIONED"),
                2 => std::borrow::Cow::Borrowed("REMOVE_AFTER_GRACE_PERIOD"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EXPIRE_BEHAVIOR_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EXPIRE_BEHAVIOR_UNSPECIFIED)
                }
                "FREE_TO_PROVISIONED" => std::option::Option::Some(Self::FREE_TO_PROVISIONED),
                "REMOVE_AFTER_GRACE_PERIOD" => {
                    std::option::Option::Some(Self::REMOVE_AFTER_GRACE_PERIOD)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ExpireBehavior {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ExpireBehavior {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Metadata type for the operation returned by
/// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceConfigMetadata {
    /// The target instance configuration end state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// The progress of the
    /// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]
    /// operation.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceConfigMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::CreateInstanceConfigMetadata::instance_config].
    pub fn set_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::CreateInstanceConfigMetadata::progress].
    pub fn set_progress<
        T: std::convert::Into<std::option::Option<crate::model::OperationProgress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstanceConfigMetadata::cancel_time].
    pub fn set_cancel_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cancel_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceConfigMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata"
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceConfigMetadata {
    /// The desired instance configuration after updating.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// The progress of the
    /// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]
    /// operation.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceConfigMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::UpdateInstanceConfigMetadata::instance_config].
    pub fn set_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::UpdateInstanceConfigMetadata::progress].
    pub fn set_progress<
        T: std::convert::Into<std::option::Option<crate::model::OperationProgress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstanceConfigMetadata::cancel_time].
    pub fn set_cancel_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cancel_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceConfigMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata"
    }
}

/// An isolated set of Cloud Spanner resources that databases can define
/// placements on.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancePartition {
    /// Required. A unique identifier for the instance partition. Values are of the
    /// form
    /// `projects/<project>/instances/<instance>/instancePartitions/[a-z][-a-z0-9]*[a-z0-9]`.
    /// The final segment of the name must be between 2 and 64 characters in
    /// length. An instance partition's name cannot be changed after the instance
    /// partition is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The name of the instance partition's configuration. Values are of
    /// the form `projects/<project>/instanceConfigs/<configuration>`. See also
    /// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config: std::string::String,

    /// Required. The descriptive name for this instance partition as it appears in
    /// UIs. Must be unique per project and between 4 and 30 characters in length.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The current instance partition state.
    pub state: crate::model::instance_partition::State,

    /// Output only. The time at which the instance partition was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the instance partition was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The names of the databases that reference this
    /// instance partition. Referencing databases should share the parent instance.
    /// The existence of any referencing database prevents the instance partition
    /// from being deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub referencing_databases: std::vec::Vec<std::string::String>,

    /// Output only. Deprecated: This field is not populated.
    /// Output only. The names of the backups that reference this instance
    /// partition. Referencing backups should share the parent instance. The
    /// existence of any referencing backup prevents the instance partition from
    /// being deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub referencing_backups: std::vec::Vec<std::string::String>,

    /// Used for optimistic concurrency control as a way
    /// to help prevent simultaneous updates of a instance partition from
    /// overwriting each other. It is strongly suggested that systems make use of
    /// the etag in the read-modify-write cycle to perform instance partition
    /// updates in order to avoid race conditions: An etag is returned in the
    /// response which contains instance partitions, and systems are expected to
    /// put that etag in the request to update instance partitions to ensure that
    /// their change will be applied to the same version of the instance partition.
    /// If no etag is provided in the call to update instance partition, then the
    /// existing instance partition is overwritten blindly.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Compute capacity defines amount of server and storage resources that are
    /// available to the databases in an instance partition. At most, one of either
    /// `node_count` or` processing_units` should be present in the message. For
    /// more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub compute_capacity: std::option::Option<crate::model::instance_partition::ComputeCapacity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancePartition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstancePartition::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::InstancePartition::config].
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InstancePartition::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::InstancePartition::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance_partition::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::InstancePartition::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::InstancePartition::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::InstancePartition::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [referencing_databases][crate::model::InstancePartition::referencing_databases].
    pub fn set_referencing_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.referencing_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [referencing_backups][crate::model::InstancePartition::referencing_backups].
    pub fn set_referencing_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.referencing_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity].
    ///
    /// Note that all the setters affecting `compute_capacity` are mutually
    /// exclusive.
    pub fn set_compute_capacity<
        T: std::convert::Into<std::option::Option<crate::model::instance_partition::ComputeCapacity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_capacity = v.into();
        self
    }

    /// The value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// if it holds a `NodeCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn node_count(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::instance_partition::ComputeCapacity::NodeCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// if it holds a `ProcessingUnits`, `None` if the field is not set or
    /// holds a different branch.
    pub fn processing_units(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::instance_partition::ComputeCapacity::ProcessingUnits(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// to hold a `NodeCount`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::instance_partition::ComputeCapacity::NodeCount(v.into()),
        );
        self
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// to hold a `ProcessingUnits`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::instance_partition::ComputeCapacity::ProcessingUnits(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InstancePartition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.InstancePartition"
    }
}

/// Defines additional types related to [InstancePartition].
pub mod instance_partition {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the instance partition.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not specified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The instance partition is still being created. Resources may not be
        /// available yet, and operations such as creating placements using this
        /// instance partition may not work.
        pub const CREATING: State = State::new(1);

        /// The instance partition is fully created and ready to do work such as
        /// creating placements and using in databases.
        pub const READY: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Compute capacity defines amount of server and storage resources that are
    /// available to the databases in an instance partition. At most, one of either
    /// `node_count` or` processing_units` should be present in the message. For
    /// more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ComputeCapacity {
        /// The number of nodes allocated to this instance partition.
        ///
        /// Users can set the `node_count` field to specify the target number of
        /// nodes allocated to the instance partition.
        ///
        /// This may be zero in API responses for instance partitions that are not
        /// yet in state `READY`.
        NodeCount(i32),
        /// The number of processing units allocated to this instance partition.
        ///
        /// Users can set the `processing_units` field to specify the target number
        /// of processing units allocated to the instance partition.
        ///
        /// This might be zero in API responses for instance partitions that are not
        /// yet in the `READY` state.
        ProcessingUnits(i32),
    }
}

/// Metadata type for the operation returned by
/// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstancePartitionMetadata {
    /// The instance partition being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// The time at which the
    /// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstancePartitionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::CreateInstancePartitionMetadata::instance_partition].
    pub fn set_instance_partition<
        T: std::convert::Into<std::option::Option<crate::model::InstancePartition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CreateInstancePartitionMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstancePartitionMetadata::cancel_time].
    pub fn set_cancel_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cancel_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CreateInstancePartitionMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstancePartitionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata"
    }
}

/// The request for
/// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstancePartitionRequest {
    /// Required. The name of the instance in which to create the instance
    /// partition. Values are of the form
    /// `projects/<project>/instances/<instance>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the instance partition to create. Valid identifiers are
    /// of the form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64
    /// characters in length.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_partition_id: std::string::String,

    /// Required. The instance partition to create. The instance_partition.name may
    /// be omitted, but if specified must be
    /// `<parent>/instancePartitions/<instance_partition_id>`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstancePartitionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_partition_id][crate::model::CreateInstancePartitionRequest::instance_partition_id].
    pub fn set_instance_partition_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition_id = v.into();
        self
    }

    /// Sets the value of [instance_partition][crate::model::CreateInstancePartitionRequest::instance_partition].
    pub fn set_instance_partition<
        T: std::convert::Into<std::option::Option<crate::model::InstancePartition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionRequest"
    }
}

/// The request for
/// [DeleteInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstancePartition]: crate::client::InstanceAdmin::delete_instance_partition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstancePartitionRequest {
    /// Required. The name of the instance partition to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If not empty, the API only deletes the instance partition when
    /// the etag provided matches the current status of the requested instance
    /// partition. Otherwise, deletes the instance partition without checking the
    /// current status of the requested instance partition.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstancePartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstancePartitionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstancePartitionRequest"
    }
}

/// The request for
/// [GetInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.GetInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstancePartition]: crate::client::InstanceAdmin::get_instance_partition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstancePartitionRequest {
    /// Required. The name of the requested instance partition. Values are of
    /// the form
    /// `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstancePartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstancePartitionRequest"
    }
}

/// The request for
/// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstancePartitionRequest {
    /// Required. The instance partition to update, which must always include the
    /// instance partition name. Otherwise, only fields mentioned in
    /// [field_mask][google.spanner.admin.instance.v1.UpdateInstancePartitionRequest.field_mask]
    /// need be included.
    ///
    /// [google.spanner.admin.instance.v1.UpdateInstancePartitionRequest.field_mask]: crate::model::UpdateInstancePartitionRequest::field_mask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// Required. A mask specifying which fields in
    /// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
    /// should be updated. The field mask must always be specified; this prevents
    /// any future fields in
    /// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
    /// from being erased accidentally by clients that do not know about them.
    ///
    /// [google.spanner.admin.instance.v1.InstancePartition]: crate::model::InstancePartition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::UpdateInstancePartitionRequest::instance_partition].
    pub fn set_instance_partition<
        T: std::convert::Into<std::option::Option<crate::model::InstancePartition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::UpdateInstancePartitionRequest::field_mask].
    pub fn set_field_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstancePartitionRequest"
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstancePartitionMetadata {
    /// The desired end state of the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// The time at which
    /// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstancePartitionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::UpdateInstancePartitionMetadata::instance_partition].
    pub fn set_instance_partition<
        T: std::convert::Into<std::option::Option<crate::model::InstancePartition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateInstancePartitionMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstancePartitionMetadata::cancel_time].
    pub fn set_cancel_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cancel_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateInstancePartitionMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstancePartitionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata"
    }
}

/// The request for
/// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancePartitionsRequest {
    /// Required. The instance whose instance partitions should be listed. Values
    /// are of the form `projects/<project>/instances/<instance>`. Use `{instance}
    /// = '-'` to list instance partitions for all Instances in a project, e.g.,
    /// `projects/myproject/instances/-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of instance partitions to be returned in the response. If 0 or less,
    /// defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.next_page_token]
    /// from a previous
    /// [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse]: crate::model::ListInstancePartitionsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse.next_page_token]: crate::model::ListInstancePartitionsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Deadline used while retrieving metadata for instance partitions.
    /// Instance partitions whose metadata cannot be retrieved within this deadline
    /// will be added to
    /// [unreachable][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.unreachable]
    /// in
    /// [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse]: crate::model::ListInstancePartitionsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse.unreachable]: crate::model::ListInstancePartitionsResponse::unreachable
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_partition_deadline: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancePartitionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancePartitionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancePartitionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [instance_partition_deadline][crate::model::ListInstancePartitionsRequest::instance_partition_deadline].
    pub fn set_instance_partition_deadline<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition_deadline = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionsRequest"
    }
}

/// The response for
/// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancePartitionsResponse {
    /// The list of requested instancePartitions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_partitions: std::vec::Vec<crate::model::InstancePartition>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]
    /// call to fetch more of the matching instance partitions.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The list of unreachable instances or instance partitions.
    /// It includes the names of instances or instance partitions whose metadata
    /// could not be retrieved within
    /// [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionsRequest.instance_partition_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsRequest.instance_partition_deadline]: crate::model::ListInstancePartitionsRequest::instance_partition_deadline
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancePartitionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instance_partitions][crate::model::ListInstancePartitionsResponse::instance_partitions].
    pub fn set_instance_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstancePartition>,
    {
        use std::iter::Iterator;
        self.instance_partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancePartitionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancePartitionsResponse {
    type PageItem = crate::model::InstancePartition;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instance_partitions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancePartitionOperationsRequest {
    /// Required. The parent instance of the instance partition operations.
    /// Values are of the form `projects/<project>/instances/<instance>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of returned operations.
    ///
    /// A filter expression consists of a field name, a
    /// comparison operator, and a value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the Operation are eligible for filtering:
    ///
    /// * `name` - The name of the long-running operation
    /// * `done` - False if the operation is in progress, else true.
    /// * `metadata.@type` - the type of metadata. For example, the type string
    ///   for
    ///   [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata]
    ///   is
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata`.
    /// * `metadata.<field_name>` - any field in metadata.value.
    ///   `metadata.@type` must be specified first, if filtering on metadata
    ///   fields.
    /// * `error` - Error associated with the long-running operation.
    /// * `response.@type` - the type of response.
    /// * `response.<field_name>` - any field in response.value.
    ///
    /// You can combine multiple expressions by enclosing each expression in
    /// parentheses. By default, expressions are combined with AND logic. However,
    /// you can specify AND, OR, and NOT logic explicitly.
    ///
    /// Here are a few examples:
    ///
    /// * `done:true` - The operation is complete.
    /// * `(metadata.@type=` \
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata)
    ///   AND` \
    ///   `(metadata.instance_partition.name:custom-instance-partition) AND` \
    ///   `(metadata.start_time < \"2021-03-28T14:50:00Z\") AND` \
    ///   `(error:*)` - Return operations where:
    ///   * The operation's metadata type is
    ///     [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
    ///   * The instance partition name contains "custom-instance-partition".
    ///   * The operation started before 2021-03-28T14:50:00Z.
    ///   * The operation resulted in an error.
    ///
    /// [google.spanner.admin.instance.v1.CreateInstancePartitionMetadata]: crate::model::CreateInstancePartitionMetadata
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Number of operations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// Optional. If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.next_page_token]
    /// from a previous
    /// [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]
    /// to the same `parent` and with the same `filter`.
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]: crate::model::ListInstancePartitionOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.next_page_token]: crate::model::ListInstancePartitionOperationsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Deadline used while retrieving metadata for instance partition
    /// operations. Instance partitions whose operation metadata cannot be
    /// retrieved within this deadline will be added to
    /// [unreachable_instance_partitions][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.unreachable_instance_partitions]
    /// in
    /// [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]: crate::model::ListInstancePartitionOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.unreachable_instance_partitions]: crate::model::ListInstancePartitionOperationsResponse::unreachable_instance_partitions
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_partition_deadline: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancePartitionOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancePartitionOperationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancePartitionOperationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancePartitionOperationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [instance_partition_deadline][crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline].
    pub fn set_instance_partition_deadline<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition_deadline = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest"
    }
}

/// The response for
/// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancePartitionOperationsResponse {
    /// The list of matching instance partition long-running operations. Each
    /// operation's name will be
    /// prefixed by the instance partition's name. The operation's
    /// metadata field type
    /// `metadata.type_url` describes the type of the metadata.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub operations: std::vec::Vec<longrunning::model::Operation>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]
    /// call to fetch more of the matching metadata.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The list of unreachable instance partitions.
    /// It includes the names of instance partitions whose operation metadata could
    /// not be retrieved within
    /// [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.instance_partition_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.instance_partition_deadline]: crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_instance_partitions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancePartitionOperationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [operations][crate::model::ListInstancePartitionOperationsResponse::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<longrunning::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable_instance_partitions][crate::model::ListInstancePartitionOperationsResponse::unreachable_instance_partitions].
    pub fn set_unreachable_instance_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_instance_partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancePartitionOperationsResponse {
    type PageItem = longrunning::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MoveInstanceRequest {
    /// Required. The instance to move.
    /// Values are of the form `projects/<project>/instances/<instance>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The target instance configuration where to move the instance.
    /// Values are of the form `projects/<project>/instanceConfigs/<config>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_config: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MoveInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_config][crate::model::MoveInstanceRequest::target_config].
    pub fn set_target_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_config = v.into();
        self
    }
}

impl wkt::message::Message for MoveInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceRequest"
    }
}

/// The response for
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MoveInstanceResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MoveInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceResponse"
    }
}

/// Metadata type for the operation returned by
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MoveInstanceMetadata {
    /// The target instance configuration where to move the instance.
    /// Values are of the form `projects/<project>/instanceConfigs/<config>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_config: std::string::String,

    /// The progress of the
    /// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]
    /// operation.
    /// [progress_percent][google.spanner.admin.instance.v1.OperationProgress.progress_percent]
    /// is reset when cancellation is requested.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
    /// [google.spanner.admin.instance.v1.OperationProgress.progress_percent]: crate::model::OperationProgress::progress_percent
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_config][crate::model::MoveInstanceMetadata::target_config].
    pub fn set_target_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_config = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::MoveInstanceMetadata::progress].
    pub fn set_progress<
        T: std::convert::Into<std::option::Option<crate::model::OperationProgress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [cancel_time][crate::model::MoveInstanceMetadata::cancel_time].
    pub fn set_cancel_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cancel_time = v.into();
        self
    }
}

impl wkt::message::Message for MoveInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceMetadata"
    }
}

/// Indicates the expected fulfillment period of an operation.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct FulfillmentPeriod(i32);

impl FulfillmentPeriod {
    /// Not specified.
    pub const FULFILLMENT_PERIOD_UNSPECIFIED: FulfillmentPeriod = FulfillmentPeriod::new(0);

    /// Normal fulfillment period. The operation is expected to complete within
    /// minutes.
    pub const FULFILLMENT_PERIOD_NORMAL: FulfillmentPeriod = FulfillmentPeriod::new(1);

    /// Extended fulfillment period. It can take up to an hour for the operation
    /// to complete.
    pub const FULFILLMENT_PERIOD_EXTENDED: FulfillmentPeriod = FulfillmentPeriod::new(2);

    /// Creates a new FulfillmentPeriod instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("FULFILLMENT_PERIOD_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("FULFILLMENT_PERIOD_NORMAL"),
            2 => std::borrow::Cow::Borrowed("FULFILLMENT_PERIOD_EXTENDED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "FULFILLMENT_PERIOD_UNSPECIFIED" => {
                std::option::Option::Some(Self::FULFILLMENT_PERIOD_UNSPECIFIED)
            }
            "FULFILLMENT_PERIOD_NORMAL" => {
                std::option::Option::Some(Self::FULFILLMENT_PERIOD_NORMAL)
            }
            "FULFILLMENT_PERIOD_EXTENDED" => {
                std::option::Option::Some(Self::FULFILLMENT_PERIOD_EXTENDED)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for FulfillmentPeriod {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for FulfillmentPeriod {
    fn default() -> Self {
        Self::new(0)
    }
}
