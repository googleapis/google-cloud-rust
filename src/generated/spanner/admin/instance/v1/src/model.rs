// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Encapsulates progress related information for a Cloud Spanner long
/// running instance operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationProgress {
    /// Percent completion of the operation.
    /// Values are between 0 and 100 inclusive.
    pub progress_percent: i32,

    /// Time the request was received.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation failed or was completed
    /// successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationProgress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_percent][crate::model::OperationProgress::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OperationProgress::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::OperationProgress::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationProgress::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationProgress::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationProgress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.OperationProgress"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationProgress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __progress_percent,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationProgress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationProgress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationProgress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationProgress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationProgress");
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReplicaSelection identifies replicas with common properties.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaSelection {
    /// Required. Name of the location of the replicas (e.g., "us-central1").
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaSelection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ReplicaSelection::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaSelection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaSelection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicaSelection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicaSelection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicaSelection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicaSelection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicaSelection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicaSelection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicaSelection");
        debug_struct.field("location", &self.location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaInfo {
    /// The location of the serving resources, e.g., "us-central1".
    pub location: std::string::String,

    /// The type of replica.
    pub r#type: crate::model::replica_info::ReplicaType,

    /// If true, this location is designated as the default leader location where
    /// leader replicas are placed. See the [region types
    /// documentation](https://cloud.google.com/spanner/docs/instances#region_types)
    /// for more details.
    pub default_leader_location: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ReplicaInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ReplicaInfo::type].
    pub fn set_type<T: std::convert::Into<crate::model::replica_info::ReplicaType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [default_leader_location][crate::model::ReplicaInfo::default_leader_location].
    pub fn set_default_leader_location<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_leader_location = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicaInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __type,
            __default_leader_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicaInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "type" => Ok(__FieldTag::__type),
                            "defaultLeaderLocation" => Ok(__FieldTag::__default_leader_location),
                            "default_leader_location" => Ok(__FieldTag::__default_leader_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicaInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicaInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::replica_info::ReplicaType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_leader_location => {
                            if !fields.insert(__FieldTag::__default_leader_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_leader_location",
                                ));
                            }
                            result.default_leader_location = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicaInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.default_leader_location) {
            state.serialize_entry("defaultLeaderLocation", &self.default_leader_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicaInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicaInfo");
        debug_struct.field("location", &self.location);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("default_leader_location", &self.default_leader_location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReplicaInfo].
pub mod replica_info {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of replica.  See the [replica types
    /// documentation](https://cloud.google.com/spanner/docs/replication#replica_types)
    /// for more details.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicaType {
        /// Not specified.
        TypeUnspecified,
        /// Read-write replicas support both reads and writes. These replicas:
        ///
        /// * Maintain a full copy of your data.
        /// * Serve reads.
        /// * Can vote whether to commit a write.
        /// * Participate in leadership election.
        /// * Are eligible to become a leader.
        ReadWrite,
        /// Read-only replicas only support reads (not writes). Read-only replicas:
        ///
        /// * Maintain a full copy of your data.
        /// * Serve reads.
        /// * Do not participate in voting to commit writes.
        /// * Are not eligible to become a leader.
        ReadOnly,
        /// Witness replicas don't support reads but do participate in voting to
        /// commit writes. Witness replicas:
        ///
        /// * Do not maintain a full copy of data.
        /// * Do not serve reads.
        /// * Vote whether to commit writes.
        /// * Participate in leader election but are not eligible to become leader.
        Witness,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplicaType::value] or
        /// [ReplicaType::name].
        UnknownValue(replica_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod replica_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReplicaType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some(0),
                Self::ReadWrite => std::option::Option::Some(1),
                Self::ReadOnly => std::option::Option::Some(2),
                Self::Witness => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::Witness => std::option::Option::Some("WITNESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReplicaType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReplicaType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReplicaType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::TypeUnspecified,
                1 => Self::ReadWrite,
                2 => Self::ReadOnly,
                3 => Self::Witness,
                _ => Self::UnknownValue(replica_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReplicaType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::TypeUnspecified,
                "READ_WRITE" => Self::ReadWrite,
                "READ_ONLY" => Self::ReadOnly,
                "WITNESS" => Self::Witness,
                _ => Self::UnknownValue(replica_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReplicaType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::TypeUnspecified => serializer.serialize_i32(0),
                Self::ReadWrite => serializer.serialize_i32(1),
                Self::ReadOnly => serializer.serialize_i32(2),
                Self::Witness => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReplicaType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicaType>::new(
                ".google.spanner.admin.instance.v1.ReplicaInfo.ReplicaType",
            ))
        }
    }
}

/// A possible configuration for a Cloud Spanner instance. Configurations
/// define the geographic placement of nodes and their replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceConfig {
    /// A unique identifier for the instance configuration.  Values
    /// are of the form
    /// `projects/<project>/instanceConfigs/[a-z][-a-z0-9]*`.
    ///
    /// User instance configuration must start with `custom-`.
    pub name: std::string::String,

    /// The name of this instance configuration as it appears in UIs.
    pub display_name: std::string::String,

    /// Output only. Whether this instance configuration is a Google-managed or
    /// user-managed configuration.
    pub config_type: crate::model::instance_config::Type,

    /// The geographic placement of nodes in this instance configuration and their
    /// replication properties.
    ///
    /// To create user-managed configurations, input
    /// `replicas` must include all replicas in `replicas` of the `base_config`
    /// and include one or more replicas in the `optional_replicas` of the
    /// `base_config`.
    pub replicas: std::vec::Vec<crate::model::ReplicaInfo>,

    /// Output only. The available optional replicas to choose from for
    /// user-managed configurations. Populated for Google-managed configurations.
    pub optional_replicas: std::vec::Vec<crate::model::ReplicaInfo>,

    /// Base configuration name, e.g. projects/<project_name>/instanceConfigs/nam3,
    /// based on which this configuration is created. Only set for user-managed
    /// configurations. `base_config` must refer to a configuration of type
    /// `GOOGLE_MANAGED` in the same project as this configuration.
    pub base_config: std::string::String,

    /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. Cloud Labels can be used to filter collections of
    /// resources. They can be used to control how resource metrics are aggregated.
    /// And they can be used as arguments to policy management rules (e.g. route,
    /// firewall, load balancing, etc.).
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform
    ///   to the regular expression `[a-z0-9_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    ///
    /// If you plan to use labels in your own code, please note that additional
    /// characters may be allowed in the future. Therefore, you are advised to use
    /// an internal label representation, such as JSON, which doesn't rely upon
    /// specific characters being disallowed.  For example, representing labels
    /// as the string:  name + "_" + value  would prove problematic if we were to
    /// allow "_" in a future release.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// etag is used for optimistic concurrency control as a way
    /// to help prevent simultaneous updates of a instance configuration from
    /// overwriting each other. It is strongly suggested that systems make use of
    /// the etag in the read-modify-write cycle to perform instance configuration
    /// updates in order to avoid race conditions: An etag is returned in the
    /// response which contains instance configurations, and systems are expected
    /// to put that etag in the request to update instance configuration to ensure
    /// that their change is applied to the same version of the instance
    /// configuration. If no etag is provided in the call to update the instance
    /// configuration, then the existing instance configuration is overwritten
    /// blindly.
    pub etag: std::string::String,

    /// Allowed values of the "default_leader" schema option for databases in
    /// instances that use this instance configuration.
    pub leader_options: std::vec::Vec<std::string::String>,

    /// Output only. If true, the instance configuration is being created or
    /// updated. If false, there are no ongoing operations for the instance
    /// configuration.
    pub reconciling: bool,

    /// Output only. The current instance configuration state. Applicable only for
    /// `USER_MANAGED` configurations.
    pub state: crate::model::instance_config::State,

    /// Output only. Describes whether free instances are available to be created
    /// in this instance configuration.
    pub free_instance_availability: crate::model::instance_config::FreeInstanceAvailability,

    /// Output only. The `QuorumType` of the instance configuration.
    pub quorum_type: crate::model::instance_config::QuorumType,

    /// Output only. The storage limit in bytes per processing unit.
    pub storage_limit_per_processing_unit: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InstanceConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [config_type][crate::model::InstanceConfig::config_type].
    pub fn set_config_type<T: std::convert::Into<crate::model::instance_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_type = v.into();
        self
    }

    /// Sets the value of [replicas][crate::model::InstanceConfig::replicas].
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaInfo>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [optional_replicas][crate::model::InstanceConfig::optional_replicas].
    pub fn set_optional_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaInfo>,
    {
        use std::iter::Iterator;
        self.optional_replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [base_config][crate::model::InstanceConfig::base_config].
    pub fn set_base_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::InstanceConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::InstanceConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [leader_options][crate::model::InstanceConfig::leader_options].
    pub fn set_leader_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.leader_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reconciling][crate::model::InstanceConfig::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [state][crate::model::InstanceConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [free_instance_availability][crate::model::InstanceConfig::free_instance_availability].
    pub fn set_free_instance_availability<
        T: std::convert::Into<crate::model::instance_config::FreeInstanceAvailability>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.free_instance_availability = v.into();
        self
    }

    /// Sets the value of [quorum_type][crate::model::InstanceConfig::quorum_type].
    pub fn set_quorum_type<T: std::convert::Into<crate::model::instance_config::QuorumType>>(
        mut self,
        v: T,
    ) -> Self {
        self.quorum_type = v.into();
        self
    }

    /// Sets the value of [storage_limit_per_processing_unit][crate::model::InstanceConfig::storage_limit_per_processing_unit].
    pub fn set_storage_limit_per_processing_unit<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_limit_per_processing_unit = v.into();
        self
    }
}

impl wkt::message::Message for InstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.InstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __config_type,
            __replicas,
            __optional_replicas,
            __base_config,
            __labels,
            __etag,
            __leader_options,
            __reconciling,
            __state,
            __free_instance_availability,
            __quorum_type,
            __storage_limit_per_processing_unit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "configType" => Ok(__FieldTag::__config_type),
                            "config_type" => Ok(__FieldTag::__config_type),
                            "replicas" => Ok(__FieldTag::__replicas),
                            "optionalReplicas" => Ok(__FieldTag::__optional_replicas),
                            "optional_replicas" => Ok(__FieldTag::__optional_replicas),
                            "baseConfig" => Ok(__FieldTag::__base_config),
                            "base_config" => Ok(__FieldTag::__base_config),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "leaderOptions" => Ok(__FieldTag::__leader_options),
                            "leader_options" => Ok(__FieldTag::__leader_options),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "state" => Ok(__FieldTag::__state),
                            "freeInstanceAvailability" => {
                                Ok(__FieldTag::__free_instance_availability)
                            }
                            "free_instance_availability" => {
                                Ok(__FieldTag::__free_instance_availability)
                            }
                            "quorumType" => Ok(__FieldTag::__quorum_type),
                            "quorum_type" => Ok(__FieldTag::__quorum_type),
                            "storageLimitPerProcessingUnit" => {
                                Ok(__FieldTag::__storage_limit_per_processing_unit)
                            }
                            "storage_limit_per_processing_unit" => {
                                Ok(__FieldTag::__storage_limit_per_processing_unit)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_type => {
                            if !fields.insert(__FieldTag::__config_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_type",
                                ));
                            }
                            result.config_type = map.next_value::<std::option::Option<crate::model::instance_config::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__replicas => {
                            if !fields.insert(__FieldTag::__replicas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicas",
                                ));
                            }
                            result.replicas = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ReplicaInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__optional_replicas => {
                            if !fields.insert(__FieldTag::__optional_replicas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_replicas",
                                ));
                            }
                            result.optional_replicas = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ReplicaInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__base_config => {
                            if !fields.insert(__FieldTag::__base_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_config",
                                ));
                            }
                            result.base_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__leader_options => {
                            if !fields.insert(__FieldTag::__leader_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for leader_options",
                                ));
                            }
                            result.leader_options = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::instance_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__free_instance_availability => {
                            if !fields.insert(__FieldTag::__free_instance_availability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_instance_availability",
                                ));
                            }
                            result.free_instance_availability = map
                                .next_value::<std::option::Option<
                                    crate::model::instance_config::FreeInstanceAvailability,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quorum_type => {
                            if !fields.insert(__FieldTag::__quorum_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quorum_type",
                                ));
                            }
                            result.quorum_type = map.next_value::<std::option::Option<crate::model::instance_config::QuorumType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_limit_per_processing_unit => {
                            if !fields.insert(__FieldTag::__storage_limit_per_processing_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_limit_per_processing_unit",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_limit_per_processing_unit =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.config_type) {
            state.serialize_entry("configType", &self.config_type)?;
        }
        if !self.replicas.is_empty() {
            state.serialize_entry("replicas", &self.replicas)?;
        }
        if !self.optional_replicas.is_empty() {
            state.serialize_entry("optionalReplicas", &self.optional_replicas)?;
        }
        if !self.base_config.is_empty() {
            state.serialize_entry("baseConfig", &self.base_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.leader_options.is_empty() {
            state.serialize_entry("leaderOptions", &self.leader_options)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.free_instance_availability) {
            state.serialize_entry("freeInstanceAvailability", &self.free_instance_availability)?;
        }
        if !wkt::internal::is_default(&self.quorum_type) {
            state.serialize_entry("quorumType", &self.quorum_type)?;
        }
        if !wkt::internal::is_default(&self.storage_limit_per_processing_unit) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "storageLimitPerProcessingUnit",
                &__With(&self.storage_limit_per_processing_unit),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("config_type", &self.config_type);
        debug_struct.field("replicas", &self.replicas);
        debug_struct.field("optional_replicas", &self.optional_replicas);
        debug_struct.field("base_config", &self.base_config);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("leader_options", &self.leader_options);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "free_instance_availability",
            &self.free_instance_availability,
        );
        debug_struct.field("quorum_type", &self.quorum_type);
        debug_struct.field(
            "storage_limit_per_processing_unit",
            &self.storage_limit_per_processing_unit,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [InstanceConfig].
pub mod instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of this configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified.
        Unspecified,
        /// Google-managed configuration.
        GoogleManaged,
        /// User-managed configuration.
        UserManaged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleManaged => std::option::Option::Some(1),
                Self::UserManaged => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::GoogleManaged => std::option::Option::Some("GOOGLE_MANAGED"),
                Self::UserManaged => std::option::Option::Some("USER_MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleManaged,
                2 => Self::UserManaged,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_MANAGED" => Self::GoogleManaged,
                "USER_MANAGED" => Self::UserManaged,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleManaged => serializer.serialize_i32(1),
                Self::UserManaged => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.spanner.admin.instance.v1.InstanceConfig.Type",
            ))
        }
    }

    /// Indicates the current state of the instance configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The instance configuration is still being created.
        Creating,
        /// The instance configuration is fully created and ready to be used to
        /// create instances.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.spanner.admin.instance.v1.InstanceConfig.State",
            ))
        }
    }

    /// Describes the availability for free instances to be created in an instance
    /// configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FreeInstanceAvailability {
        /// Not specified.
        Unspecified,
        /// Indicates that free instances are available to be created in this
        /// instance configuration.
        Available,
        /// Indicates that free instances are not supported in this instance
        /// configuration.
        Unsupported,
        /// Indicates that free instances are currently not available to be created
        /// in this instance configuration.
        Disabled,
        /// Indicates that additional free instances cannot be created in this
        /// instance configuration because the project has reached its limit of free
        /// instances.
        QuotaExceeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FreeInstanceAvailability::value] or
        /// [FreeInstanceAvailability::name].
        UnknownValue(free_instance_availability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod free_instance_availability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FreeInstanceAvailability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Available => std::option::Option::Some(1),
                Self::Unsupported => std::option::Option::Some(2),
                Self::Disabled => std::option::Option::Some(3),
                Self::QuotaExceeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("FREE_INSTANCE_AVAILABILITY_UNSPECIFIED")
                }
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Unsupported => std::option::Option::Some("UNSUPPORTED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::QuotaExceeded => std::option::Option::Some("QUOTA_EXCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FreeInstanceAvailability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FreeInstanceAvailability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FreeInstanceAvailability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Available,
                2 => Self::Unsupported,
                3 => Self::Disabled,
                4 => Self::QuotaExceeded,
                _ => Self::UnknownValue(free_instance_availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FreeInstanceAvailability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FREE_INSTANCE_AVAILABILITY_UNSPECIFIED" => Self::Unspecified,
                "AVAILABLE" => Self::Available,
                "UNSUPPORTED" => Self::Unsupported,
                "DISABLED" => Self::Disabled,
                "QUOTA_EXCEEDED" => Self::QuotaExceeded,
                _ => Self::UnknownValue(free_instance_availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FreeInstanceAvailability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Available => serializer.serialize_i32(1),
                Self::Unsupported => serializer.serialize_i32(2),
                Self::Disabled => serializer.serialize_i32(3),
                Self::QuotaExceeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FreeInstanceAvailability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<FreeInstanceAvailability>::new(
                    ".google.spanner.admin.instance.v1.InstanceConfig.FreeInstanceAvailability",
                ),
            )
        }
    }

    /// Indicates the quorum type of this instance configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum QuorumType {
        /// Quorum type not specified.
        Unspecified,
        /// An instance configuration tagged with `REGION` quorum type forms a write
        /// quorum in a single region.
        Region,
        /// An instance configuration tagged with the `DUAL_REGION` quorum type forms
        /// a write quorum with exactly two read-write regions in a multi-region
        /// configuration.
        ///
        /// This instance configuration requires failover in the event of
        /// regional failures.
        DualRegion,
        /// An instance configuration tagged with the `MULTI_REGION` quorum type
        /// forms a write quorum from replicas that are spread across more than one
        /// region in a multi-region configuration.
        MultiRegion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [QuorumType::value] or
        /// [QuorumType::name].
        UnknownValue(quorum_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod quorum_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl QuorumType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Region => std::option::Option::Some(1),
                Self::DualRegion => std::option::Option::Some(2),
                Self::MultiRegion => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("QUORUM_TYPE_UNSPECIFIED"),
                Self::Region => std::option::Option::Some("REGION"),
                Self::DualRegion => std::option::Option::Some("DUAL_REGION"),
                Self::MultiRegion => std::option::Option::Some("MULTI_REGION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for QuorumType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for QuorumType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for QuorumType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Region,
                2 => Self::DualRegion,
                3 => Self::MultiRegion,
                _ => Self::UnknownValue(quorum_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for QuorumType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "QUORUM_TYPE_UNSPECIFIED" => Self::Unspecified,
                "REGION" => Self::Region,
                "DUAL_REGION" => Self::DualRegion,
                "MULTI_REGION" => Self::MultiRegion,
                _ => Self::UnknownValue(quorum_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for QuorumType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Region => serializer.serialize_i32(1),
                Self::DualRegion => serializer.serialize_i32(2),
                Self::MultiRegion => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for QuorumType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuorumType>::new(
                ".google.spanner.admin.instance.v1.InstanceConfig.QuorumType",
            ))
        }
    }
}

/// ReplicaComputeCapacity describes the amount of server resources that are
/// allocated to each replica identified by the replica selection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaComputeCapacity {
    /// Required. Identifies replicas by specified properties.
    /// All replicas in the selection have the same amount of compute capacity.
    pub replica_selection: std::option::Option<crate::model::ReplicaSelection>,

    /// Compute capacity allocated to each replica identified by the specified
    /// selection.
    /// The unit is selected based on the unit used to specify the instance size
    /// for non-autoscaling instances, or the unit used in autoscaling limit for
    /// autoscaling instances.
    pub compute_capacity:
        std::option::Option<crate::model::replica_compute_capacity::ComputeCapacity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaComputeCapacity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replica_selection][crate::model::ReplicaComputeCapacity::replica_selection].
    pub fn set_replica_selection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicaSelection>,
    {
        self.replica_selection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replica_selection][crate::model::ReplicaComputeCapacity::replica_selection].
    pub fn set_or_clear_replica_selection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicaSelection>,
    {
        self.replica_selection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity].
    ///
    /// Note that all the setters affecting `compute_capacity` are mutually
    /// exclusive.
    pub fn set_compute_capacity<
        T: std::convert::Into<
                std::option::Option<crate::model::replica_compute_capacity::ComputeCapacity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_capacity = v.into();
        self
    }

    /// The value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// if it holds a `NodeCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn node_count(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::replica_compute_capacity::ComputeCapacity::NodeCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// to hold a `NodeCount`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::replica_compute_capacity::ComputeCapacity::NodeCount(v.into()),
        );
        self
    }

    /// The value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// if it holds a `ProcessingUnits`, `None` if the field is not set or
    /// holds a different branch.
    pub fn processing_units(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::replica_compute_capacity::ComputeCapacity::ProcessingUnits(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::ReplicaComputeCapacity::compute_capacity]
    /// to hold a `ProcessingUnits`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::replica_compute_capacity::ComputeCapacity::ProcessingUnits(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplicaComputeCapacity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ReplicaComputeCapacity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicaComputeCapacity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __replica_selection,
            __node_count,
            __processing_units,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicaComputeCapacity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replicaSelection" => Ok(__FieldTag::__replica_selection),
                            "replica_selection" => Ok(__FieldTag::__replica_selection),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "processingUnits" => Ok(__FieldTag::__processing_units),
                            "processing_units" => Ok(__FieldTag::__processing_units),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicaComputeCapacity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicaComputeCapacity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__replica_selection => {
                            if !fields.insert(__FieldTag::__replica_selection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_selection",
                                ));
                            }
                            result.replica_selection = map
                                .next_value::<std::option::Option<crate::model::ReplicaSelection>>(
                                )?;
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.compute_capacity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compute_capacity`, a oneof with full ID .google.spanner.admin.instance.v1.ReplicaComputeCapacity.node_count, latest field was nodeCount",
                                ));
                            }
                            result.compute_capacity = std::option::Option::Some(
                                crate::model::replica_compute_capacity::ComputeCapacity::NodeCount(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__processing_units => {
                            if !fields.insert(__FieldTag::__processing_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_units",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.compute_capacity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compute_capacity`, a oneof with full ID .google.spanner.admin.instance.v1.ReplicaComputeCapacity.processing_units, latest field was processingUnits",
                                ));
                            }
                            result.compute_capacity = std::option::Option::Some(
                                crate::model::replica_compute_capacity::ComputeCapacity::ProcessingUnits(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicaComputeCapacity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.replica_selection.is_some() {
            state.serialize_entry("replicaSelection", &self.replica_selection)?;
        }
        if let Some(value) = self.node_count() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(value))?;
        }
        if let Some(value) = self.processing_units() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("processingUnits", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicaComputeCapacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicaComputeCapacity");
        debug_struct.field("replica_selection", &self.replica_selection);
        debug_struct.field("compute_capacity", &self.compute_capacity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReplicaComputeCapacity].
pub mod replica_compute_capacity {
    #[allow(unused_imports)]
    use super::*;

    /// Compute capacity allocated to each replica identified by the specified
    /// selection.
    /// The unit is selected based on the unit used to specify the instance size
    /// for non-autoscaling instances, or the unit used in autoscaling limit for
    /// autoscaling instances.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComputeCapacity {
        /// The number of nodes allocated to each replica.
        ///
        /// This may be zero in API responses for instances that are not yet in
        /// state `READY`.
        NodeCount(i32),
        /// The number of processing units allocated to each replica.
        ///
        /// This may be zero in API responses for instances that are not yet in
        /// state `READY`.
        ProcessingUnits(i32),
    }
}

/// Autoscaling configuration for an instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoscalingConfig {
    /// Required. Autoscaling limits for an instance.
    pub autoscaling_limits:
        std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,

    /// Required. The autoscaling targets for an instance.
    pub autoscaling_targets:
        std::option::Option<crate::model::autoscaling_config::AutoscalingTargets>,

    /// Optional. Optional asymmetric autoscaling options.
    /// Replicas matching the replica selection criteria will be autoscaled
    /// independently from other replicas. The autoscaler will scale the replicas
    /// based on the utilization of replicas identified by the replica selection.
    /// Replica selections should not overlap with each other.
    ///
    /// Other replicas (those do not match any replica selection) will be
    /// autoscaled together and will have the same compute capacity allocated to
    /// them.
    pub asymmetric_autoscaling_options:
        std::vec::Vec<crate::model::autoscaling_config::AsymmetricAutoscalingOption>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autoscaling_limits][crate::model::AutoscalingConfig::autoscaling_limits].
    pub fn set_autoscaling_limits<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
    {
        self.autoscaling_limits = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_limits][crate::model::AutoscalingConfig::autoscaling_limits].
    pub fn set_or_clear_autoscaling_limits<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
    {
        self.autoscaling_limits = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoscaling_targets][crate::model::AutoscalingConfig::autoscaling_targets].
    pub fn set_autoscaling_targets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingTargets>,
    {
        self.autoscaling_targets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_targets][crate::model::AutoscalingConfig::autoscaling_targets].
    pub fn set_or_clear_autoscaling_targets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::autoscaling_config::AutoscalingTargets>,
    {
        self.autoscaling_targets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asymmetric_autoscaling_options][crate::model::AutoscalingConfig::asymmetric_autoscaling_options].
    pub fn set_asymmetric_autoscaling_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::autoscaling_config::AsymmetricAutoscalingOption>,
    {
        use std::iter::Iterator;
        self.asymmetric_autoscaling_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutoscalingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoscalingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autoscaling_limits,
            __autoscaling_targets,
            __asymmetric_autoscaling_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoscalingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoscalingLimits" => Ok(__FieldTag::__autoscaling_limits),
                            "autoscaling_limits" => Ok(__FieldTag::__autoscaling_limits),
                            "autoscalingTargets" => Ok(__FieldTag::__autoscaling_targets),
                            "autoscaling_targets" => Ok(__FieldTag::__autoscaling_targets),
                            "asymmetricAutoscalingOptions" => {
                                Ok(__FieldTag::__asymmetric_autoscaling_options)
                            }
                            "asymmetric_autoscaling_options" => {
                                Ok(__FieldTag::__asymmetric_autoscaling_options)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoscalingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoscalingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autoscaling_limits => {
                            if !fields.insert(__FieldTag::__autoscaling_limits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling_limits",
                                ));
                            }
                            result.autoscaling_limits = map.next_value::<std::option::Option<
                                crate::model::autoscaling_config::AutoscalingLimits,
                            >>()?;
                        }
                        __FieldTag::__autoscaling_targets => {
                            if !fields.insert(__FieldTag::__autoscaling_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling_targets",
                                ));
                            }
                            result.autoscaling_targets = map.next_value::<std::option::Option<
                                crate::model::autoscaling_config::AutoscalingTargets,
                            >>()?;
                        }
                        __FieldTag::__asymmetric_autoscaling_options => {
                            if !fields.insert(__FieldTag::__asymmetric_autoscaling_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asymmetric_autoscaling_options",
                                ));
                            }
                            result.asymmetric_autoscaling_options = map.next_value::<std::option::Option<std::vec::Vec<crate::model::autoscaling_config::AsymmetricAutoscalingOption>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoscalingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.autoscaling_limits.is_some() {
            state.serialize_entry("autoscalingLimits", &self.autoscaling_limits)?;
        }
        if self.autoscaling_targets.is_some() {
            state.serialize_entry("autoscalingTargets", &self.autoscaling_targets)?;
        }
        if !self.asymmetric_autoscaling_options.is_empty() {
            state.serialize_entry(
                "asymmetricAutoscalingOptions",
                &self.asymmetric_autoscaling_options,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutoscalingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscalingConfig");
        debug_struct.field("autoscaling_limits", &self.autoscaling_limits);
        debug_struct.field("autoscaling_targets", &self.autoscaling_targets);
        debug_struct.field(
            "asymmetric_autoscaling_options",
            &self.asymmetric_autoscaling_options,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutoscalingConfig].
pub mod autoscaling_config {
    #[allow(unused_imports)]
    use super::*;

    /// The autoscaling limits for the instance. Users can define the minimum and
    /// maximum compute capacity allocated to the instance, and the autoscaler will
    /// only scale within that range. Users can either use nodes or processing
    /// units to specify the limits, but should use the same unit to set both the
    /// min_limit and max_limit.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutoscalingLimits {
        /// The minimum compute capacity for the instance.
        pub min_limit:
            std::option::Option<crate::model::autoscaling_config::autoscaling_limits::MinLimit>,

        /// The maximum compute capacity for the instance. The maximum compute
        /// capacity should be less than or equal to 10X the minimum compute
        /// capacity.
        pub max_limit:
            std::option::Option<crate::model::autoscaling_config::autoscaling_limits::MaxLimit>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoscalingLimits {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit].
        ///
        /// Note that all the setters affecting `min_limit` are mutually
        /// exclusive.
        pub fn set_min_limit<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::autoscaling_config::autoscaling_limits::MinLimit,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_limit = v.into();
            self
        }

        /// The value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// if it holds a `MinNodes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn min_nodes(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.min_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinNodes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// to hold a `MinNodes`.
        ///
        /// Note that all the setters affecting `min_limit` are
        /// mutually exclusive.
        pub fn set_min_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinNodes(v.into()),
            );
            self
        }

        /// The value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// if it holds a `MinProcessingUnits`, `None` if the field is not set or
        /// holds a different branch.
        pub fn min_processing_units(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.min_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinProcessingUnits(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [min_limit][crate::model::autoscaling_config::AutoscalingLimits::min_limit]
        /// to hold a `MinProcessingUnits`.
        ///
        /// Note that all the setters affecting `min_limit` are
        /// mutually exclusive.
        pub fn set_min_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinProcessingUnits(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit].
        ///
        /// Note that all the setters affecting `max_limit` are mutually
        /// exclusive.
        pub fn set_max_limit<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::autoscaling_config::autoscaling_limits::MaxLimit,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_limit = v.into();
            self
        }

        /// The value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// if it holds a `MaxNodes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn max_nodes(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.max_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxNodes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// to hold a `MaxNodes`.
        ///
        /// Note that all the setters affecting `max_limit` are
        /// mutually exclusive.
        pub fn set_max_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxNodes(v.into()),
            );
            self
        }

        /// The value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// if it holds a `MaxProcessingUnits`, `None` if the field is not set or
        /// holds a different branch.
        pub fn max_processing_units(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.max_limit.as_ref().and_then(|v| match v {
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxProcessingUnits(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [max_limit][crate::model::autoscaling_config::AutoscalingLimits::max_limit]
        /// to hold a `MaxProcessingUnits`.
        ///
        /// Note that all the setters affecting `max_limit` are
        /// mutually exclusive.
        pub fn set_max_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_limit = std::option::Option::Some(
                crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxProcessingUnits(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for AutoscalingLimits {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingLimits"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AutoscalingLimits {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min_nodes,
                __min_processing_units,
                __max_nodes,
                __max_processing_units,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AutoscalingLimits")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "minNodes" => Ok(__FieldTag::__min_nodes),
                                "min_nodes" => Ok(__FieldTag::__min_nodes),
                                "minProcessingUnits" => Ok(__FieldTag::__min_processing_units),
                                "min_processing_units" => Ok(__FieldTag::__min_processing_units),
                                "maxNodes" => Ok(__FieldTag::__max_nodes),
                                "max_nodes" => Ok(__FieldTag::__max_nodes),
                                "maxProcessingUnits" => Ok(__FieldTag::__max_processing_units),
                                "max_processing_units" => Ok(__FieldTag::__max_processing_units),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AutoscalingLimits;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AutoscalingLimits")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min_nodes => {
                                if !fields.insert(__FieldTag::__min_nodes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_nodes",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.min_limit.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `min_limit`, a oneof with full ID .google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingLimits.min_nodes, latest field was minNodes",
                                    ));
                                }
                                result.min_limit = std::option::Option::Some(
                                    crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinNodes(
                                        map.next_value::<__With>()?.0.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__min_processing_units => {
                                if !fields.insert(__FieldTag::__min_processing_units) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_processing_units",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.min_limit.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `min_limit`, a oneof with full ID .google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingLimits.min_processing_units, latest field was minProcessingUnits",
                                    ));
                                }
                                result.min_limit = std::option::Option::Some(
                                    crate::model::autoscaling_config::autoscaling_limits::MinLimit::MinProcessingUnits(
                                        map.next_value::<__With>()?.0.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__max_nodes => {
                                if !fields.insert(__FieldTag::__max_nodes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_nodes",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.max_limit.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `max_limit`, a oneof with full ID .google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingLimits.max_nodes, latest field was maxNodes",
                                    ));
                                }
                                result.max_limit = std::option::Option::Some(
                                    crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxNodes(
                                        map.next_value::<__With>()?.0.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__max_processing_units => {
                                if !fields.insert(__FieldTag::__max_processing_units) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_processing_units",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.max_limit.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `max_limit`, a oneof with full ID .google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingLimits.max_processing_units, latest field was maxProcessingUnits",
                                    ));
                                }
                                result.max_limit = std::option::Option::Some(
                                    crate::model::autoscaling_config::autoscaling_limits::MaxLimit::MaxProcessingUnits(
                                        map.next_value::<__With>()?.0.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AutoscalingLimits {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.min_nodes() {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("minNodes", &__With(value))?;
            }
            if let Some(value) = self.min_processing_units() {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("minProcessingUnits", &__With(value))?;
            }
            if let Some(value) = self.max_nodes() {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxNodes", &__With(value))?;
            }
            if let Some(value) = self.max_processing_units() {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxProcessingUnits", &__With(value))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AutoscalingLimits {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AutoscalingLimits");
            debug_struct.field("min_limit", &self.min_limit);
            debug_struct.field("max_limit", &self.max_limit);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AutoscalingLimits].
    pub mod autoscaling_limits {
        #[allow(unused_imports)]
        use super::*;

        /// The minimum compute capacity for the instance.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MinLimit {
            /// Minimum number of nodes allocated to the instance. If set, this number
            /// should be greater than or equal to 1.
            MinNodes(i32),
            /// Minimum number of processing units allocated to the instance. If set,
            /// this number should be multiples of 1000.
            MinProcessingUnits(i32),
        }

        /// The maximum compute capacity for the instance. The maximum compute
        /// capacity should be less than or equal to 10X the minimum compute
        /// capacity.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MaxLimit {
            /// Maximum number of nodes allocated to the instance. If set, this number
            /// should be greater than or equal to min_nodes.
            MaxNodes(i32),
            /// Maximum number of processing units allocated to the instance. If set,
            /// this number should be multiples of 1000 and be greater than or equal to
            /// min_processing_units.
            MaxProcessingUnits(i32),
        }
    }

    /// The autoscaling targets for an instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutoscalingTargets {
        /// Required. The target high priority cpu utilization percentage that the
        /// autoscaler should be trying to achieve for the instance. This number is
        /// on a scale from 0 (no utilization) to 100 (full utilization). The valid
        /// range is [10, 90] inclusive.
        pub high_priority_cpu_utilization_percent: i32,

        /// Required. The target storage utilization percentage that the autoscaler
        /// should be trying to achieve for the instance. This number is on a scale
        /// from 0 (no utilization) to 100 (full utilization). The valid range is
        /// [10, 99] inclusive.
        pub storage_utilization_percent: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoscalingTargets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [high_priority_cpu_utilization_percent][crate::model::autoscaling_config::AutoscalingTargets::high_priority_cpu_utilization_percent].
        pub fn set_high_priority_cpu_utilization_percent<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.high_priority_cpu_utilization_percent = v.into();
            self
        }

        /// Sets the value of [storage_utilization_percent][crate::model::autoscaling_config::AutoscalingTargets::storage_utilization_percent].
        pub fn set_storage_utilization_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.storage_utilization_percent = v.into();
            self
        }
    }

    impl wkt::message::Message for AutoscalingTargets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AutoscalingTargets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AutoscalingTargets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __high_priority_cpu_utilization_percent,
                __storage_utilization_percent,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AutoscalingTargets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "highPriorityCpuUtilizationPercent" => {
                                    Ok(__FieldTag::__high_priority_cpu_utilization_percent)
                                }
                                "high_priority_cpu_utilization_percent" => {
                                    Ok(__FieldTag::__high_priority_cpu_utilization_percent)
                                }
                                "storageUtilizationPercent" => {
                                    Ok(__FieldTag::__storage_utilization_percent)
                                }
                                "storage_utilization_percent" => {
                                    Ok(__FieldTag::__storage_utilization_percent)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AutoscalingTargets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AutoscalingTargets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__high_priority_cpu_utilization_percent => {
                                if !fields
                                    .insert(__FieldTag::__high_priority_cpu_utilization_percent)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for high_priority_cpu_utilization_percent",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.high_priority_cpu_utilization_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__storage_utilization_percent => {
                                if !fields.insert(__FieldTag::__storage_utilization_percent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for storage_utilization_percent",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.storage_utilization_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AutoscalingTargets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.high_priority_cpu_utilization_percent) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "highPriorityCpuUtilizationPercent",
                    &__With(&self.high_priority_cpu_utilization_percent),
                )?;
            }
            if !wkt::internal::is_default(&self.storage_utilization_percent) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "storageUtilizationPercent",
                    &__With(&self.storage_utilization_percent),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AutoscalingTargets {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AutoscalingTargets");
            debug_struct.field(
                "high_priority_cpu_utilization_percent",
                &self.high_priority_cpu_utilization_percent,
            );
            debug_struct.field(
                "storage_utilization_percent",
                &self.storage_utilization_percent,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// AsymmetricAutoscalingOption specifies the scaling of replicas identified by
    /// the given selection.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AsymmetricAutoscalingOption {

        /// Required. Selects the replicas to which this AsymmetricAutoscalingOption
        /// applies. Only read-only replicas are supported.
        pub replica_selection: std::option::Option<crate::model::ReplicaSelection>,

        /// Optional. Overrides applied to the top-level autoscaling configuration
        /// for the selected replicas.
        pub overrides: std::option::Option<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AsymmetricAutoscalingOption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [replica_selection][crate::model::autoscaling_config::AsymmetricAutoscalingOption::replica_selection].
        pub fn set_replica_selection<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ReplicaSelection>,
        {
            self.replica_selection = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [replica_selection][crate::model::autoscaling_config::AsymmetricAutoscalingOption::replica_selection].
        pub fn set_or_clear_replica_selection<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ReplicaSelection>,
        {
            self.replica_selection = v.map(|x| x.into());
            self
        }

        /// Sets the value of [overrides][crate::model::autoscaling_config::AsymmetricAutoscalingOption::overrides].
        pub fn set_overrides<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>
        {
            self.overrides = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [overrides][crate::model::autoscaling_config::AsymmetricAutoscalingOption::overrides].
        pub fn set_or_clear_overrides<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>
        {
            self.overrides = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AsymmetricAutoscalingOption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AsymmetricAutoscalingOption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AsymmetricAutoscalingOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __replica_selection,
                __overrides,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AsymmetricAutoscalingOption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "replicaSelection" => Ok(__FieldTag::__replica_selection),
                                "replica_selection" => Ok(__FieldTag::__replica_selection),
                                "overrides" => Ok(__FieldTag::__overrides),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AsymmetricAutoscalingOption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AsymmetricAutoscalingOption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__replica_selection => {
                                if !fields.insert(__FieldTag::__replica_selection) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replica_selection",
                                    ));
                                }
                                result.replica_selection = map.next_value::<std::option::Option<crate::model::ReplicaSelection>>()?
                                    ;
                            }
                            __FieldTag::__overrides => {
                                if !fields.insert(__FieldTag::__overrides) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for overrides",
                                    ));
                                }
                                result.overrides = map.next_value::<std::option::Option<crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AsymmetricAutoscalingOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.replica_selection.is_some() {
                state.serialize_entry("replicaSelection", &self.replica_selection)?;
            }
            if self.overrides.is_some() {
                state.serialize_entry("overrides", &self.overrides)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AsymmetricAutoscalingOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AsymmetricAutoscalingOption");
            debug_struct.field("replica_selection", &self.replica_selection);
            debug_struct.field("overrides", &self.overrides);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AsymmetricAutoscalingOption].
    pub mod asymmetric_autoscaling_option {
        #[allow(unused_imports)]
        use super::*;

        /// Overrides the top-level autoscaling configuration for the replicas
        /// identified by `replica_selection`. All fields in this message are
        /// optional. Any unspecified fields will use the corresponding values from
        /// the top-level autoscaling configuration.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AutoscalingConfigOverrides {
            /// Optional. If specified, overrides the min/max limit in the top-level
            /// autoscaling configuration for the selected replicas.
            pub autoscaling_limits:
                std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>,

            /// Optional. If specified, overrides the autoscaling target
            /// high_priority_cpu_utilization_percent in the top-level autoscaling
            /// configuration for the selected replicas.
            pub autoscaling_target_high_priority_cpu_utilization_percent: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AutoscalingConfigOverrides {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [autoscaling_limits][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_limits].
            pub fn set_autoscaling_limits<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
            {
                self.autoscaling_limits = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [autoscaling_limits][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_limits].
            pub fn set_or_clear_autoscaling_limits<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::autoscaling_config::AutoscalingLimits>,
            {
                self.autoscaling_limits = v.map(|x| x.into());
                self
            }

            /// Sets the value of [autoscaling_target_high_priority_cpu_utilization_percent][crate::model::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides::autoscaling_target_high_priority_cpu_utilization_percent].
            pub fn set_autoscaling_target_high_priority_cpu_utilization_percent<
                T: std::convert::Into<i32>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.autoscaling_target_high_priority_cpu_utilization_percent = v.into();
                self
            }
        }

        impl wkt::message::Message for AutoscalingConfigOverrides {
            fn typename() -> &'static str {
                "type.googleapis.com/google.spanner.admin.instance.v1.AutoscalingConfig.AsymmetricAutoscalingOption.AutoscalingConfigOverrides"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AutoscalingConfigOverrides {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __autoscaling_limits,
                    __autoscaling_target_high_priority_cpu_utilization_percent,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AutoscalingConfigOverrides")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "autoscalingLimits" => Ok(__FieldTag::__autoscaling_limits),
                                    "autoscaling_limits" => Ok(__FieldTag::__autoscaling_limits),
                                    "autoscalingTargetHighPriorityCpuUtilizationPercent" => Ok(__FieldTag::__autoscaling_target_high_priority_cpu_utilization_percent),
                                    "autoscaling_target_high_priority_cpu_utilization_percent" => Ok(__FieldTag::__autoscaling_target_high_priority_cpu_utilization_percent),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AutoscalingConfigOverrides;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AutoscalingConfigOverrides")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__autoscaling_limits => {
                                    if !fields.insert(__FieldTag::__autoscaling_limits) {
                                        return std::result::Result::Err(A::Error::duplicate_field("multiple values for autoscaling_limits"));
                                    }
                                    result.autoscaling_limits = map.next_value::<std::option::Option<crate::model::autoscaling_config::AutoscalingLimits>>()?
                                        ;
                                },
                                __FieldTag::__autoscaling_target_high_priority_cpu_utilization_percent => {
                                    if !fields.insert(__FieldTag::__autoscaling_target_high_priority_cpu_utilization_percent) {
                                        return std::result::Result::Err(A::Error::duplicate_field("multiple values for autoscaling_target_high_priority_cpu_utilization_percent"));
                                    }
                                    struct __With( std::option::Option<i32> );
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.autoscaling_target_high_priority_cpu_utilization_percent = map.next_value::< __With >()?.0.unwrap_or_default();
                                },
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                },
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AutoscalingConfigOverrides {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.autoscaling_limits.is_some() {
                    state.serialize_entry("autoscalingLimits", &self.autoscaling_limits)?;
                }
                if !wkt::internal::is_default(
                    &self.autoscaling_target_high_priority_cpu_utilization_percent,
                ) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "autoscalingTargetHighPriorityCpuUtilizationPercent",
                        &__With(&self.autoscaling_target_high_priority_cpu_utilization_percent),
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for AutoscalingConfigOverrides {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("AutoscalingConfigOverrides");
                debug_struct.field("autoscaling_limits", &self.autoscaling_limits);
                debug_struct.field(
                    "autoscaling_target_high_priority_cpu_utilization_percent",
                    &self.autoscaling_target_high_priority_cpu_utilization_percent,
                );

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// An isolated set of Cloud Spanner resources on which databases can be hosted.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Required. A unique identifier for the instance, which cannot be changed
    /// after the instance is created. Values are of the form
    /// `projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]`. The final
    /// segment of the name must be between 2 and 64 characters in length.
    pub name: std::string::String,

    /// Required. The name of the instance's configuration. Values are of the form
    /// `projects/<project>/instanceConfigs/<configuration>`. See
    /// also [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    pub config: std::string::String,

    /// Required. The descriptive name for this instance as it appears in UIs.
    /// Must be unique per project and between 4 and 30 characters in length.
    pub display_name: std::string::String,

    /// The number of nodes allocated to this instance. At most, one of either
    /// `node_count` or `processing_units` should be present in the message.
    ///
    /// Users can set the `node_count` field to specify the target number of nodes
    /// allocated to the instance.
    ///
    /// If autoscaling is enabled, `node_count` is treated as an `OUTPUT_ONLY`
    /// field and reflects the current number of nodes allocated to the instance.
    ///
    /// This might be zero in API responses for instances that are not yet in the
    /// `READY` state.
    ///
    /// For more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub node_count: i32,

    /// The number of processing units allocated to this instance. At most, one of
    /// either `processing_units` or `node_count` should be present in the message.
    ///
    /// Users can set the `processing_units` field to specify the target number of
    /// processing units allocated to the instance.
    ///
    /// If autoscaling is enabled, `processing_units` is treated as an
    /// `OUTPUT_ONLY` field and reflects the current number of processing units
    /// allocated to the instance.
    ///
    /// This might be zero in API responses for instances that are not yet in the
    /// `READY` state.
    ///
    /// For more information, see
    /// [Compute capacity, nodes and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub processing_units: i32,

    /// Output only. Lists the compute capacity per ReplicaSelection. A replica
    /// selection identifies a set of replicas with common properties. Replicas
    /// identified by a ReplicaSelection are scaled with the same compute capacity.
    pub replica_compute_capacity: std::vec::Vec<crate::model::ReplicaComputeCapacity>,

    /// Optional. The autoscaling configuration. Autoscaling is enabled if this
    /// field is set. When autoscaling is enabled, node_count and processing_units
    /// are treated as OUTPUT_ONLY fields and reflect the current compute capacity
    /// allocated to the instance.
    pub autoscaling_config: std::option::Option<crate::model::AutoscalingConfig>,

    /// Output only. The current instance state. For
    /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance],
    /// the state must be either omitted or set to `CREATING`. For
    /// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance],
    /// the state must be either omitted or set to `READY`.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
    pub state: crate::model::instance::State,

    /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. Cloud Labels can be used to filter collections of
    /// resources. They can be used to control how resource metrics are aggregated.
    /// And they can be used as arguments to policy management rules (e.g. route,
    /// firewall, load balancing, etc.).
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform
    ///   to the regular expression `[a-z0-9_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    ///
    /// If you plan to use labels in your own code, please note that additional
    /// characters may be allowed in the future. And so you are advised to use an
    /// internal label representation, such as JSON, which doesn't rely upon
    /// specific characters being disallowed.  For example, representing labels
    /// as the string:  name + "_" + value  would prove problematic if we were to
    /// allow "_" in a future release.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The `InstanceType` of the current instance.
    pub instance_type: crate::model::instance::InstanceType,

    /// Deprecated. This field is not populated.
    pub endpoint_uris: std::vec::Vec<std::string::String>,

    /// Output only. The time at which the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the instance was most recently updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Free instance metadata. Only populated for free instances.
    pub free_instance_metadata: std::option::Option<crate::model::FreeInstanceMetadata>,

    /// Optional. The `Edition` of the current instance.
    pub edition: crate::model::instance::Edition,

    /// Optional. Controls the default backup schedule behavior for new databases
    /// within the instance. By default, a backup schedule is created automatically
    /// when a new database is created in a new instance.
    ///
    /// Note that the `AUTOMATIC` value isn't permitted for free instances,
    /// as backups and backup schedules aren't supported for free instances.
    ///
    /// In the `GetInstance` or `ListInstances` response, if the value of
    /// `default_backup_schedule_type` isn't set, or set to `NONE`, Spanner doesn't
    /// create a default backup schedule for new databases in the instance.
    pub default_backup_schedule_type: crate::model::instance::DefaultBackupScheduleType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Instance::config].
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::Instance::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [processing_units][crate::model::Instance::processing_units].
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.processing_units = v.into();
        self
    }

    /// Sets the value of [replica_compute_capacity][crate::model::Instance::replica_compute_capacity].
    pub fn set_replica_compute_capacity<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaComputeCapacity>,
    {
        use std::iter::Iterator;
        self.replica_compute_capacity = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autoscaling_config][crate::model::Instance::autoscaling_config].
    pub fn set_autoscaling_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_config][crate::model::Instance::autoscaling_config].
    pub fn set_or_clear_autoscaling_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [instance_type][crate::model::Instance::instance_type].
    pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [endpoint_uris][crate::model::Instance::endpoint_uris].
    pub fn set_endpoint_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoint_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [free_instance_metadata][crate::model::Instance::free_instance_metadata].
    pub fn set_free_instance_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FreeInstanceMetadata>,
    {
        self.free_instance_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [free_instance_metadata][crate::model::Instance::free_instance_metadata].
    pub fn set_or_clear_free_instance_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FreeInstanceMetadata>,
    {
        self.free_instance_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [edition][crate::model::Instance::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::instance::Edition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [default_backup_schedule_type][crate::model::Instance::default_backup_schedule_type].
    pub fn set_default_backup_schedule_type<
        T: std::convert::Into<crate::model::instance::DefaultBackupScheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_backup_schedule_type = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.Instance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __config,
            __display_name,
            __node_count,
            __processing_units,
            __replica_compute_capacity,
            __autoscaling_config,
            __state,
            __labels,
            __instance_type,
            __endpoint_uris,
            __create_time,
            __update_time,
            __free_instance_metadata,
            __edition,
            __default_backup_schedule_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "config" => Ok(__FieldTag::__config),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "processingUnits" => Ok(__FieldTag::__processing_units),
                            "processing_units" => Ok(__FieldTag::__processing_units),
                            "replicaComputeCapacity" => Ok(__FieldTag::__replica_compute_capacity),
                            "replica_compute_capacity" => {
                                Ok(__FieldTag::__replica_compute_capacity)
                            }
                            "autoscalingConfig" => Ok(__FieldTag::__autoscaling_config),
                            "autoscaling_config" => Ok(__FieldTag::__autoscaling_config),
                            "state" => Ok(__FieldTag::__state),
                            "labels" => Ok(__FieldTag::__labels),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "endpointUris" => Ok(__FieldTag::__endpoint_uris),
                            "endpoint_uris" => Ok(__FieldTag::__endpoint_uris),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "freeInstanceMetadata" => Ok(__FieldTag::__free_instance_metadata),
                            "free_instance_metadata" => Ok(__FieldTag::__free_instance_metadata),
                            "edition" => Ok(__FieldTag::__edition),
                            "defaultBackupScheduleType" => {
                                Ok(__FieldTag::__default_backup_schedule_type)
                            }
                            "default_backup_schedule_type" => {
                                Ok(__FieldTag::__default_backup_schedule_type)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__processing_units => {
                            if !fields.insert(__FieldTag::__processing_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_units",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.processing_units =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__replica_compute_capacity => {
                            if !fields.insert(__FieldTag::__replica_compute_capacity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_compute_capacity",
                                ));
                            }
                            result.replica_compute_capacity = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ReplicaComputeCapacity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoscaling_config => {
                            if !fields.insert(__FieldTag::__autoscaling_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling_config",
                                ));
                            }
                            result.autoscaling_config = map
                                .next_value::<std::option::Option<crate::model::AutoscalingConfig>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::instance::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map.next_value::<std::option::Option<crate::model::instance::InstanceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__endpoint_uris => {
                            if !fields.insert(__FieldTag::__endpoint_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint_uris",
                                ));
                            }
                            result.endpoint_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__free_instance_metadata => {
                            if !fields.insert(__FieldTag::__free_instance_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_instance_metadata",
                                ));
                            }
                            result.free_instance_metadata = map.next_value::<std::option::Option<crate::model::FreeInstanceMetadata>>()?
                                ;
                        }
                        __FieldTag::__edition => {
                            if !fields.insert(__FieldTag::__edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for edition",
                                ));
                            }
                            result.edition = map
                                .next_value::<std::option::Option<crate::model::instance::Edition>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_backup_schedule_type => {
                            if !fields.insert(__FieldTag::__default_backup_schedule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_backup_schedule_type",
                                ));
                            }
                            result.default_backup_schedule_type = map
                                .next_value::<std::option::Option<
                                    crate::model::instance::DefaultBackupScheduleType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.config.is_empty() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(&self.node_count))?;
        }
        if !wkt::internal::is_default(&self.processing_units) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("processingUnits", &__With(&self.processing_units))?;
        }
        if !self.replica_compute_capacity.is_empty() {
            state.serialize_entry("replicaComputeCapacity", &self.replica_compute_capacity)?;
        }
        if self.autoscaling_config.is_some() {
            state.serialize_entry("autoscalingConfig", &self.autoscaling_config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.instance_type) {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if !self.endpoint_uris.is_empty() {
            state.serialize_entry("endpointUris", &self.endpoint_uris)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.free_instance_metadata.is_some() {
            state.serialize_entry("freeInstanceMetadata", &self.free_instance_metadata)?;
        }
        if !wkt::internal::is_default(&self.edition) {
            state.serialize_entry("edition", &self.edition)?;
        }
        if !wkt::internal::is_default(&self.default_backup_schedule_type) {
            state.serialize_entry(
                "defaultBackupScheduleType",
                &self.default_backup_schedule_type,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Instance");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("processing_units", &self.processing_units);
        debug_struct.field("replica_compute_capacity", &self.replica_compute_capacity);
        debug_struct.field("autoscaling_config", &self.autoscaling_config);
        debug_struct.field("state", &self.state);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("instance_type", &self.instance_type);
        debug_struct.field("endpoint_uris", &self.endpoint_uris);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("free_instance_metadata", &self.free_instance_metadata);
        debug_struct.field("edition", &self.edition);
        debug_struct.field(
            "default_backup_schedule_type",
            &self.default_backup_schedule_type,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The instance is still being created. Resources may not be
        /// available yet, and operations such as database creation may not
        /// work.
        Creating,
        /// The instance is fully created and ready to do work such as
        /// creating databases.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.spanner.admin.instance.v1.Instance.State",
            ))
        }
    }

    /// The type of this instance. The type can be used to distinguish product
    /// variants, that can affect aspects like: usage restrictions, quotas and
    /// billing. Currently this is used to distinguish FREE_INSTANCE vs PROVISIONED
    /// instances.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceType {
        /// Not specified.
        Unspecified,
        /// Provisioned instances have dedicated resources, standard usage limits and
        /// support.
        Provisioned,
        /// Free instances provide no guarantee for dedicated resources,
        /// [node_count, processing_units] should be 0. They come
        /// with stricter usage limits and limited support.
        FreeInstance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceType::value] or
        /// [InstanceType::name].
        UnknownValue(instance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioned => std::option::Option::Some(1),
                Self::FreeInstance => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_TYPE_UNSPECIFIED"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::FreeInstance => std::option::Option::Some("FREE_INSTANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioned,
                2 => Self::FreeInstance,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONED" => Self::Provisioned,
                "FREE_INSTANCE" => Self::FreeInstance,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioned => serializer.serialize_i32(1),
                Self::FreeInstance => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceType>::new(
                ".google.spanner.admin.instance.v1.Instance.InstanceType",
            ))
        }
    }

    /// The edition selected for this instance. Different editions provide
    /// different capabilities at different price points.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Edition {
        /// Edition not specified.
        Unspecified,
        /// Standard edition.
        Standard,
        /// Enterprise edition.
        Enterprise,
        /// Enterprise Plus edition.
        EnterprisePlus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Edition::value] or
        /// [Edition::name].
        UnknownValue(edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Edition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Enterprise => std::option::Option::Some(2),
                Self::EnterprisePlus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EDITION_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::EnterprisePlus => std::option::Option::Some("ENTERPRISE_PLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Edition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Enterprise,
                3 => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Edition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "ENTERPRISE" => Self::Enterprise,
                "ENTERPRISE_PLUS" => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Edition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::EnterprisePlus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Edition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Edition>::new(
                ".google.spanner.admin.instance.v1.Instance.Edition",
            ))
        }
    }

    /// Indicates the
    /// [default backup
    /// schedule](https://cloud.google.com/spanner/docs/backup#default-backup-schedules)
    /// behavior for new databases within the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DefaultBackupScheduleType {
        /// Not specified.
        Unspecified,
        /// A default backup schedule isn't created automatically when a new database
        /// is created in the instance.
        None,
        /// A default backup schedule is created automatically when a new database
        /// is created in the instance. The default backup schedule creates a full
        /// backup every 24 hours. These full backups are retained for 7 days.
        /// You can edit or delete the default backup schedule once it's created.
        Automatic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DefaultBackupScheduleType::value] or
        /// [DefaultBackupScheduleType::name].
        UnknownValue(default_backup_schedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod default_backup_schedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DefaultBackupScheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Automatic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED")
                }
                Self::None => std::option::Option::Some("NONE"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DefaultBackupScheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DefaultBackupScheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DefaultBackupScheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Automatic,
                _ => Self::UnknownValue(default_backup_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DefaultBackupScheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "AUTOMATIC" => Self::Automatic,
                _ => Self::UnknownValue(default_backup_schedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DefaultBackupScheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Automatic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DefaultBackupScheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<DefaultBackupScheduleType>::new(
                    ".google.spanner.admin.instance.v1.Instance.DefaultBackupScheduleType",
                ),
            )
        }
    }
}

/// The request for
/// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigsRequest {
    /// Required. The name of the project for which a list of supported instance
    /// configurations is requested. Values are of the form
    /// `projects/<project>`.
    pub parent: std::string::String,

    /// Number of instance configurations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]
    /// from a previous
    /// [ListInstanceConfigsResponse][google.spanner.admin.instance.v1.ListInstanceConfigsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstanceConfigsResponse]: crate::model::ListInstanceConfigsResponse
    /// [google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]: crate::model::ListInstanceConfigsResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstanceConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstanceConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstanceConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstanceConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstanceConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstanceConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstanceConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstanceConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstanceConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigsResponse {
    /// The list of requested instance configurations.
    pub instance_configs: std::vec::Vec<crate::model::InstanceConfig>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]
    /// call to fetch more of the matching instance configurations.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_configs][crate::model::ListInstanceConfigsResponse::instance_configs].
    pub fn set_instance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceConfig>,
    {
        use std::iter::Iterator;
        self.instance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstanceConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstanceConfigsResponse {
    type PageItem = crate::model::InstanceConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instance_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstanceConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstanceConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceConfigs" => Ok(__FieldTag::__instance_configs),
                            "instance_configs" => Ok(__FieldTag::__instance_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstanceConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstanceConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_configs => {
                            if !fields.insert(__FieldTag::__instance_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_configs",
                                ));
                            }
                            result.instance_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InstanceConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstanceConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_configs.is_empty() {
            state.serialize_entry("instanceConfigs", &self.instance_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstanceConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigsResponse");
        debug_struct.field("instance_configs", &self.instance_configs);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [GetInstanceConfigRequest][google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig]: crate::client::InstanceAdmin::get_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceConfigRequest {
    /// Required. The name of the requested instance configuration. Values are of
    /// the form `projects/<project>/instanceConfigs/<config>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstanceConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstanceConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstanceConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstanceConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstanceConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstanceConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInstanceConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceConfigRequest {
    /// Required. The name of the project in which to create the instance
    /// configuration. Values are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// Required. The ID of the instance configuration to create. Valid identifiers
    /// are of the form `custom-[-a-z0-9]*[a-z0-9]` and must be between 2 and 64
    /// characters in length. The `custom-` prefix is required to avoid name
    /// conflicts with Google-managed configurations.
    pub instance_config_id: std::string::String,

    /// Required. The `InstanceConfig` proto of the configuration to create.
    /// `instance_config.name` must be
    /// `<parent>/instanceConfigs/<instance_config_id>`.
    /// `instance_config.base_config` must be a Google-managed configuration name,
    /// e.g. \<parent\>/instanceConfigs/us-east1, \<parent\>/instanceConfigs/nam3.
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_config_id][crate::model::CreateInstanceConfigRequest::instance_config_id].
    pub fn set_instance_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config_id = v.into();
        self
    }

    /// Sets the value of [instance_config][crate::model::CreateInstanceConfigRequest::instance_config].
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::CreateInstanceConfigRequest::instance_config].
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateInstanceConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __instance_config_id,
            __instance_config,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "instanceConfigId" => Ok(__FieldTag::__instance_config_id),
                            "instance_config_id" => Ok(__FieldTag::__instance_config_id),
                            "instanceConfig" => Ok(__FieldTag::__instance_config),
                            "instance_config" => Ok(__FieldTag::__instance_config),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_config_id => {
                            if !fields.insert(__FieldTag::__instance_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_config_id",
                                ));
                            }
                            result.instance_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_config => {
                            if !fields.insert(__FieldTag::__instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_config",
                                ));
                            }
                            result.instance_config = map
                                .next_value::<std::option::Option<crate::model::InstanceConfig>>(
                                )?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.instance_config_id.is_empty() {
            state.serialize_entry("instanceConfigId", &self.instance_config_id)?;
        }
        if self.instance_config.is_some() {
            state.serialize_entry("instanceConfig", &self.instance_config)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("instance_config_id", &self.instance_config_id);
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("validate_only", &self.validate_only);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceConfigRequest {
    /// Required. The user instance configuration to update, which must always
    /// include the instance configuration name. Otherwise, only fields mentioned
    /// in
    /// [update_mask][google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask]
    /// need be included. To prevent conflicts of concurrent updates,
    /// [etag][google.spanner.admin.instance.v1.InstanceConfig.reconciling] can
    /// be used.
    ///
    /// [google.spanner.admin.instance.v1.InstanceConfig.reconciling]: crate::model::InstanceConfig::reconciling
    /// [google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask]: crate::model::UpdateInstanceConfigRequest::update_mask
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// Required. A mask specifying which fields in
    /// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] should be
    /// updated. The field mask must always be specified; this prevents any future
    /// fields in [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig]
    /// from being erased accidentally by clients that do not know about them. Only
    /// display_name and labels can be updated.
    ///
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::UpdateInstanceConfigRequest::instance_config].
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::UpdateInstanceConfigRequest::instance_config].
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInstanceConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_config,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceConfig" => Ok(__FieldTag::__instance_config),
                            "instance_config" => Ok(__FieldTag::__instance_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_config => {
                            if !fields.insert(__FieldTag::__instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_config",
                                ));
                            }
                            result.instance_config = map
                                .next_value::<std::option::Option<crate::model::InstanceConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_config.is_some() {
            state.serialize_entry("instanceConfig", &self.instance_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceConfigRequest");
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [DeleteInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstanceConfig]: crate::client::InstanceAdmin::delete_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceConfigRequest {
    /// Required. The name of the instance configuration to be deleted.
    /// Values are of the form
    /// `projects/<project>/instanceConfigs/<instance_config>`
    pub name: std::string::String,

    /// Used for optimistic concurrency control as a way to help prevent
    /// simultaneous deletes of an instance configuration from overwriting each
    /// other. If not empty, the API
    /// only deletes the instance configuration when the etag provided matches the
    /// current status of the requested instance configuration. Otherwise, deletes
    /// the instance configuration without checking the current status of the
    /// requested instance configuration.
    pub etag: std::string::String,

    /// An option to validate, but not actually execute, a request,
    /// and provide the same response.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstanceConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteInstanceConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstanceConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInstanceConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInstanceConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInstanceConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInstanceConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInstanceConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInstanceConfigRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("validate_only", &self.validate_only);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigOperationsRequest {
    /// Required. The project of the instance configuration operations.
    /// Values are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// An expression that filters the list of returned operations.
    ///
    /// A filter expression consists of a field name, a
    /// comparison operator, and a value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the Operation are eligible for filtering:
    ///
    /// * `name` - The name of the long-running operation
    /// * `done` - False if the operation is in progress, else true.
    /// * `metadata.@type` - the type of metadata. For example, the type string
    ///   for
    ///   [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata]
    ///   is
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata`.
    /// * `metadata.<field_name>` - any field in metadata.value.
    ///   `metadata.@type` must be specified first, if filtering on metadata
    ///   fields.
    /// * `error` - Error associated with the long-running operation.
    /// * `response.@type` - the type of response.
    /// * `response.<field_name>` - any field in response.value.
    ///
    /// You can combine multiple expressions by enclosing each expression in
    /// parentheses. By default, expressions are combined with AND logic. However,
    /// you can specify AND, OR, and NOT logic explicitly.
    ///
    /// Here are a few examples:
    ///
    /// * `done:true` - The operation is complete.
    /// * `(metadata.@type=` \
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata)
    ///   AND` \
    ///   `(metadata.instance_config.name:custom-config) AND` \
    ///   `(metadata.progress.start_time < \"2021-03-28T14:50:00Z\") AND` \
    ///   `(error:*)` - Return operations where:
    ///   * The operation's metadata type is
    ///     [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
    ///   * The instance configuration name contains "custom-config".
    ///   * The operation started before 2021-03-28T14:50:00Z.
    ///   * The operation resulted in an error.
    ///
    /// [google.spanner.admin.instance.v1.CreateInstanceConfigMetadata]: crate::model::CreateInstanceConfigMetadata
    pub filter: std::string::String,

    /// Number of operations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token]
    /// from a previous
    /// [ListInstanceConfigOperationsResponse][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse]
    /// to the same `parent` and with the same `filter`.
    ///
    /// [google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse]: crate::model::ListInstanceConfigOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token]: crate::model::ListInstanceConfigOperationsResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstanceConfigOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstanceConfigOperationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstanceConfigOperationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstanceConfigOperationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstanceConfigOperationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstanceConfigOperationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstanceConfigOperationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstanceConfigOperationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstanceConfigOperationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstanceConfigOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigOperationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstanceConfigOperationsResponse {
    /// The list of matching instance configuration long-running operations. Each
    /// operation's name will be
    /// prefixed by the name of the instance configuration. The operation's
    /// metadata field type
    /// `metadata.type_url` describes the type of the metadata.
    pub operations: std::vec::Vec<longrunning::model::Operation>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]
    /// call to fetch more of the matching metadata.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]: crate::client::InstanceAdmin::list_instance_config_operations
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstanceConfigOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::ListInstanceConfigOperationsResponse::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<longrunning::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstanceConfigOperationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstanceConfigOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstanceConfigOperationsResponse {
    type PageItem = longrunning::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstanceConfigOperationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstanceConfigOperationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operations" => Ok(__FieldTag::__operations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstanceConfigOperationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstanceConfigOperationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<longrunning::model::Operation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstanceConfigOperationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstanceConfigOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigOperationsResponse");
        debug_struct.field("operations", &self.operations);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [GetInstance][google.spanner.admin.instance.v1.InstanceAdmin.GetInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstance]: crate::client::InstanceAdmin::get_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the requested instance. Values are of the form
    /// `projects/<project>/instances/<instance>`.
    pub name: std::string::String,

    /// If field_mask is present, specifies the subset of
    /// [Instance][google.spanner.admin.instance.v1.Instance] fields that should be
    /// returned. If absent, all
    /// [Instance][google.spanner.admin.instance.v1.Instance] fields are returned.
    ///
    /// [google.spanner.admin.instance.v1.Instance]: crate::model::Instance
    pub field_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::GetInstanceRequest::field_mask].
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::GetInstanceRequest::field_mask].
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __field_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "fieldMask" => Ok(__FieldTag::__field_mask),
                            "field_mask" => Ok(__FieldTag::__field_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__field_mask => {
                            if !fields.insert(__FieldTag::__field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_mask",
                                ));
                            }
                            result.field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.field_mask.is_some() {
            state.serialize_entry("fieldMask", &self.field_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInstanceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("field_mask", &self.field_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The name of the project in which to create the instance. Values
    /// are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// Required. The ID of the instance to create.  Valid identifiers are of the
    /// form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64 characters in
    /// length.
    pub instance_id: std::string::String,

    /// Required. The instance to create.  The name may be omitted, but if
    /// specified must be `<parent>/instances/<instance_id>`.
    pub instance: std::option::Option<crate::model::Instance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __instance_id,
            __instance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "instance" => Ok(__FieldTag::__instance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("instance_id", &self.instance_id);
        debug_struct.field("instance", &self.instance);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The name of the project for which a list of instances is
    /// requested. Values are of the form `projects/<project>`.
    pub parent: std::string::String,

    /// Number of instances to be returned in the response. If 0 or less, defaults
    /// to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token]
    /// from a previous
    /// [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesResponse]: crate::model::ListInstancesResponse
    /// [google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token]: crate::model::ListInstancesResponse::next_page_token
    pub page_token: std::string::String,

    /// An expression for filtering the results of the request. Filter rules are
    /// case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `display_name`
    /// * `labels.key` where key is the name of a label
    ///
    /// Some examples of using filters are:
    ///
    /// * `name:*` --> The instance has a name.
    /// * `name:Howl` --> The instance's name contains the string "howl".
    /// * `name:HOWL` --> Equivalent to above.
    /// * `NAME:howl` --> Equivalent to above.
    /// * `labels.env:*` --> The instance has the label "env".
    /// * `labels.env:dev` --> The instance has the label "env" and the value of
    ///   the label contains the string "dev".
    /// * `name:howl labels.env:dev` --> The instance's name contains "howl" and
    ///   it has the label "env" with its value
    ///   containing "dev".
    pub filter: std::string::String,

    /// Deadline used while retrieving metadata for instances.
    /// Instances whose metadata cannot be retrieved within this deadline will be
    /// added to
    /// [unreachable][google.spanner.admin.instance.v1.ListInstancesResponse.unreachable]
    /// in
    /// [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesResponse]: crate::model::ListInstancesResponse
    /// [google.spanner.admin.instance.v1.ListInstancesResponse.unreachable]: crate::model::ListInstancesResponse::unreachable
    pub instance_deadline: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [instance_deadline][crate::model::ListInstancesRequest::instance_deadline].
    pub fn set_instance_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_deadline][crate::model::ListInstancesRequest::instance_deadline].
    pub fn set_or_clear_instance_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_deadline = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __instance_deadline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "instanceDeadline" => Ok(__FieldTag::__instance_deadline),
                            "instance_deadline" => Ok(__FieldTag::__instance_deadline),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_deadline => {
                            if !fields.insert(__FieldTag::__instance_deadline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_deadline",
                                ));
                            }
                            result.instance_deadline =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.instance_deadline.is_some() {
            state.serialize_entry("instanceDeadline", &self.instance_deadline)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("instance_deadline", &self.instance_deadline);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of requested instances.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]
    /// call to fetch more of the matching instances.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]: crate::client::InstanceAdmin::list_instances
    pub next_page_token: std::string::String,

    /// The list of unreachable instances.
    /// It includes the names of instances whose metadata could not be retrieved
    /// within
    /// [instance_deadline][google.spanner.admin.instance.v1.ListInstancesRequest.instance_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancesRequest.instance_deadline]: crate::model::ListInstancesRequest::instance_deadline
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Instance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancesResponse");
        debug_struct.field("instances", &self.instances);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. The instance to update, which must always include the instance
    /// name.  Otherwise, only fields mentioned in
    /// [field_mask][google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask]
    /// need be included.
    ///
    /// [google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask]: crate::model::UpdateInstanceRequest::field_mask
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. A mask specifying which fields in
    /// [Instance][google.spanner.admin.instance.v1.Instance] should be updated.
    /// The field mask must always be specified; this prevents any future fields in
    /// [Instance][google.spanner.admin.instance.v1.Instance] from being erased
    /// accidentally by clients that do not know about them.
    ///
    /// [google.spanner.admin.instance.v1.Instance]: crate::model::Instance
    pub field_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_mask][crate::model::UpdateInstanceRequest::field_mask].
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::UpdateInstanceRequest::field_mask].
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __field_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "fieldMask" => Ok(__FieldTag::__field_mask),
                            "field_mask" => Ok(__FieldTag::__field_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__field_mask => {
                            if !fields.insert(__FieldTag::__field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_mask",
                                ));
                            }
                            result.field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.field_mask.is_some() {
            state.serialize_entry("fieldMask", &self.field_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("field_mask", &self.field_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [DeleteInstance][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance]: crate::client::InstanceAdmin::delete_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the instance to be deleted. Values are of the form
    /// `projects/<project>/instances/<instance>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInstanceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata type for the operation returned by
/// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceMetadata {
    /// The instance being created.
    pub instance: std::option::Option<crate::model::Instance>,

    /// The time at which the
    /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]: crate::client::InstanceAdmin::create_instance
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The expected fulfillment period of this create operation.
    pub expected_fulfillment_period: crate::model::FulfillmentPeriod,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::CreateInstanceMetadata::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceMetadata::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::CreateInstanceMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CreateInstanceMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstanceMetadata::cancel_time].
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::CreateInstanceMetadata::cancel_time].
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateInstanceMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateInstanceMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expected_fulfillment_period][crate::model::CreateInstanceMetadata::expected_fulfillment_period].
    pub fn set_expected_fulfillment_period<
        T: std::convert::Into<crate::model::FulfillmentPeriod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_fulfillment_period = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __start_time,
            __cancel_time,
            __end_time,
            __expected_fulfillment_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "cancelTime" => Ok(__FieldTag::__cancel_time),
                            "cancel_time" => Ok(__FieldTag::__cancel_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "expectedFulfillmentPeriod" => {
                                Ok(__FieldTag::__expected_fulfillment_period)
                            }
                            "expected_fulfillment_period" => {
                                Ok(__FieldTag::__expected_fulfillment_period)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cancel_time => {
                            if !fields.insert(__FieldTag::__cancel_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_time",
                                ));
                            }
                            result.cancel_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expected_fulfillment_period => {
                            if !fields.insert(__FieldTag::__expected_fulfillment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expected_fulfillment_period",
                                ));
                            }
                            result.expected_fulfillment_period = map
                                .next_value::<std::option::Option<crate::model::FulfillmentPeriod>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.cancel_time.is_some() {
            state.serialize_entry("cancelTime", &self.cancel_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.expected_fulfillment_period) {
            state.serialize_entry(
                "expectedFulfillmentPeriod",
                &self.expected_fulfillment_period,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceMetadata");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field(
            "expected_fulfillment_period",
            &self.expected_fulfillment_period,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceMetadata {
    /// The desired end state of the update.
    pub instance: std::option::Option<crate::model::Instance>,

    /// The time at which
    /// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]: crate::client::InstanceAdmin::update_instance
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The expected fulfillment period of this update operation.
    pub expected_fulfillment_period: crate::model::FulfillmentPeriod,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceMetadata::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceMetadata::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateInstanceMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpdateInstanceMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstanceMetadata::cancel_time].
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::UpdateInstanceMetadata::cancel_time].
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateInstanceMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpdateInstanceMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expected_fulfillment_period][crate::model::UpdateInstanceMetadata::expected_fulfillment_period].
    pub fn set_expected_fulfillment_period<
        T: std::convert::Into<crate::model::FulfillmentPeriod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_fulfillment_period = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __start_time,
            __cancel_time,
            __end_time,
            __expected_fulfillment_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "cancelTime" => Ok(__FieldTag::__cancel_time),
                            "cancel_time" => Ok(__FieldTag::__cancel_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "expectedFulfillmentPeriod" => {
                                Ok(__FieldTag::__expected_fulfillment_period)
                            }
                            "expected_fulfillment_period" => {
                                Ok(__FieldTag::__expected_fulfillment_period)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cancel_time => {
                            if !fields.insert(__FieldTag::__cancel_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_time",
                                ));
                            }
                            result.cancel_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expected_fulfillment_period => {
                            if !fields.insert(__FieldTag::__expected_fulfillment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expected_fulfillment_period",
                                ));
                            }
                            result.expected_fulfillment_period = map
                                .next_value::<std::option::Option<crate::model::FulfillmentPeriod>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.cancel_time.is_some() {
            state.serialize_entry("cancelTime", &self.cancel_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.expected_fulfillment_period) {
            state.serialize_entry(
                "expectedFulfillmentPeriod",
                &self.expected_fulfillment_period,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceMetadata");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field(
            "expected_fulfillment_period",
            &self.expected_fulfillment_period,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Free instance specific metadata that is kept even after an instance has been
/// upgraded for tracking purposes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FreeInstanceMetadata {
    /// Output only. Timestamp after which the instance will either be upgraded or
    /// scheduled for deletion after a grace period. ExpireBehavior is used to
    /// choose between upgrading or scheduling the free instance for deletion. This
    /// timestamp is set during the creation of a free instance.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. If present, the timestamp at which the free instance was
    /// upgraded to a provisioned instance.
    pub upgrade_time: std::option::Option<wkt::Timestamp>,

    /// Specifies the expiration behavior of a free instance. The default of
    /// ExpireBehavior is `REMOVE_AFTER_GRACE_PERIOD`. This can be modified during
    /// or after creation, and before expiration.
    pub expire_behavior: crate::model::free_instance_metadata::ExpireBehavior,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FreeInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expire_time][crate::model::FreeInstanceMetadata::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::FreeInstanceMetadata::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upgrade_time][crate::model::FreeInstanceMetadata::upgrade_time].
    pub fn set_upgrade_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.upgrade_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_time][crate::model::FreeInstanceMetadata::upgrade_time].
    pub fn set_or_clear_upgrade_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.upgrade_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_behavior][crate::model::FreeInstanceMetadata::expire_behavior].
    pub fn set_expire_behavior<
        T: std::convert::Into<crate::model::free_instance_metadata::ExpireBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expire_behavior = v.into();
        self
    }
}

impl wkt::message::Message for FreeInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.FreeInstanceMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FreeInstanceMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expire_time,
            __upgrade_time,
            __expire_behavior,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FreeInstanceMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "upgradeTime" => Ok(__FieldTag::__upgrade_time),
                            "upgrade_time" => Ok(__FieldTag::__upgrade_time),
                            "expireBehavior" => Ok(__FieldTag::__expire_behavior),
                            "expire_behavior" => Ok(__FieldTag::__expire_behavior),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FreeInstanceMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FreeInstanceMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__upgrade_time => {
                            if !fields.insert(__FieldTag::__upgrade_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_time",
                                ));
                            }
                            result.upgrade_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_behavior => {
                            if !fields.insert(__FieldTag::__expire_behavior) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_behavior",
                                ));
                            }
                            result.expire_behavior = map
                                .next_value::<std::option::Option<
                                    crate::model::free_instance_metadata::ExpireBehavior,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FreeInstanceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.upgrade_time.is_some() {
            state.serialize_entry("upgradeTime", &self.upgrade_time)?;
        }
        if !wkt::internal::is_default(&self.expire_behavior) {
            state.serialize_entry("expireBehavior", &self.expire_behavior)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FreeInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FreeInstanceMetadata");
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("upgrade_time", &self.upgrade_time);
        debug_struct.field("expire_behavior", &self.expire_behavior);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FreeInstanceMetadata].
pub mod free_instance_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Allows users to change behavior when a free instance expires.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExpireBehavior {
        /// Not specified.
        Unspecified,
        /// When the free instance expires, upgrade the instance to a provisioned
        /// instance.
        FreeToProvisioned,
        /// When the free instance expires, disable the instance, and delete it
        /// after the grace period passes if it has not been upgraded.
        RemoveAfterGracePeriod,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExpireBehavior::value] or
        /// [ExpireBehavior::name].
        UnknownValue(expire_behavior::UnknownValue),
    }

    #[doc(hidden)]
    pub mod expire_behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExpireBehavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FreeToProvisioned => std::option::Option::Some(1),
                Self::RemoveAfterGracePeriod => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXPIRE_BEHAVIOR_UNSPECIFIED"),
                Self::FreeToProvisioned => std::option::Option::Some("FREE_TO_PROVISIONED"),
                Self::RemoveAfterGracePeriod => {
                    std::option::Option::Some("REMOVE_AFTER_GRACE_PERIOD")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExpireBehavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExpireBehavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExpireBehavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FreeToProvisioned,
                2 => Self::RemoveAfterGracePeriod,
                _ => Self::UnknownValue(expire_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExpireBehavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXPIRE_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "FREE_TO_PROVISIONED" => Self::FreeToProvisioned,
                "REMOVE_AFTER_GRACE_PERIOD" => Self::RemoveAfterGracePeriod,
                _ => Self::UnknownValue(expire_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExpireBehavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FreeToProvisioned => serializer.serialize_i32(1),
                Self::RemoveAfterGracePeriod => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExpireBehavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExpireBehavior>::new(
                ".google.spanner.admin.instance.v1.FreeInstanceMetadata.ExpireBehavior",
            ))
        }
    }
}

/// Metadata type for the operation returned by
/// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceConfigMetadata {
    /// The target instance configuration end state.
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// The progress of the
    /// [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]
    /// operation.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]: crate::client::InstanceAdmin::create_instance_config
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceConfigMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::CreateInstanceConfigMetadata::instance_config].
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::CreateInstanceConfigMetadata::instance_config].
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::CreateInstanceConfigMetadata::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::CreateInstanceConfigMetadata::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstanceConfigMetadata::cancel_time].
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::CreateInstanceConfigMetadata::cancel_time].
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstanceConfigMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceConfigMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_config,
            __progress,
            __cancel_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceConfigMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceConfig" => Ok(__FieldTag::__instance_config),
                            "instance_config" => Ok(__FieldTag::__instance_config),
                            "progress" => Ok(__FieldTag::__progress),
                            "cancelTime" => Ok(__FieldTag::__cancel_time),
                            "cancel_time" => Ok(__FieldTag::__cancel_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceConfigMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceConfigMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_config => {
                            if !fields.insert(__FieldTag::__instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_config",
                                ));
                            }
                            result.instance_config = map
                                .next_value::<std::option::Option<crate::model::InstanceConfig>>(
                                )?;
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::__cancel_time => {
                            if !fields.insert(__FieldTag::__cancel_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_time",
                                ));
                            }
                            result.cancel_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceConfigMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_config.is_some() {
            state.serialize_entry("instanceConfig", &self.instance_config)?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if self.cancel_time.is_some() {
            state.serialize_entry("cancelTime", &self.cancel_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateInstanceConfigMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceConfigMetadata");
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cancel_time", &self.cancel_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceConfigMetadata {
    /// The desired instance configuration after updating.
    pub instance_config: std::option::Option<crate::model::InstanceConfig>,

    /// The progress of the
    /// [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]
    /// operation.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]: crate::client::InstanceAdmin::update_instance_config
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceConfigMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_config][crate::model::UpdateInstanceConfigMetadata::instance_config].
    pub fn set_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_config][crate::model::UpdateInstanceConfigMetadata::instance_config].
    pub fn set_or_clear_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceConfig>,
    {
        self.instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::UpdateInstanceConfigMetadata::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::UpdateInstanceConfigMetadata::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstanceConfigMetadata::cancel_time].
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::UpdateInstanceConfigMetadata::cancel_time].
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstanceConfigMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceConfigMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_config,
            __progress,
            __cancel_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceConfigMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceConfig" => Ok(__FieldTag::__instance_config),
                            "instance_config" => Ok(__FieldTag::__instance_config),
                            "progress" => Ok(__FieldTag::__progress),
                            "cancelTime" => Ok(__FieldTag::__cancel_time),
                            "cancel_time" => Ok(__FieldTag::__cancel_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceConfigMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceConfigMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_config => {
                            if !fields.insert(__FieldTag::__instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_config",
                                ));
                            }
                            result.instance_config = map
                                .next_value::<std::option::Option<crate::model::InstanceConfig>>(
                                )?;
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::__cancel_time => {
                            if !fields.insert(__FieldTag::__cancel_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_time",
                                ));
                            }
                            result.cancel_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceConfigMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_config.is_some() {
            state.serialize_entry("instanceConfig", &self.instance_config)?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if self.cancel_time.is_some() {
            state.serialize_entry("cancelTime", &self.cancel_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateInstanceConfigMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceConfigMetadata");
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cancel_time", &self.cancel_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An isolated set of Cloud Spanner resources that databases can define
/// placements on.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancePartition {
    /// Required. A unique identifier for the instance partition. Values are of the
    /// form
    /// `projects/<project>/instances/<instance>/instancePartitions/[a-z][-a-z0-9]*[a-z0-9]`.
    /// The final segment of the name must be between 2 and 64 characters in
    /// length. An instance partition's name cannot be changed after the instance
    /// partition is created.
    pub name: std::string::String,

    /// Required. The name of the instance partition's configuration. Values are of
    /// the form `projects/<project>/instanceConfigs/<configuration>`. See also
    /// [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
    /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]: crate::client::InstanceAdmin::list_instance_configs
    /// [google.spanner.admin.instance.v1.InstanceConfig]: crate::model::InstanceConfig
    pub config: std::string::String,

    /// Required. The descriptive name for this instance partition as it appears in
    /// UIs. Must be unique per project and between 4 and 30 characters in length.
    pub display_name: std::string::String,

    /// Output only. The current instance partition state.
    pub state: crate::model::instance_partition::State,

    /// Output only. The time at which the instance partition was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the instance partition was most recently
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The names of the databases that reference this
    /// instance partition. Referencing databases should share the parent instance.
    /// The existence of any referencing database prevents the instance partition
    /// from being deleted.
    pub referencing_databases: std::vec::Vec<std::string::String>,

    /// Output only. Deprecated: This field is not populated.
    /// Output only. The names of the backups that reference this instance
    /// partition. Referencing backups should share the parent instance. The
    /// existence of any referencing backup prevents the instance partition from
    /// being deleted.
    #[deprecated]
    pub referencing_backups: std::vec::Vec<std::string::String>,

    /// Used for optimistic concurrency control as a way
    /// to help prevent simultaneous updates of a instance partition from
    /// overwriting each other. It is strongly suggested that systems make use of
    /// the etag in the read-modify-write cycle to perform instance partition
    /// updates in order to avoid race conditions: An etag is returned in the
    /// response which contains instance partitions, and systems are expected to
    /// put that etag in the request to update instance partitions to ensure that
    /// their change will be applied to the same version of the instance partition.
    /// If no etag is provided in the call to update instance partition, then the
    /// existing instance partition is overwritten blindly.
    pub etag: std::string::String,

    /// Compute capacity defines amount of server and storage resources that are
    /// available to the databases in an instance partition. At most, one of either
    /// `node_count` or` processing_units` should be present in the message. For
    /// more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    pub compute_capacity: std::option::Option<crate::model::instance_partition::ComputeCapacity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancePartition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstancePartition::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::InstancePartition::config].
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InstancePartition::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::InstancePartition::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance_partition::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::InstancePartition::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::InstancePartition::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::InstancePartition::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::InstancePartition::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [referencing_databases][crate::model::InstancePartition::referencing_databases].
    pub fn set_referencing_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.referencing_databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [referencing_backups][crate::model::InstancePartition::referencing_backups].
    #[deprecated]
    pub fn set_referencing_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.referencing_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::InstancePartition::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity].
    ///
    /// Note that all the setters affecting `compute_capacity` are mutually
    /// exclusive.
    pub fn set_compute_capacity<
        T: std::convert::Into<std::option::Option<crate::model::instance_partition::ComputeCapacity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_capacity = v.into();
        self
    }

    /// The value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// if it holds a `NodeCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn node_count(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::instance_partition::ComputeCapacity::NodeCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// to hold a `NodeCount`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::instance_partition::ComputeCapacity::NodeCount(v.into()),
        );
        self
    }

    /// The value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// if it holds a `ProcessingUnits`, `None` if the field is not set or
    /// holds a different branch.
    pub fn processing_units(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.compute_capacity.as_ref().and_then(|v| match v {
            crate::model::instance_partition::ComputeCapacity::ProcessingUnits(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compute_capacity][crate::model::InstancePartition::compute_capacity]
    /// to hold a `ProcessingUnits`.
    ///
    /// Note that all the setters affecting `compute_capacity` are
    /// mutually exclusive.
    pub fn set_processing_units<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compute_capacity = std::option::Option::Some(
            crate::model::instance_partition::ComputeCapacity::ProcessingUnits(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InstancePartition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.InstancePartition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancePartition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __config,
            __display_name,
            __node_count,
            __processing_units,
            __state,
            __create_time,
            __update_time,
            __referencing_databases,
            __referencing_backups,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancePartition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "config" => Ok(__FieldTag::__config),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "processingUnits" => Ok(__FieldTag::__processing_units),
                            "processing_units" => Ok(__FieldTag::__processing_units),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "referencingDatabases" => Ok(__FieldTag::__referencing_databases),
                            "referencing_databases" => Ok(__FieldTag::__referencing_databases),
                            "referencingBackups" => Ok(__FieldTag::__referencing_backups),
                            "referencing_backups" => Ok(__FieldTag::__referencing_backups),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancePartition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancePartition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.compute_capacity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compute_capacity`, a oneof with full ID .google.spanner.admin.instance.v1.InstancePartition.node_count, latest field was nodeCount",
                                ));
                            }
                            result.compute_capacity = std::option::Option::Some(
                                crate::model::instance_partition::ComputeCapacity::NodeCount(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__processing_units => {
                            if !fields.insert(__FieldTag::__processing_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_units",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.compute_capacity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compute_capacity`, a oneof with full ID .google.spanner.admin.instance.v1.InstancePartition.processing_units, latest field was processingUnits",
                                ));
                            }
                            result.compute_capacity = std::option::Option::Some(
                                crate::model::instance_partition::ComputeCapacity::ProcessingUnits(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::instance_partition::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__referencing_databases => {
                            if !fields.insert(__FieldTag::__referencing_databases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referencing_databases",
                                ));
                            }
                            result.referencing_databases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__referencing_backups => {
                            if !fields.insert(__FieldTag::__referencing_backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referencing_backups",
                                ));
                            }
                            result.referencing_backups = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancePartition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.config.is_empty() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.node_count() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(value))?;
        }
        if let Some(value) = self.processing_units() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("processingUnits", &__With(value))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.referencing_databases.is_empty() {
            state.serialize_entry("referencingDatabases", &self.referencing_databases)?;
        }
        if !self.referencing_backups.is_empty() {
            state.serialize_entry("referencingBackups", &self.referencing_backups)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InstancePartition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancePartition");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("referencing_databases", &self.referencing_databases);
        debug_struct.field("referencing_backups", &self.referencing_backups);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("compute_capacity", &self.compute_capacity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [InstancePartition].
pub mod instance_partition {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the instance partition.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The instance partition is still being created. Resources may not be
        /// available yet, and operations such as creating placements using this
        /// instance partition may not work.
        Creating,
        /// The instance partition is fully created and ready to do work such as
        /// creating placements and using in databases.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.spanner.admin.instance.v1.InstancePartition.State",
            ))
        }
    }

    /// Compute capacity defines amount of server and storage resources that are
    /// available to the databases in an instance partition. At most, one of either
    /// `node_count` or` processing_units` should be present in the message. For
    /// more information, see
    /// [Compute capacity, nodes, and processing
    /// units](https://cloud.google.com/spanner/docs/compute-capacity).
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComputeCapacity {
        /// The number of nodes allocated to this instance partition.
        ///
        /// Users can set the `node_count` field to specify the target number of
        /// nodes allocated to the instance partition.
        ///
        /// This may be zero in API responses for instance partitions that are not
        /// yet in state `READY`.
        NodeCount(i32),
        /// The number of processing units allocated to this instance partition.
        ///
        /// Users can set the `processing_units` field to specify the target number
        /// of processing units allocated to the instance partition.
        ///
        /// This might be zero in API responses for instance partitions that are not
        /// yet in the `READY` state.
        ProcessingUnits(i32),
    }
}

/// Metadata type for the operation returned by
/// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstancePartitionMetadata {
    /// The instance partition being created.
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// The time at which the
    /// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstancePartitionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::CreateInstancePartitionMetadata::instance_partition].
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::CreateInstancePartitionMetadata::instance_partition].
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::CreateInstancePartitionMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CreateInstancePartitionMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::CreateInstancePartitionMetadata::cancel_time].
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::CreateInstancePartitionMetadata::cancel_time].
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateInstancePartitionMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateInstancePartitionMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstancePartitionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstancePartitionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_partition,
            __start_time,
            __cancel_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstancePartitionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instancePartition" => Ok(__FieldTag::__instance_partition),
                            "instance_partition" => Ok(__FieldTag::__instance_partition),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "cancelTime" => Ok(__FieldTag::__cancel_time),
                            "cancel_time" => Ok(__FieldTag::__cancel_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstancePartitionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstancePartitionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_partition => {
                            if !fields.insert(__FieldTag::__instance_partition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partition",
                                ));
                            }
                            result.instance_partition = map
                                .next_value::<std::option::Option<crate::model::InstancePartition>>(
                                )?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cancel_time => {
                            if !fields.insert(__FieldTag::__cancel_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_time",
                                ));
                            }
                            result.cancel_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstancePartitionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_partition.is_some() {
            state.serialize_entry("instancePartition", &self.instance_partition)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.cancel_time.is_some() {
            state.serialize_entry("cancelTime", &self.cancel_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateInstancePartitionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstancePartitionMetadata");
        debug_struct.field("instance_partition", &self.instance_partition);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]: crate::client::InstanceAdmin::create_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstancePartitionRequest {
    /// Required. The name of the instance in which to create the instance
    /// partition. Values are of the form
    /// `projects/<project>/instances/<instance>`.
    pub parent: std::string::String,

    /// Required. The ID of the instance partition to create. Valid identifiers are
    /// of the form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64
    /// characters in length.
    pub instance_partition_id: std::string::String,

    /// Required. The instance partition to create. The instance_partition.name may
    /// be omitted, but if specified must be
    /// `<parent>/instancePartitions/<instance_partition_id>`.
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstancePartitionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_partition_id][crate::model::CreateInstancePartitionRequest::instance_partition_id].
    pub fn set_instance_partition_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_partition_id = v.into();
        self
    }

    /// Sets the value of [instance_partition][crate::model::CreateInstancePartitionRequest::instance_partition].
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::CreateInstancePartitionRequest::instance_partition].
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstancePartitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __instance_partition_id,
            __instance_partition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstancePartitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "instancePartitionId" => Ok(__FieldTag::__instance_partition_id),
                            "instance_partition_id" => Ok(__FieldTag::__instance_partition_id),
                            "instancePartition" => Ok(__FieldTag::__instance_partition),
                            "instance_partition" => Ok(__FieldTag::__instance_partition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstancePartitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstancePartitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_partition_id => {
                            if !fields.insert(__FieldTag::__instance_partition_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partition_id",
                                ));
                            }
                            result.instance_partition_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_partition => {
                            if !fields.insert(__FieldTag::__instance_partition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partition",
                                ));
                            }
                            result.instance_partition = map
                                .next_value::<std::option::Option<crate::model::InstancePartition>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstancePartitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.instance_partition_id.is_empty() {
            state.serialize_entry("instancePartitionId", &self.instance_partition_id)?;
        }
        if self.instance_partition.is_some() {
            state.serialize_entry("instancePartition", &self.instance_partition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstancePartitionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("instance_partition_id", &self.instance_partition_id);
        debug_struct.field("instance_partition", &self.instance_partition);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [DeleteInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstancePartition]: crate::client::InstanceAdmin::delete_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstancePartitionRequest {
    /// Required. The name of the instance partition to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`
    pub name: std::string::String,

    /// Optional. If not empty, the API only deletes the instance partition when
    /// the etag provided matches the current status of the requested instance
    /// partition. Otherwise, deletes the instance partition without checking the
    /// current status of the requested instance partition.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstancePartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstancePartitionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.DeleteInstancePartitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInstancePartitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInstancePartitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInstancePartitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInstancePartitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInstancePartitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInstancePartitionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [GetInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.GetInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.GetInstancePartition]: crate::client::InstanceAdmin::get_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstancePartitionRequest {
    /// Required. The name of the requested instance partition. Values are of
    /// the form
    /// `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstancePartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.GetInstancePartitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstancePartitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstancePartitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstancePartitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstancePartitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstancePartitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInstancePartitionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstancePartitionRequest {
    /// Required. The instance partition to update, which must always include the
    /// instance partition name. Otherwise, only fields mentioned in
    /// [field_mask][google.spanner.admin.instance.v1.UpdateInstancePartitionRequest.field_mask]
    /// need be included.
    ///
    /// [google.spanner.admin.instance.v1.UpdateInstancePartitionRequest.field_mask]: crate::model::UpdateInstancePartitionRequest::field_mask
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// Required. A mask specifying which fields in
    /// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
    /// should be updated. The field mask must always be specified; this prevents
    /// any future fields in
    /// [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
    /// from being erased accidentally by clients that do not know about them.
    ///
    /// [google.spanner.admin.instance.v1.InstancePartition]: crate::model::InstancePartition
    pub field_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstancePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::UpdateInstancePartitionRequest::instance_partition].
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::UpdateInstancePartitionRequest::instance_partition].
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_mask][crate::model::UpdateInstancePartitionRequest::field_mask].
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::UpdateInstancePartitionRequest::field_mask].
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstancePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstancePartitionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstancePartitionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_partition,
            __field_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstancePartitionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instancePartition" => Ok(__FieldTag::__instance_partition),
                            "instance_partition" => Ok(__FieldTag::__instance_partition),
                            "fieldMask" => Ok(__FieldTag::__field_mask),
                            "field_mask" => Ok(__FieldTag::__field_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstancePartitionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstancePartitionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_partition => {
                            if !fields.insert(__FieldTag::__instance_partition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partition",
                                ));
                            }
                            result.instance_partition = map
                                .next_value::<std::option::Option<crate::model::InstancePartition>>(
                                )?;
                        }
                        __FieldTag::__field_mask => {
                            if !fields.insert(__FieldTag::__field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_mask",
                                ));
                            }
                            result.field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstancePartitionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_partition.is_some() {
            state.serialize_entry("instancePartition", &self.instance_partition)?;
        }
        if self.field_mask.is_some() {
            state.serialize_entry("fieldMask", &self.field_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstancePartitionRequest");
        debug_struct.field("instance_partition", &self.instance_partition);
        debug_struct.field("field_mask", &self.field_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata type for the operation returned by
/// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstancePartitionMetadata {
    /// The desired end state of the update.
    pub instance_partition: std::option::Option<crate::model::InstancePartition>,

    /// The time at which
    /// [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]
    /// request was received.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]: crate::client::InstanceAdmin::update_instance_partition
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation was cancelled. If set, this operation is
    /// in the process of undoing itself (which is guaranteed to succeed) and
    /// cannot be cancelled again.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this operation failed or was completed successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstancePartitionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partition][crate::model::UpdateInstancePartitionMetadata::instance_partition].
    pub fn set_instance_partition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition][crate::model::UpdateInstancePartitionMetadata::instance_partition].
    pub fn set_or_clear_instance_partition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePartition>,
    {
        self.instance_partition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateInstancePartitionMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpdateInstancePartitionMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::UpdateInstancePartitionMetadata::cancel_time].
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::UpdateInstancePartitionMetadata::cancel_time].
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateInstancePartitionMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpdateInstancePartitionMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstancePartitionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstancePartitionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_partition,
            __start_time,
            __cancel_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstancePartitionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instancePartition" => Ok(__FieldTag::__instance_partition),
                            "instance_partition" => Ok(__FieldTag::__instance_partition),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "cancelTime" => Ok(__FieldTag::__cancel_time),
                            "cancel_time" => Ok(__FieldTag::__cancel_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstancePartitionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstancePartitionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_partition => {
                            if !fields.insert(__FieldTag::__instance_partition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partition",
                                ));
                            }
                            result.instance_partition = map
                                .next_value::<std::option::Option<crate::model::InstancePartition>>(
                                )?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cancel_time => {
                            if !fields.insert(__FieldTag::__cancel_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_time",
                                ));
                            }
                            result.cancel_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstancePartitionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_partition.is_some() {
            state.serialize_entry("instancePartition", &self.instance_partition)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.cancel_time.is_some() {
            state.serialize_entry("cancelTime", &self.cancel_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateInstancePartitionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstancePartitionMetadata");
        debug_struct.field("instance_partition", &self.instance_partition);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionsRequest {
    /// Required. The instance whose instance partitions should be listed. Values
    /// are of the form `projects/<project>/instances/<instance>`. Use `{instance}
    /// = '-'` to list instance partitions for all Instances in a project, e.g.,
    /// `projects/myproject/instances/-`.
    pub parent: std::string::String,

    /// Number of instance partitions to be returned in the response. If 0 or less,
    /// defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.next_page_token]
    /// from a previous
    /// [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse]: crate::model::ListInstancePartitionsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse.next_page_token]: crate::model::ListInstancePartitionsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Deadline used while retrieving metadata for instance partitions.
    /// Instance partitions whose metadata cannot be retrieved within this deadline
    /// will be added to
    /// [unreachable][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.unreachable]
    /// in
    /// [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse]: crate::model::ListInstancePartitionsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsResponse.unreachable]: crate::model::ListInstancePartitionsResponse::unreachable
    pub instance_partition_deadline: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancePartitionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancePartitionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancePartitionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [instance_partition_deadline][crate::model::ListInstancePartitionsRequest::instance_partition_deadline].
    pub fn set_instance_partition_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition_deadline][crate::model::ListInstancePartitionsRequest::instance_partition_deadline].
    pub fn set_or_clear_instance_partition_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListInstancePartitionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancePartitionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __instance_partition_deadline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancePartitionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "instancePartitionDeadline" => {
                                Ok(__FieldTag::__instance_partition_deadline)
                            }
                            "instance_partition_deadline" => {
                                Ok(__FieldTag::__instance_partition_deadline)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancePartitionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancePartitionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_partition_deadline => {
                            if !fields.insert(__FieldTag::__instance_partition_deadline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partition_deadline",
                                ));
                            }
                            result.instance_partition_deadline =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancePartitionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if self.instance_partition_deadline.is_some() {
            state.serialize_entry(
                "instancePartitionDeadline",
                &self.instance_partition_deadline,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancePartitionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field(
            "instance_partition_deadline",
            &self.instance_partition_deadline,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionsResponse {
    /// The list of requested instancePartitions.
    pub instance_partitions: std::vec::Vec<crate::model::InstancePartition>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]
    /// call to fetch more of the matching instance partitions.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]: crate::client::InstanceAdmin::list_instance_partitions
    pub next_page_token: std::string::String,

    /// The list of unreachable instances or instance partitions.
    /// It includes the names of instances or instance partitions whose metadata
    /// could not be retrieved within
    /// [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionsRequest.instance_partition_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionsRequest.instance_partition_deadline]: crate::model::ListInstancePartitionsRequest::instance_partition_deadline
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_partitions][crate::model::ListInstancePartitionsResponse::instance_partitions].
    pub fn set_instance_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstancePartition>,
    {
        use std::iter::Iterator;
        self.instance_partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancePartitionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancePartitionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancePartitionsResponse {
    type PageItem = crate::model::InstancePartition;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instance_partitions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancePartitionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_partitions,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancePartitionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instancePartitions" => Ok(__FieldTag::__instance_partitions),
                            "instance_partitions" => Ok(__FieldTag::__instance_partitions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancePartitionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancePartitionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_partitions => {
                            if !fields.insert(__FieldTag::__instance_partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partitions",
                                ));
                            }
                            result.instance_partitions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InstancePartition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancePartitionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_partitions.is_empty() {
            state.serialize_entry("instancePartitions", &self.instance_partitions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancePartitionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionsResponse");
        debug_struct.field("instance_partitions", &self.instance_partitions);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionOperationsRequest {
    /// Required. The parent instance of the instance partition operations.
    /// Values are of the form `projects/<project>/instances/<instance>`.
    pub parent: std::string::String,

    /// Optional. An expression that filters the list of returned operations.
    ///
    /// A filter expression consists of a field name, a
    /// comparison operator, and a value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the Operation are eligible for filtering:
    ///
    /// * `name` - The name of the long-running operation
    /// * `done` - False if the operation is in progress, else true.
    /// * `metadata.@type` - the type of metadata. For example, the type string
    ///   for
    ///   [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata]
    ///   is
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata`.
    /// * `metadata.<field_name>` - any field in metadata.value.
    ///   `metadata.@type` must be specified first, if filtering on metadata
    ///   fields.
    /// * `error` - Error associated with the long-running operation.
    /// * `response.@type` - the type of response.
    /// * `response.<field_name>` - any field in response.value.
    ///
    /// You can combine multiple expressions by enclosing each expression in
    /// parentheses. By default, expressions are combined with AND logic. However,
    /// you can specify AND, OR, and NOT logic explicitly.
    ///
    /// Here are a few examples:
    ///
    /// * `done:true` - The operation is complete.
    /// * `(metadata.@type=` \
    ///   `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata)
    ///   AND` \
    ///   `(metadata.instance_partition.name:custom-instance-partition) AND` \
    ///   `(metadata.start_time < \"2021-03-28T14:50:00Z\") AND` \
    ///   `(error:*)` - Return operations where:
    ///   * The operation's metadata type is
    ///     [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
    ///   * The instance partition name contains "custom-instance-partition".
    ///   * The operation started before 2021-03-28T14:50:00Z.
    ///   * The operation resulted in an error.
    ///
    /// [google.spanner.admin.instance.v1.CreateInstancePartitionMetadata]: crate::model::CreateInstancePartitionMetadata
    pub filter: std::string::String,

    /// Optional. Number of operations to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// Optional. If non-empty, `page_token` should contain a
    /// [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.next_page_token]
    /// from a previous
    /// [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]
    /// to the same `parent` and with the same `filter`.
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]: crate::model::ListInstancePartitionOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.next_page_token]: crate::model::ListInstancePartitionOperationsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Deadline used while retrieving metadata for instance partition
    /// operations. Instance partitions whose operation metadata cannot be
    /// retrieved within this deadline will be added to
    /// [unreachable_instance_partitions][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.unreachable_instance_partitions]
    /// in
    /// [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]: crate::model::ListInstancePartitionOperationsResponse
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.unreachable_instance_partitions]: crate::model::ListInstancePartitionOperationsResponse::unreachable_instance_partitions
    pub instance_partition_deadline: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancePartitionOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancePartitionOperationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancePartitionOperationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancePartitionOperationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [instance_partition_deadline][crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline].
    pub fn set_instance_partition_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_partition_deadline][crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline].
    pub fn set_or_clear_instance_partition_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.instance_partition_deadline = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListInstancePartitionOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancePartitionOperationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            __instance_partition_deadline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListInstancePartitionOperationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "instancePartitionDeadline" => {
                                Ok(__FieldTag::__instance_partition_deadline)
                            }
                            "instance_partition_deadline" => {
                                Ok(__FieldTag::__instance_partition_deadline)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancePartitionOperationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancePartitionOperationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_partition_deadline => {
                            if !fields.insert(__FieldTag::__instance_partition_deadline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_partition_deadline",
                                ));
                            }
                            result.instance_partition_deadline =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancePartitionOperationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if self.instance_partition_deadline.is_some() {
            state.serialize_entry(
                "instancePartitionDeadline",
                &self.instance_partition_deadline,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancePartitionOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionOperationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field(
            "instance_partition_deadline",
            &self.instance_partition_deadline,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancePartitionOperationsResponse {
    /// The list of matching instance partition long-running operations. Each
    /// operation's name will be
    /// prefixed by the instance partition's name. The operation's
    /// metadata field type
    /// `metadata.type_url` describes the type of the metadata.
    pub operations: std::vec::Vec<longrunning::model::Operation>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]
    /// call to fetch more of the matching metadata.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]: crate::client::InstanceAdmin::list_instance_partition_operations
    pub next_page_token: std::string::String,

    /// The list of unreachable instance partitions.
    /// It includes the names of instance partitions whose operation metadata could
    /// not be retrieved within
    /// [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.instance_partition_deadline].
    ///
    /// [google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.instance_partition_deadline]: crate::model::ListInstancePartitionOperationsRequest::instance_partition_deadline
    pub unreachable_instance_partitions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancePartitionOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::ListInstancePartitionOperationsResponse::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<longrunning::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancePartitionOperationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_instance_partitions][crate::model::ListInstancePartitionOperationsResponse::unreachable_instance_partitions].
    pub fn set_unreachable_instance_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_instance_partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancePartitionOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancePartitionOperationsResponse {
    type PageItem = longrunning::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.operations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancePartitionOperationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operations,
            __next_page_token,
            __unreachable_instance_partitions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListInstancePartitionOperationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operations" => Ok(__FieldTag::__operations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachableInstancePartitions" => {
                                Ok(__FieldTag::__unreachable_instance_partitions)
                            }
                            "unreachable_instance_partitions" => {
                                Ok(__FieldTag::__unreachable_instance_partitions)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancePartitionOperationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancePartitionOperationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<longrunning::model::Operation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable_instance_partitions => {
                            if !fields.insert(__FieldTag::__unreachable_instance_partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable_instance_partitions",
                                ));
                            }
                            result.unreachable_instance_partitions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancePartitionOperationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable_instance_partitions.is_empty() {
            state.serialize_entry(
                "unreachableInstancePartitions",
                &self.unreachable_instance_partitions,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancePartitionOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionOperationsResponse");
        debug_struct.field("operations", &self.operations);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field(
            "unreachable_instance_partitions",
            &self.unreachable_instance_partitions,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveInstanceRequest {
    /// Required. The instance to move.
    /// Values are of the form `projects/<project>/instances/<instance>`.
    pub name: std::string::String,

    /// Required. The target instance configuration where to move the instance.
    /// Values are of the form `projects/<project>/instanceConfigs/<config>`.
    pub target_config: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MoveInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_config][crate::model::MoveInstanceRequest::target_config].
    pub fn set_target_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_config = v.into();
        self
    }
}

impl wkt::message::Message for MoveInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetConfig" => Ok(__FieldTag::__target_config),
                            "target_config" => Ok(__FieldTag::__target_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_config => {
                            if !fields.insert(__FieldTag::__target_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_config",
                                ));
                            }
                            result.target_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target_config.is_empty() {
            state.serialize_entry("targetConfig", &self.target_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MoveInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveInstanceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_config", &self.target_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveInstanceResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MoveInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveInstanceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveInstanceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveInstanceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveInstanceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveInstanceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MoveInstanceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveInstanceResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata type for the operation returned by
/// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
///
/// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveInstanceMetadata {
    /// The target instance configuration where to move the instance.
    /// Values are of the form `projects/<project>/instanceConfigs/<config>`.
    pub target_config: std::string::String,

    /// The progress of the
    /// [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]
    /// operation.
    /// [progress_percent][google.spanner.admin.instance.v1.OperationProgress.progress_percent]
    /// is reset when cancellation is requested.
    ///
    /// [google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]: crate::client::InstanceAdmin::move_instance
    /// [google.spanner.admin.instance.v1.OperationProgress.progress_percent]: crate::model::OperationProgress::progress_percent
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// The time at which this operation was cancelled.
    pub cancel_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_config][crate::model::MoveInstanceMetadata::target_config].
    pub fn set_target_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_config = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::MoveInstanceMetadata::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::MoveInstanceMetadata::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cancel_time][crate::model::MoveInstanceMetadata::cancel_time].
    pub fn set_cancel_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cancel_time][crate::model::MoveInstanceMetadata::cancel_time].
    pub fn set_or_clear_cancel_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.cancel_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MoveInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.spanner.admin.instance.v1.MoveInstanceMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveInstanceMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_config,
            __progress,
            __cancel_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveInstanceMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetConfig" => Ok(__FieldTag::__target_config),
                            "target_config" => Ok(__FieldTag::__target_config),
                            "progress" => Ok(__FieldTag::__progress),
                            "cancelTime" => Ok(__FieldTag::__cancel_time),
                            "cancel_time" => Ok(__FieldTag::__cancel_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveInstanceMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveInstanceMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_config => {
                            if !fields.insert(__FieldTag::__target_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_config",
                                ));
                            }
                            result.target_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::__cancel_time => {
                            if !fields.insert(__FieldTag::__cancel_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_time",
                                ));
                            }
                            result.cancel_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveInstanceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_config.is_empty() {
            state.serialize_entry("targetConfig", &self.target_config)?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if self.cancel_time.is_some() {
            state.serialize_entry("cancelTime", &self.cancel_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MoveInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveInstanceMetadata");
        debug_struct.field("target_config", &self.target_config);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cancel_time", &self.cancel_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Indicates the expected fulfillment period of an operation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FulfillmentPeriod {
    /// Not specified.
    Unspecified,
    /// Normal fulfillment period. The operation is expected to complete within
    /// minutes.
    Normal,
    /// Extended fulfillment period. It can take up to an hour for the operation
    /// to complete.
    Extended,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FulfillmentPeriod::value] or
    /// [FulfillmentPeriod::name].
    UnknownValue(fulfillment_period::UnknownValue),
}

#[doc(hidden)]
pub mod fulfillment_period {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FulfillmentPeriod {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Normal => std::option::Option::Some(1),
            Self::Extended => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FULFILLMENT_PERIOD_UNSPECIFIED"),
            Self::Normal => std::option::Option::Some("FULFILLMENT_PERIOD_NORMAL"),
            Self::Extended => std::option::Option::Some("FULFILLMENT_PERIOD_EXTENDED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FulfillmentPeriod {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FulfillmentPeriod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FulfillmentPeriod {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Normal,
            2 => Self::Extended,
            _ => Self::UnknownValue(fulfillment_period::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FulfillmentPeriod {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FULFILLMENT_PERIOD_UNSPECIFIED" => Self::Unspecified,
            "FULFILLMENT_PERIOD_NORMAL" => Self::Normal,
            "FULFILLMENT_PERIOD_EXTENDED" => Self::Extended,
            _ => Self::UnknownValue(fulfillment_period::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FulfillmentPeriod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Normal => serializer.serialize_i32(1),
            Self::Extended => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FulfillmentPeriod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FulfillmentPeriod>::new(
            ".google.spanner.admin.instance.v1.FulfillmentPeriod",
        ))
    }
}
