// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::OperationProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationProgress");
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReplicaSelection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicaSelection");
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReplicaInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicaInfo");
        debug_struct.field("location", &self.location);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("default_leader_location", &self.default_leader_location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("config_type", &self.config_type);
        debug_struct.field("replicas", &self.replicas);
        debug_struct.field("optional_replicas", &self.optional_replicas);
        debug_struct.field("base_config", &self.base_config);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("leader_options", &self.leader_options);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "free_instance_availability",
            &self.free_instance_availability,
        );
        debug_struct.field("quorum_type", &self.quorum_type);
        debug_struct.field(
            "storage_limit_per_processing_unit",
            &self.storage_limit_per_processing_unit,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReplicaComputeCapacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicaComputeCapacity");
        debug_struct.field("replica_selection", &self.replica_selection);
        debug_struct.field("compute_capacity", &self.compute_capacity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutoscalingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscalingConfig");
        debug_struct.field("autoscaling_limits", &self.autoscaling_limits);
        debug_struct.field("autoscaling_targets", &self.autoscaling_targets);
        debug_struct.field(
            "asymmetric_autoscaling_options",
            &self.asymmetric_autoscaling_options,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::autoscaling_config::AutoscalingLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscalingLimits");
        debug_struct.field("min_limit", &self.min_limit);
        debug_struct.field("max_limit", &self.max_limit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::autoscaling_config::AutoscalingTargets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscalingTargets");
        debug_struct.field(
            "high_priority_cpu_utilization_percent",
            &self.high_priority_cpu_utilization_percent,
        );
        debug_struct.field(
            "storage_utilization_percent",
            &self.storage_utilization_percent,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::autoscaling_config::AsymmetricAutoscalingOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsymmetricAutoscalingOption");
        debug_struct.field("replica_selection", &self.replica_selection);
        debug_struct.field("overrides", &self.overrides);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug
    for super::autoscaling_config::asymmetric_autoscaling_option::AutoscalingConfigOverrides
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscalingConfigOverrides");
        debug_struct.field("autoscaling_limits", &self.autoscaling_limits);
        debug_struct.field(
            "autoscaling_target_high_priority_cpu_utilization_percent",
            &self.autoscaling_target_high_priority_cpu_utilization_percent,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Instance");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("processing_units", &self.processing_units);
        debug_struct.field("replica_compute_capacity", &self.replica_compute_capacity);
        debug_struct.field("autoscaling_config", &self.autoscaling_config);
        debug_struct.field("state", &self.state);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("instance_type", &self.instance_type);
        debug_struct.field("endpoint_uris", &self.endpoint_uris);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("free_instance_metadata", &self.free_instance_metadata);
        debug_struct.field("edition", &self.edition);
        debug_struct.field(
            "default_backup_schedule_type",
            &self.default_backup_schedule_type,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstanceConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstanceConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigsResponse");
        debug_struct.field("instance_configs", &self.instance_configs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInstanceConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("instance_config_id", &self.instance_config_id);
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceConfigRequest");
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteInstanceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInstanceConfigRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstanceConfigOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigOperationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstanceConfigOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstanceConfigOperationsResponse");
        debug_struct.field("operations", &self.operations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInstanceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("field_mask", &self.field_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("instance_id", &self.instance_id);
        debug_struct.field("instance", &self.instance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstancesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("instance_deadline", &self.instance_deadline);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstancesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancesResponse");
        debug_struct.field("instances", &self.instances);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("field_mask", &self.field_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInstanceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceMetadata");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field(
            "expected_fulfillment_period",
            &self.expected_fulfillment_period,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceMetadata");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field(
            "expected_fulfillment_period",
            &self.expected_fulfillment_period,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FreeInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FreeInstanceMetadata");
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("upgrade_time", &self.upgrade_time);
        debug_struct.field("expire_behavior", &self.expire_behavior);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateInstanceConfigMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstanceConfigMetadata");
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cancel_time", &self.cancel_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateInstanceConfigMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstanceConfigMetadata");
        debug_struct.field("instance_config", &self.instance_config);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cancel_time", &self.cancel_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancePartition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancePartition");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("referencing_databases", &self.referencing_databases);
        debug_struct.field("referencing_backups", &self.referencing_backups);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("compute_capacity", &self.compute_capacity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateInstancePartitionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstancePartitionMetadata");
        debug_struct.field("instance_partition", &self.instance_partition);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInstancePartitionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("instance_partition_id", &self.instance_partition_id);
        debug_struct.field("instance_partition", &self.instance_partition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInstancePartitionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInstancePartitionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateInstancePartitionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstancePartitionRequest");
        debug_struct.field("instance_partition", &self.instance_partition);
        debug_struct.field("field_mask", &self.field_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateInstancePartitionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInstancePartitionMetadata");
        debug_struct.field("instance_partition", &self.instance_partition);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("cancel_time", &self.cancel_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstancePartitionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field(
            "instance_partition_deadline",
            &self.instance_partition_deadline,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstancePartitionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionsResponse");
        debug_struct.field("instance_partitions", &self.instance_partitions);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstancePartitionOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionOperationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field(
            "instance_partition_deadline",
            &self.instance_partition_deadline,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInstancePartitionOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancePartitionOperationsResponse");
        debug_struct.field("operations", &self.operations);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field(
            "unreachable_instance_partitions",
            &self.unreachable_instance_partitions,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MoveInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveInstanceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_config", &self.target_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MoveInstanceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveInstanceResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MoveInstanceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveInstanceMetadata");
        debug_struct.field("target_config", &self.target_config);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cancel_time", &self.cancel_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
