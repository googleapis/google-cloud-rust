// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Metadata common to all Datastore Admin operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CommonMetadata {
    /// The time that work began on the operation.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation ended, either successfully or otherwise.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The type of the operation. Can be used as a filter in
    /// ListOperationsRequest.
    pub operation_type: crate::model::OperationType,

    /// The client-assigned labels which were provided when the operation was
    /// created. May also include additional labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The current state of the Operation.
    pub state: crate::model::common_metadata::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommonMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CommonMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CommonMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CommonMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CommonMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_type][crate::model::CommonMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::OperationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CommonMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::CommonMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::common_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for CommonMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.CommonMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommonMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __operation_type,
            __labels,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommonMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommonMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommonMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<crate::model::OperationType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::common_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommonMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CommonMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommonMetadata");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CommonMetadata].
pub mod common_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The various possible states for an ongoing Operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// Request is being prepared for processing.
        Initializing,
        /// Request is actively being processed.
        Processing,
        /// Request is in the process of being cancelled after user called
        /// google.longrunning.Operations.CancelOperation on the operation.
        Cancelling,
        /// Request has been processed and is in its finalization stage.
        Finalizing,
        /// Request has completed successfully.
        Successful,
        /// Request has finished being processed, but encountered an error.
        Failed,
        /// Request has finished being cancelled after user called
        /// google.longrunning.Operations.CancelOperation.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Initializing => std::option::Option::Some(1),
                Self::Processing => std::option::Option::Some(2),
                Self::Cancelling => std::option::Option::Some(3),
                Self::Finalizing => std::option::Option::Some(4),
                Self::Successful => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Cancelled => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Initializing => std::option::Option::Some("INITIALIZING"),
                Self::Processing => std::option::Option::Some("PROCESSING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Finalizing => std::option::Option::Some("FINALIZING"),
                Self::Successful => std::option::Option::Some("SUCCESSFUL"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Initializing,
                2 => Self::Processing,
                3 => Self::Cancelling,
                4 => Self::Finalizing,
                5 => Self::Successful,
                6 => Self::Failed,
                7 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INITIALIZING" => Self::Initializing,
                "PROCESSING" => Self::Processing,
                "CANCELLING" => Self::Cancelling,
                "FINALIZING" => Self::Finalizing,
                "SUCCESSFUL" => Self::Successful,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Initializing => serializer.serialize_i32(1),
                Self::Processing => serializer.serialize_i32(2),
                Self::Cancelling => serializer.serialize_i32(3),
                Self::Finalizing => serializer.serialize_i32(4),
                Self::Successful => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Cancelled => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.datastore.admin.v1.CommonMetadata.State",
            ))
        }
    }
}

/// Measures the progress of a particular metric.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Progress {
    /// The amount of work that has been completed. Note that this may be greater
    /// than work_estimated.
    pub work_completed: i64,

    /// An estimate of how much work needs to be performed. May be zero if the
    /// work estimate is unavailable.
    pub work_estimated: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Progress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [work_completed][crate::model::Progress::work_completed].
    pub fn set_work_completed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.work_completed = v.into();
        self
    }

    /// Sets the value of [work_estimated][crate::model::Progress::work_estimated].
    pub fn set_work_estimated<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.work_estimated = v.into();
        self
    }
}

impl wkt::message::Message for Progress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.Progress"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Progress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __work_completed,
            __work_estimated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Progress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workCompleted" => Ok(__FieldTag::__work_completed),
                            "work_completed" => Ok(__FieldTag::__work_completed),
                            "workEstimated" => Ok(__FieldTag::__work_estimated),
                            "work_estimated" => Ok(__FieldTag::__work_estimated),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Progress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Progress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__work_completed => {
                            if !fields.insert(__FieldTag::__work_completed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for work_completed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.work_completed =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__work_estimated => {
                            if !fields.insert(__FieldTag::__work_estimated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for work_estimated",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.work_estimated =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Progress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.work_completed) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("workCompleted", &__With(&self.work_completed))?;
        }
        if !wkt::internal::is_default(&self.work_estimated) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("workEstimated", &__With(&self.work_estimated))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Progress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Progress");
        debug_struct.field("work_completed", &self.work_completed);
        debug_struct.field("work_estimated", &self.work_estimated);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities][google.datastore.admin.v1.DatastoreAdmin.ExportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities]: crate::client::DatastoreAdmin::export_entities
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportEntitiesRequest {
    /// Required. Project ID against which to make the request.
    pub project_id: std::string::String,

    /// Client-assigned labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Description of what data from the project is included in the export.
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// Required. Location for the export metadata and data files.
    ///
    /// The full resource URL of the external storage location. Currently, only
    /// Google Cloud Storage is supported. So output_url_prefix should be of the
    /// form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the
    /// name of the Cloud Storage bucket and `NAMESPACE_PATH` is an optional Cloud
    /// Storage namespace path (this is not a Cloud Datastore namespace). For more
    /// information about Cloud Storage namespace paths, see
    /// [Object name
    /// considerations](https://cloud.google.com/storage/docs/naming#object-considerations).
    ///
    /// The resulting files will be nested deeper than the specified URL prefix.
    /// The final output URL will be provided in the
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url]
    /// field. That value should be used for subsequent ImportEntities operations.
    ///
    /// By nesting the data files deeper, the same Cloud Storage bucket can be used
    /// in multiple ExportEntities operations without conflict.
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    pub output_url_prefix: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ExportEntitiesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ExportEntitiesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ExportEntitiesRequest::entity_filter].
    pub fn set_entity_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_filter][crate::model::ExportEntitiesRequest::entity_filter].
    pub fn set_or_clear_entity_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_url_prefix][crate::model::ExportEntitiesRequest::output_url_prefix].
    pub fn set_output_url_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_url_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __labels,
            __entity_filter,
            __output_url_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "labels" => Ok(__FieldTag::__labels),
                            "entityFilter" => Ok(__FieldTag::__entity_filter),
                            "entity_filter" => Ok(__FieldTag::__entity_filter),
                            "outputUrlPrefix" => Ok(__FieldTag::__output_url_prefix),
                            "output_url_prefix" => Ok(__FieldTag::__output_url_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_filter => {
                            if !fields.insert(__FieldTag::__entity_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_filter",
                                ));
                            }
                            result.entity_filter = map
                                .next_value::<std::option::Option<crate::model::EntityFilter>>()?;
                        }
                        __FieldTag::__output_url_prefix => {
                            if !fields.insert(__FieldTag::__output_url_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_url_prefix",
                                ));
                            }
                            result.output_url_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.entity_filter.is_some() {
            state.serialize_entry("entityFilter", &self.entity_filter)?;
        }
        if !self.output_url_prefix.is_empty() {
            state.serialize_entry("outputUrlPrefix", &self.output_url_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportEntitiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportEntitiesRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("entity_filter", &self.entity_filter);
        debug_struct.field("output_url_prefix", &self.output_url_prefix);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ImportEntities][google.datastore.admin.v1.DatastoreAdmin.ImportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ImportEntities]: crate::client::DatastoreAdmin::import_entities
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntitiesRequest {
    /// Required. Project ID against which to make the request.
    pub project_id: std::string::String,

    /// Client-assigned labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The full resource URL of the external storage location.
    /// Currently, only Google Cloud Storage is supported. So input_url should be
    /// of the form:
    /// `gs://BUCKET_NAME[/NAMESPACE_PATH]/OVERALL_EXPORT_METADATA_FILE`, where
    /// `BUCKET_NAME` is the name of the Cloud Storage bucket, `NAMESPACE_PATH` is
    /// an optional Cloud Storage namespace path (this is not a Cloud Datastore
    /// namespace), and `OVERALL_EXPORT_METADATA_FILE` is the metadata file written
    /// by the ExportEntities operation. For more information about Cloud Storage
    /// namespace paths, see
    /// [Object name
    /// considerations](https://cloud.google.com/storage/docs/naming#object-considerations).
    ///
    /// For more information, see
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url].
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    pub input_url: std::string::String,

    /// Optionally specify which kinds/namespaces are to be imported. If provided,
    /// the list must be a subset of the EntityFilter used in creating the export,
    /// otherwise a FAILED_PRECONDITION error will be returned. If no filter is
    /// specified then all entities from the export are imported.
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ImportEntitiesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ImportEntitiesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [input_url][crate::model::ImportEntitiesRequest::input_url].
    pub fn set_input_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_url = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ImportEntitiesRequest::entity_filter].
    pub fn set_entity_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_filter][crate::model::ImportEntitiesRequest::entity_filter].
    pub fn set_or_clear_entity_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ImportEntitiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __labels,
            __input_url,
            __entity_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "labels" => Ok(__FieldTag::__labels),
                            "inputUrl" => Ok(__FieldTag::__input_url),
                            "input_url" => Ok(__FieldTag::__input_url),
                            "entityFilter" => Ok(__FieldTag::__entity_filter),
                            "entity_filter" => Ok(__FieldTag::__entity_filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_url => {
                            if !fields.insert(__FieldTag::__input_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_url",
                                ));
                            }
                            result.input_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_filter => {
                            if !fields.insert(__FieldTag::__entity_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_filter",
                                ));
                            }
                            result.entity_filter = map
                                .next_value::<std::option::Option<crate::model::EntityFilter>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.input_url.is_empty() {
            state.serialize_entry("inputUrl", &self.input_url)?;
        }
        if self.entity_filter.is_some() {
            state.serialize_entry("entityFilter", &self.entity_filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportEntitiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportEntitiesRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("input_url", &self.input_url);
        debug_struct.field("entity_filter", &self.entity_filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities][google.datastore.admin.v1.DatastoreAdmin.ExportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities]: crate::client::DatastoreAdmin::export_entities
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportEntitiesResponse {
    /// Location of the output metadata file. This can be used to begin an import
    /// into Cloud Datastore (this project or another project). See
    /// [google.datastore.admin.v1.ImportEntitiesRequest.input_url][google.datastore.admin.v1.ImportEntitiesRequest.input_url].
    /// Only present if the operation completed successfully.
    ///
    /// [google.datastore.admin.v1.ImportEntitiesRequest.input_url]: crate::model::ImportEntitiesRequest::input_url
    pub output_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_url][crate::model::ExportEntitiesResponse::output_url].
    pub fn set_output_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_url = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportEntitiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportEntitiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputUrl" => Ok(__FieldTag::__output_url),
                            "output_url" => Ok(__FieldTag::__output_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportEntitiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportEntitiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_url => {
                            if !fields.insert(__FieldTag::__output_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_url",
                                ));
                            }
                            result.output_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportEntitiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.output_url.is_empty() {
            state.serialize_entry("outputUrl", &self.output_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportEntitiesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportEntitiesResponse");
        debug_struct.field("output_url", &self.output_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for ExportEntities operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportEntitiesMetadata {
    /// Metadata common to all Datastore Admin operations.
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// An estimate of the number of bytes processed.
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Description of which entities are being exported.
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// Location for the export metadata and data files. This will be the same
    /// value as the
    /// [google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix][google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix]
    /// field. The final output location is provided in
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url].
    ///
    /// [google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix]: crate::model::ExportEntitiesRequest::output_url_prefix
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    pub output_url_prefix: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportEntitiesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::ExportEntitiesMetadata::common].
    pub fn set_common<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonMetadata>,
    {
        self.common = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common][crate::model::ExportEntitiesMetadata::common].
    pub fn set_or_clear_common<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonMetadata>,
    {
        self.common = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_entities][crate::model::ExportEntitiesMetadata::progress_entities].
    pub fn set_progress_entities<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_entities = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_entities][crate::model::ExportEntitiesMetadata::progress_entities].
    pub fn set_or_clear_progress_entities<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_entities = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ExportEntitiesMetadata::progress_bytes].
    pub fn set_progress_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_bytes][crate::model::ExportEntitiesMetadata::progress_bytes].
    pub fn set_or_clear_progress_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entity_filter][crate::model::ExportEntitiesMetadata::entity_filter].
    pub fn set_entity_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_filter][crate::model::ExportEntitiesMetadata::entity_filter].
    pub fn set_or_clear_entity_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_url_prefix][crate::model::ExportEntitiesMetadata::output_url_prefix].
    pub fn set_output_url_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_url_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportEntitiesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common,
            __progress_entities,
            __progress_bytes,
            __entity_filter,
            __output_url_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportEntitiesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "common" => Ok(__FieldTag::__common),
                            "progressEntities" => Ok(__FieldTag::__progress_entities),
                            "progress_entities" => Ok(__FieldTag::__progress_entities),
                            "progressBytes" => Ok(__FieldTag::__progress_bytes),
                            "progress_bytes" => Ok(__FieldTag::__progress_bytes),
                            "entityFilter" => Ok(__FieldTag::__entity_filter),
                            "entity_filter" => Ok(__FieldTag::__entity_filter),
                            "outputUrlPrefix" => Ok(__FieldTag::__output_url_prefix),
                            "output_url_prefix" => Ok(__FieldTag::__output_url_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportEntitiesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportEntitiesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common => {
                            if !fields.insert(__FieldTag::__common) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common",
                                ));
                            }
                            result.common = map
                                .next_value::<std::option::Option<crate::model::CommonMetadata>>(
                                )?;
                        }
                        __FieldTag::__progress_entities => {
                            if !fields.insert(__FieldTag::__progress_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_entities",
                                ));
                            }
                            result.progress_entities =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__progress_bytes => {
                            if !fields.insert(__FieldTag::__progress_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_bytes",
                                ));
                            }
                            result.progress_bytes =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__entity_filter => {
                            if !fields.insert(__FieldTag::__entity_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_filter",
                                ));
                            }
                            result.entity_filter = map
                                .next_value::<std::option::Option<crate::model::EntityFilter>>()?;
                        }
                        __FieldTag::__output_url_prefix => {
                            if !fields.insert(__FieldTag::__output_url_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_url_prefix",
                                ));
                            }
                            result.output_url_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportEntitiesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common.is_some() {
            state.serialize_entry("common", &self.common)?;
        }
        if self.progress_entities.is_some() {
            state.serialize_entry("progressEntities", &self.progress_entities)?;
        }
        if self.progress_bytes.is_some() {
            state.serialize_entry("progressBytes", &self.progress_bytes)?;
        }
        if self.entity_filter.is_some() {
            state.serialize_entry("entityFilter", &self.entity_filter)?;
        }
        if !self.output_url_prefix.is_empty() {
            state.serialize_entry("outputUrlPrefix", &self.output_url_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportEntitiesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportEntitiesMetadata");
        debug_struct.field("common", &self.common);
        debug_struct.field("progress_entities", &self.progress_entities);
        debug_struct.field("progress_bytes", &self.progress_bytes);
        debug_struct.field("entity_filter", &self.entity_filter);
        debug_struct.field("output_url_prefix", &self.output_url_prefix);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for ImportEntities operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntitiesMetadata {
    /// Metadata common to all Datastore Admin operations.
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// An estimate of the number of bytes processed.
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Description of which entities are being imported.
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// The location of the import metadata file. This will be the same value as
    /// the
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url]
    /// field.
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    pub input_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntitiesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::ImportEntitiesMetadata::common].
    pub fn set_common<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonMetadata>,
    {
        self.common = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common][crate::model::ImportEntitiesMetadata::common].
    pub fn set_or_clear_common<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonMetadata>,
    {
        self.common = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_entities][crate::model::ImportEntitiesMetadata::progress_entities].
    pub fn set_progress_entities<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_entities = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_entities][crate::model::ImportEntitiesMetadata::progress_entities].
    pub fn set_or_clear_progress_entities<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_entities = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ImportEntitiesMetadata::progress_bytes].
    pub fn set_progress_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_bytes][crate::model::ImportEntitiesMetadata::progress_bytes].
    pub fn set_or_clear_progress_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entity_filter][crate::model::ImportEntitiesMetadata::entity_filter].
    pub fn set_entity_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_filter][crate::model::ImportEntitiesMetadata::entity_filter].
    pub fn set_or_clear_entity_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityFilter>,
    {
        self.entity_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_url][crate::model::ImportEntitiesMetadata::input_url].
    pub fn set_input_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_url = v.into();
        self
    }
}

impl wkt::message::Message for ImportEntitiesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ImportEntitiesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntitiesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common,
            __progress_entities,
            __progress_bytes,
            __entity_filter,
            __input_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntitiesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "common" => Ok(__FieldTag::__common),
                            "progressEntities" => Ok(__FieldTag::__progress_entities),
                            "progress_entities" => Ok(__FieldTag::__progress_entities),
                            "progressBytes" => Ok(__FieldTag::__progress_bytes),
                            "progress_bytes" => Ok(__FieldTag::__progress_bytes),
                            "entityFilter" => Ok(__FieldTag::__entity_filter),
                            "entity_filter" => Ok(__FieldTag::__entity_filter),
                            "inputUrl" => Ok(__FieldTag::__input_url),
                            "input_url" => Ok(__FieldTag::__input_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntitiesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntitiesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common => {
                            if !fields.insert(__FieldTag::__common) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common",
                                ));
                            }
                            result.common = map
                                .next_value::<std::option::Option<crate::model::CommonMetadata>>(
                                )?;
                        }
                        __FieldTag::__progress_entities => {
                            if !fields.insert(__FieldTag::__progress_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_entities",
                                ));
                            }
                            result.progress_entities =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__progress_bytes => {
                            if !fields.insert(__FieldTag::__progress_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_bytes",
                                ));
                            }
                            result.progress_bytes =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__entity_filter => {
                            if !fields.insert(__FieldTag::__entity_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_filter",
                                ));
                            }
                            result.entity_filter = map
                                .next_value::<std::option::Option<crate::model::EntityFilter>>()?;
                        }
                        __FieldTag::__input_url => {
                            if !fields.insert(__FieldTag::__input_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_url",
                                ));
                            }
                            result.input_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportEntitiesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common.is_some() {
            state.serialize_entry("common", &self.common)?;
        }
        if self.progress_entities.is_some() {
            state.serialize_entry("progressEntities", &self.progress_entities)?;
        }
        if self.progress_bytes.is_some() {
            state.serialize_entry("progressBytes", &self.progress_bytes)?;
        }
        if self.entity_filter.is_some() {
            state.serialize_entry("entityFilter", &self.entity_filter)?;
        }
        if !self.input_url.is_empty() {
            state.serialize_entry("inputUrl", &self.input_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportEntitiesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportEntitiesMetadata");
        debug_struct.field("common", &self.common);
        debug_struct.field("progress_entities", &self.progress_entities);
        debug_struct.field("progress_bytes", &self.progress_bytes);
        debug_struct.field("entity_filter", &self.entity_filter);
        debug_struct.field("input_url", &self.input_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Identifies a subset of entities in a project. This is specified as
/// combinations of kinds and namespaces (either or both of which may be all, as
/// described in the following examples).
/// Example usage:
///
/// Entire project:
/// kinds=[], namespace_ids=[]
///
/// Kinds Foo and Bar in all namespaces:
/// kinds=['Foo', 'Bar'], namespace_ids=[]
///
/// Kinds Foo and Bar only in the default namespace:
/// kinds=['Foo', 'Bar'], namespace_ids=['']
///
/// Kinds Foo and Bar in both the default and Baz namespaces:
/// kinds=['Foo', 'Bar'], namespace_ids=['', 'Baz']
///
/// The entire Baz namespace:
/// kinds=[], namespace_ids=['Baz']
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityFilter {
    /// If empty, then this represents all kinds.
    pub kinds: std::vec::Vec<std::string::String>,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for projects that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the project has data in non-default namespaces, but doesn't want to
    /// include them.
    /// Each namespace in this list must be unique.
    pub namespace_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kinds][crate::model::EntityFilter::kinds].
    pub fn set_kinds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kinds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::EntityFilter::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.EntityFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kinds,
            __namespace_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kinds" => Ok(__FieldTag::__kinds),
                            "namespaceIds" => Ok(__FieldTag::__namespace_ids),
                            "namespace_ids" => Ok(__FieldTag::__namespace_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kinds => {
                            if !fields.insert(__FieldTag::__kinds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kinds",
                                ));
                            }
                            result.kinds = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__namespace_ids => {
                            if !fields.insert(__FieldTag::__namespace_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_ids",
                                ));
                            }
                            result.namespace_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kinds.is_empty() {
            state.serialize_entry("kinds", &self.kinds)?;
        }
        if !self.namespace_ids.is_empty() {
            state.serialize_entry("namespaceIds", &self.namespace_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityFilter");
        debug_struct.field("kinds", &self.kinds);
        debug_struct.field("namespace_ids", &self.namespace_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.CreateIndex][google.datastore.admin.v1.DatastoreAdmin.CreateIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.CreateIndex]: crate::client::DatastoreAdmin::create_index
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Project ID against which to make the request.
    pub project_id: std::string::String,

    /// The index to create. The name and state fields are output only and will be
    /// ignored. Single property indexes cannot be created or deleted.
    pub index: std::option::Option<crate::model::Index>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Index>,
    {
        self.index = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_or_clear_index<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Index>,
    {
        self.index = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.CreateIndexRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIndexRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __index,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIndexRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "index" => Ok(__FieldTag::__index),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIndexRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIndexRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            result.index =
                                map.next_value::<std::option::Option<crate::model::Index>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateIndexRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.index.is_some() {
            state.serialize_entry("index", &self.index)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateIndexRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateIndexRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("index", &self.index);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.DeleteIndex][google.datastore.admin.v1.DatastoreAdmin.DeleteIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.DeleteIndex]: crate::client::DatastoreAdmin::delete_index
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Project ID against which to make the request.
    pub project_id: std::string::String,

    /// The resource ID of the index to delete.
    pub index_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::DeleteIndexRequest::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.DeleteIndexRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIndexRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __index_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIndexRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "indexId" => Ok(__FieldTag::__index_id),
                            "index_id" => Ok(__FieldTag::__index_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIndexRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIndexRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_id => {
                            if !fields.insert(__FieldTag::__index_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_id",
                                ));
                            }
                            result.index_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteIndexRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.index_id.is_empty() {
            state.serialize_entry("indexId", &self.index_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteIndexRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteIndexRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("index_id", &self.index_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.GetIndex][google.datastore.admin.v1.DatastoreAdmin.GetIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.GetIndex]: crate::client::DatastoreAdmin::get_index
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Project ID against which to make the request.
    pub project_id: std::string::String,

    /// The resource ID of the index to get.
    pub index_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::GetIndexRequest::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.GetIndexRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIndexRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __index_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIndexRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "indexId" => Ok(__FieldTag::__index_id),
                            "index_id" => Ok(__FieldTag::__index_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIndexRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIndexRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_id => {
                            if !fields.insert(__FieldTag::__index_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_id",
                                ));
                            }
                            result.index_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetIndexRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.index_id.is_empty() {
            state.serialize_entry("indexId", &self.index_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetIndexRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetIndexRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("index_id", &self.index_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes][google.datastore.admin.v1.DatastoreAdmin.ListIndexes].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes]: crate::client::DatastoreAdmin::list_indexes
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Project ID against which to make the request.
    pub project_id: std::string::String,

    pub filter: std::string::String,

    /// The maximum number of items to return.  If zero, then all results will be
    /// returned.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListIndexesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ListIndexesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIndexesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIndexesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIndexesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIndexesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIndexesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIndexesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIndexesRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes][google.datastore.admin.v1.DatastoreAdmin.ListIndexes].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes]: crate::client::DatastoreAdmin::list_indexes
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// The indexes.
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// The standard List next-page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ListIndexesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIndexesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __indexes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIndexesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "indexes" => Ok(__FieldTag::__indexes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIndexesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIndexesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__indexes => {
                            if !fields.insert(__FieldTag::__indexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indexes",
                                ));
                            }
                            result.indexes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Index>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIndexesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.indexes.is_empty() {
            state.serialize_entry("indexes", &self.indexes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIndexesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIndexesResponse");
        debug_struct.field("indexes", &self.indexes);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for Index operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IndexOperationMetadata {
    /// Metadata common to all Datastore Admin operations.
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// The index resource ID that this operation is acting on.
    pub index_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::IndexOperationMetadata::common].
    pub fn set_common<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonMetadata>,
    {
        self.common = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common][crate::model::IndexOperationMetadata::common].
    pub fn set_or_clear_common<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonMetadata>,
    {
        self.common = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_entities][crate::model::IndexOperationMetadata::progress_entities].
    pub fn set_progress_entities<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_entities = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_entities][crate::model::IndexOperationMetadata::progress_entities].
    pub fn set_or_clear_progress_entities<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_entities = v.map(|x| x.into());
        self
    }

    /// Sets the value of [index_id][crate::model::IndexOperationMetadata::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for IndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.IndexOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IndexOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common,
            __progress_entities,
            __index_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IndexOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "common" => Ok(__FieldTag::__common),
                            "progressEntities" => Ok(__FieldTag::__progress_entities),
                            "progress_entities" => Ok(__FieldTag::__progress_entities),
                            "indexId" => Ok(__FieldTag::__index_id),
                            "index_id" => Ok(__FieldTag::__index_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IndexOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IndexOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common => {
                            if !fields.insert(__FieldTag::__common) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common",
                                ));
                            }
                            result.common = map
                                .next_value::<std::option::Option<crate::model::CommonMetadata>>(
                                )?;
                        }
                        __FieldTag::__progress_entities => {
                            if !fields.insert(__FieldTag::__progress_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_entities",
                                ));
                            }
                            result.progress_entities =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__index_id => {
                            if !fields.insert(__FieldTag::__index_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_id",
                                ));
                            }
                            result.index_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IndexOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common.is_some() {
            state.serialize_entry("common", &self.common)?;
        }
        if self.progress_entities.is_some() {
            state.serialize_entry("progressEntities", &self.progress_entities)?;
        }
        if !self.index_id.is_empty() {
            state.serialize_entry("indexId", &self.index_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IndexOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IndexOperationMetadata");
        debug_struct.field("common", &self.common);
        debug_struct.field("progress_entities", &self.progress_entities);
        debug_struct.field("index_id", &self.index_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for Datastore to Firestore migration operations.
///
/// The DatastoreFirestoreMigration operation is not started by the end-user via
/// an explicit "creation" method. This is an intentional deviation from the LRO
/// design pattern.
///
/// This singleton resource can be accessed at:
/// "projects/{project_id}/operations/datastore-firestore-migration"
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatastoreFirestoreMigrationMetadata {
    /// The current state of migration from Cloud Datastore to Cloud Firestore in
    /// Datastore mode.
    pub migration_state: crate::model::MigrationState,

    /// The current step of migration from Cloud Datastore to Cloud Firestore in
    /// Datastore mode.
    pub migration_step: crate::model::MigrationStep,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatastoreFirestoreMigrationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_state][crate::model::DatastoreFirestoreMigrationMetadata::migration_state].
    pub fn set_migration_state<T: std::convert::Into<crate::model::MigrationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_state = v.into();
        self
    }

    /// Sets the value of [migration_step][crate::model::DatastoreFirestoreMigrationMetadata::migration_step].
    pub fn set_migration_step<T: std::convert::Into<crate::model::MigrationStep>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_step = v.into();
        self
    }
}

impl wkt::message::Message for DatastoreFirestoreMigrationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.DatastoreFirestoreMigrationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatastoreFirestoreMigrationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migration_state,
            __migration_step,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatastoreFirestoreMigrationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migrationState" => Ok(__FieldTag::__migration_state),
                            "migration_state" => Ok(__FieldTag::__migration_state),
                            "migrationStep" => Ok(__FieldTag::__migration_step),
                            "migration_step" => Ok(__FieldTag::__migration_step),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatastoreFirestoreMigrationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatastoreFirestoreMigrationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migration_state => {
                            if !fields.insert(__FieldTag::__migration_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_state",
                                ));
                            }
                            result.migration_state = map
                                .next_value::<std::option::Option<crate::model::MigrationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migration_step => {
                            if !fields.insert(__FieldTag::__migration_step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_step",
                                ));
                            }
                            result.migration_step = map
                                .next_value::<std::option::Option<crate::model::MigrationStep>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatastoreFirestoreMigrationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.migration_state) {
            state.serialize_entry("migrationState", &self.migration_state)?;
        }
        if !wkt::internal::is_default(&self.migration_step) {
            state.serialize_entry("migrationStep", &self.migration_step)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatastoreFirestoreMigrationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatastoreFirestoreMigrationMetadata");
        debug_struct.field("migration_state", &self.migration_state);
        debug_struct.field("migration_step", &self.migration_step);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Datastore composite index definition.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Index {
    /// Output only. Project ID.
    pub project_id: std::string::String,

    /// Output only. The resource ID of the index.
    pub index_id: std::string::String,

    /// Required. The entity kind to which this index applies.
    pub kind: std::string::String,

    /// Required. The index's ancestor mode.  Must not be
    /// ANCESTOR_MODE_UNSPECIFIED.
    pub ancestor: crate::model::index::AncestorMode,

    /// Required. An ordered sequence of property names and their index attributes.
    ///
    /// Requires:
    ///
    /// * A maximum of 100 properties.
    pub properties: std::vec::Vec<crate::model::index::IndexedProperty>,

    /// Output only. The state of the index.
    pub state: crate::model::index::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::Index::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::Index::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Index::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [ancestor][crate::model::Index::ancestor].
    pub fn set_ancestor<T: std::convert::Into<crate::model::index::AncestorMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.ancestor = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::Index::properties].
    pub fn set_properties<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index::IndexedProperty>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::Index::state].
    pub fn set_state<T: std::convert::Into<crate::model::index::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.Index"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Index {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __index_id,
            __kind,
            __ancestor,
            __properties,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Index")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "indexId" => Ok(__FieldTag::__index_id),
                            "index_id" => Ok(__FieldTag::__index_id),
                            "kind" => Ok(__FieldTag::__kind),
                            "ancestor" => Ok(__FieldTag::__ancestor),
                            "properties" => Ok(__FieldTag::__properties),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Index;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Index")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_id => {
                            if !fields.insert(__FieldTag::__index_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_id",
                                ));
                            }
                            result.index_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ancestor => {
                            if !fields.insert(__FieldTag::__ancestor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ancestor",
                                ));
                            }
                            result.ancestor = map.next_value::<std::option::Option<crate::model::index::AncestorMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::index::IndexedProperty>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::index::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Index {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.index_id.is_empty() {
            state.serialize_entry("indexId", &self.index_id)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.ancestor) {
            state.serialize_entry("ancestor", &self.ancestor)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Index {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Index");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("index_id", &self.index_id);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("ancestor", &self.ancestor);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Index].
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// A property of an index.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IndexedProperty {
        /// Required. The property name to index.
        pub name: std::string::String,

        /// Required. The indexed property's direction.  Must not be
        /// DIRECTION_UNSPECIFIED.
        pub direction: crate::model::index::Direction,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexedProperty {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::index::IndexedProperty::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [direction][crate::model::index::IndexedProperty::direction].
        pub fn set_direction<T: std::convert::Into<crate::model::index::Direction>>(
            mut self,
            v: T,
        ) -> Self {
            self.direction = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexedProperty {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.Index.IndexedProperty"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IndexedProperty {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __direction,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IndexedProperty")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "direction" => Ok(__FieldTag::__direction),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IndexedProperty;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IndexedProperty")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__direction => {
                                if !fields.insert(__FieldTag::__direction) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for direction",
                                    ));
                                }
                                result.direction = map.next_value::<std::option::Option<crate::model::index::Direction>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IndexedProperty {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.direction) {
                state.serialize_entry("direction", &self.direction)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IndexedProperty {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IndexedProperty");
            debug_struct.field("name", &self.name);
            debug_struct.field("direction", &self.direction);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// For an ordered index, specifies whether each of the entity's ancestors
    /// will be included.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AncestorMode {
        /// The ancestor mode is unspecified.
        Unspecified,
        /// Do not include the entity's ancestors in the index.
        None,
        /// Include all the entity's ancestors in the index.
        AllAncestors,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AncestorMode::value] or
        /// [AncestorMode::name].
        UnknownValue(ancestor_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ancestor_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AncestorMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::AllAncestors => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANCESTOR_MODE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::AllAncestors => std::option::Option::Some("ALL_ANCESTORS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AncestorMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AncestorMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AncestorMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::AllAncestors,
                _ => Self::UnknownValue(ancestor_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AncestorMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANCESTOR_MODE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "ALL_ANCESTORS" => Self::AllAncestors,
                _ => Self::UnknownValue(ancestor_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AncestorMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::AllAncestors => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AncestorMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AncestorMode>::new(
                ".google.datastore.admin.v1.Index.AncestorMode",
            ))
        }
    }

    /// The direction determines how a property is indexed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// The direction is unspecified.
        Unspecified,
        /// The property's values are indexed so as to support sequencing in
        /// ascending order and also query by <, >, <=, >=, and =.
        Ascending,
        /// The property's values are indexed so as to support sequencing in
        /// descending order and also query by <, >, <=, >=, and =.
        Descending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ascending => std::option::Option::Some(1),
                Self::Descending => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Ascending => std::option::Option::Some("ASCENDING"),
                Self::Descending => std::option::Option::Some("DESCENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ascending,
                2 => Self::Descending,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "ASCENDING" => Self::Ascending,
                "DESCENDING" => Self::Descending,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ascending => serializer.serialize_i32(1),
                Self::Descending => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.datastore.admin.v1.Index.Direction",
            ))
        }
    }

    /// The possible set of states of an index.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The index is being created, and cannot be used by queries.
        /// There is an active long-running operation for the index.
        /// The index is updated when writing an entity.
        /// Some index data may exist.
        Creating,
        /// The index is ready to be used.
        /// The index is updated when writing an entity.
        /// The index is fully populated from all stored entities it applies to.
        Ready,
        /// The index is being deleted, and cannot be used by queries.
        /// There is an active long-running operation for the index.
        /// The index is not updated when writing an entity.
        /// Some index data may exist.
        Deleting,
        /// The index was being created or deleted, but something went wrong.
        /// The index cannot by used by queries.
        /// There is no active long-running operation for the index,
        /// and the most recently finished long-running operation failed.
        /// The index is not updated when writing an entity.
        /// Some index data may exist.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.datastore.admin.v1.Index.State",
            ))
        }
    }
}

/// An event signifying a change in state of a [migration from Cloud Datastore to
/// Cloud Firestore in Datastore
/// mode](https://cloud.google.com/datastore/docs/upgrade-to-firestore).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationStateEvent {
    /// The new state of the migration.
    pub state: crate::model::MigrationState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationStateEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::MigrationStateEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::MigrationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for MigrationStateEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.MigrationStateEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationStateEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationStateEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationStateEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationStateEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::MigrationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationStateEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationStateEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationStateEvent");
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An event signifying the start of a new step in a [migration from Cloud
/// Datastore to Cloud Firestore in Datastore
/// mode](https://cloud.google.com/datastore/docs/upgrade-to-firestore).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationProgressEvent {
    /// The step that is starting.
    ///
    /// An event with step set to `START` indicates that the migration
    /// has been reverted back to the initial pre-migration state.
    pub step: crate::model::MigrationStep,

    /// Details about this step.
    pub step_details: std::option::Option<crate::model::migration_progress_event::StepDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationProgressEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::MigrationProgressEvent::step].
    pub fn set_step<T: std::convert::Into<crate::model::MigrationStep>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details].
    ///
    /// Note that all the setters affecting `step_details` are mutually
    /// exclusive.
    pub fn set_step_details<
        T: std::convert::Into<
                std::option::Option<crate::model::migration_progress_event::StepDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = v.into();
        self
    }

    /// The value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// if it holds a `PrepareStepDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn prepare_step_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.step_details.as_ref().and_then(|v| match v {
            crate::model::migration_progress_event::StepDetails::PrepareStepDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// to hold a `PrepareStepDetails`.
    ///
    /// Note that all the setters affecting `step_details` are
    /// mutually exclusive.
    pub fn set_prepare_step_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = std::option::Option::Some(
            crate::model::migration_progress_event::StepDetails::PrepareStepDetails(v.into()),
        );
        self
    }

    /// The value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// if it holds a `RedirectWritesStepDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redirect_writes_step_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.step_details.as_ref().and_then(|v| match v {
            crate::model::migration_progress_event::StepDetails::RedirectWritesStepDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// to hold a `RedirectWritesStepDetails`.
    ///
    /// Note that all the setters affecting `step_details` are
    /// mutually exclusive.
    pub fn set_redirect_writes_step_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = std::option::Option::Some(
            crate::model::migration_progress_event::StepDetails::RedirectWritesStepDetails(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for MigrationProgressEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationProgressEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __step,
            __prepare_step_details,
            __redirect_writes_step_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationProgressEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "step" => Ok(__FieldTag::__step),
                            "prepareStepDetails" => Ok(__FieldTag::__prepare_step_details),
                            "prepare_step_details" => Ok(__FieldTag::__prepare_step_details),
                            "redirectWritesStepDetails" => {
                                Ok(__FieldTag::__redirect_writes_step_details)
                            }
                            "redirect_writes_step_details" => {
                                Ok(__FieldTag::__redirect_writes_step_details)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationProgressEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationProgressEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__step => {
                            if !fields.insert(__FieldTag::__step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step",
                                ));
                            }
                            result.step = map
                                .next_value::<std::option::Option<crate::model::MigrationStep>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__prepare_step_details => {
                            if !fields.insert(__FieldTag::__prepare_step_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prepare_step_details",
                                ));
                            }
                            if result.step_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_details`, a oneof with full ID .google.datastore.admin.v1.MigrationProgressEvent.prepare_step_details, latest field was prepareStepDetails",
                                ));
                            }
                            result.step_details = std::option::Option::Some(
                                crate::model::migration_progress_event::StepDetails::PrepareStepDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__redirect_writes_step_details => {
                            if !fields.insert(__FieldTag::__redirect_writes_step_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redirect_writes_step_details",
                                ));
                            }
                            if result.step_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_details`, a oneof with full ID .google.datastore.admin.v1.MigrationProgressEvent.redirect_writes_step_details, latest field was redirectWritesStepDetails",
                                ));
                            }
                            result.step_details = std::option::Option::Some(
                                crate::model::migration_progress_event::StepDetails::RedirectWritesStepDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationProgressEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.step) {
            state.serialize_entry("step", &self.step)?;
        }
        if let Some(value) = self.prepare_step_details() {
            state.serialize_entry("prepareStepDetails", value)?;
        }
        if let Some(value) = self.redirect_writes_step_details() {
            state.serialize_entry("redirectWritesStepDetails", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationProgressEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationProgressEvent");
        debug_struct.field("step", &self.step);
        debug_struct.field("step_details", &self.step_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigrationProgressEvent].
pub mod migration_progress_event {
    #[allow(unused_imports)]
    use super::*;

    /// Details for the `PREPARE` step.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PrepareStepDetails {
        /// The concurrency mode this database will use when it reaches the
        /// `REDIRECT_WRITES` step.
        pub concurrency_mode: crate::model::migration_progress_event::ConcurrencyMode,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrepareStepDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [concurrency_mode][crate::model::migration_progress_event::PrepareStepDetails::concurrency_mode].
        pub fn set_concurrency_mode<
            T: std::convert::Into<crate::model::migration_progress_event::ConcurrencyMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.concurrency_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for PrepareStepDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent.PrepareStepDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PrepareStepDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __concurrency_mode,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PrepareStepDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "concurrencyMode" => Ok(__FieldTag::__concurrency_mode),
                                "concurrency_mode" => Ok(__FieldTag::__concurrency_mode),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PrepareStepDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PrepareStepDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__concurrency_mode => {
                                if !fields.insert(__FieldTag::__concurrency_mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for concurrency_mode",
                                    ));
                                }
                                result.concurrency_mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::migration_progress_event::ConcurrencyMode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PrepareStepDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.concurrency_mode) {
                state.serialize_entry("concurrencyMode", &self.concurrency_mode)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PrepareStepDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PrepareStepDetails");
            debug_struct.field("concurrency_mode", &self.concurrency_mode);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Details for the `REDIRECT_WRITES` step.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RedirectWritesStepDetails {
        /// Ths concurrency mode for this database.
        pub concurrency_mode: crate::model::migration_progress_event::ConcurrencyMode,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RedirectWritesStepDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [concurrency_mode][crate::model::migration_progress_event::RedirectWritesStepDetails::concurrency_mode].
        pub fn set_concurrency_mode<
            T: std::convert::Into<crate::model::migration_progress_event::ConcurrencyMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.concurrency_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for RedirectWritesStepDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent.RedirectWritesStepDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RedirectWritesStepDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __concurrency_mode,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RedirectWritesStepDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "concurrencyMode" => Ok(__FieldTag::__concurrency_mode),
                                "concurrency_mode" => Ok(__FieldTag::__concurrency_mode),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RedirectWritesStepDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RedirectWritesStepDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__concurrency_mode => {
                                if !fields.insert(__FieldTag::__concurrency_mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for concurrency_mode",
                                    ));
                                }
                                result.concurrency_mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::migration_progress_event::ConcurrencyMode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RedirectWritesStepDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.concurrency_mode) {
                state.serialize_entry("concurrencyMode", &self.concurrency_mode)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RedirectWritesStepDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RedirectWritesStepDetails");
            debug_struct.field("concurrency_mode", &self.concurrency_mode);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Concurrency modes for transactions in Cloud Firestore.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConcurrencyMode {
        /// Unspecified.
        Unspecified,
        /// Pessimistic concurrency.
        Pessimistic,
        /// Optimistic concurrency.
        Optimistic,
        /// Optimistic concurrency with entity groups.
        OptimisticWithEntityGroups,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConcurrencyMode::value] or
        /// [ConcurrencyMode::name].
        UnknownValue(concurrency_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod concurrency_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConcurrencyMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pessimistic => std::option::Option::Some(1),
                Self::Optimistic => std::option::Option::Some(2),
                Self::OptimisticWithEntityGroups => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONCURRENCY_MODE_UNSPECIFIED"),
                Self::Pessimistic => std::option::Option::Some("PESSIMISTIC"),
                Self::Optimistic => std::option::Option::Some("OPTIMISTIC"),
                Self::OptimisticWithEntityGroups => {
                    std::option::Option::Some("OPTIMISTIC_WITH_ENTITY_GROUPS")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConcurrencyMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConcurrencyMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConcurrencyMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pessimistic,
                2 => Self::Optimistic,
                3 => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConcurrencyMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONCURRENCY_MODE_UNSPECIFIED" => Self::Unspecified,
                "PESSIMISTIC" => Self::Pessimistic,
                "OPTIMISTIC" => Self::Optimistic,
                "OPTIMISTIC_WITH_ENTITY_GROUPS" => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConcurrencyMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pessimistic => serializer.serialize_i32(1),
                Self::Optimistic => serializer.serialize_i32(2),
                Self::OptimisticWithEntityGroups => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConcurrencyMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConcurrencyMode>::new(
                ".google.datastore.admin.v1.MigrationProgressEvent.ConcurrencyMode",
            ))
        }
    }

    /// Details about this step.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StepDetails {
        /// Details for the `PREPARE` step.
        PrepareStepDetails(
            std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
        ),
        /// Details for the `REDIRECT_WRITES` step.
        RedirectWritesStepDetails(
            std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
        ),
    }
}

/// Operation types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationType {
    /// Unspecified.
    Unspecified,
    /// ExportEntities.
    ExportEntities,
    /// ImportEntities.
    ImportEntities,
    /// CreateIndex.
    CreateIndex,
    /// DeleteIndex.
    DeleteIndex,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationType::value] or
    /// [OperationType::name].
    UnknownValue(operation_type::UnknownValue),
}

#[doc(hidden)]
pub mod operation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ExportEntities => std::option::Option::Some(1),
            Self::ImportEntities => std::option::Option::Some(2),
            Self::CreateIndex => std::option::Option::Some(3),
            Self::DeleteIndex => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATION_TYPE_UNSPECIFIED"),
            Self::ExportEntities => std::option::Option::Some("EXPORT_ENTITIES"),
            Self::ImportEntities => std::option::Option::Some("IMPORT_ENTITIES"),
            Self::CreateIndex => std::option::Option::Some("CREATE_INDEX"),
            Self::DeleteIndex => std::option::Option::Some("DELETE_INDEX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ExportEntities,
            2 => Self::ImportEntities,
            3 => Self::CreateIndex,
            4 => Self::DeleteIndex,
            _ => Self::UnknownValue(operation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "EXPORT_ENTITIES" => Self::ExportEntities,
            "IMPORT_ENTITIES" => Self::ImportEntities,
            "CREATE_INDEX" => Self::CreateIndex,
            "DELETE_INDEX" => Self::DeleteIndex,
            _ => Self::UnknownValue(operation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ExportEntities => serializer.serialize_i32(1),
            Self::ImportEntities => serializer.serialize_i32(2),
            Self::CreateIndex => serializer.serialize_i32(3),
            Self::DeleteIndex => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationType>::new(
            ".google.datastore.admin.v1.OperationType",
        ))
    }
}

/// States for a migration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MigrationState {
    /// Unspecified.
    Unspecified,
    /// The migration is running.
    Running,
    /// The migration is paused.
    Paused,
    /// The migration is complete.
    Complete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MigrationState::value] or
    /// [MigrationState::name].
    UnknownValue(migration_state::UnknownValue),
}

#[doc(hidden)]
pub mod migration_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MigrationState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Running => std::option::Option::Some(1),
            Self::Paused => std::option::Option::Some(2),
            Self::Complete => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MIGRATION_STATE_UNSPECIFIED"),
            Self::Running => std::option::Option::Some("RUNNING"),
            Self::Paused => std::option::Option::Some("PAUSED"),
            Self::Complete => std::option::Option::Some("COMPLETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MigrationState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MigrationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MigrationState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Running,
            2 => Self::Paused,
            3 => Self::Complete,
            _ => Self::UnknownValue(migration_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MigrationState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MIGRATION_STATE_UNSPECIFIED" => Self::Unspecified,
            "RUNNING" => Self::Running,
            "PAUSED" => Self::Paused,
            "COMPLETE" => Self::Complete,
            _ => Self::UnknownValue(migration_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MigrationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Running => serializer.serialize_i32(1),
            Self::Paused => serializer.serialize_i32(2),
            Self::Complete => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MigrationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationState>::new(
            ".google.datastore.admin.v1.MigrationState",
        ))
    }
}

/// Steps in a migration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MigrationStep {
    /// Unspecified.
    Unspecified,
    /// Pre-migration: the database is prepared for migration.
    Prepare,
    /// Start of migration.
    Start,
    /// Writes are applied synchronously to at least one replica.
    ApplyWritesSynchronously,
    /// Data is copied to Cloud Firestore and then verified to match the data in
    /// Cloud Datastore.
    CopyAndVerify,
    /// Eventually-consistent reads are redirected to Cloud Firestore.
    RedirectEventuallyConsistentReads,
    /// Strongly-consistent reads are redirected to Cloud Firestore.
    RedirectStronglyConsistentReads,
    /// Writes are redirected to Cloud Firestore.
    RedirectWrites,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MigrationStep::value] or
    /// [MigrationStep::name].
    UnknownValue(migration_step::UnknownValue),
}

#[doc(hidden)]
pub mod migration_step {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MigrationStep {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Prepare => std::option::Option::Some(6),
            Self::Start => std::option::Option::Some(1),
            Self::ApplyWritesSynchronously => std::option::Option::Some(7),
            Self::CopyAndVerify => std::option::Option::Some(2),
            Self::RedirectEventuallyConsistentReads => std::option::Option::Some(3),
            Self::RedirectStronglyConsistentReads => std::option::Option::Some(4),
            Self::RedirectWrites => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MIGRATION_STEP_UNSPECIFIED"),
            Self::Prepare => std::option::Option::Some("PREPARE"),
            Self::Start => std::option::Option::Some("START"),
            Self::ApplyWritesSynchronously => {
                std::option::Option::Some("APPLY_WRITES_SYNCHRONOUSLY")
            }
            Self::CopyAndVerify => std::option::Option::Some("COPY_AND_VERIFY"),
            Self::RedirectEventuallyConsistentReads => {
                std::option::Option::Some("REDIRECT_EVENTUALLY_CONSISTENT_READS")
            }
            Self::RedirectStronglyConsistentReads => {
                std::option::Option::Some("REDIRECT_STRONGLY_CONSISTENT_READS")
            }
            Self::RedirectWrites => std::option::Option::Some("REDIRECT_WRITES"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MigrationStep {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MigrationStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MigrationStep {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Start,
            2 => Self::CopyAndVerify,
            3 => Self::RedirectEventuallyConsistentReads,
            4 => Self::RedirectStronglyConsistentReads,
            5 => Self::RedirectWrites,
            6 => Self::Prepare,
            7 => Self::ApplyWritesSynchronously,
            _ => Self::UnknownValue(migration_step::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MigrationStep {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MIGRATION_STEP_UNSPECIFIED" => Self::Unspecified,
            "PREPARE" => Self::Prepare,
            "START" => Self::Start,
            "APPLY_WRITES_SYNCHRONOUSLY" => Self::ApplyWritesSynchronously,
            "COPY_AND_VERIFY" => Self::CopyAndVerify,
            "REDIRECT_EVENTUALLY_CONSISTENT_READS" => Self::RedirectEventuallyConsistentReads,
            "REDIRECT_STRONGLY_CONSISTENT_READS" => Self::RedirectStronglyConsistentReads,
            "REDIRECT_WRITES" => Self::RedirectWrites,
            _ => Self::UnknownValue(migration_step::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MigrationStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Prepare => serializer.serialize_i32(6),
            Self::Start => serializer.serialize_i32(1),
            Self::ApplyWritesSynchronously => serializer.serialize_i32(7),
            Self::CopyAndVerify => serializer.serialize_i32(2),
            Self::RedirectEventuallyConsistentReads => serializer.serialize_i32(3),
            Self::RedirectStronglyConsistentReads => serializer.serialize_i32(4),
            Self::RedirectWrites => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MigrationStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationStep>::new(
            ".google.datastore.admin.v1.MigrationStep",
        ))
    }
}
