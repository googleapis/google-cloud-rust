// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Metadata common to all Datastore Admin operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CommonMetadata {
    /// The time that work began on the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation ended, either successfully or otherwise.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The type of the operation. Can be used as a filter in
    /// ListOperationsRequest.
    pub operation_type: crate::model::OperationType,

    /// The client-assigned labels which were provided when the operation was
    /// created. May also include additional labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The current state of the Operation.
    pub state: crate::model::common_metadata::State,
}

impl CommonMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CommonMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CommonMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::CommonMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::OperationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CommonMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::common_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CommonMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CommonMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.CommonMetadata"
    }
}

/// Defines additional types related to CommonMetadata
pub mod common_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The various possible states for an ongoing Operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unspecified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Request is being prepared for processing.
        pub const INITIALIZING: State = State::new(1);

        /// Request is actively being processed.
        pub const PROCESSING: State = State::new(2);

        /// Request is in the process of being cancelled after user called
        /// google.longrunning.Operations.CancelOperation on the operation.
        pub const CANCELLING: State = State::new(3);

        /// Request has been processed and is in its finalization stage.
        pub const FINALIZING: State = State::new(4);

        /// Request has completed successfully.
        pub const SUCCESSFUL: State = State::new(5);

        /// Request has finished being processed, but encountered an error.
        pub const FAILED: State = State::new(6);

        /// Request has finished being cancelled after user called
        /// google.longrunning.Operations.CancelOperation.
        pub const CANCELLED: State = State::new(7);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INITIALIZING"),
                2 => std::borrow::Cow::Borrowed("PROCESSING"),
                3 => std::borrow::Cow::Borrowed("CANCELLING"),
                4 => std::borrow::Cow::Borrowed("FINALIZING"),
                5 => std::borrow::Cow::Borrowed("SUCCESSFUL"),
                6 => std::borrow::Cow::Borrowed("FAILED"),
                7 => std::borrow::Cow::Borrowed("CANCELLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "INITIALIZING" => std::option::Option::Some(Self::INITIALIZING),
                "PROCESSING" => std::option::Option::Some(Self::PROCESSING),
                "CANCELLING" => std::option::Option::Some(Self::CANCELLING),
                "FINALIZING" => std::option::Option::Some(Self::FINALIZING),
                "SUCCESSFUL" => std::option::Option::Some(Self::SUCCESSFUL),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Measures the progress of a particular metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Progress {
    /// The amount of work that has been completed. Note that this may be greater
    /// than work_estimated.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub work_completed: i64,

    /// An estimate of how much work needs to be performed. May be zero if the
    /// work estimate is unavailable.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub work_estimated: i64,
}

impl Progress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [work_completed][crate::model::Progress::work_completed].
    pub fn set_work_completed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.work_completed = v.into();
        self
    }

    /// Sets the value of [work_estimated][crate::model::Progress::work_estimated].
    pub fn set_work_estimated<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.work_estimated = v.into();
        self
    }
}

impl wkt::message::Message for Progress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.Progress"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities][google.datastore.admin.v1.DatastoreAdmin.ExportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities]: crate::client::DatastoreAdmin::export_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEntitiesRequest {
    /// Required. Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Client-assigned labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Description of what data from the project is included in the export.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// Required. Location for the export metadata and data files.
    ///
    /// The full resource URL of the external storage location. Currently, only
    /// Google Cloud Storage is supported. So output_url_prefix should be of the
    /// form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the
    /// name of the Cloud Storage bucket and `NAMESPACE_PATH` is an optional Cloud
    /// Storage namespace path (this is not a Cloud Datastore namespace). For more
    /// information about Cloud Storage namespace paths, see
    /// [Object name
    /// considerations](https://cloud.google.com/storage/docs/naming#object-considerations).
    ///
    /// The resulting files will be nested deeper than the specified URL prefix.
    /// The final output URL will be provided in the
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url]
    /// field. That value should be used for subsequent ImportEntities operations.
    ///
    /// By nesting the data files deeper, the same Cloud Storage bucket can be used
    /// in multiple ExportEntities operations without conflict.
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_url_prefix: std::string::String,
}

impl ExportEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ExportEntitiesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ExportEntitiesRequest::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }

    /// Sets the value of [output_url_prefix][crate::model::ExportEntitiesRequest::output_url_prefix].
    pub fn set_output_url_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_url_prefix = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ExportEntitiesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ExportEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ImportEntities][google.datastore.admin.v1.DatastoreAdmin.ImportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ImportEntities]: crate::client::DatastoreAdmin::import_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportEntitiesRequest {
    /// Required. Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Client-assigned labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The full resource URL of the external storage location.
    /// Currently, only Google Cloud Storage is supported. So input_url should be
    /// of the form:
    /// `gs://BUCKET_NAME[/NAMESPACE_PATH]/OVERALL_EXPORT_METADATA_FILE`, where
    /// `BUCKET_NAME` is the name of the Cloud Storage bucket, `NAMESPACE_PATH` is
    /// an optional Cloud Storage namespace path (this is not a Cloud Datastore
    /// namespace), and `OVERALL_EXPORT_METADATA_FILE` is the metadata file written
    /// by the ExportEntities operation. For more information about Cloud Storage
    /// namespace paths, see
    /// [Object name
    /// considerations](https://cloud.google.com/storage/docs/naming#object-considerations).
    ///
    /// For more information, see
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url].
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_url: std::string::String,

    /// Optionally specify which kinds/namespaces are to be imported. If provided,
    /// the list must be a subset of the EntityFilter used in creating the export,
    /// otherwise a FAILED_PRECONDITION error will be returned. If no filter is
    /// specified then all entities from the export are imported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,
}

impl ImportEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ImportEntitiesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [input_url][crate::model::ImportEntitiesRequest::input_url].
    pub fn set_input_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_url = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ImportEntitiesRequest::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ImportEntitiesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ImportEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ImportEntitiesRequest"
    }
}

/// The response for
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities][google.datastore.admin.v1.DatastoreAdmin.ExportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities]: crate::client::DatastoreAdmin::export_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEntitiesResponse {
    /// Location of the output metadata file. This can be used to begin an import
    /// into Cloud Datastore (this project or another project). See
    /// [google.datastore.admin.v1.ImportEntitiesRequest.input_url][google.datastore.admin.v1.ImportEntitiesRequest.input_url].
    /// Only present if the operation completed successfully.
    ///
    /// [google.datastore.admin.v1.ImportEntitiesRequest.input_url]: crate::model::ImportEntitiesRequest::input_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_url: std::string::String,
}

impl ExportEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_url][crate::model::ExportEntitiesResponse::output_url].
    pub fn set_output_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_url = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesResponse"
    }
}

/// Metadata for ExportEntities operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEntitiesMetadata {
    /// Metadata common to all Datastore Admin operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// An estimate of the number of bytes processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Description of which entities are being exported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// Location for the export metadata and data files. This will be the same
    /// value as the
    /// [google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix][google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix]
    /// field. The final output location is provided in
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url].
    ///
    /// [google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix]: crate::model::ExportEntitiesRequest::output_url_prefix
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_url_prefix: std::string::String,
}

impl ExportEntitiesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::ExportEntitiesMetadata::common].
    pub fn set_common<T: std::convert::Into<std::option::Option<crate::model::CommonMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.common = v.into();
        self
    }

    /// Sets the value of [progress_entities][crate::model::ExportEntitiesMetadata::progress_entities].
    pub fn set_progress_entities<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_entities = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ExportEntitiesMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ExportEntitiesMetadata::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }

    /// Sets the value of [output_url_prefix][crate::model::ExportEntitiesMetadata::output_url_prefix].
    pub fn set_output_url_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_url_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesMetadata"
    }
}

/// Metadata for ImportEntities operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportEntitiesMetadata {
    /// Metadata common to all Datastore Admin operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// An estimate of the number of bytes processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Description of which entities are being imported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// The location of the import metadata file. This will be the same value as
    /// the
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url]
    /// field.
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_url: std::string::String,
}

impl ImportEntitiesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::ImportEntitiesMetadata::common].
    pub fn set_common<T: std::convert::Into<std::option::Option<crate::model::CommonMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.common = v.into();
        self
    }

    /// Sets the value of [progress_entities][crate::model::ImportEntitiesMetadata::progress_entities].
    pub fn set_progress_entities<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_entities = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ImportEntitiesMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ImportEntitiesMetadata::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }

    /// Sets the value of [input_url][crate::model::ImportEntitiesMetadata::input_url].
    pub fn set_input_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_url = v.into();
        self
    }
}

impl wkt::message::Message for ImportEntitiesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ImportEntitiesMetadata"
    }
}

/// Identifies a subset of entities in a project. This is specified as
/// combinations of kinds and namespaces (either or both of which may be all, as
/// described in the following examples).
/// Example usage:
///
/// Entire project:
/// kinds=[], namespace_ids=[]
///
/// Kinds Foo and Bar in all namespaces:
/// kinds=['Foo', 'Bar'], namespace_ids=[]
///
/// Kinds Foo and Bar only in the default namespace:
/// kinds=['Foo', 'Bar'], namespace_ids=['']
///
/// Kinds Foo and Bar in both the default and Baz namespaces:
/// kinds=['Foo', 'Bar'], namespace_ids=['', 'Baz']
///
/// The entire Baz namespace:
/// kinds=[], namespace_ids=['Baz']
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityFilter {
    /// If empty, then this represents all kinds.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub kinds: std::vec::Vec<std::string::String>,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for projects that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the project has data in non-default namespaces, but doesn't want to
    /// include them.
    /// Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,
}

impl EntityFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kinds][crate::model::EntityFilter::kinds].
    pub fn set_kinds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kinds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::EntityFilter::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.EntityFilter"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.CreateIndex][google.datastore.admin.v1.DatastoreAdmin.CreateIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.CreateIndex]: crate::client::DatastoreAdmin::create_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The index to create. The name and state fields are output only and will be
    /// ignored. Single property indexes cannot be created or deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,
}

impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.CreateIndexRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.DeleteIndex][google.datastore.admin.v1.DatastoreAdmin.DeleteIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.DeleteIndex]: crate::client::DatastoreAdmin::delete_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The resource ID of the index to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,
}

impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::DeleteIndexRequest::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.DeleteIndexRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.GetIndex][google.datastore.admin.v1.DatastoreAdmin.GetIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.GetIndex]: crate::client::DatastoreAdmin::get_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The resource ID of the index to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,
}

impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::GetIndexRequest::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.GetIndexRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes][google.datastore.admin.v1.DatastoreAdmin.ListIndexes].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes]: crate::client::DatastoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of items to return.  If zero, then all results will be
    /// returned.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListIndexesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ListIndexesRequest"
    }
}

/// The response for
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes][google.datastore.admin.v1.DatastoreAdmin.ListIndexes].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes]: crate::client::DatastoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// The indexes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ListIndexesResponse"
    }
}

impl gax::paginator::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Metadata for Index operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexOperationMetadata {
    /// Metadata common to all Datastore Admin operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// The index resource ID that this operation is acting on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,
}

impl IndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::IndexOperationMetadata::common].
    pub fn set_common<T: std::convert::Into<std::option::Option<crate::model::CommonMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.common = v.into();
        self
    }

    /// Sets the value of [progress_entities][crate::model::IndexOperationMetadata::progress_entities].
    pub fn set_progress_entities<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_entities = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::IndexOperationMetadata::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for IndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.IndexOperationMetadata"
    }
}

/// Metadata for Datastore to Firestore migration operations.
///
/// The DatastoreFirestoreMigration operation is not started by the end-user via
/// an explicit "creation" method. This is an intentional deviation from the LRO
/// design pattern.
///
/// This singleton resource can be accessed at:
/// "projects/{project_id}/operations/datastore-firestore-migration"
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatastoreFirestoreMigrationMetadata {
    /// The current state of migration from Cloud Datastore to Cloud Firestore in
    /// Datastore mode.
    pub migration_state: crate::model::MigrationState,

    /// The current step of migration from Cloud Datastore to Cloud Firestore in
    /// Datastore mode.
    pub migration_step: crate::model::MigrationStep,
}

impl DatastoreFirestoreMigrationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_state][crate::model::DatastoreFirestoreMigrationMetadata::migration_state].
    pub fn set_migration_state<T: std::convert::Into<crate::model::MigrationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_state = v.into();
        self
    }

    /// Sets the value of [migration_step][crate::model::DatastoreFirestoreMigrationMetadata::migration_step].
    pub fn set_migration_step<T: std::convert::Into<crate::model::MigrationStep>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_step = v.into();
        self
    }
}

impl wkt::message::Message for DatastoreFirestoreMigrationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.DatastoreFirestoreMigrationMetadata"
    }
}

/// Datastore composite index definition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Index {
    /// Output only. Project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Output only. The resource ID of the index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,

    /// Required. The entity kind to which this index applies.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Required. The index's ancestor mode.  Must not be
    /// ANCESTOR_MODE_UNSPECIFIED.
    pub ancestor: crate::model::index::AncestorMode,

    /// Required. An ordered sequence of property names and their index attributes.
    ///
    /// Requires:
    ///
    /// * A maximum of 100 properties.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub properties: std::vec::Vec<crate::model::index::IndexedProperty>,

    /// Output only. The state of the index.
    pub state: crate::model::index::State,
}

impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::Index::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::Index::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Index::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [ancestor][crate::model::Index::ancestor].
    pub fn set_ancestor<T: std::convert::Into<crate::model::index::AncestorMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.ancestor = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Index::state].
    pub fn set_state<T: std::convert::Into<crate::model::index::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::Index::properties].
    pub fn set_properties<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index::IndexedProperty>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.Index"
    }
}

/// Defines additional types related to Index
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// A property of an index.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexedProperty {
        /// Required. The property name to index.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Required. The indexed property's direction.  Must not be
        /// DIRECTION_UNSPECIFIED.
        pub direction: crate::model::index::Direction,
    }

    impl IndexedProperty {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::index::IndexedProperty::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [direction][crate::model::index::IndexedProperty::direction].
        pub fn set_direction<T: std::convert::Into<crate::model::index::Direction>>(
            mut self,
            v: T,
        ) -> Self {
            self.direction = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexedProperty {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.Index.IndexedProperty"
        }
    }

    /// For an ordered index, specifies whether each of the entity's ancestors
    /// will be included.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AncestorMode(i32);

    impl AncestorMode {
        /// The ancestor mode is unspecified.
        pub const ANCESTOR_MODE_UNSPECIFIED: AncestorMode = AncestorMode::new(0);

        /// Do not include the entity's ancestors in the index.
        pub const NONE: AncestorMode = AncestorMode::new(1);

        /// Include all the entity's ancestors in the index.
        pub const ALL_ANCESTORS: AncestorMode = AncestorMode::new(2);

        /// Creates a new AncestorMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ANCESTOR_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NONE"),
                2 => std::borrow::Cow::Borrowed("ALL_ANCESTORS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ANCESTOR_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ANCESTOR_MODE_UNSPECIFIED)
                }
                "NONE" => std::option::Option::Some(Self::NONE),
                "ALL_ANCESTORS" => std::option::Option::Some(Self::ALL_ANCESTORS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AncestorMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AncestorMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The direction determines how a property is indexed.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Direction(i32);

    impl Direction {
        /// The direction is unspecified.
        pub const DIRECTION_UNSPECIFIED: Direction = Direction::new(0);

        /// The property's values are indexed so as to support sequencing in
        /// ascending order and also query by <, >, <=, >=, and =.
        pub const ASCENDING: Direction = Direction::new(1);

        /// The property's values are indexed so as to support sequencing in
        /// descending order and also query by <, >, <=, >=, and =.
        pub const DESCENDING: Direction = Direction::new(2);

        /// Creates a new Direction instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DIRECTION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ASCENDING"),
                2 => std::borrow::Cow::Borrowed("DESCENDING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DIRECTION_UNSPECIFIED" => std::option::Option::Some(Self::DIRECTION_UNSPECIFIED),
                "ASCENDING" => std::option::Option::Some(Self::ASCENDING),
                "DESCENDING" => std::option::Option::Some(Self::DESCENDING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The possible set of states of an index.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The state is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The index is being created, and cannot be used by queries.
        /// There is an active long-running operation for the index.
        /// The index is updated when writing an entity.
        /// Some index data may exist.
        pub const CREATING: State = State::new(1);

        /// The index is ready to be used.
        /// The index is updated when writing an entity.
        /// The index is fully populated from all stored entities it applies to.
        pub const READY: State = State::new(2);

        /// The index is being deleted, and cannot be used by queries.
        /// There is an active long-running operation for the index.
        /// The index is not updated when writing an entity.
        /// Some index data may exist.
        pub const DELETING: State = State::new(3);

        /// The index was being created or deleted, but something went wrong.
        /// The index cannot by used by queries.
        /// There is no active long-running operation for the index,
        /// and the most recently finished long-running operation failed.
        /// The index is not updated when writing an entity.
        /// Some index data may exist.
        pub const ERROR: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("DELETING"),
                4 => std::borrow::Cow::Borrowed("ERROR"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An event signifying a change in state of a [migration from Cloud Datastore to
/// Cloud Firestore in Datastore
/// mode](https://cloud.google.com/datastore/docs/upgrade-to-firestore).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationStateEvent {
    /// The new state of the migration.
    pub state: crate::model::MigrationState,
}

impl MigrationStateEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::MigrationStateEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::MigrationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for MigrationStateEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.MigrationStateEvent"
    }
}

/// An event signifying the start of a new step in a [migration from Cloud
/// Datastore to Cloud Firestore in Datastore
/// mode](https://cloud.google.com/datastore/docs/upgrade-to-firestore).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationProgressEvent {
    /// The step that is starting.
    ///
    /// An event with step set to `START` indicates that the migration
    /// has been reverted back to the initial pre-migration state.
    pub step: crate::model::MigrationStep,

    /// Details about this step.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub step_details: std::option::Option<crate::model::migration_progress_event::StepDetails>,
}

impl MigrationProgressEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::MigrationProgressEvent::step].
    pub fn set_step<T: std::convert::Into<crate::model::MigrationStep>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of `step_details`.
    pub fn set_step_details<
        T: std::convert::Into<
            std::option::Option<crate::model::migration_progress_event::StepDetails>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = v.into();
        self
    }

    /// The value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// if it holds a `PrepareStepDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_prepare_step_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.step_details.as_ref().and_then(|v| match v {
            crate::model::migration_progress_event::StepDetails::PrepareStepDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// if it holds a `RedirectWritesStepDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_redirect_writes_step_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.step_details.as_ref().and_then(|v| match v {
            crate::model::migration_progress_event::StepDetails::RedirectWritesStepDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// to hold a `PrepareStepDetails`.
    ///
    /// Note that all the setters affecting `step_details` are
    /// mutually exclusive.
    pub fn set_prepare_step_details<
        T: std::convert::Into<
            std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = std::option::Option::Some(
            crate::model::migration_progress_event::StepDetails::PrepareStepDetails(v.into()),
        );
        self
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// to hold a `RedirectWritesStepDetails`.
    ///
    /// Note that all the setters affecting `step_details` are
    /// mutually exclusive.
    pub fn set_redirect_writes_step_details<
        T: std::convert::Into<
            std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = std::option::Option::Some(
            crate::model::migration_progress_event::StepDetails::RedirectWritesStepDetails(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for MigrationProgressEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent"
    }
}

/// Defines additional types related to MigrationProgressEvent
pub mod migration_progress_event {
    #[allow(unused_imports)]
    use super::*;

    /// Details for the `PREPARE` step.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrepareStepDetails {
        /// The concurrency mode this database will use when it reaches the
        /// `REDIRECT_WRITES` step.
        pub concurrency_mode: crate::model::migration_progress_event::ConcurrencyMode,
    }

    impl PrepareStepDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [concurrency_mode][crate::model::migration_progress_event::PrepareStepDetails::concurrency_mode].
        pub fn set_concurrency_mode<
            T: std::convert::Into<crate::model::migration_progress_event::ConcurrencyMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.concurrency_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for PrepareStepDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent.PrepareStepDetails"
        }
    }

    /// Details for the `REDIRECT_WRITES` step.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RedirectWritesStepDetails {
        /// Ths concurrency mode for this database.
        pub concurrency_mode: crate::model::migration_progress_event::ConcurrencyMode,
    }

    impl RedirectWritesStepDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [concurrency_mode][crate::model::migration_progress_event::RedirectWritesStepDetails::concurrency_mode].
        pub fn set_concurrency_mode<
            T: std::convert::Into<crate::model::migration_progress_event::ConcurrencyMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.concurrency_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for RedirectWritesStepDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent.RedirectWritesStepDetails"
        }
    }

    /// Concurrency modes for transactions in Cloud Firestore.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConcurrencyMode(i32);

    impl ConcurrencyMode {
        /// Unspecified.
        pub const CONCURRENCY_MODE_UNSPECIFIED: ConcurrencyMode = ConcurrencyMode::new(0);

        /// Pessimistic concurrency.
        pub const PESSIMISTIC: ConcurrencyMode = ConcurrencyMode::new(1);

        /// Optimistic concurrency.
        pub const OPTIMISTIC: ConcurrencyMode = ConcurrencyMode::new(2);

        /// Optimistic concurrency with entity groups.
        pub const OPTIMISTIC_WITH_ENTITY_GROUPS: ConcurrencyMode = ConcurrencyMode::new(3);

        /// Creates a new ConcurrencyMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONCURRENCY_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PESSIMISTIC"),
                2 => std::borrow::Cow::Borrowed("OPTIMISTIC"),
                3 => std::borrow::Cow::Borrowed("OPTIMISTIC_WITH_ENTITY_GROUPS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONCURRENCY_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONCURRENCY_MODE_UNSPECIFIED)
                }
                "PESSIMISTIC" => std::option::Option::Some(Self::PESSIMISTIC),
                "OPTIMISTIC" => std::option::Option::Some(Self::OPTIMISTIC),
                "OPTIMISTIC_WITH_ENTITY_GROUPS" => {
                    std::option::Option::Some(Self::OPTIMISTIC_WITH_ENTITY_GROUPS)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConcurrencyMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConcurrencyMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Details about this step.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum StepDetails {
        /// Details for the `PREPARE` step.
        PrepareStepDetails(
            std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
        ),
        /// Details for the `REDIRECT_WRITES` step.
        RedirectWritesStepDetails(
            std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
        ),
    }
}

/// Operation types.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct OperationType(i32);

impl OperationType {
    /// Unspecified.
    pub const OPERATION_TYPE_UNSPECIFIED: OperationType = OperationType::new(0);

    /// ExportEntities.
    pub const EXPORT_ENTITIES: OperationType = OperationType::new(1);

    /// ImportEntities.
    pub const IMPORT_ENTITIES: OperationType = OperationType::new(2);

    /// CreateIndex.
    pub const CREATE_INDEX: OperationType = OperationType::new(3);

    /// DeleteIndex.
    pub const DELETE_INDEX: OperationType = OperationType::new(4);

    /// Creates a new OperationType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("OPERATION_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("EXPORT_ENTITIES"),
            2 => std::borrow::Cow::Borrowed("IMPORT_ENTITIES"),
            3 => std::borrow::Cow::Borrowed("CREATE_INDEX"),
            4 => std::borrow::Cow::Borrowed("DELETE_INDEX"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "OPERATION_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::OPERATION_TYPE_UNSPECIFIED)
            }
            "EXPORT_ENTITIES" => std::option::Option::Some(Self::EXPORT_ENTITIES),
            "IMPORT_ENTITIES" => std::option::Option::Some(Self::IMPORT_ENTITIES),
            "CREATE_INDEX" => std::option::Option::Some(Self::CREATE_INDEX),
            "DELETE_INDEX" => std::option::Option::Some(Self::DELETE_INDEX),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for OperationType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for OperationType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// States for a migration.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MigrationState(i32);

impl MigrationState {
    /// Unspecified.
    pub const MIGRATION_STATE_UNSPECIFIED: MigrationState = MigrationState::new(0);

    /// The migration is running.
    pub const RUNNING: MigrationState = MigrationState::new(1);

    /// The migration is paused.
    pub const PAUSED: MigrationState = MigrationState::new(2);

    /// The migration is complete.
    pub const COMPLETE: MigrationState = MigrationState::new(3);

    /// Creates a new MigrationState instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MIGRATION_STATE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("RUNNING"),
            2 => std::borrow::Cow::Borrowed("PAUSED"),
            3 => std::borrow::Cow::Borrowed("COMPLETE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MIGRATION_STATE_UNSPECIFIED" => {
                std::option::Option::Some(Self::MIGRATION_STATE_UNSPECIFIED)
            }
            "RUNNING" => std::option::Option::Some(Self::RUNNING),
            "PAUSED" => std::option::Option::Some(Self::PAUSED),
            "COMPLETE" => std::option::Option::Some(Self::COMPLETE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for MigrationState {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for MigrationState {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Steps in a migration.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MigrationStep(i32);

impl MigrationStep {
    /// Unspecified.
    pub const MIGRATION_STEP_UNSPECIFIED: MigrationStep = MigrationStep::new(0);

    /// Pre-migration: the database is prepared for migration.
    pub const PREPARE: MigrationStep = MigrationStep::new(6);

    /// Start of migration.
    pub const START: MigrationStep = MigrationStep::new(1);

    /// Writes are applied synchronously to at least one replica.
    pub const APPLY_WRITES_SYNCHRONOUSLY: MigrationStep = MigrationStep::new(7);

    /// Data is copied to Cloud Firestore and then verified to match the data in
    /// Cloud Datastore.
    pub const COPY_AND_VERIFY: MigrationStep = MigrationStep::new(2);

    /// Eventually-consistent reads are redirected to Cloud Firestore.
    pub const REDIRECT_EVENTUALLY_CONSISTENT_READS: MigrationStep = MigrationStep::new(3);

    /// Strongly-consistent reads are redirected to Cloud Firestore.
    pub const REDIRECT_STRONGLY_CONSISTENT_READS: MigrationStep = MigrationStep::new(4);

    /// Writes are redirected to Cloud Firestore.
    pub const REDIRECT_WRITES: MigrationStep = MigrationStep::new(5);

    /// Creates a new MigrationStep instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MIGRATION_STEP_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("START"),
            2 => std::borrow::Cow::Borrowed("COPY_AND_VERIFY"),
            3 => std::borrow::Cow::Borrowed("REDIRECT_EVENTUALLY_CONSISTENT_READS"),
            4 => std::borrow::Cow::Borrowed("REDIRECT_STRONGLY_CONSISTENT_READS"),
            5 => std::borrow::Cow::Borrowed("REDIRECT_WRITES"),
            6 => std::borrow::Cow::Borrowed("PREPARE"),
            7 => std::borrow::Cow::Borrowed("APPLY_WRITES_SYNCHRONOUSLY"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MIGRATION_STEP_UNSPECIFIED" => {
                std::option::Option::Some(Self::MIGRATION_STEP_UNSPECIFIED)
            }
            "PREPARE" => std::option::Option::Some(Self::PREPARE),
            "START" => std::option::Option::Some(Self::START),
            "APPLY_WRITES_SYNCHRONOUSLY" => {
                std::option::Option::Some(Self::APPLY_WRITES_SYNCHRONOUSLY)
            }
            "COPY_AND_VERIFY" => std::option::Option::Some(Self::COPY_AND_VERIFY),
            "REDIRECT_EVENTUALLY_CONSISTENT_READS" => {
                std::option::Option::Some(Self::REDIRECT_EVENTUALLY_CONSISTENT_READS)
            }
            "REDIRECT_STRONGLY_CONSISTENT_READS" => {
                std::option::Option::Some(Self::REDIRECT_STRONGLY_CONSISTENT_READS)
            }
            "REDIRECT_WRITES" => std::option::Option::Some(Self::REDIRECT_WRITES),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for MigrationStep {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for MigrationStep {
    fn default() -> Self {
        Self::new(0)
    }
}
