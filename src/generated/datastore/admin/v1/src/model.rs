// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Metadata common to all Datastore Admin operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CommonMetadata {
    /// The time that work began on the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation ended, either successfully or otherwise.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The type of the operation. Can be used as a filter in
    /// ListOperationsRequest.
    pub operation_type: crate::model::OperationType,

    /// The client-assigned labels which were provided when the operation was
    /// created. May also include additional labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The current state of the Operation.
    pub state: crate::model::common_metadata::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommonMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CommonMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CommonMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::CommonMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::OperationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CommonMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::CommonMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::common_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for CommonMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.CommonMetadata"
    }
}

/// Defines additional types related to [CommonMetadata].
pub mod common_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The various possible states for an ongoing Operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// Request is being prepared for processing.
        Initializing,
        /// Request is actively being processed.
        Processing,
        /// Request is in the process of being cancelled after user called
        /// google.longrunning.Operations.CancelOperation on the operation.
        Cancelling,
        /// Request has been processed and is in its finalization stage.
        Finalizing,
        /// Request has completed successfully.
        Successful,
        /// Request has finished being processed, but encountered an error.
        Failed,
        /// Request has finished being cancelled after user called
        /// google.longrunning.Operations.CancelOperation.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Initializing => std::option::Option::Some(1),
                Self::Processing => std::option::Option::Some(2),
                Self::Cancelling => std::option::Option::Some(3),
                Self::Finalizing => std::option::Option::Some(4),
                Self::Successful => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Cancelled => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Initializing => std::option::Option::Some("INITIALIZING"),
                Self::Processing => std::option::Option::Some("PROCESSING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Finalizing => std::option::Option::Some("FINALIZING"),
                Self::Successful => std::option::Option::Some("SUCCESSFUL"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Initializing,
                2 => Self::Processing,
                3 => Self::Cancelling,
                4 => Self::Finalizing,
                5 => Self::Successful,
                6 => Self::Failed,
                7 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INITIALIZING" => Self::Initializing,
                "PROCESSING" => Self::Processing,
                "CANCELLING" => Self::Cancelling,
                "FINALIZING" => Self::Finalizing,
                "SUCCESSFUL" => Self::Successful,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Initializing => serializer.serialize_i32(1),
                Self::Processing => serializer.serialize_i32(2),
                Self::Cancelling => serializer.serialize_i32(3),
                Self::Finalizing => serializer.serialize_i32(4),
                Self::Successful => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Cancelled => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.datastore.admin.v1.CommonMetadata.State",
            ))
        }
    }
}

/// Measures the progress of a particular metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Progress {
    /// The amount of work that has been completed. Note that this may be greater
    /// than work_estimated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub work_completed: i64,

    /// An estimate of how much work needs to be performed. May be zero if the
    /// work estimate is unavailable.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub work_estimated: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Progress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [work_completed][crate::model::Progress::work_completed].
    pub fn set_work_completed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.work_completed = v.into();
        self
    }

    /// Sets the value of [work_estimated][crate::model::Progress::work_estimated].
    pub fn set_work_estimated<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.work_estimated = v.into();
        self
    }
}

impl wkt::message::Message for Progress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.Progress"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities][google.datastore.admin.v1.DatastoreAdmin.ExportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities]: crate::client::DatastoreAdmin::export_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEntitiesRequest {
    /// Required. Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Client-assigned labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Description of what data from the project is included in the export.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// Required. Location for the export metadata and data files.
    ///
    /// The full resource URL of the external storage location. Currently, only
    /// Google Cloud Storage is supported. So output_url_prefix should be of the
    /// form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the
    /// name of the Cloud Storage bucket and `NAMESPACE_PATH` is an optional Cloud
    /// Storage namespace path (this is not a Cloud Datastore namespace). For more
    /// information about Cloud Storage namespace paths, see
    /// [Object name
    /// considerations](https://cloud.google.com/storage/docs/naming#object-considerations).
    ///
    /// The resulting files will be nested deeper than the specified URL prefix.
    /// The final output URL will be provided in the
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url]
    /// field. That value should be used for subsequent ImportEntities operations.
    ///
    /// By nesting the data files deeper, the same Cloud Storage bucket can be used
    /// in multiple ExportEntities operations without conflict.
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_url_prefix: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ExportEntitiesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ExportEntitiesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ExportEntitiesRequest::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }

    /// Sets the value of [output_url_prefix][crate::model::ExportEntitiesRequest::output_url_prefix].
    pub fn set_output_url_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_url_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ImportEntities][google.datastore.admin.v1.DatastoreAdmin.ImportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ImportEntities]: crate::client::DatastoreAdmin::import_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportEntitiesRequest {
    /// Required. Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Client-assigned labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The full resource URL of the external storage location.
    /// Currently, only Google Cloud Storage is supported. So input_url should be
    /// of the form:
    /// `gs://BUCKET_NAME[/NAMESPACE_PATH]/OVERALL_EXPORT_METADATA_FILE`, where
    /// `BUCKET_NAME` is the name of the Cloud Storage bucket, `NAMESPACE_PATH` is
    /// an optional Cloud Storage namespace path (this is not a Cloud Datastore
    /// namespace), and `OVERALL_EXPORT_METADATA_FILE` is the metadata file written
    /// by the ExportEntities operation. For more information about Cloud Storage
    /// namespace paths, see
    /// [Object name
    /// considerations](https://cloud.google.com/storage/docs/naming#object-considerations).
    ///
    /// For more information, see
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url].
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_url: std::string::String,

    /// Optionally specify which kinds/namespaces are to be imported. If provided,
    /// the list must be a subset of the EntityFilter used in creating the export,
    /// otherwise a FAILED_PRECONDITION error will be returned. If no filter is
    /// specified then all entities from the export are imported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ImportEntitiesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ImportEntitiesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [input_url][crate::model::ImportEntitiesRequest::input_url].
    pub fn set_input_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_url = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ImportEntitiesRequest::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }
}

impl wkt::message::Message for ImportEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ImportEntitiesRequest"
    }
}

/// The response for
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities][google.datastore.admin.v1.DatastoreAdmin.ExportEntities].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ExportEntities]: crate::client::DatastoreAdmin::export_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEntitiesResponse {
    /// Location of the output metadata file. This can be used to begin an import
    /// into Cloud Datastore (this project or another project). See
    /// [google.datastore.admin.v1.ImportEntitiesRequest.input_url][google.datastore.admin.v1.ImportEntitiesRequest.input_url].
    /// Only present if the operation completed successfully.
    ///
    /// [google.datastore.admin.v1.ImportEntitiesRequest.input_url]: crate::model::ImportEntitiesRequest::input_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_url][crate::model::ExportEntitiesResponse::output_url].
    pub fn set_output_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_url = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesResponse"
    }
}

/// Metadata for ExportEntities operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEntitiesMetadata {
    /// Metadata common to all Datastore Admin operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// An estimate of the number of bytes processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Description of which entities are being exported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// Location for the export metadata and data files. This will be the same
    /// value as the
    /// [google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix][google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix]
    /// field. The final output location is provided in
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url].
    ///
    /// [google.datastore.admin.v1.ExportEntitiesRequest.output_url_prefix]: crate::model::ExportEntitiesRequest::output_url_prefix
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_url_prefix: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportEntitiesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::ExportEntitiesMetadata::common].
    pub fn set_common<T: std::convert::Into<std::option::Option<crate::model::CommonMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.common = v.into();
        self
    }

    /// Sets the value of [progress_entities][crate::model::ExportEntitiesMetadata::progress_entities].
    pub fn set_progress_entities<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_entities = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ExportEntitiesMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ExportEntitiesMetadata::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }

    /// Sets the value of [output_url_prefix][crate::model::ExportEntitiesMetadata::output_url_prefix].
    pub fn set_output_url_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_url_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportEntitiesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ExportEntitiesMetadata"
    }
}

/// Metadata for ImportEntities operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportEntitiesMetadata {
    /// Metadata common to all Datastore Admin operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// An estimate of the number of bytes processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Description of which entities are being imported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_filter: std::option::Option<crate::model::EntityFilter>,

    /// The location of the import metadata file. This will be the same value as
    /// the
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url][google.datastore.admin.v1.ExportEntitiesResponse.output_url]
    /// field.
    ///
    /// [google.datastore.admin.v1.ExportEntitiesResponse.output_url]: crate::model::ExportEntitiesResponse::output_url
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportEntitiesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::ImportEntitiesMetadata::common].
    pub fn set_common<T: std::convert::Into<std::option::Option<crate::model::CommonMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.common = v.into();
        self
    }

    /// Sets the value of [progress_entities][crate::model::ImportEntitiesMetadata::progress_entities].
    pub fn set_progress_entities<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_entities = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ImportEntitiesMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [entity_filter][crate::model::ImportEntitiesMetadata::entity_filter].
    pub fn set_entity_filter<
        T: std::convert::Into<std::option::Option<crate::model::EntityFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_filter = v.into();
        self
    }

    /// Sets the value of [input_url][crate::model::ImportEntitiesMetadata::input_url].
    pub fn set_input_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_url = v.into();
        self
    }
}

impl wkt::message::Message for ImportEntitiesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ImportEntitiesMetadata"
    }
}

/// Identifies a subset of entities in a project. This is specified as
/// combinations of kinds and namespaces (either or both of which may be all, as
/// described in the following examples).
/// Example usage:
///
/// Entire project:
/// kinds=[], namespace_ids=[]
///
/// Kinds Foo and Bar in all namespaces:
/// kinds=['Foo', 'Bar'], namespace_ids=[]
///
/// Kinds Foo and Bar only in the default namespace:
/// kinds=['Foo', 'Bar'], namespace_ids=['']
///
/// Kinds Foo and Bar in both the default and Baz namespaces:
/// kinds=['Foo', 'Bar'], namespace_ids=['', 'Baz']
///
/// The entire Baz namespace:
/// kinds=[], namespace_ids=['Baz']
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityFilter {
    /// If empty, then this represents all kinds.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub kinds: std::vec::Vec<std::string::String>,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for projects that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the project has data in non-default namespaces, but doesn't want to
    /// include them.
    /// Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kinds][crate::model::EntityFilter::kinds].
    pub fn set_kinds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kinds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::EntityFilter::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.EntityFilter"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.CreateIndex][google.datastore.admin.v1.DatastoreAdmin.CreateIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.CreateIndex]: crate::client::DatastoreAdmin::create_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The index to create. The name and state fields are output only and will be
    /// ignored. Single property indexes cannot be created or deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.CreateIndexRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.DeleteIndex][google.datastore.admin.v1.DatastoreAdmin.DeleteIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.DeleteIndex]: crate::client::DatastoreAdmin::delete_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The resource ID of the index to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::DeleteIndexRequest::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.DeleteIndexRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.GetIndex][google.datastore.admin.v1.DatastoreAdmin.GetIndex].
///
/// [google.datastore.admin.v1.DatastoreAdmin.GetIndex]: crate::client::DatastoreAdmin::get_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The resource ID of the index to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetIndexRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::GetIndexRequest::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.GetIndexRequest"
    }
}

/// The request for
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes][google.datastore.admin.v1.DatastoreAdmin.ListIndexes].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes]: crate::client::DatastoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Project ID against which to make the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of items to return.  If zero, then all results will be
    /// returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListIndexesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ListIndexesRequest"
    }
}

/// The response for
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes][google.datastore.admin.v1.DatastoreAdmin.ListIndexes].
///
/// [google.datastore.admin.v1.DatastoreAdmin.ListIndexes]: crate::client::DatastoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// The indexes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.ListIndexesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Metadata for Index operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexOperationMetadata {
    /// Metadata common to all Datastore Admin operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common: std::option::Option<crate::model::CommonMetadata>,

    /// An estimate of the number of entities processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_entities: std::option::Option<crate::model::Progress>,

    /// The index resource ID that this operation is acting on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common][crate::model::IndexOperationMetadata::common].
    pub fn set_common<T: std::convert::Into<std::option::Option<crate::model::CommonMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.common = v.into();
        self
    }

    /// Sets the value of [progress_entities][crate::model::IndexOperationMetadata::progress_entities].
    pub fn set_progress_entities<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_entities = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::IndexOperationMetadata::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }
}

impl wkt::message::Message for IndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.IndexOperationMetadata"
    }
}

/// Metadata for Datastore to Firestore migration operations.
///
/// The DatastoreFirestoreMigration operation is not started by the end-user via
/// an explicit "creation" method. This is an intentional deviation from the LRO
/// design pattern.
///
/// This singleton resource can be accessed at:
/// "projects/{project_id}/operations/datastore-firestore-migration"
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatastoreFirestoreMigrationMetadata {
    /// The current state of migration from Cloud Datastore to Cloud Firestore in
    /// Datastore mode.
    pub migration_state: crate::model::MigrationState,

    /// The current step of migration from Cloud Datastore to Cloud Firestore in
    /// Datastore mode.
    pub migration_step: crate::model::MigrationStep,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatastoreFirestoreMigrationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_state][crate::model::DatastoreFirestoreMigrationMetadata::migration_state].
    pub fn set_migration_state<T: std::convert::Into<crate::model::MigrationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_state = v.into();
        self
    }

    /// Sets the value of [migration_step][crate::model::DatastoreFirestoreMigrationMetadata::migration_step].
    pub fn set_migration_step<T: std::convert::Into<crate::model::MigrationStep>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_step = v.into();
        self
    }
}

impl wkt::message::Message for DatastoreFirestoreMigrationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.DatastoreFirestoreMigrationMetadata"
    }
}

/// Datastore composite index definition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Index {
    /// Output only. Project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Output only. The resource ID of the index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_id: std::string::String,

    /// Required. The entity kind to which this index applies.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Required. The index's ancestor mode.  Must not be
    /// ANCESTOR_MODE_UNSPECIFIED.
    pub ancestor: crate::model::index::AncestorMode,

    /// Required. An ordered sequence of property names and their index attributes.
    ///
    /// Requires:
    ///
    /// * A maximum of 100 properties.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub properties: std::vec::Vec<crate::model::index::IndexedProperty>,

    /// Output only. The state of the index.
    pub state: crate::model::index::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::Index::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [index_id][crate::model::Index::index_id].
    pub fn set_index_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Index::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [ancestor][crate::model::Index::ancestor].
    pub fn set_ancestor<T: std::convert::Into<crate::model::index::AncestorMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.ancestor = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::Index::properties].
    pub fn set_properties<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index::IndexedProperty>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::Index::state].
    pub fn set_state<T: std::convert::Into<crate::model::index::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.Index"
    }
}

/// Defines additional types related to [Index].
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// A property of an index.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexedProperty {
        /// Required. The property name to index.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Required. The indexed property's direction.  Must not be
        /// DIRECTION_UNSPECIFIED.
        pub direction: crate::model::index::Direction,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexedProperty {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::index::IndexedProperty::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [direction][crate::model::index::IndexedProperty::direction].
        pub fn set_direction<T: std::convert::Into<crate::model::index::Direction>>(
            mut self,
            v: T,
        ) -> Self {
            self.direction = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexedProperty {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.Index.IndexedProperty"
        }
    }

    /// For an ordered index, specifies whether each of the entity's ancestors
    /// will be included.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AncestorMode {
        /// The ancestor mode is unspecified.
        Unspecified,
        /// Do not include the entity's ancestors in the index.
        None,
        /// Include all the entity's ancestors in the index.
        AllAncestors,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AncestorMode::value] or
        /// [AncestorMode::name].
        UnknownValue(ancestor_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ancestor_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AncestorMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::AllAncestors => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANCESTOR_MODE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::AllAncestors => std::option::Option::Some("ALL_ANCESTORS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AncestorMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AncestorMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AncestorMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::AllAncestors,
                _ => Self::UnknownValue(ancestor_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AncestorMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANCESTOR_MODE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "ALL_ANCESTORS" => Self::AllAncestors,
                _ => Self::UnknownValue(ancestor_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AncestorMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::AllAncestors => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AncestorMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AncestorMode>::new(
                ".google.datastore.admin.v1.Index.AncestorMode",
            ))
        }
    }

    /// The direction determines how a property is indexed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// The direction is unspecified.
        Unspecified,
        /// The property's values are indexed so as to support sequencing in
        /// ascending order and also query by <, >, <=, >=, and =.
        Ascending,
        /// The property's values are indexed so as to support sequencing in
        /// descending order and also query by <, >, <=, >=, and =.
        Descending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ascending => std::option::Option::Some(1),
                Self::Descending => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Ascending => std::option::Option::Some("ASCENDING"),
                Self::Descending => std::option::Option::Some("DESCENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ascending,
                2 => Self::Descending,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "ASCENDING" => Self::Ascending,
                "DESCENDING" => Self::Descending,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ascending => serializer.serialize_i32(1),
                Self::Descending => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.datastore.admin.v1.Index.Direction",
            ))
        }
    }

    /// The possible set of states of an index.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The index is being created, and cannot be used by queries.
        /// There is an active long-running operation for the index.
        /// The index is updated when writing an entity.
        /// Some index data may exist.
        Creating,
        /// The index is ready to be used.
        /// The index is updated when writing an entity.
        /// The index is fully populated from all stored entities it applies to.
        Ready,
        /// The index is being deleted, and cannot be used by queries.
        /// There is an active long-running operation for the index.
        /// The index is not updated when writing an entity.
        /// Some index data may exist.
        Deleting,
        /// The index was being created or deleted, but something went wrong.
        /// The index cannot by used by queries.
        /// There is no active long-running operation for the index,
        /// and the most recently finished long-running operation failed.
        /// The index is not updated when writing an entity.
        /// Some index data may exist.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.datastore.admin.v1.Index.State",
            ))
        }
    }
}

/// An event signifying a change in state of a [migration from Cloud Datastore to
/// Cloud Firestore in Datastore
/// mode](https://cloud.google.com/datastore/docs/upgrade-to-firestore).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationStateEvent {
    /// The new state of the migration.
    pub state: crate::model::MigrationState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationStateEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::MigrationStateEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::MigrationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for MigrationStateEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.MigrationStateEvent"
    }
}

/// An event signifying the start of a new step in a [migration from Cloud
/// Datastore to Cloud Firestore in Datastore
/// mode](https://cloud.google.com/datastore/docs/upgrade-to-firestore).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationProgressEvent {
    /// The step that is starting.
    ///
    /// An event with step set to `START` indicates that the migration
    /// has been reverted back to the initial pre-migration state.
    pub step: crate::model::MigrationStep,

    /// Details about this step.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub step_details: std::option::Option<crate::model::migration_progress_event::StepDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationProgressEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::MigrationProgressEvent::step].
    pub fn set_step<T: std::convert::Into<crate::model::MigrationStep>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details].
    ///
    /// Note that all the setters affecting `step_details` are mutually
    /// exclusive.
    pub fn set_step_details<
        T: std::convert::Into<
                std::option::Option<crate::model::migration_progress_event::StepDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = v.into();
        self
    }

    /// The value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// if it holds a `PrepareStepDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn prepare_step_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.step_details.as_ref().and_then(|v| match v {
            crate::model::migration_progress_event::StepDetails::PrepareStepDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// to hold a `PrepareStepDetails`.
    ///
    /// Note that all the setters affecting `step_details` are
    /// mutually exclusive.
    pub fn set_prepare_step_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = std::option::Option::Some(
            crate::model::migration_progress_event::StepDetails::PrepareStepDetails(v.into()),
        );
        self
    }

    /// The value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// if it holds a `RedirectWritesStepDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redirect_writes_step_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.step_details.as_ref().and_then(|v| match v {
            crate::model::migration_progress_event::StepDetails::RedirectWritesStepDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_details][crate::model::MigrationProgressEvent::step_details]
    /// to hold a `RedirectWritesStepDetails`.
    ///
    /// Note that all the setters affecting `step_details` are
    /// mutually exclusive.
    pub fn set_redirect_writes_step_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_details = std::option::Option::Some(
            crate::model::migration_progress_event::StepDetails::RedirectWritesStepDetails(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for MigrationProgressEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent"
    }
}

/// Defines additional types related to [MigrationProgressEvent].
pub mod migration_progress_event {
    #[allow(unused_imports)]
    use super::*;

    /// Details for the `PREPARE` step.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrepareStepDetails {
        /// The concurrency mode this database will use when it reaches the
        /// `REDIRECT_WRITES` step.
        pub concurrency_mode: crate::model::migration_progress_event::ConcurrencyMode,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrepareStepDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [concurrency_mode][crate::model::migration_progress_event::PrepareStepDetails::concurrency_mode].
        pub fn set_concurrency_mode<
            T: std::convert::Into<crate::model::migration_progress_event::ConcurrencyMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.concurrency_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for PrepareStepDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent.PrepareStepDetails"
        }
    }

    /// Details for the `REDIRECT_WRITES` step.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RedirectWritesStepDetails {
        /// Ths concurrency mode for this database.
        pub concurrency_mode: crate::model::migration_progress_event::ConcurrencyMode,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RedirectWritesStepDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [concurrency_mode][crate::model::migration_progress_event::RedirectWritesStepDetails::concurrency_mode].
        pub fn set_concurrency_mode<
            T: std::convert::Into<crate::model::migration_progress_event::ConcurrencyMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.concurrency_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for RedirectWritesStepDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.datastore.admin.v1.MigrationProgressEvent.RedirectWritesStepDetails"
        }
    }

    /// Concurrency modes for transactions in Cloud Firestore.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConcurrencyMode {
        /// Unspecified.
        Unspecified,
        /// Pessimistic concurrency.
        Pessimistic,
        /// Optimistic concurrency.
        Optimistic,
        /// Optimistic concurrency with entity groups.
        OptimisticWithEntityGroups,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConcurrencyMode::value] or
        /// [ConcurrencyMode::name].
        UnknownValue(concurrency_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod concurrency_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConcurrencyMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pessimistic => std::option::Option::Some(1),
                Self::Optimistic => std::option::Option::Some(2),
                Self::OptimisticWithEntityGroups => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONCURRENCY_MODE_UNSPECIFIED"),
                Self::Pessimistic => std::option::Option::Some("PESSIMISTIC"),
                Self::Optimistic => std::option::Option::Some("OPTIMISTIC"),
                Self::OptimisticWithEntityGroups => {
                    std::option::Option::Some("OPTIMISTIC_WITH_ENTITY_GROUPS")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConcurrencyMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConcurrencyMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConcurrencyMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pessimistic,
                2 => Self::Optimistic,
                3 => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConcurrencyMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONCURRENCY_MODE_UNSPECIFIED" => Self::Unspecified,
                "PESSIMISTIC" => Self::Pessimistic,
                "OPTIMISTIC" => Self::Optimistic,
                "OPTIMISTIC_WITH_ENTITY_GROUPS" => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConcurrencyMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pessimistic => serializer.serialize_i32(1),
                Self::Optimistic => serializer.serialize_i32(2),
                Self::OptimisticWithEntityGroups => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConcurrencyMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConcurrencyMode>::new(
                ".google.datastore.admin.v1.MigrationProgressEvent.ConcurrencyMode",
            ))
        }
    }

    /// Details about this step.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum StepDetails {
        /// Details for the `PREPARE` step.
        PrepareStepDetails(
            std::boxed::Box<crate::model::migration_progress_event::PrepareStepDetails>,
        ),
        /// Details for the `REDIRECT_WRITES` step.
        RedirectWritesStepDetails(
            std::boxed::Box<crate::model::migration_progress_event::RedirectWritesStepDetails>,
        ),
    }
}

/// Operation types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationType {
    /// Unspecified.
    Unspecified,
    /// ExportEntities.
    ExportEntities,
    /// ImportEntities.
    ImportEntities,
    /// CreateIndex.
    CreateIndex,
    /// DeleteIndex.
    DeleteIndex,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationType::value] or
    /// [OperationType::name].
    UnknownValue(operation_type::UnknownValue),
}

#[doc(hidden)]
pub mod operation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ExportEntities => std::option::Option::Some(1),
            Self::ImportEntities => std::option::Option::Some(2),
            Self::CreateIndex => std::option::Option::Some(3),
            Self::DeleteIndex => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATION_TYPE_UNSPECIFIED"),
            Self::ExportEntities => std::option::Option::Some("EXPORT_ENTITIES"),
            Self::ImportEntities => std::option::Option::Some("IMPORT_ENTITIES"),
            Self::CreateIndex => std::option::Option::Some("CREATE_INDEX"),
            Self::DeleteIndex => std::option::Option::Some("DELETE_INDEX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ExportEntities,
            2 => Self::ImportEntities,
            3 => Self::CreateIndex,
            4 => Self::DeleteIndex,
            _ => Self::UnknownValue(operation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "EXPORT_ENTITIES" => Self::ExportEntities,
            "IMPORT_ENTITIES" => Self::ImportEntities,
            "CREATE_INDEX" => Self::CreateIndex,
            "DELETE_INDEX" => Self::DeleteIndex,
            _ => Self::UnknownValue(operation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ExportEntities => serializer.serialize_i32(1),
            Self::ImportEntities => serializer.serialize_i32(2),
            Self::CreateIndex => serializer.serialize_i32(3),
            Self::DeleteIndex => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationType>::new(
            ".google.datastore.admin.v1.OperationType",
        ))
    }
}

/// States for a migration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MigrationState {
    /// Unspecified.
    Unspecified,
    /// The migration is running.
    Running,
    /// The migration is paused.
    Paused,
    /// The migration is complete.
    Complete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MigrationState::value] or
    /// [MigrationState::name].
    UnknownValue(migration_state::UnknownValue),
}

#[doc(hidden)]
pub mod migration_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MigrationState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Running => std::option::Option::Some(1),
            Self::Paused => std::option::Option::Some(2),
            Self::Complete => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MIGRATION_STATE_UNSPECIFIED"),
            Self::Running => std::option::Option::Some("RUNNING"),
            Self::Paused => std::option::Option::Some("PAUSED"),
            Self::Complete => std::option::Option::Some("COMPLETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MigrationState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MigrationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MigrationState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Running,
            2 => Self::Paused,
            3 => Self::Complete,
            _ => Self::UnknownValue(migration_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MigrationState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MIGRATION_STATE_UNSPECIFIED" => Self::Unspecified,
            "RUNNING" => Self::Running,
            "PAUSED" => Self::Paused,
            "COMPLETE" => Self::Complete,
            _ => Self::UnknownValue(migration_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MigrationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Running => serializer.serialize_i32(1),
            Self::Paused => serializer.serialize_i32(2),
            Self::Complete => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MigrationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationState>::new(
            ".google.datastore.admin.v1.MigrationState",
        ))
    }
}

/// Steps in a migration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MigrationStep {
    /// Unspecified.
    Unspecified,
    /// Pre-migration: the database is prepared for migration.
    Prepare,
    /// Start of migration.
    Start,
    /// Writes are applied synchronously to at least one replica.
    ApplyWritesSynchronously,
    /// Data is copied to Cloud Firestore and then verified to match the data in
    /// Cloud Datastore.
    CopyAndVerify,
    /// Eventually-consistent reads are redirected to Cloud Firestore.
    RedirectEventuallyConsistentReads,
    /// Strongly-consistent reads are redirected to Cloud Firestore.
    RedirectStronglyConsistentReads,
    /// Writes are redirected to Cloud Firestore.
    RedirectWrites,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MigrationStep::value] or
    /// [MigrationStep::name].
    UnknownValue(migration_step::UnknownValue),
}

#[doc(hidden)]
pub mod migration_step {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MigrationStep {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Prepare => std::option::Option::Some(6),
            Self::Start => std::option::Option::Some(1),
            Self::ApplyWritesSynchronously => std::option::Option::Some(7),
            Self::CopyAndVerify => std::option::Option::Some(2),
            Self::RedirectEventuallyConsistentReads => std::option::Option::Some(3),
            Self::RedirectStronglyConsistentReads => std::option::Option::Some(4),
            Self::RedirectWrites => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MIGRATION_STEP_UNSPECIFIED"),
            Self::Prepare => std::option::Option::Some("PREPARE"),
            Self::Start => std::option::Option::Some("START"),
            Self::ApplyWritesSynchronously => {
                std::option::Option::Some("APPLY_WRITES_SYNCHRONOUSLY")
            }
            Self::CopyAndVerify => std::option::Option::Some("COPY_AND_VERIFY"),
            Self::RedirectEventuallyConsistentReads => {
                std::option::Option::Some("REDIRECT_EVENTUALLY_CONSISTENT_READS")
            }
            Self::RedirectStronglyConsistentReads => {
                std::option::Option::Some("REDIRECT_STRONGLY_CONSISTENT_READS")
            }
            Self::RedirectWrites => std::option::Option::Some("REDIRECT_WRITES"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MigrationStep {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MigrationStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MigrationStep {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Start,
            2 => Self::CopyAndVerify,
            3 => Self::RedirectEventuallyConsistentReads,
            4 => Self::RedirectStronglyConsistentReads,
            5 => Self::RedirectWrites,
            6 => Self::Prepare,
            7 => Self::ApplyWritesSynchronously,
            _ => Self::UnknownValue(migration_step::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MigrationStep {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MIGRATION_STEP_UNSPECIFIED" => Self::Unspecified,
            "PREPARE" => Self::Prepare,
            "START" => Self::Start,
            "APPLY_WRITES_SYNCHRONOUSLY" => Self::ApplyWritesSynchronously,
            "COPY_AND_VERIFY" => Self::CopyAndVerify,
            "REDIRECT_EVENTUALLY_CONSISTENT_READS" => Self::RedirectEventuallyConsistentReads,
            "REDIRECT_STRONGLY_CONSISTENT_READS" => Self::RedirectStronglyConsistentReads,
            "REDIRECT_WRITES" => Self::RedirectWrites,
            _ => Self::UnknownValue(migration_step::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MigrationStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Prepare => serializer.serialize_i32(6),
            Self::Start => serializer.serialize_i32(1),
            Self::ApplyWritesSynchronously => serializer.serialize_i32(7),
            Self::CopyAndVerify => serializer.serialize_i32(2),
            Self::RedirectEventuallyConsistentReads => serializer.serialize_i32(3),
            Self::RedirectStronglyConsistentReads => serializer.serialize_i32(4),
            Self::RedirectWrites => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MigrationStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationStep>::new(
            ".google.datastore.admin.v1.MigrationStep",
        ))
    }
}
