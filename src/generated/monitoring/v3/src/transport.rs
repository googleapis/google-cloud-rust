// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [AlertPolicyService](super::stub::AlertPolicyService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct AlertPolicyService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for AlertPolicyService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("AlertPolicyService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl AlertPolicyService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::AlertPolicyService for AlertPolicyService {
    async fn list_alert_policies(
        &self,
        req: crate::model::ListAlertPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAlertPoliciesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/alertPolicies", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_alert_policy(
        &self,
        req: crate::model::GetAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_alert_policy(
        &self,
        req: crate::model::CreateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/alertPolicies", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.alert_policy), options)
            .await
    }

    async fn delete_alert_policy(
        &self,
        req: crate::model::DeleteAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn update_alert_policy(
        &self,
        req: crate::model::UpdateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}", {
            let arg = &req
                .alert_policy
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("alert_policy"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("alert_policy.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.alert_policy), options)
            .await
    }
}

/// Implements [GroupService](super::stub::GroupService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct GroupService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for GroupService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GroupService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl GroupService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::GroupService for GroupService {
    async fn list_groups(
        &self,
        req: crate::model::ListGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGroupsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/groups", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req.children_of_group().iter().fold(builder, |builder, p| {
            builder.query(&[("childrenOfGroup", p)])
        });
        let builder = req.ancestors_of_group().iter().fold(builder, |builder, p| {
            builder.query(&[("ancestorsOfGroup", p)])
        });
        let builder = req
            .descendants_of_group()
            .iter()
            .fold(builder, |builder, p| {
                builder.query(&[("descendantsOfGroup", p)])
            });
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_group(
        &self,
        req: crate::model::GetGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_group(
        &self,
        req: crate::model::CreateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/groups", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);
        self.inner.execute(builder, Some(req.group), options).await
    }

    async fn update_group(
        &self,
        req: crate::model::UpdateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req
                .group
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("group"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("group.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);
        self.inner.execute(builder, Some(req.group), options).await
    }

    async fn delete_group(
        &self,
        req: crate::model::DeleteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("recursive", &req.recursive)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_group_members(
        &self,
        req: crate::model::ListGroupMembersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGroupMembersResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/members", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = req
            .interval
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "interval")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [MetricService](super::stub::MetricService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct MetricService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for MetricService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MetricService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl MetricService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::MetricService for MetricService {
    async fn list_monitored_resource_descriptors(
        &self,
        req: crate::model::ListMonitoredResourceDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMonitoredResourceDescriptorsResponse>>
    {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/monitoredResourceDescriptors", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_monitored_resource_descriptor(
        &self,
        req: crate::model::GetMonitoredResourceDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MonitoredResourceDescriptor>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_metric_descriptors(
        &self,
        req: crate::model::ListMetricDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetricDescriptorsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/metricDescriptors", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("activeOnly", &req.active_only)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_metric_descriptor(
        &self,
        req: crate::model::GetMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MetricDescriptor>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_metric_descriptor(
        &self,
        req: crate::model::CreateMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MetricDescriptor>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/metricDescriptors", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.metric_descriptor), options)
            .await
    }

    async fn delete_metric_descriptor(
        &self,
        req: crate::model::DeleteMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_time_series(
        &self,
        req: crate::model::ListTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTimeSeriesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/timeSeries", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = req
            .interval
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "interval")
            });
        let builder = req
            .aggregation
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "aggregation")
            });
        let builder = req
            .secondary_aggregation
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "secondaryAggregation")
            });
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("view", &req.view)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/timeSeries", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn create_service_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/timeSeries:createService", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }
}

/// Implements [NotificationChannelService](super::stub::NotificationChannelService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct NotificationChannelService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for NotificationChannelService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NotificationChannelService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl NotificationChannelService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::NotificationChannelService for NotificationChannelService {
    async fn list_notification_channel_descriptors(
        &self,
        req: crate::model::ListNotificationChannelDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotificationChannelDescriptorsResponse>>
    {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/notificationChannelDescriptors", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_notification_channel_descriptor(
        &self,
        req: crate::model::GetNotificationChannelDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannelDescriptor>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_notification_channels(
        &self,
        req: crate::model::ListNotificationChannelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotificationChannelsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/notificationChannels", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_notification_channel(
        &self,
        req: crate::model::GetNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_notification_channel(
        &self,
        req: crate::model::CreateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/notificationChannels", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.notification_channel), options)
            .await
    }

    async fn update_notification_channel(
        &self,
        req: crate::model::UpdateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}", {
            let arg = &req
                .notification_channel
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("notification_channel"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("notification_channel.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.notification_channel), options)
            .await
    }

    async fn delete_notification_channel(
        &self,
        req: crate::model::DeleteNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn send_notification_channel_verification_code(
        &self,
        req: crate::model::SendNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}:sendVerificationCode", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn get_notification_channel_verification_code(
        &self,
        req: crate::model::GetNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetNotificationChannelVerificationCodeResponse>>
    {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}:getVerificationCode", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn verify_notification_channel(
        &self,
        req: crate::model::VerifyNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}:verify", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }
}

/// Implements [QueryService](super::stub::QueryService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct QueryService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for QueryService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("QueryService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl QueryService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::QueryService for QueryService {
    async fn query_time_series(
        &self,
        req: crate::model::QueryTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryTimeSeriesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/timeSeries:query", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }
}

/// Implements [ServiceMonitoringService](super::stub::ServiceMonitoringService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ServiceMonitoringService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ServiceMonitoringService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ServiceMonitoringService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ServiceMonitoringService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ServiceMonitoringService for ServiceMonitoringService {
    async fn create_service(
        &self,
        req: crate::model::CreateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/services", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("serviceId", &req.service_id)]);
        self.inner
            .execute(builder, Some(req.service), options)
            .await
    }

    async fn get_service(
        &self,
        req: crate::model::GetServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_services(
        &self,
        req: crate::model::ListServicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServicesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/services", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_service(
        &self,
        req: crate::model::UpdateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}", {
            let arg = &req
                .service
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("service"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("service.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.service), options)
            .await
    }

    async fn delete_service(
        &self,
        req: crate::model::DeleteServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn create_service_level_objective(
        &self,
        req: crate::model::CreateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/serviceLevelObjectives", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder =
            builder.query(&[("serviceLevelObjectiveId", &req.service_level_objective_id)]);
        self.inner
            .execute(builder, Some(req.service_level_objective), options)
            .await
    }

    async fn get_service_level_objective(
        &self,
        req: crate::model::GetServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_service_level_objectives(
        &self,
        req: crate::model::ListServiceLevelObjectivesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServiceLevelObjectivesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/serviceLevelObjectives", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("view", &req.view)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_service_level_objective(
        &self,
        req: crate::model::UpdateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}", {
            let arg = &req
                .service_level_objective
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("service_level_objective"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing(
                    "service_level_objective.name",
                ));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.service_level_objective), options)
            .await
    }

    async fn delete_service_level_objective(
        &self,
        req: crate::model::DeleteServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [SnoozeService](super::stub::SnoozeService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SnoozeService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SnoozeService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SnoozeService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SnoozeService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SnoozeService for SnoozeService {
    async fn create_snooze(
        &self,
        req: crate::model::CreateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/snoozes", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.snooze), options).await
    }

    async fn list_snoozes(
        &self,
        req: crate::model::ListSnoozesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSnoozesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/snoozes", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_snooze(
        &self,
        req: crate::model::GetSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_snooze(
        &self,
        req: crate::model::UpdateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}", {
            let arg = &req
                .snooze
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("snooze"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("snooze.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner.execute(builder, Some(req.snooze), options).await
    }
}

/// Implements [UptimeCheckService](super::stub::UptimeCheckService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct UptimeCheckService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for UptimeCheckService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("UptimeCheckService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl UptimeCheckService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::UptimeCheckService for UptimeCheckService {
    async fn list_uptime_check_configs(
        &self,
        req: crate::model::ListUptimeCheckConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUptimeCheckConfigsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}/uptimeCheckConfigs", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_uptime_check_config(
        &self,
        req: crate::model::GetUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_uptime_check_config(
        &self,
        req: crate::model::CreateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}/uptimeCheckConfigs", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.uptime_check_config), options)
            .await
    }

    async fn update_uptime_check_config(
        &self,
        req: crate::model::UpdateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v3/{}", {
            let arg = &req
                .uptime_check_config
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("uptime_check_config"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("uptime_check_config.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.uptime_check_config), options)
            .await
    }

    async fn delete_uptime_check_config(
        &self,
        req: crate::model::DeleteUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v3/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_uptime_check_ips(
        &self,
        req: crate::model::ListUptimeCheckIpsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUptimeCheckIpsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = "/v3/uptimeCheckIps".to_string();
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}
