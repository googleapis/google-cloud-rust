// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [AlertPolicyService](super::stub::AlertPolicyService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct AlertPolicyService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for AlertPolicyService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("AlertPolicyService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl AlertPolicyService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::AlertPolicyService for AlertPolicyService {
    async fn list_alert_policies(
        &self,
        req: crate::model::ListAlertPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListAlertPoliciesResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v3/{}/alertPolicies", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<crate::model::ListAlertPoliciesResponse>| r.into_body(),
            )
    }

    async fn get_alert_policy(
        &self,
        req: crate::model::GetAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::AlertPolicy> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::AlertPolicy>| r.into_body())
    }

    async fn create_alert_policy(
        &self,
        req: crate::model::CreateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::AlertPolicy> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/alertPolicies", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.alert_policy), options)
            .await
            .map(|r: gax::response::Response<crate::model::AlertPolicy>| r.into_body())
    }

    async fn delete_alert_policy(
        &self,
        req: crate::model::DeleteAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::DELETE.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn update_alert_policy(
        &self,
        req: crate::model::UpdateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::AlertPolicy> {
        let options = options.set_default_idempotency(reqwest::Method::PATCH.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v3/{}",
                    req.alert_policy
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("alert_policy"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.alert_policy), options)
            .await
            .map(|r: gax::response::Response<crate::model::AlertPolicy>| r.into_body())
    }
}

/// Implements [GroupService](super::stub::GroupService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct GroupService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for GroupService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GroupService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl GroupService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::GroupService for GroupService {
    async fn list_groups(
        &self,
        req: crate::model::ListGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListGroupsResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}/groups", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .get_children_of_group()
            .iter()
            .fold(builder, |builder, p| {
                builder.query(&[("childrenOfGroup", p)])
            });
        let builder = req
            .get_ancestors_of_group()
            .iter()
            .fold(builder, |builder, p| {
                builder.query(&[("ancestorsOfGroup", p)])
            });
        let builder = req
            .get_descendants_of_group()
            .iter()
            .fold(builder, |builder, p| {
                builder.query(&[("descendantsOfGroup", p)])
            });
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::ListGroupsResponse>| r.into_body())
    }

    async fn get_group(
        &self,
        req: crate::model::GetGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Group> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::Group>| r.into_body())
    }

    async fn create_group(
        &self,
        req: crate::model::CreateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Group> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v3/{}/groups", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);
        self.inner
            .execute(builder, Some(req.group), options)
            .await
            .map(|r: gax::response::Response<crate::model::Group>| r.into_body())
    }

    async fn update_group(
        &self,
        req: crate::model::UpdateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Group> {
        let options = options.set_default_idempotency(reqwest::Method::PUT.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::PUT,
                format!(
                    "/v3/{}",
                    req.group
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("group"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);
        self.inner
            .execute(builder, Some(req.group), options)
            .await
            .map(|r: gax::response::Response<crate::model::Group>| r.into_body())
    }

    async fn delete_group(
        &self,
        req: crate::model::DeleteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::DELETE.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("recursive", &req.recursive)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn list_group_members(
        &self,
        req: crate::model::ListGroupMembersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListGroupMembersResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}/members", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = req
            .interval
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "interval")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::ListGroupMembersResponse>| r.into_body())
    }
}

/// Implements [MetricService](super::stub::MetricService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct MetricService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for MetricService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MetricService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl MetricService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::MetricService for MetricService {
    async fn list_monitored_resource_descriptors(
        &self,
        req: crate::model::ListMonitoredResourceDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListMonitoredResourceDescriptorsResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v3/{}/monitoredResourceDescriptors", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<
                    crate::model::ListMonitoredResourceDescriptorsResponse,
                >| r.into_body(),
            )
    }

    async fn get_monitored_resource_descriptor(
        &self,
        req: crate::model::GetMonitoredResourceDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<api::model::MonitoredResourceDescriptor> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<api::model::MonitoredResourceDescriptor>| r.into_body(),
            )
    }

    async fn list_metric_descriptors(
        &self,
        req: crate::model::ListMetricDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListMetricDescriptorsResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v3/{}/metricDescriptors", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("activeOnly", &req.active_only)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<crate::model::ListMetricDescriptorsResponse>| {
                    r.into_body()
                },
            )
    }

    async fn get_metric_descriptor(
        &self,
        req: crate::model::GetMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<api::model::MetricDescriptor> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<api::model::MetricDescriptor>| r.into_body())
    }

    async fn create_metric_descriptor(
        &self,
        req: crate::model::CreateMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<api::model::MetricDescriptor> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/metricDescriptors", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.metric_descriptor), options)
            .await
            .map(|r: gax::response::Response<api::model::MetricDescriptor>| r.into_body())
    }

    async fn delete_metric_descriptor(
        &self,
        req: crate::model::DeleteMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::DELETE.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn list_time_series(
        &self,
        req: crate::model::ListTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListTimeSeriesResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}/timeSeries", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = req
            .interval
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "interval")
            });
        let builder = req
            .aggregation
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "aggregation")
            });
        let builder = req
            .secondary_aggregation
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "secondaryAggregation")
            });
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("view", &req.view.value())]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::ListTimeSeriesResponse>| r.into_body())
    }

    async fn create_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/timeSeries", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req), options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn create_service_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/timeSeries:createService", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req), options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }
}

/// Implements [NotificationChannelService](super::stub::NotificationChannelService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct NotificationChannelService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for NotificationChannelService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NotificationChannelService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl NotificationChannelService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::NotificationChannelService for NotificationChannelService {
    async fn list_notification_channel_descriptors(
        &self,
        req: crate::model::ListNotificationChannelDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListNotificationChannelDescriptorsResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v3/{}/notificationChannelDescriptors", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<
                    crate::model::ListNotificationChannelDescriptorsResponse,
                >| r.into_body(),
            )
    }

    async fn get_notification_channel_descriptor(
        &self,
        req: crate::model::GetNotificationChannelDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::NotificationChannelDescriptor> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<crate::model::NotificationChannelDescriptor>| {
                    r.into_body()
                },
            )
    }

    async fn list_notification_channels(
        &self,
        req: crate::model::ListNotificationChannelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListNotificationChannelsResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v3/{}/notificationChannels", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<crate::model::ListNotificationChannelsResponse>| {
                    r.into_body()
                },
            )
    }

    async fn get_notification_channel(
        &self,
        req: crate::model::GetNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::NotificationChannel> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::NotificationChannel>| r.into_body())
    }

    async fn create_notification_channel(
        &self,
        req: crate::model::CreateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::NotificationChannel> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/notificationChannels", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.notification_channel), options)
            .await
            .map(|r: gax::response::Response<crate::model::NotificationChannel>| r.into_body())
    }

    async fn update_notification_channel(
        &self,
        req: crate::model::UpdateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::NotificationChannel> {
        let options = options.set_default_idempotency(reqwest::Method::PATCH.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v3/{}",
                    req.notification_channel
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("notification_channel"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.notification_channel), options)
            .await
            .map(|r: gax::response::Response<crate::model::NotificationChannel>| r.into_body())
    }

    async fn delete_notification_channel(
        &self,
        req: crate::model::DeleteNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::DELETE.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn send_notification_channel_verification_code(
        &self,
        req: crate::model::SendNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}:sendVerificationCode", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req), options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn get_notification_channel_verification_code(
        &self,
        req: crate::model::GetNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::GetNotificationChannelVerificationCodeResponse> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}:getVerificationCode", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<
                crate::model::GetNotificationChannelVerificationCodeResponse,
            >| r.into_body(),
        )
    }

    async fn verify_notification_channel(
        &self,
        req: crate::model::VerifyNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::NotificationChannel> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v3/{}:verify", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req), options)
            .await
            .map(|r: gax::response::Response<crate::model::NotificationChannel>| r.into_body())
    }
}

/// Implements [QueryService](super::stub::QueryService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct QueryService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for QueryService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("QueryService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl QueryService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::QueryService for QueryService {
    async fn query_time_series(
        &self,
        req: crate::model::QueryTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::QueryTimeSeriesResponse> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/timeSeries:query", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req), options)
            .await
            .map(|r: gax::response::Response<crate::model::QueryTimeSeriesResponse>| r.into_body())
    }
}

/// Implements [ServiceMonitoringService](super::stub::ServiceMonitoringService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ServiceMonitoringService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ServiceMonitoringService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ServiceMonitoringService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ServiceMonitoringService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ServiceMonitoringService for ServiceMonitoringService {
    async fn create_service(
        &self,
        req: crate::model::CreateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Service> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/services", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("serviceId", &req.service_id)]);
        self.inner
            .execute(builder, Some(req.service), options)
            .await
            .map(|r: gax::response::Response<crate::model::Service>| r.into_body())
    }

    async fn get_service(
        &self,
        req: crate::model::GetServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Service> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::Service>| r.into_body())
    }

    async fn list_services(
        &self,
        req: crate::model::ListServicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListServicesResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}/services", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::ListServicesResponse>| r.into_body())
    }

    async fn update_service(
        &self,
        req: crate::model::UpdateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Service> {
        let options = options.set_default_idempotency(reqwest::Method::PATCH.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v3/{}",
                    req.service
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("service"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.service), options)
            .await
            .map(|r: gax::response::Response<crate::model::Service>| r.into_body())
    }

    async fn delete_service(
        &self,
        req: crate::model::DeleteServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::DELETE.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn create_service_level_objective(
        &self,
        req: crate::model::CreateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ServiceLevelObjective> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/serviceLevelObjectives", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder =
            builder.query(&[("serviceLevelObjectiveId", &req.service_level_objective_id)]);
        self.inner
            .execute(builder, Some(req.service_level_objective), options)
            .await
            .map(|r: gax::response::Response<crate::model::ServiceLevelObjective>| r.into_body())
    }

    async fn get_service_level_objective(
        &self,
        req: crate::model::GetServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ServiceLevelObjective> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view.value())]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::ServiceLevelObjective>| r.into_body())
    }

    async fn list_service_level_objectives(
        &self,
        req: crate::model::ListServiceLevelObjectivesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListServiceLevelObjectivesResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v3/{}/serviceLevelObjectives", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("view", &req.view.value())]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<crate::model::ListServiceLevelObjectivesResponse>| {
                    r.into_body()
                },
            )
    }

    async fn update_service_level_objective(
        &self,
        req: crate::model::UpdateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ServiceLevelObjective> {
        let options = options.set_default_idempotency(reqwest::Method::PATCH.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v3/{}",
                    req.service_level_objective
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("service_level_objective"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.service_level_objective), options)
            .await
            .map(|r: gax::response::Response<crate::model::ServiceLevelObjective>| r.into_body())
    }

    async fn delete_service_level_objective(
        &self,
        req: crate::model::DeleteServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::DELETE.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }
}

/// Implements [SnoozeService](super::stub::SnoozeService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SnoozeService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SnoozeService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SnoozeService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SnoozeService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SnoozeService for SnoozeService {
    async fn create_snooze(
        &self,
        req: crate::model::CreateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Snooze> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v3/{}/snoozes", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.snooze), options)
            .await
            .map(|r: gax::response::Response<crate::model::Snooze>| r.into_body())
    }

    async fn list_snoozes(
        &self,
        req: crate::model::ListSnoozesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListSnoozesResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}/snoozes", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::ListSnoozesResponse>| r.into_body())
    }

    async fn get_snooze(
        &self,
        req: crate::model::GetSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Snooze> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::Snooze>| r.into_body())
    }

    async fn update_snooze(
        &self,
        req: crate::model::UpdateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Snooze> {
        let options = options.set_default_idempotency(reqwest::Method::PATCH.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v3/{}",
                    req.snooze
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("snooze"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.snooze), options)
            .await
            .map(|r: gax::response::Response<crate::model::Snooze>| r.into_body())
    }
}

/// Implements [UptimeCheckService](super::stub::UptimeCheckService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct UptimeCheckService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for UptimeCheckService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("UptimeCheckService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl UptimeCheckService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::UptimeCheckService for UptimeCheckService {
    async fn list_uptime_check_configs(
        &self,
        req: crate::model::ListUptimeCheckConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListUptimeCheckConfigsResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v3/{}/uptimeCheckConfigs", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<crate::model::ListUptimeCheckConfigsResponse>| {
                    r.into_body()
                },
            )
    }

    async fn get_uptime_check_config(
        &self,
        req: crate::model::GetUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::UptimeCheckConfig> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<crate::model::UptimeCheckConfig>| r.into_body())
    }

    async fn create_uptime_check_config(
        &self,
        req: crate::model::CreateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::UptimeCheckConfig> {
        let options = options.set_default_idempotency(reqwest::Method::POST.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v3/{}/uptimeCheckConfigs", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.uptime_check_config), options)
            .await
            .map(|r: gax::response::Response<crate::model::UptimeCheckConfig>| r.into_body())
    }

    async fn update_uptime_check_config(
        &self,
        req: crate::model::UpdateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::UptimeCheckConfig> {
        let options = options.set_default_idempotency(reqwest::Method::PATCH.is_idempotent());
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v3/{}",
                    req.uptime_check_config
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("uptime_check_config"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.uptime_check_config), options)
            .await
            .map(|r: gax::response::Response<crate::model::UptimeCheckConfig>| r.into_body())
    }

    async fn delete_uptime_check_config(
        &self,
        req: crate::model::DeleteUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<()> {
        let options = options.set_default_idempotency(reqwest::Method::DELETE.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v3/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|_: gax::response::Response<wkt::Empty>| ())
    }

    async fn list_uptime_check_ips(
        &self,
        req: crate::model::ListUptimeCheckIpsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListUptimeCheckIpsResponse> {
        let options = options.set_default_idempotency(reqwest::Method::GET.is_idempotent());
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v3/uptimeCheckIps".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(
                |r: gax::response::Response<crate::model::ListUptimeCheckIpsResponse>| {
                    r.into_body()
                },
            )
    }
}
