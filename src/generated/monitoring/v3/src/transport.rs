// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [AlertPolicyService](super::stub::AlertPolicyService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct AlertPolicyService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for AlertPolicyService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("AlertPolicyService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl AlertPolicyService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::AlertPolicyService for AlertPolicyService {
    async fn list_alert_policies(
        &self,
        req: crate::model::ListAlertPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAlertPoliciesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/alertPolicies",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("orderBy", &req.order_by)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_alert_policy(
        &self,
        req: crate::model::GetAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/alertPolicies/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/alertPolicies/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/alertPolicies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_alert_policy(
        &self,
        req: crate::model::CreateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/alertPolicies",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.alert_policy), options)
            .await
    }

    async fn delete_alert_policy(
        &self,
        req: crate::model::DeleteAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/alertPolicies/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/alertPolicies/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/alertPolicies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn update_alert_policy(
        &self,
        req: crate::model::UpdateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req)
                            .and_then(|m| m.alert_policy.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/alertPolicies/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .and_then(|m| m.alert_policy.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/alertPolicies/"),
                            Segment::SingleWildcard,
                        ],
                        "alert_policy.name",
                        "projects/*/alertPolicies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.alert_policy), options)
            .await
    }
}

/// Implements [GroupService](super::stub::GroupService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct GroupService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for GroupService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GroupService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl GroupService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::GroupService for GroupService {
    async fn list_groups(
        &self,
        req: crate::model::ListGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGroupsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/groups",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req.children_of_group().iter().fold(builder, |builder, p| {
                    builder.query(&[("childrenOfGroup", p)])
                });
                let builder = req.ancestors_of_group().iter().fold(builder, |builder, p| {
                    builder.query(&[("ancestorsOfGroup", p)])
                });
                let builder = req
                    .descendants_of_group()
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("descendantsOfGroup", p)])
                    });
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_group(
        &self,
        req: crate::model::GetGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/groups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_group(
        &self,
        req: crate::model::CreateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/groups",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("validateOnly", &req.validate_only)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req.group), options).await
    }

    async fn update_group(
        &self,
        req: crate::model::UpdateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req)
                            .and_then(|m| m.group.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = builder.query(&[("validateOnly", &req.validate_only)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .and_then(|m| m.group.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard,
                        ],
                        "group.name",
                        "projects/*/groups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req.group), options).await
    }

    async fn delete_group(
        &self,
        req: crate::model::DeleteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = builder.query(&[("recursive", &req.recursive)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/groups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_group_members(
        &self,
        req: crate::model::ListGroupMembersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGroupMembersResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/members",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = (|| {
                    let builder = builder.query(&[("pageSize", &req.page_size)]);
                    let builder = builder.query(&[("pageToken", &req.page_token)]);
                    let builder = builder.query(&[("filter", &req.filter)]);
                    let builder = req
                        .interval
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "interval")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/groups/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/groups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [MetricService](super::stub::MetricService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct MetricService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for MetricService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MetricService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl MetricService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::MetricService for MetricService {
    async fn list_monitored_resource_descriptors(
        &self,
        req: crate::model::ListMonitoredResourceDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMonitoredResourceDescriptorsResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/monitoredResourceDescriptors",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_monitored_resource_descriptor(
        &self,
        req: crate::model::GetMonitoredResourceDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MonitoredResourceDescriptor>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/monitoredResourceDescriptors"),
                            Segment::TrailingMultiWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/monitoredResourceDescriptors"),
                            Segment::TrailingMultiWildcard,
                        ],
                        "name",
                        "projects/*/monitoredResourceDescriptors/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_metric_descriptors(
        &self,
        req: crate::model::ListMetricDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetricDescriptorsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/metricDescriptors",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = builder.query(&[("activeOnly", &req.active_only)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_metric_descriptor(
        &self,
        req: crate::model::GetMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MetricDescriptor>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metricDescriptors"),
                            Segment::TrailingMultiWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metricDescriptors"),
                            Segment::TrailingMultiWildcard,
                        ],
                        "name",
                        "projects/*/metricDescriptors/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_metric_descriptor(
        &self,
        req: crate::model::CreateMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MetricDescriptor>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/metricDescriptors",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.metric_descriptor), options)
            .await
    }

    async fn delete_metric_descriptor(
        &self,
        req: crate::model::DeleteMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metricDescriptors"),
                            Segment::TrailingMultiWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metricDescriptors"),
                            Segment::TrailingMultiWildcard,
                        ],
                        "name",
                        "projects/*/metricDescriptors/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_time_series(
        &self,
        req: crate::model::ListTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTimeSeriesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/timeSeries",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = (|| {
                    let builder = builder.query(&[("filter", &req.filter)]);
                    let builder = req
                        .interval
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "interval")
                        });
                    let builder = req
                        .aggregation
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "aggregation")
                        });
                    let builder = req
                        .secondary_aggregation
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "secondaryAggregation")
                        });
                    let builder = builder.query(&[("orderBy", &req.order_by)]);
                    let builder = builder.query(&[("view", &req.view)]);
                    let builder = builder.query(&[("pageSize", &req.page_size)]);
                    let builder = builder.query(&[("pageToken", &req.page_token)]);
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, true)))
            })
            .or_else(|| {
                let path = format!(
                    "/v3/{}/timeSeries",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("organizations/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = (|| {
                    let builder = builder.query(&[("filter", &req.filter)]);
                    let builder = req
                        .interval
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "interval")
                        });
                    let builder = req
                        .aggregation
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "aggregation")
                        });
                    let builder = req
                        .secondary_aggregation
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "secondaryAggregation")
                        });
                    let builder = builder.query(&[("orderBy", &req.order_by)]);
                    let builder = builder.query(&[("view", &req.view)]);
                    let builder = builder.query(&[("pageSize", &req.page_size)]);
                    let builder = builder.query(&[("pageToken", &req.page_token)]);
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, true)))
            })
            .or_else(|| {
                let path = format!(
                    "/v3/{}/timeSeries",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("folders/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = (|| {
                    let builder = builder.query(&[("filter", &req.filter)]);
                    let builder = req
                        .interval
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "interval")
                        });
                    let builder = req
                        .aggregation
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "aggregation")
                        });
                    let builder = req
                        .secondary_aggregation
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "secondaryAggregation")
                        });
                    let builder = builder.query(&[("orderBy", &req.order_by)]);
                    let builder = builder.query(&[("view", &req.view)]);
                    let builder = builder.query(&[("pageSize", &req.page_size)]);
                    let builder = builder.query(&[("pageToken", &req.page_token)]);
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("organizations/"), Segment::SingleWildcard],
                        "name",
                        "organizations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("folders/"), Segment::SingleWildcard],
                        "name",
                        "folders/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/timeSeries",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn create_service_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/timeSeries:createService",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }
}

/// Implements [NotificationChannelService](super::stub::NotificationChannelService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct NotificationChannelService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for NotificationChannelService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NotificationChannelService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl NotificationChannelService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::NotificationChannelService for NotificationChannelService {
    async fn list_notification_channel_descriptors(
        &self,
        req: crate::model::ListNotificationChannelDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotificationChannelDescriptorsResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/notificationChannelDescriptors",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_notification_channel_descriptor(
        &self,
        req: crate::model::GetNotificationChannelDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannelDescriptor>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannelDescriptors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannelDescriptors/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/notificationChannelDescriptors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_notification_channels(
        &self,
        req: crate::model::ListNotificationChannelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotificationChannelsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/notificationChannels",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("orderBy", &req.order_by)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_notification_channel(
        &self,
        req: crate::model::GetNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/notificationChannels/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_notification_channel(
        &self,
        req: crate::model::CreateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/notificationChannels",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.notification_channel), options)
            .await
    }

    async fn update_notification_channel(
        &self,
        req: crate::model::UpdateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req)
                            .and_then(|m| m.notification_channel.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .and_then(|m| m.notification_channel.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard,
                        ],
                        "notification_channel.name",
                        "projects/*/notificationChannels/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.notification_channel), options)
            .await
    }

    async fn delete_notification_channel(
        &self,
        req: crate::model::DeleteNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = builder.query(&[("force", &req.force)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/notificationChannels/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn send_notification_channel_verification_code(
        &self,
        req: crate::model::SendNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}:sendVerificationCode",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/notificationChannels/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn get_notification_channel_verification_code(
        &self,
        req: crate::model::GetNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetNotificationChannelVerificationCodeResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}:getVerificationCode",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/notificationChannels/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req), options).await
    }

    async fn verify_notification_channel(
        &self,
        req: crate::model::VerifyNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}:verify",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/notificationChannels/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/notificationChannels/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req), options).await
    }
}

/// Implements [QueryService](super::stub::QueryService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct QueryService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for QueryService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("QueryService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl QueryService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::QueryService for QueryService {
    async fn query_time_series(
        &self,
        req: crate::model::QueryTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryTimeSeriesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/timeSeries:query",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req), options).await
    }
}

/// Implements [ServiceMonitoringService](super::stub::ServiceMonitoringService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ServiceMonitoringService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ServiceMonitoringService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ServiceMonitoringService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ServiceMonitoringService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ServiceMonitoringService for ServiceMonitoringService {
    async fn create_service(
        &self,
        req: crate::model::CreateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/services",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("serviceId", &req.service_id)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "*/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.service), options)
            .await
    }

    async fn get_service(
        &self,
        req: crate::model::GetServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "*/*/services/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_services(
        &self,
        req: crate::model::ListServicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServicesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/services",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "*/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_service(
        &self,
        req: crate::model::UpdateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req)
                            .and_then(|m| m.service.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .and_then(|m| m.service.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                        ],
                        "service.name",
                        "*/*/services/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.service), options)
            .await
    }

    async fn delete_service(
        &self,
        req: crate::model::DeleteServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "*/*/services/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn create_service_level_objective(
        &self,
        req: crate::model::CreateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/serviceLevelObjectives",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder =
                    builder.query(&[("serviceLevelObjectiveId", &req.service_level_objective_id)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "*/*/services/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.service_level_objective), options)
            .await
    }

    async fn get_service_level_objective(
        &self,
        req: crate::model::GetServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/serviceLevelObjectives/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("view", &req.view)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/serviceLevelObjectives/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "*/*/services/*/serviceLevelObjectives/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_service_level_objectives(
        &self,
        req: crate::model::ListServiceLevelObjectivesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServiceLevelObjectivesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/serviceLevelObjectives",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = builder.query(&[("view", &req.view)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "*/*/services/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_service_level_objective(
        &self,
        req: crate::model::UpdateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req)
                            .and_then(|m| m.service_level_objective.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/serviceLevelObjectives/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .and_then(|m| m.service_level_objective.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/serviceLevelObjectives/"),
                            Segment::SingleWildcard,
                        ],
                        "service_level_objective.name",
                        "*/*/services/*/serviceLevelObjectives/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.service_level_objective), options)
            .await
    }

    async fn delete_service_level_objective(
        &self,
        req: crate::model::DeleteServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/serviceLevelObjectives/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/services/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/serviceLevelObjectives/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "*/*/services/*/serviceLevelObjectives/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [SnoozeService](super::stub::SnoozeService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SnoozeService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SnoozeService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SnoozeService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SnoozeService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SnoozeService for SnoozeService {
    async fn create_snooze(
        &self,
        req: crate::model::CreateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/snoozes",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "parent",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req.snooze), options).await
    }

    async fn list_snoozes(
        &self,
        req: crate::model::ListSnoozesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSnoozesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/snoozes",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "parent",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_snooze(
        &self,
        req: crate::model::GetSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/snoozes/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/snoozes/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/snoozes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_snooze(
        &self,
        req: crate::model::UpdateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req)
                            .and_then(|m| m.snooze.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/snoozes/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .and_then(|m| m.snooze.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/snoozes/"),
                            Segment::SingleWildcard,
                        ],
                        "snooze.name",
                        "projects/*/snoozes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner.execute(builder, Some(req.snooze), options).await
    }
}

/// Implements [UptimeCheckService](super::stub::UptimeCheckService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct UptimeCheckService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for UptimeCheckService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("UptimeCheckService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl UptimeCheckService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::UptimeCheckService for UptimeCheckService {
    async fn list_uptime_check_configs(
        &self,
        req: crate::model::ListUptimeCheckConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUptimeCheckConfigsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/uptimeCheckConfigs",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "parent",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_uptime_check_config(
        &self,
        req: crate::model::GetUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/uptimeCheckConfigs/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/uptimeCheckConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/uptimeCheckConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_uptime_check_config(
        &self,
        req: crate::model::CreateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}/uptimeCheckConfigs",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "parent",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.uptime_check_config), options)
            .await
    }

    async fn update_uptime_check_config(
        &self,
        req: crate::model::UpdateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req)
                            .and_then(|m| m.uptime_check_config.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/uptimeCheckConfigs/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, false)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .and_then(|m| m.uptime_check_config.as_ref())
                            .map(|m| &m.name)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/uptimeCheckConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "uptime_check_config.name",
                        "projects/*/uptimeCheckConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, Some(req.uptime_check_config), options)
            .await
    }

    async fn delete_uptime_check_config(
        &self,
        req: crate::model::DeleteUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = format!(
                    "/v3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/uptimeCheckConfigs/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/uptimeCheckConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/uptimeCheckConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_uptime_check_ips(
        &self,
        req: crate::model::ListUptimeCheckIpsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUptimeCheckIpsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, default_idempotency) = None
            .or_else(|| {
                let path = "/v3/uptimeCheckIps".to_string();

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, true)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let options = gax::options::internal::set_default_idempotency(options, default_idempotency);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}
