// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::broken_intra_doc_links)]

use crate::Result;
use std::sync::Arc;

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// The AlertPolicyService API is used to manage (list, create, delete,
/// edit) alert policies in Cloud Monitoring. An alerting policy is
/// a description of the conditions under which some aspect of your
/// system is considered to be "unhealthy" and the ways to notify
/// people or services about this state. In addition to using this API, alert
/// policies can also be managed through
/// [Cloud Monitoring](https://cloud.google.com/monitoring/docs/),
/// which can be reached by clicking the "Monitoring" tab in
/// [Cloud console](https://console.cloud.google.com/).
///
/// # Configuration
///
/// `AlertPolicyService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `AlertPolicyService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `AlertPolicyService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct AlertPolicyService {
    inner: Arc<dyn crate::stubs::dynamic::AlertPolicyService>,
}

impl AlertPolicyService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::AlertPolicyService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::AlertPolicyService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::AlertPolicyService> {
        crate::transport::AlertPolicyService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::AlertPolicyService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::AlertPolicyService::new)
    }

    /// Lists the existing alerting policies for the workspace.
    pub fn list_alert_policies(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::alert_policy_service::ListAlertPolicies {
        crate::builders::alert_policy_service::ListAlertPolicies::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Gets a single alerting policy.
    pub fn get_alert_policy(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::alert_policy_service::GetAlertPolicy {
        crate::builders::alert_policy_service::GetAlertPolicy::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Creates a new alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    pub fn create_alert_policy(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::alert_policy_service::CreateAlertPolicy {
        crate::builders::alert_policy_service::CreateAlertPolicy::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Deletes an alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    pub fn delete_alert_policy(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::alert_policy_service::DeleteAlertPolicy {
        crate::builders::alert_policy_service::DeleteAlertPolicy::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Updates an alerting policy. You can either replace the entire policy with
    /// a new one or replace only certain fields in the current alerting policy by
    /// specifying the fields to be updated via `updateMask`. Returns the
    /// updated alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    pub fn update_alert_policy(
        &self,
        alert_policy: impl Into<crate::model::AlertPolicy>,
    ) -> crate::builders::alert_policy_service::UpdateAlertPolicy {
        crate::builders::alert_policy_service::UpdateAlertPolicy::new(self.inner.clone())
            .set_alert_policy(alert_policy.into())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// The Group API lets you inspect and manage your
/// [groups](#google.monitoring.v3.Group).
///
/// A group is a named filter that is used to identify
/// a collection of monitored resources. Groups are typically used to
/// mirror the physical and/or logical topology of the environment.
/// Because group membership is computed dynamically, monitored
/// resources that are started in the future are automatically placed
/// in matching groups. By using a group to name monitored resources in,
/// for example, an alert policy, the target of that alert policy is
/// updated automatically as monitored resources are added and removed
/// from the infrastructure.
///
/// # Configuration
///
/// `GroupService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `GroupService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GroupService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct GroupService {
    inner: Arc<dyn crate::stubs::dynamic::GroupService>,
}

impl GroupService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::GroupService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::GroupService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::GroupService> {
        crate::transport::GroupService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::GroupService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::GroupService::new)
    }

    /// Lists the existing groups.
    pub fn list_groups(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::group_service::ListGroups {
        crate::builders::group_service::ListGroups::new(self.inner.clone()).set_name(name.into())
    }

    /// Gets a single group.
    pub fn get_group(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::group_service::GetGroup {
        crate::builders::group_service::GetGroup::new(self.inner.clone()).set_name(name.into())
    }

    /// Creates a new group.
    pub fn create_group(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::group_service::CreateGroup {
        crate::builders::group_service::CreateGroup::new(self.inner.clone()).set_name(name.into())
    }

    /// Updates an existing group.
    /// You can change any group attributes except `name`.
    pub fn update_group(
        &self,
        group: impl Into<crate::model::Group>,
    ) -> crate::builders::group_service::UpdateGroup {
        crate::builders::group_service::UpdateGroup::new(self.inner.clone()).set_group(group.into())
    }

    /// Deletes an existing group.
    pub fn delete_group(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::group_service::DeleteGroup {
        crate::builders::group_service::DeleteGroup::new(self.inner.clone()).set_name(name.into())
    }

    /// Lists the monitored resources that are members of a group.
    pub fn list_group_members(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::group_service::ListGroupMembers {
        crate::builders::group_service::ListGroupMembers::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// Manages metric descriptors, monitored resource descriptors, and
/// time series data.
///
/// # Configuration
///
/// `MetricService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `MetricService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `MetricService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct MetricService {
    inner: Arc<dyn crate::stubs::dynamic::MetricService>,
}

impl MetricService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::MetricService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::MetricService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::MetricService> {
        crate::transport::MetricService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::MetricService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::MetricService::new)
    }

    /// Lists monitored resource descriptors that match a filter.
    pub fn list_monitored_resource_descriptors(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::ListMonitoredResourceDescriptors {
        crate::builders::metric_service::ListMonitoredResourceDescriptors::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Gets a single monitored resource descriptor.
    pub fn get_monitored_resource_descriptor(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::GetMonitoredResourceDescriptor {
        crate::builders::metric_service::GetMonitoredResourceDescriptor::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Lists metric descriptors that match a filter.
    pub fn list_metric_descriptors(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::ListMetricDescriptors {
        crate::builders::metric_service::ListMetricDescriptors::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Gets a single metric descriptor.
    pub fn get_metric_descriptor(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::GetMetricDescriptor {
        crate::builders::metric_service::GetMetricDescriptor::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Creates a new metric descriptor.
    /// The creation is executed asynchronously.
    /// User-created metric descriptors define
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics).
    /// The metric descriptor is updated if it already exists,
    /// except that metric labels are never removed.
    pub fn create_metric_descriptor(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::CreateMetricDescriptor {
        crate::builders::metric_service::CreateMetricDescriptor::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Deletes a metric descriptor. Only user-created
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics) can be
    /// deleted.
    pub fn delete_metric_descriptor(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::DeleteMetricDescriptor {
        crate::builders::metric_service::DeleteMetricDescriptor::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Lists time series that match a filter.
    pub fn list_time_series(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::ListTimeSeries {
        crate::builders::metric_service::ListTimeSeries::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Creates or adds data to one or more time series.
    /// The response is empty if all time series in the request were written.
    /// If any time series could not be written, a corresponding failure message is
    /// included in the error response.
    /// This method does not support
    /// [resource locations constraint of an organization
    /// policy](https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy).
    pub fn create_time_series(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::CreateTimeSeries {
        crate::builders::metric_service::CreateTimeSeries::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Creates or adds data to one or more service time series. A service time
    /// series is a time series for a metric from a Google Cloud service. The
    /// response is empty if all time series in the request were written. If any
    /// time series could not be written, a corresponding failure message is
    /// included in the error response. This endpoint rejects writes to
    /// user-defined metrics.
    /// This method is only for use by Google Cloud services. Use
    /// [projects.timeSeries.create][google.monitoring.v3.MetricService.CreateTimeSeries]
    /// instead.
    ///
    /// [google.monitoring.v3.MetricService.CreateTimeSeries]: crate::client::MetricService::create_time_series
    pub fn create_service_time_series(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::metric_service::CreateServiceTimeSeries {
        crate::builders::metric_service::CreateServiceTimeSeries::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// The Notification Channel API provides access to configuration that
/// controls how messages related to incidents are sent.
///
/// # Configuration
///
/// `NotificationChannelService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `NotificationChannelService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NotificationChannelService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct NotificationChannelService {
    inner: Arc<dyn crate::stubs::dynamic::NotificationChannelService>,
}

impl NotificationChannelService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::NotificationChannelService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::NotificationChannelService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::NotificationChannelService> {
        crate::transport::NotificationChannelService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::NotificationChannelService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::NotificationChannelService::new)
    }

    /// Lists the descriptors for supported channel types. The use of descriptors
    /// makes it possible for new channel types to be dynamically added.
    pub fn list_notification_channel_descriptors(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::ListNotificationChannelDescriptors {
        crate::builders::notification_channel_service::ListNotificationChannelDescriptors::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Gets a single channel descriptor. The descriptor indicates which fields
    /// are expected / permitted for a notification channel of the given type.
    pub fn get_notification_channel_descriptor(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::GetNotificationChannelDescriptor {
        crate::builders::notification_channel_service::GetNotificationChannelDescriptor::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Lists the notification channels that have been created for the project.
    /// To list the types of notification channels that are supported, use
    /// the `ListNotificationChannelDescriptors` method.
    pub fn list_notification_channels(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::ListNotificationChannels {
        crate::builders::notification_channel_service::ListNotificationChannels::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Gets a single notification channel. The channel includes the relevant
    /// configuration details with which the channel was created. However, the
    /// response may truncate or omit passwords, API keys, or other private key
    /// matter and thus the response may not be 100% identical to the information
    /// that was supplied in the call to the create method.
    pub fn get_notification_channel(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::GetNotificationChannel {
        crate::builders::notification_channel_service::GetNotificationChannel::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Creates a new notification channel, representing a single notification
    /// endpoint such as an email address, SMS number, or PagerDuty service.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    pub fn create_notification_channel(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::CreateNotificationChannel {
        crate::builders::notification_channel_service::CreateNotificationChannel::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Updates a notification channel. Fields not specified in the field mask
    /// remain unchanged.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    pub fn update_notification_channel(
        &self,
        notification_channel: impl Into<crate::model::NotificationChannel>,
    ) -> crate::builders::notification_channel_service::UpdateNotificationChannel {
        crate::builders::notification_channel_service::UpdateNotificationChannel::new(
            self.inner.clone(),
        )
        .set_notification_channel(notification_channel.into())
    }

    /// Deletes a notification channel.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    pub fn delete_notification_channel(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::DeleteNotificationChannel {
        crate::builders::notification_channel_service::DeleteNotificationChannel::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Causes a verification code to be delivered to the channel. The code
    /// can then be supplied in `VerifyNotificationChannel` to verify the channel.
    pub fn send_notification_channel_verification_code(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::SendNotificationChannelVerificationCode
    {
        crate::builders::notification_channel_service::SendNotificationChannelVerificationCode::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Requests a verification code for an already verified channel that can then
    /// be used in a call to VerifyNotificationChannel() on a different channel
    /// with an equivalent identity in the same or in a different project. This
    /// makes it possible to copy a channel between projects without requiring
    /// manual reverification of the channel. If the channel is not in the
    /// verified state, this method will fail (in other words, this may only be
    /// used if the SendNotificationChannelVerificationCode and
    /// VerifyNotificationChannel paths have already been used to put the given
    /// channel into the verified state).
    ///
    /// There is no guarantee that the verification codes returned by this method
    /// will be of a similar structure or form as the ones that are delivered
    /// to the channel via SendNotificationChannelVerificationCode; while
    /// VerifyNotificationChannel() will recognize both the codes delivered via
    /// SendNotificationChannelVerificationCode() and returned from
    /// GetNotificationChannelVerificationCode(), it is typically the case that
    /// the verification codes delivered via
    /// SendNotificationChannelVerificationCode() will be shorter and also
    /// have a shorter expiration (e.g. codes such as "G-123456") whereas
    /// GetVerificationCode() will typically return a much longer, websafe base
    /// 64 encoded string that has a longer expiration time.
    pub fn get_notification_channel_verification_code(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::GetNotificationChannelVerificationCode {
        crate::builders::notification_channel_service::GetNotificationChannelVerificationCode::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// Verifies a `NotificationChannel` by proving receipt of the code
    /// delivered to the channel as a result of calling
    /// `SendNotificationChannelVerificationCode`.
    pub fn verify_notification_channel(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::notification_channel_service::VerifyNotificationChannel {
        crate::builders::notification_channel_service::VerifyNotificationChannel::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// The QueryService API is used to manage time series data in Cloud
/// Monitoring. Time series data is a collection of data points that describes
/// the time-varying values of a metric.
///
/// # Configuration
///
/// `QueryService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `QueryService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `QueryService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct QueryService {
    inner: Arc<dyn crate::stubs::dynamic::QueryService>,
}

impl QueryService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::QueryService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::QueryService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::QueryService> {
        crate::transport::QueryService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::QueryService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::QueryService::new)
    }

    /// Queries time series by using Monitoring Query Language (MQL). We recommend
    /// using PromQL instead of MQL. For more information about the status of MQL,
    /// see the [MQL deprecation
    /// notice](https://cloud.google.com/stackdriver/docs/deprecations/mql).
    pub fn query_time_series(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::query_service::QueryTimeSeries {
        crate::builders::query_service::QueryTimeSeries::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// The Cloud Monitoring Service-Oriented Monitoring API has endpoints for
/// managing and querying aspects of a Metrics Scope's services. These include
/// the `Service`'s monitored resources, its Service-Level Objectives, and a
/// taxonomy of categorized Health Metrics.
///
/// # Configuration
///
/// `ServiceMonitoringService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ServiceMonitoringService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ServiceMonitoringService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ServiceMonitoringService {
    inner: Arc<dyn crate::stubs::dynamic::ServiceMonitoringService>,
}

impl ServiceMonitoringService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::ServiceMonitoringService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::ServiceMonitoringService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ServiceMonitoringService> {
        crate::transport::ServiceMonitoringService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ServiceMonitoringService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::ServiceMonitoringService::new)
    }

    /// Create a `Service`.
    pub fn create_service(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::CreateService {
        crate::builders::service_monitoring_service::CreateService::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Get the named `Service`.
    pub fn get_service(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::GetService {
        crate::builders::service_monitoring_service::GetService::new(self.inner.clone())
            .set_name(name.into())
    }

    /// List `Service`s for this Metrics Scope.
    pub fn list_services(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::ListServices {
        crate::builders::service_monitoring_service::ListServices::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Update this `Service`.
    pub fn update_service(
        &self,
        service: impl Into<crate::model::Service>,
    ) -> crate::builders::service_monitoring_service::UpdateService {
        crate::builders::service_monitoring_service::UpdateService::new(self.inner.clone())
            .set_service(service.into())
    }

    /// Soft delete this `Service`.
    pub fn delete_service(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::DeleteService {
        crate::builders::service_monitoring_service::DeleteService::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Create a `ServiceLevelObjective` for the given `Service`.
    pub fn create_service_level_objective(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::CreateServiceLevelObjective {
        crate::builders::service_monitoring_service::CreateServiceLevelObjective::new(
            self.inner.clone(),
        )
        .set_parent(parent.into())
    }

    /// Get a `ServiceLevelObjective` by name.
    pub fn get_service_level_objective(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::GetServiceLevelObjective {
        crate::builders::service_monitoring_service::GetServiceLevelObjective::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }

    /// List the `ServiceLevelObjective`s for the given `Service`.
    pub fn list_service_level_objectives(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::ListServiceLevelObjectives {
        crate::builders::service_monitoring_service::ListServiceLevelObjectives::new(
            self.inner.clone(),
        )
        .set_parent(parent.into())
    }

    /// Update the given `ServiceLevelObjective`.
    pub fn update_service_level_objective(
        &self,
        service_level_objective: impl Into<crate::model::ServiceLevelObjective>,
    ) -> crate::builders::service_monitoring_service::UpdateServiceLevelObjective {
        crate::builders::service_monitoring_service::UpdateServiceLevelObjective::new(
            self.inner.clone(),
        )
        .set_service_level_objective(service_level_objective.into())
    }

    /// Delete the given `ServiceLevelObjective`.
    pub fn delete_service_level_objective(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::service_monitoring_service::DeleteServiceLevelObjective {
        crate::builders::service_monitoring_service::DeleteServiceLevelObjective::new(
            self.inner.clone(),
        )
        .set_name(name.into())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// The SnoozeService API is used to temporarily prevent an alert policy from
/// generating alerts. A Snooze is a description of the criteria under which one
/// or more alert policies should not fire alerts for the specified duration.
///
/// # Configuration
///
/// `SnoozeService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `SnoozeService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SnoozeService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct SnoozeService {
    inner: Arc<dyn crate::stubs::dynamic::SnoozeService>,
}

impl SnoozeService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::SnoozeService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::SnoozeService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::SnoozeService> {
        crate::transport::SnoozeService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::SnoozeService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::SnoozeService::new)
    }

    /// Creates a `Snooze` that will prevent alerts, which match the provided
    /// criteria, from being opened. The `Snooze` applies for a specific time
    /// interval.
    pub fn create_snooze(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::snooze_service::CreateSnooze {
        crate::builders::snooze_service::CreateSnooze::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Lists the `Snooze`s associated with a project. Can optionally pass in
    /// `filter`, which specifies predicates to match `Snooze`s.
    pub fn list_snoozes(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::snooze_service::ListSnoozes {
        crate::builders::snooze_service::ListSnoozes::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Retrieves a `Snooze` by `name`.
    pub fn get_snooze(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::snooze_service::GetSnooze {
        crate::builders::snooze_service::GetSnooze::new(self.inner.clone()).set_name(name.into())
    }

    /// Updates a `Snooze`, identified by its `name`, with the parameters in the
    /// given `Snooze` object.
    pub fn update_snooze(
        &self,
        snooze: impl Into<crate::model::Snooze>,
    ) -> crate::builders::snooze_service::UpdateSnooze {
        crate::builders::snooze_service::UpdateSnooze::new(self.inner.clone())
            .set_snooze(snooze.into())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Service Description
///
/// The UptimeCheckService API is used to manage (list, create, delete, edit)
/// Uptime check configurations in the Cloud Monitoring product. An Uptime
/// check is a piece of configuration that determines which resources and
/// services to monitor for availability. These configurations can also be
/// configured interactively by navigating to the [Cloud console]
/// (<https://console.cloud.google.com>), selecting the appropriate project,
/// clicking on "Monitoring" on the left-hand side to navigate to Cloud
/// Monitoring, and then clicking on "Uptime".
///
/// # Configuration
///
/// `UptimeCheckService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `UptimeCheckService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `UptimeCheckService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct UptimeCheckService {
    inner: Arc<dyn crate::stubs::dynamic::UptimeCheckService>,
}

impl UptimeCheckService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::UptimeCheckService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::UptimeCheckService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::UptimeCheckService> {
        crate::transport::UptimeCheckService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::UptimeCheckService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::UptimeCheckService::new)
    }

    /// Lists the existing valid Uptime check configurations for the project
    /// (leaving out any invalid configurations).
    pub fn list_uptime_check_configs(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::uptime_check_service::ListUptimeCheckConfigs {
        crate::builders::uptime_check_service::ListUptimeCheckConfigs::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Gets a single Uptime check configuration.
    pub fn get_uptime_check_config(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::uptime_check_service::GetUptimeCheckConfig {
        crate::builders::uptime_check_service::GetUptimeCheckConfig::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Creates a new Uptime check configuration.
    pub fn create_uptime_check_config(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::uptime_check_service::CreateUptimeCheckConfig {
        crate::builders::uptime_check_service::CreateUptimeCheckConfig::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Updates an Uptime check configuration. You can either replace the entire
    /// configuration with a new one or replace only certain fields in the current
    /// configuration by specifying the fields to be updated via `updateMask`.
    /// Returns the updated configuration.
    pub fn update_uptime_check_config(
        &self,
        uptime_check_config: impl Into<crate::model::UptimeCheckConfig>,
    ) -> crate::builders::uptime_check_service::UpdateUptimeCheckConfig {
        crate::builders::uptime_check_service::UpdateUptimeCheckConfig::new(self.inner.clone())
            .set_uptime_check_config(uptime_check_config.into())
    }

    /// Deletes an Uptime check configuration. Note that this method will fail
    /// if the Uptime check configuration is referenced by an alert policy or
    /// other dependent configs that would be rendered invalid by the deletion.
    pub fn delete_uptime_check_config(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::uptime_check_service::DeleteUptimeCheckConfig {
        crate::builders::uptime_check_service::DeleteUptimeCheckConfig::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Returns the list of IP addresses that checkers run from.
    pub fn list_uptime_check_ips(
        &self,
    ) -> crate::builders::uptime_check_service::ListUptimeCheckIps {
        crate::builders::uptime_check_service::ListUptimeCheckIps::new(self.inner.clone())
    }
}
