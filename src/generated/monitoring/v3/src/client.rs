// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::AlertPolicyService;
/// let client = AlertPolicyService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// The AlertPolicyService API is used to manage (list, create, delete,
/// edit) alert policies in Cloud Monitoring. An alerting policy is
/// a description of the conditions under which some aspect of your
/// system is considered to be "unhealthy" and the ways to notify
/// people or services about this state. In addition to using this API, alert
/// policies can also be managed through
/// [Cloud Monitoring](https://cloud.google.com/monitoring/docs/),
/// which can be reached by clicking the "Monitoring" tab in
/// [Cloud console](https://console.cloud.google.com/).
///
/// # Configuration
///
/// To configure `AlertPolicyService` use the `with_*` methods in the type returned
/// by [builder()][AlertPolicyService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::alert_policy_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::alert_policy_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `AlertPolicyService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `AlertPolicyService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct AlertPolicyService {
    inner: std::sync::Arc<dyn super::stub::dynamic::AlertPolicyService>,
}

impl AlertPolicyService {
    /// Returns a builder for [AlertPolicyService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::AlertPolicyService;
    /// let client = AlertPolicyService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::alert_policy_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::alert_policy_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::AlertPolicyService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::AlertPolicyService>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::AlertPolicyService> {
        super::transport::AlertPolicyService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::AlertPolicyService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::AlertPolicyService::new)
    }

    /// Lists the existing alerting policies for the workspace.
    pub fn list_alert_policies(&self) -> super::builder::alert_policy_service::ListAlertPolicies {
        super::builder::alert_policy_service::ListAlertPolicies::new(self.inner.clone())
    }

    /// Gets a single alerting policy.
    pub fn get_alert_policy(&self) -> super::builder::alert_policy_service::GetAlertPolicy {
        super::builder::alert_policy_service::GetAlertPolicy::new(self.inner.clone())
    }

    /// Creates a new alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    pub fn create_alert_policy(&self) -> super::builder::alert_policy_service::CreateAlertPolicy {
        super::builder::alert_policy_service::CreateAlertPolicy::new(self.inner.clone())
    }

    /// Deletes an alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    pub fn delete_alert_policy(&self) -> super::builder::alert_policy_service::DeleteAlertPolicy {
        super::builder::alert_policy_service::DeleteAlertPolicy::new(self.inner.clone())
    }

    /// Updates an alerting policy. You can either replace the entire policy with
    /// a new one or replace only certain fields in the current alerting policy by
    /// specifying the fields to be updated via `updateMask`. Returns the
    /// updated alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    pub fn update_alert_policy(&self) -> super::builder::alert_policy_service::UpdateAlertPolicy {
        super::builder::alert_policy_service::UpdateAlertPolicy::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::GroupService;
/// let client = GroupService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// The Group API lets you inspect and manage your
/// [groups](#google.monitoring.v3.Group).
///
/// A group is a named filter that is used to identify
/// a collection of monitored resources. Groups are typically used to
/// mirror the physical and/or logical topology of the environment.
/// Because group membership is computed dynamically, monitored
/// resources that are started in the future are automatically placed
/// in matching groups. By using a group to name monitored resources in,
/// for example, an alert policy, the target of that alert policy is
/// updated automatically as monitored resources are added and removed
/// from the infrastructure.
///
/// # Configuration
///
/// To configure `GroupService` use the `with_*` methods in the type returned
/// by [builder()][GroupService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::group_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::group_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GroupService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GroupService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct GroupService {
    inner: std::sync::Arc<dyn super::stub::dynamic::GroupService>,
}

impl GroupService {
    /// Returns a builder for [GroupService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::GroupService;
    /// let client = GroupService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::group_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::group_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GroupService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::GroupService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GroupService> {
        super::transport::GroupService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GroupService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GroupService::new)
    }

    /// Lists the existing groups.
    pub fn list_groups(&self) -> super::builder::group_service::ListGroups {
        super::builder::group_service::ListGroups::new(self.inner.clone())
    }

    /// Gets a single group.
    pub fn get_group(&self) -> super::builder::group_service::GetGroup {
        super::builder::group_service::GetGroup::new(self.inner.clone())
    }

    /// Creates a new group.
    pub fn create_group(&self) -> super::builder::group_service::CreateGroup {
        super::builder::group_service::CreateGroup::new(self.inner.clone())
    }

    /// Updates an existing group.
    /// You can change any group attributes except `name`.
    pub fn update_group(&self) -> super::builder::group_service::UpdateGroup {
        super::builder::group_service::UpdateGroup::new(self.inner.clone())
    }

    /// Deletes an existing group.
    pub fn delete_group(&self) -> super::builder::group_service::DeleteGroup {
        super::builder::group_service::DeleteGroup::new(self.inner.clone())
    }

    /// Lists the monitored resources that are members of a group.
    pub fn list_group_members(&self) -> super::builder::group_service::ListGroupMembers {
        super::builder::group_service::ListGroupMembers::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::MetricService;
/// let client = MetricService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Manages metric descriptors, monitored resource descriptors, and
/// time series data.
///
/// # Configuration
///
/// To configure `MetricService` use the `with_*` methods in the type returned
/// by [builder()][MetricService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::metric_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::metric_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `MetricService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `MetricService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct MetricService {
    inner: std::sync::Arc<dyn super::stub::dynamic::MetricService>,
}

impl MetricService {
    /// Returns a builder for [MetricService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::MetricService;
    /// let client = MetricService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::metric_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::metric_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::MetricService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::MetricService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::MetricService> {
        super::transport::MetricService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::MetricService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::MetricService::new)
    }

    /// Lists monitored resource descriptors that match a filter.
    pub fn list_monitored_resource_descriptors(
        &self,
    ) -> super::builder::metric_service::ListMonitoredResourceDescriptors {
        super::builder::metric_service::ListMonitoredResourceDescriptors::new(self.inner.clone())
    }

    /// Gets a single monitored resource descriptor.
    pub fn get_monitored_resource_descriptor(
        &self,
    ) -> super::builder::metric_service::GetMonitoredResourceDescriptor {
        super::builder::metric_service::GetMonitoredResourceDescriptor::new(self.inner.clone())
    }

    /// Lists metric descriptors that match a filter.
    pub fn list_metric_descriptors(&self) -> super::builder::metric_service::ListMetricDescriptors {
        super::builder::metric_service::ListMetricDescriptors::new(self.inner.clone())
    }

    /// Gets a single metric descriptor.
    pub fn get_metric_descriptor(&self) -> super::builder::metric_service::GetMetricDescriptor {
        super::builder::metric_service::GetMetricDescriptor::new(self.inner.clone())
    }

    /// Creates a new metric descriptor.
    /// The creation is executed asynchronously.
    /// User-created metric descriptors define
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics).
    /// The metric descriptor is updated if it already exists,
    /// except that metric labels are never removed.
    pub fn create_metric_descriptor(
        &self,
    ) -> super::builder::metric_service::CreateMetricDescriptor {
        super::builder::metric_service::CreateMetricDescriptor::new(self.inner.clone())
    }

    /// Deletes a metric descriptor. Only user-created
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics) can be
    /// deleted.
    pub fn delete_metric_descriptor(
        &self,
    ) -> super::builder::metric_service::DeleteMetricDescriptor {
        super::builder::metric_service::DeleteMetricDescriptor::new(self.inner.clone())
    }

    /// Lists time series that match a filter.
    pub fn list_time_series(&self) -> super::builder::metric_service::ListTimeSeries {
        super::builder::metric_service::ListTimeSeries::new(self.inner.clone())
    }

    /// Creates or adds data to one or more time series.
    /// The response is empty if all time series in the request were written.
    /// If any time series could not be written, a corresponding failure message is
    /// included in the error response.
    /// This method does not support
    /// [resource locations constraint of an organization
    /// policy](https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy).
    pub fn create_time_series(&self) -> super::builder::metric_service::CreateTimeSeries {
        super::builder::metric_service::CreateTimeSeries::new(self.inner.clone())
    }

    /// Creates or adds data to one or more service time series. A service time
    /// series is a time series for a metric from a Google Cloud service. The
    /// response is empty if all time series in the request were written. If any
    /// time series could not be written, a corresponding failure message is
    /// included in the error response. This endpoint rejects writes to
    /// user-defined metrics.
    /// This method is only for use by Google Cloud services. Use
    /// [projects.timeSeries.create][google.monitoring.v3.MetricService.CreateTimeSeries]
    /// instead.
    ///
    /// [google.monitoring.v3.MetricService.CreateTimeSeries]: crate::client::MetricService::create_time_series
    pub fn create_service_time_series(
        &self,
    ) -> super::builder::metric_service::CreateServiceTimeSeries {
        super::builder::metric_service::CreateServiceTimeSeries::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::NotificationChannelService;
/// let client = NotificationChannelService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// The Notification Channel API provides access to configuration that
/// controls how messages related to incidents are sent.
///
/// # Configuration
///
/// To configure `NotificationChannelService` use the `with_*` methods in the type returned
/// by [builder()][NotificationChannelService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::notification_channel_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::notification_channel_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NotificationChannelService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NotificationChannelService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct NotificationChannelService {
    inner: std::sync::Arc<dyn super::stub::dynamic::NotificationChannelService>,
}

impl NotificationChannelService {
    /// Returns a builder for [NotificationChannelService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::NotificationChannelService;
    /// let client = NotificationChannelService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::notification_channel_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::notification_channel_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NotificationChannelService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::NotificationChannelService>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NotificationChannelService> {
        super::transport::NotificationChannelService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NotificationChannelService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NotificationChannelService::new)
    }

    /// Lists the descriptors for supported channel types. The use of descriptors
    /// makes it possible for new channel types to be dynamically added.
    pub fn list_notification_channel_descriptors(
        &self,
    ) -> super::builder::notification_channel_service::ListNotificationChannelDescriptors {
        super::builder::notification_channel_service::ListNotificationChannelDescriptors::new(
            self.inner.clone(),
        )
    }

    /// Gets a single channel descriptor. The descriptor indicates which fields
    /// are expected / permitted for a notification channel of the given type.
    pub fn get_notification_channel_descriptor(
        &self,
    ) -> super::builder::notification_channel_service::GetNotificationChannelDescriptor {
        super::builder::notification_channel_service::GetNotificationChannelDescriptor::new(
            self.inner.clone(),
        )
    }

    /// Lists the notification channels that have been created for the project.
    /// To list the types of notification channels that are supported, use
    /// the `ListNotificationChannelDescriptors` method.
    pub fn list_notification_channels(
        &self,
    ) -> super::builder::notification_channel_service::ListNotificationChannels {
        super::builder::notification_channel_service::ListNotificationChannels::new(
            self.inner.clone(),
        )
    }

    /// Gets a single notification channel. The channel includes the relevant
    /// configuration details with which the channel was created. However, the
    /// response may truncate or omit passwords, API keys, or other private key
    /// matter and thus the response may not be 100% identical to the information
    /// that was supplied in the call to the create method.
    pub fn get_notification_channel(
        &self,
    ) -> super::builder::notification_channel_service::GetNotificationChannel {
        super::builder::notification_channel_service::GetNotificationChannel::new(
            self.inner.clone(),
        )
    }

    /// Creates a new notification channel, representing a single notification
    /// endpoint such as an email address, SMS number, or PagerDuty service.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    pub fn create_notification_channel(
        &self,
    ) -> super::builder::notification_channel_service::CreateNotificationChannel {
        super::builder::notification_channel_service::CreateNotificationChannel::new(
            self.inner.clone(),
        )
    }

    /// Updates a notification channel. Fields not specified in the field mask
    /// remain unchanged.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    pub fn update_notification_channel(
        &self,
    ) -> super::builder::notification_channel_service::UpdateNotificationChannel {
        super::builder::notification_channel_service::UpdateNotificationChannel::new(
            self.inner.clone(),
        )
    }

    /// Deletes a notification channel.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    pub fn delete_notification_channel(
        &self,
    ) -> super::builder::notification_channel_service::DeleteNotificationChannel {
        super::builder::notification_channel_service::DeleteNotificationChannel::new(
            self.inner.clone(),
        )
    }

    /// Causes a verification code to be delivered to the channel. The code
    /// can then be supplied in `VerifyNotificationChannel` to verify the channel.
    pub fn send_notification_channel_verification_code(
        &self,
    ) -> super::builder::notification_channel_service::SendNotificationChannelVerificationCode {
        super::builder::notification_channel_service::SendNotificationChannelVerificationCode::new(
            self.inner.clone(),
        )
    }

    /// Requests a verification code for an already verified channel that can then
    /// be used in a call to VerifyNotificationChannel() on a different channel
    /// with an equivalent identity in the same or in a different project. This
    /// makes it possible to copy a channel between projects without requiring
    /// manual reverification of the channel. If the channel is not in the
    /// verified state, this method will fail (in other words, this may only be
    /// used if the SendNotificationChannelVerificationCode and
    /// VerifyNotificationChannel paths have already been used to put the given
    /// channel into the verified state).
    ///
    /// There is no guarantee that the verification codes returned by this method
    /// will be of a similar structure or form as the ones that are delivered
    /// to the channel via SendNotificationChannelVerificationCode; while
    /// VerifyNotificationChannel() will recognize both the codes delivered via
    /// SendNotificationChannelVerificationCode() and returned from
    /// GetNotificationChannelVerificationCode(), it is typically the case that
    /// the verification codes delivered via
    /// SendNotificationChannelVerificationCode() will be shorter and also
    /// have a shorter expiration (e.g. codes such as "G-123456") whereas
    /// GetVerificationCode() will typically return a much longer, websafe base
    /// 64 encoded string that has a longer expiration time.
    pub fn get_notification_channel_verification_code(
        &self,
    ) -> super::builder::notification_channel_service::GetNotificationChannelVerificationCode {
        super::builder::notification_channel_service::GetNotificationChannelVerificationCode::new(
            self.inner.clone(),
        )
    }

    /// Verifies a `NotificationChannel` by proving receipt of the code
    /// delivered to the channel as a result of calling
    /// `SendNotificationChannelVerificationCode`.
    pub fn verify_notification_channel(
        &self,
    ) -> super::builder::notification_channel_service::VerifyNotificationChannel {
        super::builder::notification_channel_service::VerifyNotificationChannel::new(
            self.inner.clone(),
        )
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::QueryService;
/// let client = QueryService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// The QueryService API is used to manage time series data in Cloud
/// Monitoring. Time series data is a collection of data points that describes
/// the time-varying values of a metric.
///
/// # Configuration
///
/// To configure `QueryService` use the `with_*` methods in the type returned
/// by [builder()][QueryService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::query_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::query_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `QueryService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `QueryService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct QueryService {
    inner: std::sync::Arc<dyn super::stub::dynamic::QueryService>,
}

impl QueryService {
    /// Returns a builder for [QueryService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::QueryService;
    /// let client = QueryService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::query_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::query_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::QueryService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::QueryService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::QueryService> {
        super::transport::QueryService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::QueryService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::QueryService::new)
    }

    /// Queries time series by using Monitoring Query Language (MQL). We recommend
    /// using PromQL instead of MQL. For more information about the status of MQL,
    /// see the [MQL deprecation
    /// notice](https://cloud.google.com/stackdriver/docs/deprecations/mql).
    #[deprecated]
    pub fn query_time_series(&self) -> super::builder::query_service::QueryTimeSeries {
        super::builder::query_service::QueryTimeSeries::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::ServiceMonitoringService;
/// let client = ServiceMonitoringService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// The Cloud Monitoring Service-Oriented Monitoring API has endpoints for
/// managing and querying aspects of a Metrics Scope's services. These include
/// the `Service`'s monitored resources, its Service-Level Objectives, and a
/// taxonomy of categorized Health Metrics.
///
/// # Configuration
///
/// To configure `ServiceMonitoringService` use the `with_*` methods in the type returned
/// by [builder()][ServiceMonitoringService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::service_monitoring_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::service_monitoring_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ServiceMonitoringService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ServiceMonitoringService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ServiceMonitoringService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ServiceMonitoringService>,
}

impl ServiceMonitoringService {
    /// Returns a builder for [ServiceMonitoringService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::ServiceMonitoringService;
    /// let client = ServiceMonitoringService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::service_monitoring_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::service_monitoring_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ServiceMonitoringService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::ServiceMonitoringService>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ServiceMonitoringService> {
        super::transport::ServiceMonitoringService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ServiceMonitoringService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ServiceMonitoringService::new)
    }

    /// Create a `Service`.
    pub fn create_service(&self) -> super::builder::service_monitoring_service::CreateService {
        super::builder::service_monitoring_service::CreateService::new(self.inner.clone())
    }

    /// Get the named `Service`.
    pub fn get_service(&self) -> super::builder::service_monitoring_service::GetService {
        super::builder::service_monitoring_service::GetService::new(self.inner.clone())
    }

    /// List `Service`s for this Metrics Scope.
    pub fn list_services(&self) -> super::builder::service_monitoring_service::ListServices {
        super::builder::service_monitoring_service::ListServices::new(self.inner.clone())
    }

    /// Update this `Service`.
    pub fn update_service(&self) -> super::builder::service_monitoring_service::UpdateService {
        super::builder::service_monitoring_service::UpdateService::new(self.inner.clone())
    }

    /// Soft delete this `Service`.
    pub fn delete_service(&self) -> super::builder::service_monitoring_service::DeleteService {
        super::builder::service_monitoring_service::DeleteService::new(self.inner.clone())
    }

    /// Create a `ServiceLevelObjective` for the given `Service`.
    pub fn create_service_level_objective(
        &self,
    ) -> super::builder::service_monitoring_service::CreateServiceLevelObjective {
        super::builder::service_monitoring_service::CreateServiceLevelObjective::new(
            self.inner.clone(),
        )
    }

    /// Get a `ServiceLevelObjective` by name.
    pub fn get_service_level_objective(
        &self,
    ) -> super::builder::service_monitoring_service::GetServiceLevelObjective {
        super::builder::service_monitoring_service::GetServiceLevelObjective::new(
            self.inner.clone(),
        )
    }

    /// List the `ServiceLevelObjective`s for the given `Service`.
    pub fn list_service_level_objectives(
        &self,
    ) -> super::builder::service_monitoring_service::ListServiceLevelObjectives {
        super::builder::service_monitoring_service::ListServiceLevelObjectives::new(
            self.inner.clone(),
        )
    }

    /// Update the given `ServiceLevelObjective`.
    pub fn update_service_level_objective(
        &self,
    ) -> super::builder::service_monitoring_service::UpdateServiceLevelObjective {
        super::builder::service_monitoring_service::UpdateServiceLevelObjective::new(
            self.inner.clone(),
        )
    }

    /// Delete the given `ServiceLevelObjective`.
    pub fn delete_service_level_objective(
        &self,
    ) -> super::builder::service_monitoring_service::DeleteServiceLevelObjective {
        super::builder::service_monitoring_service::DeleteServiceLevelObjective::new(
            self.inner.clone(),
        )
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::SnoozeService;
/// let client = SnoozeService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// The SnoozeService API is used to temporarily prevent an alert policy from
/// generating alerts. A Snooze is a description of the criteria under which one
/// or more alert policies should not fire alerts for the specified duration.
///
/// # Configuration
///
/// To configure `SnoozeService` use the `with_*` methods in the type returned
/// by [builder()][SnoozeService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::snooze_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::snooze_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `SnoozeService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SnoozeService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct SnoozeService {
    inner: std::sync::Arc<dyn super::stub::dynamic::SnoozeService>,
}

impl SnoozeService {
    /// Returns a builder for [SnoozeService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::SnoozeService;
    /// let client = SnoozeService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::snooze_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::snooze_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::SnoozeService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::SnoozeService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SnoozeService> {
        super::transport::SnoozeService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SnoozeService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::SnoozeService::new)
    }

    /// Creates a `Snooze` that will prevent alerts, which match the provided
    /// criteria, from being opened. The `Snooze` applies for a specific time
    /// interval.
    pub fn create_snooze(&self) -> super::builder::snooze_service::CreateSnooze {
        super::builder::snooze_service::CreateSnooze::new(self.inner.clone())
    }

    /// Lists the `Snooze`s associated with a project. Can optionally pass in
    /// `filter`, which specifies predicates to match `Snooze`s.
    pub fn list_snoozes(&self) -> super::builder::snooze_service::ListSnoozes {
        super::builder::snooze_service::ListSnoozes::new(self.inner.clone())
    }

    /// Retrieves a `Snooze` by `name`.
    pub fn get_snooze(&self) -> super::builder::snooze_service::GetSnooze {
        super::builder::snooze_service::GetSnooze::new(self.inner.clone())
    }

    /// Updates a `Snooze`, identified by its `name`, with the parameters in the
    /// given `Snooze` object.
    pub fn update_snooze(&self) -> super::builder::snooze_service::UpdateSnooze {
        super::builder::snooze_service::UpdateSnooze::new(self.inner.clone())
    }
}

/// Implements a client for the Cloud Monitoring API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_monitoring_v3::client::UptimeCheckService;
/// let client = UptimeCheckService::builder().build().await?;
/// // use `client` to make requests to the Cloud Monitoring API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// The UptimeCheckService API is used to manage (list, create, delete, edit)
/// Uptime check configurations in the Cloud Monitoring product. An Uptime
/// check is a piece of configuration that determines which resources and
/// services to monitor for availability. These configurations can also be
/// configured interactively by navigating to the [Cloud console]
/// (<https://console.cloud.google.com>), selecting the appropriate project,
/// clicking on "Monitoring" on the left-hand side to navigate to Cloud
/// Monitoring, and then clicking on "Uptime".
///
/// # Configuration
///
/// To configure `UptimeCheckService` use the `with_*` methods in the type returned
/// by [builder()][UptimeCheckService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://monitoring.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::uptime_check_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::uptime_check_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `UptimeCheckService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `UptimeCheckService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct UptimeCheckService {
    inner: std::sync::Arc<dyn super::stub::dynamic::UptimeCheckService>,
}

impl UptimeCheckService {
    /// Returns a builder for [UptimeCheckService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_monitoring_v3::client::UptimeCheckService;
    /// let client = UptimeCheckService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::uptime_check_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::uptime_check_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::UptimeCheckService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::UptimeCheckService>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::UptimeCheckService> {
        super::transport::UptimeCheckService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::UptimeCheckService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::UptimeCheckService::new)
    }

    /// Lists the existing valid Uptime check configurations for the project
    /// (leaving out any invalid configurations).
    pub fn list_uptime_check_configs(
        &self,
    ) -> super::builder::uptime_check_service::ListUptimeCheckConfigs {
        super::builder::uptime_check_service::ListUptimeCheckConfigs::new(self.inner.clone())
    }

    /// Gets a single Uptime check configuration.
    pub fn get_uptime_check_config(
        &self,
    ) -> super::builder::uptime_check_service::GetUptimeCheckConfig {
        super::builder::uptime_check_service::GetUptimeCheckConfig::new(self.inner.clone())
    }

    /// Creates a new Uptime check configuration.
    pub fn create_uptime_check_config(
        &self,
    ) -> super::builder::uptime_check_service::CreateUptimeCheckConfig {
        super::builder::uptime_check_service::CreateUptimeCheckConfig::new(self.inner.clone())
    }

    /// Updates an Uptime check configuration. You can either replace the entire
    /// configuration with a new one or replace only certain fields in the current
    /// configuration by specifying the fields to be updated via `updateMask`.
    /// Returns the updated configuration.
    pub fn update_uptime_check_config(
        &self,
    ) -> super::builder::uptime_check_service::UpdateUptimeCheckConfig {
        super::builder::uptime_check_service::UpdateUptimeCheckConfig::new(self.inner.clone())
    }

    /// Deletes an Uptime check configuration. Note that this method will fail
    /// if the Uptime check configuration is referenced by an alert policy or
    /// other dependent configs that would be rendered invalid by the deletion.
    pub fn delete_uptime_check_config(
        &self,
    ) -> super::builder::uptime_check_service::DeleteUptimeCheckConfig {
        super::builder::uptime_check_service::DeleteUptimeCheckConfig::new(self.inner.clone())
    }

    /// Returns the list of IP addresses that checkers run from.
    pub fn list_uptime_check_ips(
        &self,
    ) -> super::builder::uptime_check_service::ListUptimeCheckIps {
        super::builder::uptime_check_service::ListUptimeCheckIps::new(self.inner.clone())
    }
}
