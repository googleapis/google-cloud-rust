// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [AlertPolicyService](super::stub::AlertPolicyService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct AlertPolicyService<T>
where
    T: super::stub::AlertPolicyService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> AlertPolicyService<T>
where
    T: super::stub::AlertPolicyService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::AlertPolicyService for AlertPolicyService<T>
where
    T: super::stub::AlertPolicyService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_alert_policies(
        &self,
        req: crate::model::ListAlertPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAlertPoliciesResponse>> {
        self.inner.list_alert_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_alert_policy(
        &self,
        req: crate::model::GetAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        self.inner.get_alert_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_alert_policy(
        &self,
        req: crate::model::CreateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        self.inner.create_alert_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_alert_policy(
        &self,
        req: crate::model::DeleteAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_alert_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_alert_policy(
        &self,
        req: crate::model::UpdateAlertPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AlertPolicy>> {
        self.inner.update_alert_policy(req, options).await
    }
}

/// Implements a [GroupService](super::stub::GroupService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct GroupService<T>
where
    T: super::stub::GroupService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> GroupService<T>
where
    T: super::stub::GroupService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::GroupService for GroupService<T>
where
    T: super::stub::GroupService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_groups(
        &self,
        req: crate::model::ListGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGroupsResponse>> {
        self.inner.list_groups(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_group(
        &self,
        req: crate::model::GetGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        self.inner.get_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_group(
        &self,
        req: crate::model::CreateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        self.inner.create_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_group(
        &self,
        req: crate::model::UpdateGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Group>> {
        self.inner.update_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_group(
        &self,
        req: crate::model::DeleteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_group_members(
        &self,
        req: crate::model::ListGroupMembersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGroupMembersResponse>> {
        self.inner.list_group_members(req, options).await
    }
}

/// Implements a [MetricService](super::stub::MetricService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct MetricService<T>
where
    T: super::stub::MetricService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> MetricService<T>
where
    T: super::stub::MetricService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::MetricService for MetricService<T>
where
    T: super::stub::MetricService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_monitored_resource_descriptors(
        &self,
        req: crate::model::ListMonitoredResourceDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMonitoredResourceDescriptorsResponse>>
    {
        self.inner
            .list_monitored_resource_descriptors(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_monitored_resource_descriptor(
        &self,
        req: crate::model::GetMonitoredResourceDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MonitoredResourceDescriptor>> {
        self.inner
            .get_monitored_resource_descriptor(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_metric_descriptors(
        &self,
        req: crate::model::ListMetricDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetricDescriptorsResponse>> {
        self.inner.list_metric_descriptors(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_metric_descriptor(
        &self,
        req: crate::model::GetMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MetricDescriptor>> {
        self.inner.get_metric_descriptor(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_metric_descriptor(
        &self,
        req: crate::model::CreateMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::MetricDescriptor>> {
        self.inner.create_metric_descriptor(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_metric_descriptor(
        &self,
        req: crate::model::DeleteMetricDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_metric_descriptor(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_time_series(
        &self,
        req: crate::model::ListTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTimeSeriesResponse>> {
        self.inner.list_time_series(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.create_time_series(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_service_time_series(
        &self,
        req: crate::model::CreateTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.create_service_time_series(req, options).await
    }
}

/// Implements a [NotificationChannelService](super::stub::NotificationChannelService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct NotificationChannelService<T>
where
    T: super::stub::NotificationChannelService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> NotificationChannelService<T>
where
    T: super::stub::NotificationChannelService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::NotificationChannelService for NotificationChannelService<T>
where
    T: super::stub::NotificationChannelService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_notification_channel_descriptors(
        &self,
        req: crate::model::ListNotificationChannelDescriptorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotificationChannelDescriptorsResponse>>
    {
        self.inner
            .list_notification_channel_descriptors(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_notification_channel_descriptor(
        &self,
        req: crate::model::GetNotificationChannelDescriptorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannelDescriptor>> {
        self.inner
            .get_notification_channel_descriptor(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_notification_channels(
        &self,
        req: crate::model::ListNotificationChannelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotificationChannelsResponse>> {
        self.inner.list_notification_channels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_notification_channel(
        &self,
        req: crate::model::GetNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        self.inner.get_notification_channel(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_notification_channel(
        &self,
        req: crate::model::CreateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        self.inner.create_notification_channel(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_notification_channel(
        &self,
        req: crate::model::UpdateNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        self.inner.update_notification_channel(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_notification_channel(
        &self,
        req: crate::model::DeleteNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_notification_channel(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn send_notification_channel_verification_code(
        &self,
        req: crate::model::SendNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .send_notification_channel_verification_code(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_notification_channel_verification_code(
        &self,
        req: crate::model::GetNotificationChannelVerificationCodeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetNotificationChannelVerificationCodeResponse>>
    {
        self.inner
            .get_notification_channel_verification_code(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn verify_notification_channel(
        &self,
        req: crate::model::VerifyNotificationChannelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationChannel>> {
        self.inner.verify_notification_channel(req, options).await
    }
}

/// Implements a [QueryService](super::stub::QueryService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct QueryService<T>
where
    T: super::stub::QueryService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> QueryService<T>
where
    T: super::stub::QueryService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::QueryService for QueryService<T>
where
    T: super::stub::QueryService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn query_time_series(
        &self,
        req: crate::model::QueryTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryTimeSeriesResponse>> {
        self.inner.query_time_series(req, options).await
    }
}

/// Implements a [ServiceMonitoringService](super::stub::ServiceMonitoringService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ServiceMonitoringService<T>
where
    T: super::stub::ServiceMonitoringService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ServiceMonitoringService<T>
where
    T: super::stub::ServiceMonitoringService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ServiceMonitoringService for ServiceMonitoringService<T>
where
    T: super::stub::ServiceMonitoringService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_service(
        &self,
        req: crate::model::CreateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        self.inner.create_service(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_service(
        &self,
        req: crate::model::GetServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        self.inner.get_service(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_services(
        &self,
        req: crate::model::ListServicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServicesResponse>> {
        self.inner.list_services(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_service(
        &self,
        req: crate::model::UpdateServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Service>> {
        self.inner.update_service(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_service(
        &self,
        req: crate::model::DeleteServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_service(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_service_level_objective(
        &self,
        req: crate::model::CreateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        self.inner
            .create_service_level_objective(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_service_level_objective(
        &self,
        req: crate::model::GetServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        self.inner.get_service_level_objective(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_service_level_objectives(
        &self,
        req: crate::model::ListServiceLevelObjectivesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServiceLevelObjectivesResponse>> {
        self.inner.list_service_level_objectives(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_service_level_objective(
        &self,
        req: crate::model::UpdateServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceLevelObjective>> {
        self.inner
            .update_service_level_objective(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn delete_service_level_objective(
        &self,
        req: crate::model::DeleteServiceLevelObjectiveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .delete_service_level_objective(req, options)
            .await
    }
}

/// Implements a [SnoozeService](super::stub::SnoozeService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SnoozeService<T>
where
    T: super::stub::SnoozeService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SnoozeService<T>
where
    T: super::stub::SnoozeService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SnoozeService for SnoozeService<T>
where
    T: super::stub::SnoozeService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_snooze(
        &self,
        req: crate::model::CreateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        self.inner.create_snooze(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_snoozes(
        &self,
        req: crate::model::ListSnoozesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSnoozesResponse>> {
        self.inner.list_snoozes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_snooze(
        &self,
        req: crate::model::GetSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        self.inner.get_snooze(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_snooze(
        &self,
        req: crate::model::UpdateSnoozeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snooze>> {
        self.inner.update_snooze(req, options).await
    }
}

/// Implements a [UptimeCheckService](super::stub::UptimeCheckService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct UptimeCheckService<T>
where
    T: super::stub::UptimeCheckService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> UptimeCheckService<T>
where
    T: super::stub::UptimeCheckService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::UptimeCheckService for UptimeCheckService<T>
where
    T: super::stub::UptimeCheckService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_uptime_check_configs(
        &self,
        req: crate::model::ListUptimeCheckConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUptimeCheckConfigsResponse>> {
        self.inner.list_uptime_check_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_uptime_check_config(
        &self,
        req: crate::model::GetUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        self.inner.get_uptime_check_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_uptime_check_config(
        &self,
        req: crate::model::CreateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        self.inner.create_uptime_check_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_uptime_check_config(
        &self,
        req: crate::model::UpdateUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UptimeCheckConfig>> {
        self.inner.update_uptime_check_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_uptime_check_config(
        &self,
        req: crate::model::DeleteUptimeCheckConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_uptime_check_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_uptime_check_ips(
        &self,
        req: crate::model::ListUptimeCheckIpsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUptimeCheckIpsResponse>> {
        self.inner.list_uptime_check_ips(req, options).await
    }
}
