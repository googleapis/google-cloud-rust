// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::broken_intra_doc_links)]

use gax::error::Error;

pub(crate) mod dyntraits;

/// The AlertPolicyService API is used to manage (list, create, delete,
/// edit) alert policies in Cloud Monitoring. An alerting policy is
/// a description of the conditions under which some aspect of your
/// system is considered to be "unhealthy" and the ways to notify
/// people or services about this state. In addition to using this API, alert
/// policies can also be managed through
/// [Cloud Monitoring](https://cloud.google.com/monitoring/docs/),
/// which can be reached by clicking the "Monitoring" tab in
/// [Cloud console](https://console.cloud.google.com/).
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait AlertPolicyService: std::fmt::Debug + Send + Sync {
    /// Lists the existing alerting policies for the workspace.
    fn list_alert_policies(
        &self,
        _req: crate::model::ListAlertPoliciesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListAlertPoliciesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListAlertPoliciesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets a single alerting policy.
    fn get_alert_policy(
        &self,
        _req: crate::model::GetAlertPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AlertPolicy>> + Send {
        std::future::ready::<crate::Result<crate::model::AlertPolicy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Creates a new alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    fn create_alert_policy(
        &self,
        _req: crate::model::CreateAlertPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AlertPolicy>> + Send {
        std::future::ready::<crate::Result<crate::model::AlertPolicy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Deletes an alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    fn delete_alert_policy(
        &self,
        _req: crate::model::DeleteAlertPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Updates an alerting policy. You can either replace the entire policy with
    /// a new one or replace only certain fields in the current alerting policy by
    /// specifying the fields to be updated via `updateMask`. Returns the
    /// updated alerting policy.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// alerting policies in a single project. This includes calls to
    /// CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy.
    fn update_alert_policy(
        &self,
        _req: crate::model::UpdateAlertPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AlertPolicy>> + Send {
        std::future::ready::<crate::Result<crate::model::AlertPolicy>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// The Group API lets you inspect and manage your
/// [groups](#google.monitoring.v3.Group).
///
/// A group is a named filter that is used to identify
/// a collection of monitored resources. Groups are typically used to
/// mirror the physical and/or logical topology of the environment.
/// Because group membership is computed dynamically, monitored
/// resources that are started in the future are automatically placed
/// in matching groups. By using a group to name monitored resources in,
/// for example, an alert policy, the target of that alert policy is
/// updated automatically as monitored resources are added and removed
/// from the infrastructure.
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait GroupService: std::fmt::Debug + Send + Sync {
    /// Lists the existing groups.
    fn list_groups(
        &self,
        _req: crate::model::ListGroupsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListGroupsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListGroupsResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Gets a single group.
    fn get_group(
        &self,
        _req: crate::model::GetGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Group>> + Send {
        std::future::ready::<crate::Result<crate::model::Group>>(Err(Error::other("unimplemented")))
    }

    /// Creates a new group.
    fn create_group(
        &self,
        _req: crate::model::CreateGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Group>> + Send {
        std::future::ready::<crate::Result<crate::model::Group>>(Err(Error::other("unimplemented")))
    }

    /// Updates an existing group.
    /// You can change any group attributes except `name`.
    fn update_group(
        &self,
        _req: crate::model::UpdateGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Group>> + Send {
        std::future::ready::<crate::Result<crate::model::Group>>(Err(Error::other("unimplemented")))
    }

    /// Deletes an existing group.
    fn delete_group(
        &self,
        _req: crate::model::DeleteGroupRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Lists the monitored resources that are members of a group.
    fn list_group_members(
        &self,
        _req: crate::model::ListGroupMembersRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListGroupMembersResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListGroupMembersResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }
}

/// Manages metric descriptors, monitored resource descriptors, and
/// time series data.
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait MetricService: std::fmt::Debug + Send + Sync {
    /// Lists monitored resource descriptors that match a filter.
    fn list_monitored_resource_descriptors(
        &self,
        _req: crate::model::ListMonitoredResourceDescriptorsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ListMonitoredResourceDescriptorsResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ListMonitoredResourceDescriptorsResponse>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Gets a single monitored resource descriptor.
    fn get_monitored_resource_descriptor(
        &self,
        _req: crate::model::GetMonitoredResourceDescriptorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<api::model::MonitoredResourceDescriptor>> + Send
    {
        std::future::ready::<crate::Result<api::model::MonitoredResourceDescriptor>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists metric descriptors that match a filter.
    fn list_metric_descriptors(
        &self,
        _req: crate::model::ListMetricDescriptorsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListMetricDescriptorsResponse>>
           + Send {
        std::future::ready::<crate::Result<crate::model::ListMetricDescriptorsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets a single metric descriptor.
    fn get_metric_descriptor(
        &self,
        _req: crate::model::GetMetricDescriptorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<api::model::MetricDescriptor>> + Send {
        std::future::ready::<crate::Result<api::model::MetricDescriptor>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Creates a new metric descriptor.
    /// The creation is executed asynchronously.
    /// User-created metric descriptors define
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics).
    /// The metric descriptor is updated if it already exists,
    /// except that metric labels are never removed.
    fn create_metric_descriptor(
        &self,
        _req: crate::model::CreateMetricDescriptorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<api::model::MetricDescriptor>> + Send {
        std::future::ready::<crate::Result<api::model::MetricDescriptor>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Deletes a metric descriptor. Only user-created
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics) can be
    /// deleted.
    fn delete_metric_descriptor(
        &self,
        _req: crate::model::DeleteMetricDescriptorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Lists time series that match a filter.
    fn list_time_series(
        &self,
        _req: crate::model::ListTimeSeriesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListTimeSeriesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListTimeSeriesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Creates or adds data to one or more time series.
    /// The response is empty if all time series in the request were written.
    /// If any time series could not be written, a corresponding failure message is
    /// included in the error response.
    /// This method does not support
    /// [resource locations constraint of an organization
    /// policy](https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy).
    fn create_time_series(
        &self,
        _req: crate::model::CreateTimeSeriesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Creates or adds data to one or more service time series. A service time
    /// series is a time series for a metric from a Google Cloud service. The
    /// response is empty if all time series in the request were written. If any
    /// time series could not be written, a corresponding failure message is
    /// included in the error response. This endpoint rejects writes to
    /// user-defined metrics.
    /// This method is only for use by Google Cloud services. Use
    /// [projects.timeSeries.create][google.monitoring.v3.MetricService.CreateTimeSeries]
    /// instead.
    ///
    /// [google.monitoring.v3.MetricService.CreateTimeSeries]: crate::client::MetricService::create_time_series
    fn create_service_time_series(
        &self,
        _req: crate::model::CreateTimeSeriesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// The Notification Channel API provides access to configuration that
/// controls how messages related to incidents are sent.
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait NotificationChannelService: std::fmt::Debug + Send + Sync {
    /// Lists the descriptors for supported channel types. The use of descriptors
    /// makes it possible for new channel types to be dynamically added.
    fn list_notification_channel_descriptors(
        &self,
        _req: crate::model::ListNotificationChannelDescriptorsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ListNotificationChannelDescriptorsResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ListNotificationChannelDescriptorsResponse>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Gets a single channel descriptor. The descriptor indicates which fields
    /// are expected / permitted for a notification channel of the given type.
    fn get_notification_channel_descriptor(
        &self,
        _req: crate::model::GetNotificationChannelDescriptorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::NotificationChannelDescriptor>>
           + Send {
        std::future::ready::<crate::Result<crate::model::NotificationChannelDescriptor>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists the notification channels that have been created for the project.
    /// To list the types of notification channels that are supported, use
    /// the `ListNotificationChannelDescriptors` method.
    fn list_notification_channels(
        &self,
        _req: crate::model::ListNotificationChannelsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ListNotificationChannelsResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ListNotificationChannelsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets a single notification channel. The channel includes the relevant
    /// configuration details with which the channel was created. However, the
    /// response may truncate or omit passwords, API keys, or other private key
    /// matter and thus the response may not be 100% identical to the information
    /// that was supplied in the call to the create method.
    fn get_notification_channel(
        &self,
        _req: crate::model::GetNotificationChannelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::NotificationChannel>> + Send
    {
        std::future::ready::<crate::Result<crate::model::NotificationChannel>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Creates a new notification channel, representing a single notification
    /// endpoint such as an email address, SMS number, or PagerDuty service.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    fn create_notification_channel(
        &self,
        _req: crate::model::CreateNotificationChannelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::NotificationChannel>> + Send
    {
        std::future::ready::<crate::Result<crate::model::NotificationChannel>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Updates a notification channel. Fields not specified in the field mask
    /// remain unchanged.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    fn update_notification_channel(
        &self,
        _req: crate::model::UpdateNotificationChannelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::NotificationChannel>> + Send
    {
        std::future::ready::<crate::Result<crate::model::NotificationChannel>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Deletes a notification channel.
    ///
    /// Design your application to single-thread API calls that modify the state of
    /// notification channels in a single project. This includes calls to
    /// CreateNotificationChannel, DeleteNotificationChannel and
    /// UpdateNotificationChannel.
    fn delete_notification_channel(
        &self,
        _req: crate::model::DeleteNotificationChannelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Causes a verification code to be delivered to the channel. The code
    /// can then be supplied in `VerifyNotificationChannel` to verify the channel.
    fn send_notification_channel_verification_code(
        &self,
        _req: crate::model::SendNotificationChannelVerificationCodeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Requests a verification code for an already verified channel that can then
    /// be used in a call to VerifyNotificationChannel() on a different channel
    /// with an equivalent identity in the same or in a different project. This
    /// makes it possible to copy a channel between projects without requiring
    /// manual reverification of the channel. If the channel is not in the
    /// verified state, this method will fail (in other words, this may only be
    /// used if the SendNotificationChannelVerificationCode and
    /// VerifyNotificationChannel paths have already been used to put the given
    /// channel into the verified state).
    ///
    /// There is no guarantee that the verification codes returned by this method
    /// will be of a similar structure or form as the ones that are delivered
    /// to the channel via SendNotificationChannelVerificationCode; while
    /// VerifyNotificationChannel() will recognize both the codes delivered via
    /// SendNotificationChannelVerificationCode() and returned from
    /// GetNotificationChannelVerificationCode(), it is typically the case that
    /// the verification codes delivered via
    /// SendNotificationChannelVerificationCode() will be shorter and also
    /// have a shorter expiration (e.g. codes such as "G-123456") whereas
    /// GetVerificationCode() will typically return a much longer, websafe base
    /// 64 encoded string that has a longer expiration time.
    fn get_notification_channel_verification_code(
        &self,
        _req: crate::model::GetNotificationChannelVerificationCodeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::GetNotificationChannelVerificationCodeResponse>,
    > + Send {
        std::future::ready::<
            crate::Result<crate::model::GetNotificationChannelVerificationCodeResponse>,
        >(Err(Error::other("unimplemented")))
    }

    /// Verifies a `NotificationChannel` by proving receipt of the code
    /// delivered to the channel as a result of calling
    /// `SendNotificationChannelVerificationCode`.
    fn verify_notification_channel(
        &self,
        _req: crate::model::VerifyNotificationChannelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::NotificationChannel>> + Send
    {
        std::future::ready::<crate::Result<crate::model::NotificationChannel>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// The QueryService API is used to manage time series data in Cloud
/// Monitoring. Time series data is a collection of data points that describes
/// the time-varying values of a metric.
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait QueryService: std::fmt::Debug + Send + Sync {
    /// Queries time series by using Monitoring Query Language (MQL). We recommend
    /// using PromQL instead of MQL. For more information about the status of MQL,
    /// see the [MQL deprecation
    /// notice](https://cloud.google.com/stackdriver/docs/deprecations/mql).
    fn query_time_series(
        &self,
        _req: crate::model::QueryTimeSeriesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::QueryTimeSeriesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::QueryTimeSeriesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }
}

/// The Cloud Monitoring Service-Oriented Monitoring API has endpoints for
/// managing and querying aspects of a Metrics Scope's services. These include
/// the `Service`'s monitored resources, its Service-Level Objectives, and a
/// taxonomy of categorized Health Metrics.
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait ServiceMonitoringService: std::fmt::Debug + Send + Sync {
    /// Create a `Service`.
    fn create_service(
        &self,
        _req: crate::model::CreateServiceRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Service>> + Send {
        std::future::ready::<crate::Result<crate::model::Service>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Get the named `Service`.
    fn get_service(
        &self,
        _req: crate::model::GetServiceRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Service>> + Send {
        std::future::ready::<crate::Result<crate::model::Service>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// List `Service`s for this Metrics Scope.
    fn list_services(
        &self,
        _req: crate::model::ListServicesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListServicesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListServicesResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Update this `Service`.
    fn update_service(
        &self,
        _req: crate::model::UpdateServiceRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Service>> + Send {
        std::future::ready::<crate::Result<crate::model::Service>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Soft delete this `Service`.
    fn delete_service(
        &self,
        _req: crate::model::DeleteServiceRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Create a `ServiceLevelObjective` for the given `Service`.
    fn create_service_level_objective(
        &self,
        _req: crate::model::CreateServiceLevelObjectiveRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ServiceLevelObjective>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ServiceLevelObjective>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Get a `ServiceLevelObjective` by name.
    fn get_service_level_objective(
        &self,
        _req: crate::model::GetServiceLevelObjectiveRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ServiceLevelObjective>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ServiceLevelObjective>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// List the `ServiceLevelObjective`s for the given `Service`.
    fn list_service_level_objectives(
        &self,
        _req: crate::model::ListServiceLevelObjectivesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ListServiceLevelObjectivesResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ListServiceLevelObjectivesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Update the given `ServiceLevelObjective`.
    fn update_service_level_objective(
        &self,
        _req: crate::model::UpdateServiceLevelObjectiveRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ServiceLevelObjective>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ServiceLevelObjective>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Delete the given `ServiceLevelObjective`.
    fn delete_service_level_objective(
        &self,
        _req: crate::model::DeleteServiceLevelObjectiveRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// The SnoozeService API is used to temporarily prevent an alert policy from
/// generating alerts. A Snooze is a description of the criteria under which one
/// or more alert policies should not fire alerts for the specified duration.
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait SnoozeService: std::fmt::Debug + Send + Sync {
    /// Creates a `Snooze` that will prevent alerts, which match the provided
    /// criteria, from being opened. The `Snooze` applies for a specific time
    /// interval.
    fn create_snooze(
        &self,
        _req: crate::model::CreateSnoozeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Snooze>> + Send {
        std::future::ready::<crate::Result<crate::model::Snooze>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Lists the `Snooze`s associated with a project. Can optionally pass in
    /// `filter`, which specifies predicates to match `Snooze`s.
    fn list_snoozes(
        &self,
        _req: crate::model::ListSnoozesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListSnoozesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListSnoozesResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Retrieves a `Snooze` by `name`.
    fn get_snooze(
        &self,
        _req: crate::model::GetSnoozeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Snooze>> + Send {
        std::future::ready::<crate::Result<crate::model::Snooze>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Updates a `Snooze`, identified by its `name`, with the parameters in the
    /// given `Snooze` object.
    fn update_snooze(
        &self,
        _req: crate::model::UpdateSnoozeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Snooze>> + Send {
        std::future::ready::<crate::Result<crate::model::Snooze>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// The UptimeCheckService API is used to manage (list, create, delete, edit)
/// Uptime check configurations in the Cloud Monitoring product. An Uptime
/// check is a piece of configuration that determines which resources and
/// services to monitor for availability. These configurations can also be
/// configured interactively by navigating to the [Cloud console]
/// (<https://console.cloud.google.com>), selecting the appropriate project,
/// clicking on "Monitoring" on the left-hand side to navigate to Cloud
/// Monitoring, and then clicking on "Uptime".
///
/// # Mocking
///
/// Application developers may use this trait to mock the monitoring clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait UptimeCheckService: std::fmt::Debug + Send + Sync {
    /// Lists the existing valid Uptime check configurations for the project
    /// (leaving out any invalid configurations).
    fn list_uptime_check_configs(
        &self,
        _req: crate::model::ListUptimeCheckConfigsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListUptimeCheckConfigsResponse>>
           + Send {
        std::future::ready::<crate::Result<crate::model::ListUptimeCheckConfigsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets a single Uptime check configuration.
    fn get_uptime_check_config(
        &self,
        _req: crate::model::GetUptimeCheckConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::UptimeCheckConfig>> + Send
    {
        std::future::ready::<crate::Result<crate::model::UptimeCheckConfig>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Creates a new Uptime check configuration.
    fn create_uptime_check_config(
        &self,
        _req: crate::model::CreateUptimeCheckConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::UptimeCheckConfig>> + Send
    {
        std::future::ready::<crate::Result<crate::model::UptimeCheckConfig>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Updates an Uptime check configuration. You can either replace the entire
    /// configuration with a new one or replace only certain fields in the current
    /// configuration by specifying the fields to be updated via `updateMask`.
    /// Returns the updated configuration.
    fn update_uptime_check_config(
        &self,
        _req: crate::model::UpdateUptimeCheckConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::UptimeCheckConfig>> + Send
    {
        std::future::ready::<crate::Result<crate::model::UptimeCheckConfig>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Deletes an Uptime check configuration. Note that this method will fail
    /// if the Uptime check configuration is referenced by an alert policy or
    /// other dependent configs that would be rendered invalid by the deletion.
    fn delete_uptime_check_config(
        &self,
        _req: crate::model::DeleteUptimeCheckConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Returns the list of IP addresses that checkers run from.
    fn list_uptime_check_ips(
        &self,
        _req: crate::model::ListUptimeCheckIpsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListUptimeCheckIpsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListUptimeCheckIpsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }
}
