// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A description of the conditions under which some aspect of your system is
/// considered to be "unhealthy" and the ways to notify people or services about
/// this state. For an overview of alerting policies, see
/// [Introduction to Alerting](https://cloud.google.com/monitoring/alerts/).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlertPolicy {
    /// Identifier. Required if the policy exists. The resource name for this
    /// policy. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    ///
    /// `[ALERT_POLICY_ID]` is assigned by Cloud Monitoring when the policy
    /// is created. When calling the
    /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
    /// method, do not include the `name` field in the alerting policy passed as
    /// part of the request.
    ///
    /// [google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]: crate::client::AlertPolicyService::create_alert_policy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A short name or phrase used to identify the policy in dashboards,
    /// notifications, and incidents. To avoid confusion, don't use the same
    /// display name for multiple policies in the same project. The name is
    /// limited to 512 Unicode characters.
    ///
    /// The convention for the display_name of a PrometheusQueryLanguageCondition
    /// is "{rule group name}/{alert name}", where the {rule group name} and
    /// {alert name} should be taken from the corresponding Prometheus
    /// configuration file. This convention is not enforced.
    /// In any case the display_name is not a unique key of the AlertPolicy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Documentation that is included with notifications and incidents related to
    /// this policy. Best practice is for the documentation to include information
    /// to help responders understand, mitigate, escalate, and correct the
    /// underlying problems detected by the alerting policy. Notification channels
    /// that have limited capacity might not show this documentation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub documentation: std::option::Option<crate::model::alert_policy::Documentation>,

    /// User-supplied key/value data to be used for organizing and
    /// identifying the `AlertPolicy` objects.
    ///
    /// The field can contain up to 64 entries. Each key and value is limited to
    /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
    /// values can contain only lowercase letters, numerals, underscores, and
    /// dashes. Keys must begin with a letter.
    ///
    /// Note that Prometheus {alert name} is a
    /// [valid Prometheus label
    /// names](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels),
    /// whereas Prometheus {rule group} is an unrestricted UTF-8 string.
    /// This means that they cannot be stored as-is in user labels, because
    /// they may contain characters that are not allowed in user-label values.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A list of conditions for the policy. The conditions are combined by AND or
    /// OR according to the `combiner` field. If the combined conditions evaluate
    /// to true, then an incident is created. A policy can have from one to six
    /// conditions.
    /// If `condition_time_series_query_language` is present, it must be the only
    /// `condition`.
    /// If `condition_monitoring_query_language` is present, it must be the only
    /// `condition`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::alert_policy::Condition>,

    /// How to combine the results of multiple conditions to determine if an
    /// incident should be opened.
    /// If `condition_time_series_query_language` is present, this must be
    /// `COMBINE_UNSPECIFIED`.
    pub combiner: crate::model::alert_policy::ConditionCombinerType,

    /// Whether or not the policy is enabled. On write, the default interpretation
    /// if unset is that the policy is enabled. On read, clients should not make
    /// any assumption about the state if it has not been populated. The
    /// field should always be populated on List and Get operations, unless
    /// a field projection has been specified that strips it out.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<wkt::BoolValue>,

    /// Read-only description of how the alerting policy is invalid. This field is
    /// only set when the alerting policy is invalid. An invalid alerting policy
    /// will not generate incidents.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub validity: std::option::Option<rpc::model::Status>,

    /// Identifies the notification channels to which notifications should be sent
    /// when incidents are opened or closed or when new violations occur on
    /// an already opened incident. Each element of this array corresponds to
    /// the `name` field in each of the
    /// [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
    /// objects that are returned from the [`ListNotificationChannels`]
    /// [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
    /// method. The format of the entries in this field is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    ///
    /// [google.monitoring.v3.NotificationChannel]: crate::model::NotificationChannel
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notification_channels: std::vec::Vec<std::string::String>,

    /// A read-only record of the creation of the alerting policy. If provided
    /// in a call to create or update, this field will be ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub creation_record: std::option::Option<crate::model::MutationRecord>,

    /// A read-only record of the most recent change to the alerting policy. If
    /// provided in a call to create or update, this field will be ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mutation_record: std::option::Option<crate::model::MutationRecord>,

    /// Control over how this alerting policy's notification channels are notified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub alert_strategy: std::option::Option<crate::model::alert_policy::AlertStrategy>,

    /// Optional. The severity of an alerting policy indicates how important
    /// incidents generated by that policy are. The severity level will be
    /// displayed on the Incident detail page and in notifications.
    pub severity: crate::model::alert_policy::Severity,
}

impl AlertPolicy {
    /// Sets the value of [name][crate::model::AlertPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AlertPolicy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [documentation][crate::model::AlertPolicy::documentation].
    pub fn set_documentation<
        T: std::convert::Into<std::option::Option<crate::model::alert_policy::Documentation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.documentation = v.into();
        self
    }

    /// Sets the value of [combiner][crate::model::AlertPolicy::combiner].
    pub fn set_combiner<
        T: std::convert::Into<crate::model::alert_policy::ConditionCombinerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.combiner = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::AlertPolicy::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [validity][crate::model::AlertPolicy::validity].
    pub fn set_validity<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.validity = v.into();
        self
    }

    /// Sets the value of [creation_record][crate::model::AlertPolicy::creation_record].
    pub fn set_creation_record<
        T: std::convert::Into<std::option::Option<crate::model::MutationRecord>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.creation_record = v.into();
        self
    }

    /// Sets the value of [mutation_record][crate::model::AlertPolicy::mutation_record].
    pub fn set_mutation_record<
        T: std::convert::Into<std::option::Option<crate::model::MutationRecord>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mutation_record = v.into();
        self
    }

    /// Sets the value of [alert_strategy][crate::model::AlertPolicy::alert_strategy].
    pub fn set_alert_strategy<
        T: std::convert::Into<std::option::Option<crate::model::alert_policy::AlertStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alert_strategy = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::AlertPolicy::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::alert_policy::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::AlertPolicy::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::alert_policy::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [notification_channels][crate::model::AlertPolicy::notification_channels].
    pub fn set_notification_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.notification_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::AlertPolicy::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AlertPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.AlertPolicy"
    }
}

/// Defines additional types related to AlertPolicy
pub mod alert_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Documentation that is included in the notifications and incidents
    /// pertaining to this policy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Documentation {
        /// The body of the documentation, interpreted according to `mime_type`.
        /// The content may not exceed 8,192 Unicode characters and may not exceed
        /// more than 10,240 bytes when encoded in UTF-8 format, whichever is
        /// smaller. This text can be [templatized by using
        /// variables](https://cloud.google.com/monitoring/alerts/doc-variables#doc-vars).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub content: std::string::String,

        /// The format of the `content` field. Presently, only the value
        /// `"text/markdown"` is supported. See
        /// [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub mime_type: std::string::String,

        /// Optional. The subject line of the notification. The subject line may not
        /// exceed 10,240 bytes. In notifications generated by this policy, the
        /// contents of the subject line after variable expansion will be truncated
        /// to 255 bytes or shorter at the latest UTF-8 character boundary. The
        /// 255-byte limit is recommended by [this
        /// thread](https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit).
        /// It is both the limit imposed by some third-party ticketing products and
        /// it is common to define textual fields in databases as VARCHAR(255).
        ///
        /// The contents of the subject line can be [templatized by using
        /// variables](https://cloud.google.com/monitoring/alerts/doc-variables#doc-vars).
        /// If this field is missing or empty, a default subject line will be
        /// generated.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub subject: std::string::String,

        /// Optional. Links to content such as playbooks, repositories, and other
        /// resources. This field can contain up to 3 entries.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub links: std::vec::Vec<crate::model::alert_policy::documentation::Link>,
    }

    impl Documentation {
        /// Sets the value of [content][crate::model::alert_policy::Documentation::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }

        /// Sets the value of [mime_type][crate::model::alert_policy::Documentation::mime_type].
        pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mime_type = v.into();
            self
        }

        /// Sets the value of [subject][crate::model::alert_policy::Documentation::subject].
        pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subject = v.into();
            self
        }

        /// Sets the value of [links][crate::model::alert_policy::Documentation::links].
        pub fn set_links<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::alert_policy::documentation::Link>,
        {
            use std::iter::Iterator;
            self.links = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Documentation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.AlertPolicy.Documentation"
        }
    }

    /// Defines additional types related to Documentation
    pub mod documentation {
        #[allow(unused_imports)]
        use super::*;

        /// Links to content such as playbooks, repositories, and other resources.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Link {
            /// A short display name for the link. The display name must not be empty
            /// or exceed 63 characters. Example: "playbook".
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub display_name: std::string::String,

            /// The url of a webpage.
            /// A url can be templatized by using variables
            /// in the path or the query parameters. The total length of a URL should
            /// not exceed 2083 characters before and after variable expansion.
            /// Example: `https://my_domain.com/playbook?name=${resource.name}`
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub url: std::string::String,
        }

        impl Link {
            /// Sets the value of [display_name][crate::model::alert_policy::documentation::Link::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [url][crate::model::alert_policy::documentation::Link::url].
            pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.url = v.into();
                self
            }
        }

        impl wkt::message::Message for Link {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Documentation.Link"
            }
        }
    }

    /// A condition is a true/false test that determines when an alerting policy
    /// should open an incident. If a condition evaluates to true, it signifies
    /// that something is wrong.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Condition {
        /// Required if the condition exists. The unique resource name for this
        /// condition. Its format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
        /// ```
        ///
        /// `[CONDITION_ID]` is assigned by Cloud Monitoring when the
        /// condition is created as part of a new or updated alerting policy.
        ///
        /// When calling the
        /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
        /// method, do not include the `name` field in the conditions of the
        /// requested alerting policy. Cloud Monitoring creates the
        /// condition identifiers and includes them in the new policy.
        ///
        /// When calling the
        /// [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
        /// method to update a policy, including a condition `name` causes the
        /// existing condition to be updated. Conditions without names are added to
        /// the updated policy. Existing conditions are deleted if they are not
        /// updated.
        ///
        /// Best practice is to preserve `[CONDITION_ID]` if you make only small
        /// changes, such as those to condition thresholds, durations, or trigger
        /// values.  Otherwise, treat the change as a new condition and let the
        /// existing condition be deleted.
        ///
        /// [google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]: crate::client::AlertPolicyService::create_alert_policy
        /// [google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]: crate::client::AlertPolicyService::update_alert_policy
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// A short name or phrase used to identify the condition in dashboards,
        /// notifications, and incidents. To avoid confusion, don't use the same
        /// display name for multiple conditions in the same policy.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// Only one of the following condition types will be specified.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub condition: std::option::Option<crate::model::alert_policy::condition::Condition>,
    }

    impl Condition {
        /// Sets the value of [name][crate::model::alert_policy::Condition::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::alert_policy::Condition::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of `condition`.
        pub fn set_condition<
            T: std::convert::Into<
                std::option::Option<crate::model::alert_policy::condition::Condition>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = v.into();
            self
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_condition_threshold(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::alert_policy::condition::MetricThreshold>,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionThreshold(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionAbsent`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_condition_absent(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::alert_policy::condition::MetricAbsence>,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionAbsent(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionMatchedLog`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_condition_matched_log(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::alert_policy::condition::LogMatch>>
        {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionMatchedLog(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionMonitoringQueryLanguage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_condition_monitoring_query_language(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::alert_policy::condition::MonitoringQueryLanguageCondition,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionMonitoringQueryLanguage(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionPrometheusQueryLanguage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_condition_prometheus_query_language(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::alert_policy::condition::PrometheusQueryLanguageCondition,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionPrometheusQueryLanguage(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionSql`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_condition_sql(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::alert_policy::condition::SqlCondition>,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionSql(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionThreshold`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_threshold<
            T: std::convert::Into<
                std::boxed::Box<crate::model::alert_policy::condition::MetricThreshold>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionThreshold(v.into()),
            );
            self
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionAbsent`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_absent<
            T: std::convert::Into<
                std::boxed::Box<crate::model::alert_policy::condition::MetricAbsence>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionAbsent(v.into()),
            );
            self
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionMatchedLog`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_matched_log<
            T: std::convert::Into<std::boxed::Box<crate::model::alert_policy::condition::LogMatch>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionMatchedLog(v.into()),
            );
            self
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionMonitoringQueryLanguage`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_monitoring_query_language<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::alert_policy::condition::MonitoringQueryLanguageCondition,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionMonitoringQueryLanguage(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionPrometheusQueryLanguage`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_prometheus_query_language<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::alert_policy::condition::PrometheusQueryLanguageCondition,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionPrometheusQueryLanguage(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionSql`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_sql<
            T: std::convert::Into<
                std::boxed::Box<crate::model::alert_policy::condition::SqlCondition>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionSql(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Condition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition"
        }
    }

    /// Defines additional types related to Condition
    pub mod condition {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how many time series must fail a predicate to trigger a
        /// condition. If not specified, then a `{count: 1}` trigger is used.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Trigger {
            /// A type of trigger.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub r#type: std::option::Option<crate::model::alert_policy::condition::trigger::Type>,
        }

        impl Trigger {
            /// Sets the value of `r#type`.
            pub fn set_type<
                T: std::convert::Into<
                    std::option::Option<crate::model::alert_policy::condition::trigger::Type>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// if it holds a `Count`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_count(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::trigger::Type::Count(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// if it holds a `Percent`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_percent(&self) -> std::option::Option<&f64> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::trigger::Type::Percent(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// to hold a `Count`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::alert_policy::condition::trigger::Type::Count(v.into()),
                );
                self
            }

            /// Sets the value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// to hold a `Percent`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_percent<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::alert_policy::condition::trigger::Type::Percent(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Trigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.Trigger"
            }
        }

        /// Defines additional types related to Trigger
        pub mod trigger {
            #[allow(unused_imports)]
            use super::*;

            /// A type of trigger.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Type {
                /// The absolute number of time series that must fail
                /// the predicate for the condition to be triggered.
                Count(i32),
                /// The percentage of time series that must fail the
                /// predicate for the condition to be triggered.
                Percent(f64),
            }
        }

        /// A condition type that compares a collection of time series
        /// against a threshold.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MetricThreshold {
            /// Required. A
            /// [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            /// identifies which time series should be compared with the threshold.
            ///
            /// The filter is similar to the one that is specified in the
            /// [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
            /// (that call is useful to verify the time series that will be retrieved /
            /// processed). The filter must specify the metric type and the resource
            /// type. Optionally, it can specify resource labels and metric labels.
            /// This field must not exceed 2048 Unicode characters in length.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub filter: std::string::String,

            /// Specifies the alignment of data points in individual time series as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resources). Multiple aggregations
            /// are applied in the order specified.
            ///
            /// This field is similar to the one in the [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
            /// It is advisable to use the `ListTimeSeries` method when debugging this
            /// field.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub aggregations: std::vec::Vec<crate::model::Aggregation>,

            /// A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            /// identifies a time series that should be used as the denominator of a
            /// ratio that will be compared with the threshold. If a
            /// `denominator_filter` is specified, the time series specified by the
            /// `filter` field will be used as the numerator.
            ///
            /// The filter must specify the metric type and optionally may contain
            /// restrictions on resource type, resource labels, and metric labels.
            /// This field may not exceed 2048 Unicode characters in length.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub denominator_filter: std::string::String,

            /// Specifies the alignment of data points in individual time series
            /// selected by `denominatorFilter` as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resources).
            ///
            /// When computing ratios, the `aggregations` and
            /// `denominator_aggregations` fields must use the same alignment period
            /// and produce time series that have the same periodicity and labels.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub denominator_aggregations: std::vec::Vec<crate::model::Aggregation>,

            /// When this field is present, the `MetricThreshold` condition forecasts
            /// whether the time series is predicted to violate the threshold within
            /// the `forecast_horizon`. When this field is not set, the
            /// `MetricThreshold` tests the current value of the timeseries against the
            /// threshold.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub forecast_options: std::option::Option<
                crate::model::alert_policy::condition::metric_threshold::ForecastOptions,
            >,

            /// The comparison to apply between the time series (indicated by `filter`
            /// and `aggregation`) and the threshold (indicated by `threshold_value`).
            /// The comparison is applied on each time series, with the time series
            /// on the left-hand side and the threshold on the right-hand side.
            ///
            /// Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
            pub comparison: crate::model::ComparisonType,

            /// A value against which to compare the time series.
            pub threshold_value: f64,

            /// The amount of time that a time series must violate the
            /// threshold to be considered failing. Currently, only values
            /// that are a multiple of a minute--e.g., 0, 60, 120, or 300
            /// seconds--are supported. If an invalid value is given, an
            /// error will be returned. When choosing a duration, it is useful to
            /// keep in mind the frequency of the underlying time series data
            /// (which may also be affected by any alignments specified in the
            /// `aggregations` field); a good duration is long enough so that a single
            /// outlier does not generate spurious alerts, but short enough that
            /// unhealthy states are detected and alerted on quickly.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub duration: std::option::Option<wkt::Duration>,

            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`,
            /// or by the ratio, if `denominator_filter` and `denominator_aggregations`
            /// are specified.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub trigger: std::option::Option<crate::model::alert_policy::condition::Trigger>,

            /// A condition control that determines how metric-threshold conditions
            /// are evaluated when data stops arriving. To use this control, the value
            /// of the `duration` field must be greater than or equal to 60 seconds.
            pub evaluation_missing_data:
                crate::model::alert_policy::condition::EvaluationMissingData,
        }

        impl MetricThreshold {
            /// Sets the value of [filter][crate::model::alert_policy::condition::MetricThreshold::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [denominator_filter][crate::model::alert_policy::condition::MetricThreshold::denominator_filter].
            pub fn set_denominator_filter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.denominator_filter = v.into();
                self
            }

            /// Sets the value of [forecast_options][crate::model::alert_policy::condition::MetricThreshold::forecast_options].
            pub fn set_forecast_options<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::alert_policy::condition::metric_threshold::ForecastOptions,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.forecast_options = v.into();
                self
            }

            /// Sets the value of [comparison][crate::model::alert_policy::condition::MetricThreshold::comparison].
            pub fn set_comparison<T: std::convert::Into<crate::model::ComparisonType>>(
                mut self,
                v: T,
            ) -> Self {
                self.comparison = v.into();
                self
            }

            /// Sets the value of [threshold_value][crate::model::alert_policy::condition::MetricThreshold::threshold_value].
            pub fn set_threshold_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.threshold_value = v.into();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::MetricThreshold::duration].
            pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
                mut self,
                v: T,
            ) -> Self {
                self.duration = v.into();
                self
            }

            /// Sets the value of [trigger][crate::model::alert_policy::condition::MetricThreshold::trigger].
            pub fn set_trigger<
                T: std::convert::Into<
                    std::option::Option<crate::model::alert_policy::condition::Trigger>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.trigger = v.into();
                self
            }

            /// Sets the value of [evaluation_missing_data][crate::model::alert_policy::condition::MetricThreshold::evaluation_missing_data].
            pub fn set_evaluation_missing_data<
                T: std::convert::Into<crate::model::alert_policy::condition::EvaluationMissingData>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluation_missing_data = v.into();
                self
            }

            /// Sets the value of [aggregations][crate::model::alert_policy::condition::MetricThreshold::aggregations].
            pub fn set_aggregations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Aggregation>,
            {
                use std::iter::Iterator;
                self.aggregations = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [denominator_aggregations][crate::model::alert_policy::condition::MetricThreshold::denominator_aggregations].
            pub fn set_denominator_aggregations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Aggregation>,
            {
                use std::iter::Iterator;
                self.denominator_aggregations = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for MetricThreshold {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MetricThreshold"
            }
        }

        /// Defines additional types related to MetricThreshold
        pub mod metric_threshold {
            #[allow(unused_imports)]
            use super::*;

            /// Options used when forecasting the time series and testing
            /// the predicted value against the threshold.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ForecastOptions {
                /// Required. The length of time into the future to forecast whether a
                /// time series will violate the threshold. If the predicted value is
                /// found to violate the threshold, and the violation is observed in all
                /// forecasts made for the configured `duration`, then the time series is
                /// considered to be failing.
                /// The forecast horizon can range from 1 hour to 60 hours.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub forecast_horizon: std::option::Option<wkt::Duration>,
            }

            impl ForecastOptions {
                /// Sets the value of [forecast_horizon][crate::model::alert_policy::condition::metric_threshold::ForecastOptions::forecast_horizon].
                pub fn set_forecast_horizon<
                    T: std::convert::Into<std::option::Option<wkt::Duration>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.forecast_horizon = v.into();
                    self
                }
            }

            impl wkt::message::Message for ForecastOptions {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions"
                }
            }
        }

        /// A condition type that checks that monitored resources
        /// are reporting data. The configuration defines a metric and
        /// a set of monitored resources. The predicate is considered in violation
        /// when a time series for the specified metric of a monitored
        /// resource does not include any data in the specified `duration`.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MetricAbsence {
            /// Required. A
            /// [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            /// identifies which time series should be compared with the threshold.
            ///
            /// The filter is similar to the one that is specified in the
            /// [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
            /// (that call is useful to verify the time series that will be retrieved /
            /// processed). The filter must specify the metric type and the resource
            /// type. Optionally, it can specify resource labels and metric labels.
            /// This field must not exceed 2048 Unicode characters in length.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub filter: std::string::String,

            /// Specifies the alignment of data points in individual time series as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resources). Multiple aggregations
            /// are applied in the order specified.
            ///
            /// This field is similar to the one in the [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
            /// It is advisable to use the `ListTimeSeries` method when debugging this
            /// field.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub aggregations: std::vec::Vec<crate::model::Aggregation>,

            /// The amount of time that a time series must fail to report new
            /// data to be considered failing. The minimum value of this field
            /// is 120 seconds. Larger values that are a multiple of a
            /// minute--for example, 240 or 300 seconds--are supported.
            /// If an invalid value is given, an
            /// error will be returned. The `Duration.nanos` field is
            /// ignored.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub duration: std::option::Option<wkt::Duration>,

            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub trigger: std::option::Option<crate::model::alert_policy::condition::Trigger>,
        }

        impl MetricAbsence {
            /// Sets the value of [filter][crate::model::alert_policy::condition::MetricAbsence::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::MetricAbsence::duration].
            pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
                mut self,
                v: T,
            ) -> Self {
                self.duration = v.into();
                self
            }

            /// Sets the value of [trigger][crate::model::alert_policy::condition::MetricAbsence::trigger].
            pub fn set_trigger<
                T: std::convert::Into<
                    std::option::Option<crate::model::alert_policy::condition::Trigger>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.trigger = v.into();
                self
            }

            /// Sets the value of [aggregations][crate::model::alert_policy::condition::MetricAbsence::aggregations].
            pub fn set_aggregations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Aggregation>,
            {
                use std::iter::Iterator;
                self.aggregations = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for MetricAbsence {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MetricAbsence"
            }
        }

        /// A condition type that checks whether a log message in the [scoping
        /// project](https://cloud.google.com/monitoring/api/v3#project_name)
        /// satisfies the given filter. Logs from other projects in the metrics
        /// scope are not evaluated.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LogMatch {
            /// Required. A logs-based filter. See [Advanced Logs
            /// Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
            /// for how this filter should be constructed.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub filter: std::string::String,

            /// Optional. A map from a label key to an extractor expression, which is
            /// used to extract the value for this label key. Each entry in this map is
            /// a specification for how data should be extracted from log entries that
            /// match `filter`. Each combination of extracted values is treated as a
            /// separate rule for the purposes of triggering notifications. Label keys
            /// and corresponding values can be used in notifications generated by this
            /// condition.
            ///
            /// Please see [the documentation on logs-based metric
            /// `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
            /// for syntax and examples.
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub label_extractors:
                std::collections::HashMap<std::string::String, std::string::String>,
        }

        impl LogMatch {
            /// Sets the value of [filter][crate::model::alert_policy::condition::LogMatch::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [label_extractors][crate::model::alert_policy::condition::LogMatch::label_extractors].
            pub fn set_label_extractors<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.label_extractors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for LogMatch {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.LogMatch"
            }
        }

        /// A condition type that allows alerting policies to be defined using
        /// [Monitoring Query Language](https://cloud.google.com/monitoring/mql).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MonitoringQueryLanguageCondition {
            /// [Monitoring Query Language](https://cloud.google.com/monitoring/mql)
            /// query that outputs a boolean stream.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub query: std::string::String,

            /// The amount of time that a time series must violate the
            /// threshold to be considered failing. Currently, only values
            /// that are a multiple of a minute--e.g., 0, 60, 120, or 300
            /// seconds--are supported. If an invalid value is given, an
            /// error will be returned. When choosing a duration, it is useful to
            /// keep in mind the frequency of the underlying time series data
            /// (which may also be affected by any alignments specified in the
            /// `aggregations` field); a good duration is long enough so that a single
            /// outlier does not generate spurious alerts, but short enough that
            /// unhealthy states are detected and alerted on quickly.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub duration: std::option::Option<wkt::Duration>,

            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`,
            /// or by the ratio, if `denominator_filter` and `denominator_aggregations`
            /// are specified.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub trigger: std::option::Option<crate::model::alert_policy::condition::Trigger>,

            /// A condition control that determines how metric-threshold conditions
            /// are evaluated when data stops arriving.
            pub evaluation_missing_data:
                crate::model::alert_policy::condition::EvaluationMissingData,
        }

        impl MonitoringQueryLanguageCondition {
            /// Sets the value of [query][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::duration].
            pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
                mut self,
                v: T,
            ) -> Self {
                self.duration = v.into();
                self
            }

            /// Sets the value of [trigger][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::trigger].
            pub fn set_trigger<
                T: std::convert::Into<
                    std::option::Option<crate::model::alert_policy::condition::Trigger>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.trigger = v.into();
                self
            }

            /// Sets the value of [evaluation_missing_data][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::evaluation_missing_data].
            pub fn set_evaluation_missing_data<
                T: std::convert::Into<crate::model::alert_policy::condition::EvaluationMissingData>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluation_missing_data = v.into();
                self
            }
        }

        impl wkt::message::Message for MonitoringQueryLanguageCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition"
            }
        }

        /// A condition type that allows alerting policies to be defined using
        /// [Prometheus Query Language
        /// (PromQL)](https://prometheus.io/docs/prometheus/latest/querying/basics/).
        ///
        /// The PrometheusQueryLanguageCondition message contains information
        /// from a Prometheus alerting rule and its associated rule group.
        ///
        /// A Prometheus alerting rule is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/).
        /// The semantics of a Prometheus alerting rule is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).
        ///
        /// A Prometheus rule group is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/).
        /// The semantics of a Prometheus rule group is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).
        ///
        /// Because Cloud Alerting has no representation of a Prometheus rule
        /// group resource, we must embed the information of the parent rule
        /// group inside each of the conditions that refer to it. We must also
        /// update the contents of all Prometheus alerts in case the information
        /// of their rule group changes.
        ///
        /// The PrometheusQueryLanguageCondition protocol buffer combines the
        /// information of the corresponding rule group and alerting rule.
        /// The structure of the PrometheusQueryLanguageCondition protocol buffer
        /// does NOT mimic the structure of the Prometheus rule group and alerting
        /// rule YAML declarations. The PrometheusQueryLanguageCondition protocol
        /// buffer may change in the future to support future rule group and/or
        /// alerting rule features. There are no new such features at the present
        /// time (2023-06-26).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PrometheusQueryLanguageCondition {
            /// Required. The PromQL expression to evaluate. Every evaluation cycle
            /// this expression is evaluated at the current time, and all resultant
            /// time series become pending/firing alerts. This field must not be empty.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub query: std::string::String,

            /// Optional. Alerts are considered firing once their PromQL expression was
            /// evaluated to be "true" for this long.
            /// Alerts whose PromQL expression was not evaluated to be "true" for
            /// long enough are considered pending.
            /// Must be a non-negative duration or missing.
            /// This field is optional. Its default value is zero.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub duration: std::option::Option<wkt::Duration>,

            /// Optional. How often this rule should be evaluated.
            /// Must be a positive multiple of 30 seconds or missing.
            /// This field is optional. Its default value is 30 seconds.
            /// If this PrometheusQueryLanguageCondition was generated from a
            /// Prometheus alerting rule, then this value should be taken from the
            /// enclosing rule group.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub evaluation_interval: std::option::Option<wkt::Duration>,

            /// Optional. Labels to add to or overwrite in the PromQL query result.
            /// Label names [must be
            /// valid](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
            /// Label values can be [templatized by using
            /// variables](https://cloud.google.com/monitoring/alerts/doc-variables#doc-vars).
            /// The only available variable names are the names of the labels in the
            /// PromQL result, including "__name__" and "value". "labels" may be empty.
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub labels: std::collections::HashMap<std::string::String, std::string::String>,

            /// Optional. The rule group name of this alert in the corresponding
            /// Prometheus configuration file.
            ///
            /// Some external tools may require this field to be populated correctly
            /// in order to refer to the original Prometheus configuration file.
            /// The rule group name and the alert name are necessary to update the
            /// relevant AlertPolicies in case the definition of the rule group changes
            /// in the future.
            ///
            /// This field is optional. If this field is not empty, then it must
            /// contain a valid UTF-8 string.
            /// This field may not exceed 2048 Unicode characters in length.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub rule_group: std::string::String,

            /// Optional. The alerting rule name of this alert in the corresponding
            /// Prometheus configuration file.
            ///
            /// Some external tools may require this field to be populated correctly
            /// in order to refer to the original Prometheus configuration file.
            /// The rule group name and the alert name are necessary to update the
            /// relevant AlertPolicies in case the definition of the rule group changes
            /// in the future.
            ///
            /// This field is optional. If this field is not empty, then it must be a
            /// [valid Prometheus label
            /// name](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
            /// This field may not exceed 2048 Unicode characters in length.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub alert_rule: std::string::String,

            /// Optional. Whether to disable metric existence validation for this
            /// condition.
            ///
            /// This allows alerting policies to be defined on metrics that do not yet
            /// exist, improving advanced customer workflows such as configuring
            /// alerting policies using Terraform.
            ///
            /// Users with the `monitoring.alertPolicyViewer` role are able to see the
            /// name of the non-existent metric in the alerting policy condition.
            pub disable_metric_validation: bool,
        }

        impl PrometheusQueryLanguageCondition {
            /// Sets the value of [query][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::duration].
            pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
                mut self,
                v: T,
            ) -> Self {
                self.duration = v.into();
                self
            }

            /// Sets the value of [evaluation_interval][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::evaluation_interval].
            pub fn set_evaluation_interval<
                T: std::convert::Into<std::option::Option<wkt::Duration>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluation_interval = v.into();
                self
            }

            /// Sets the value of [rule_group][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::rule_group].
            pub fn set_rule_group<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.rule_group = v.into();
                self
            }

            /// Sets the value of [alert_rule][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::alert_rule].
            pub fn set_alert_rule<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.alert_rule = v.into();
                self
            }

            /// Sets the value of [disable_metric_validation][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::disable_metric_validation].
            pub fn set_disable_metric_validation<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.disable_metric_validation = v.into();
                self
            }

            /// Sets the value of [labels][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::labels].
            pub fn set_labels<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for PrometheusQueryLanguageCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.PrometheusQueryLanguageCondition"
            }
        }

        /// A condition that allows alerting policies to be defined using GoogleSQL.
        /// SQL conditions examine a sliding window of logs using GoogleSQL.
        /// Alert policies with SQL conditions may incur additional billing.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SqlCondition {
            /// Required. The Log Analytics SQL query to run, as a string.  The query
            /// must conform to the required shape. Specifically, the query must not
            /// try to filter the input by time.  A filter will automatically be
            /// applied to filter the input so that the query receives all rows
            /// received since the last time the query was run.
            ///
            /// For example, the following query extracts all log entries containing an
            /// HTTP request:
            ///
            /// ```norust
            /// SELECT
            ///   timestamp, log_name, severity, http_request, resource, labels
            /// FROM
            ///   my-project.global._Default._AllLogs
            /// WHERE
            ///   http_request IS NOT NULL
            /// ```
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub query: std::string::String,

            /// The schedule indicates how often the query should be run.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub schedule:
                std::option::Option<crate::model::alert_policy::condition::sql_condition::Schedule>,

            /// The test to be run against the SQL result set.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub evaluate:
                std::option::Option<crate::model::alert_policy::condition::sql_condition::Evaluate>,
        }

        impl SqlCondition {
            /// Sets the value of [query][crate::model::alert_policy::condition::SqlCondition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of `schedule`.
            pub fn set_schedule<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::alert_policy::condition::sql_condition::Schedule,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = v.into();
                self
            }

            /// The value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// if it holds a `Minutes`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_minutes(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Minutes>,
            > {
                #[allow(unreachable_patterns)]
                self.schedule.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Schedule::Minutes(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// if it holds a `Hourly`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_hourly(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Hourly>,
            > {
                #[allow(unreachable_patterns)]
                self.schedule.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Schedule::Hourly(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// if it holds a `Daily`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_daily(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Daily>,
            > {
                #[allow(unreachable_patterns)]
                self.schedule.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Schedule::Daily(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// to hold a `Minutes`.
            ///
            /// Note that all the setters affecting `schedule` are
            /// mutually exclusive.
            pub fn set_minutes<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Minutes>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Schedule::Minutes(
                        v.into(),
                    ),
                );
                self
            }

            /// Sets the value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// to hold a `Hourly`.
            ///
            /// Note that all the setters affecting `schedule` are
            /// mutually exclusive.
            pub fn set_hourly<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Hourly>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Schedule::Hourly(
                        v.into(),
                    ),
                );
                self
            }

            /// Sets the value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// to hold a `Daily`.
            ///
            /// Note that all the setters affecting `schedule` are
            /// mutually exclusive.
            pub fn set_daily<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Daily>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Schedule::Daily(v.into()),
                );
                self
            }

            /// Sets the value of `evaluate`.
            pub fn set_evaluate<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::alert_policy::condition::sql_condition::Evaluate,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluate = v.into();
                self
            }

            /// The value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// if it holds a `RowCountTest`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_row_count_test(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::alert_policy::condition::sql_condition::RowCountTest,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.evaluate.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Evaluate::RowCountTest(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// if it holds a `BooleanTest`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_boolean_test(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::BooleanTest>,
            > {
                #[allow(unreachable_patterns)]
                self.evaluate.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Evaluate::BooleanTest(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// to hold a `RowCountTest`.
            ///
            /// Note that all the setters affecting `evaluate` are
            /// mutually exclusive.
            pub fn set_row_count_test<
                T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::alert_policy::condition::sql_condition::RowCountTest,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluate = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Evaluate::RowCountTest(
                        v.into(),
                    ),
                );
                self
            }

            /// Sets the value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// to hold a `BooleanTest`.
            ///
            /// Note that all the setters affecting `evaluate` are
            /// mutually exclusive.
            pub fn set_boolean_test<
                T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::alert_policy::condition::sql_condition::BooleanTest,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluate = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Evaluate::BooleanTest(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for SqlCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition"
            }
        }

        /// Defines additional types related to SqlCondition
        pub mod sql_condition {
            #[allow(unused_imports)]
            use super::*;

            /// Used to schedule the query to run every so many minutes.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Minutes {
                /// Required. Number of minutes between runs. The interval must be
                /// greater than or equal to 5 minutes and less than or equal to 1440
                /// minutes.
                pub periodicity: i32,
            }

            impl Minutes {
                /// Sets the value of [periodicity][crate::model::alert_policy::condition::sql_condition::Minutes::periodicity].
                pub fn set_periodicity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.periodicity = v.into();
                    self
                }
            }

            impl wkt::message::Message for Minutes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Minutes"
                }
            }

            /// Used to schedule the query to run every so many hours.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Hourly {
                /// Required. The number of hours between runs. Must be greater than or
                /// equal to 1 hour and less than or equal to 48 hours.
                pub periodicity: i32,

                /// Optional. The number of minutes after the hour (in UTC) to run the
                /// query. Must be greater than or equal to 0 minutes and less than or
                /// equal to 59 minutes.  If left unspecified, then an arbitrary offset
                /// is used.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub minute_offset: std::option::Option<i32>,
            }

            impl Hourly {
                /// Sets the value of [periodicity][crate::model::alert_policy::condition::sql_condition::Hourly::periodicity].
                pub fn set_periodicity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.periodicity = v.into();
                    self
                }

                /// Sets the value of [minute_offset][crate::model::alert_policy::condition::sql_condition::Hourly::minute_offset].
                pub fn set_minute_offset<T: std::convert::Into<std::option::Option<i32>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.minute_offset = v.into();
                    self
                }
            }

            impl wkt::message::Message for Hourly {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Hourly"
                }
            }

            /// Used to schedule the query to run every so many days.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Daily {
                /// Required. The number of days between runs. Must be greater than or
                /// equal to 1 day and less than or equal to 31 days.
                pub periodicity: i32,

                /// Optional. The time of day (in UTC) at which the query should run. If
                /// left unspecified, the server picks an arbitrary time of day and runs
                /// the query at the same time each day.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub execution_time: std::option::Option<gtype::model::TimeOfDay>,
            }

            impl Daily {
                /// Sets the value of [periodicity][crate::model::alert_policy::condition::sql_condition::Daily::periodicity].
                pub fn set_periodicity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.periodicity = v.into();
                    self
                }

                /// Sets the value of [execution_time][crate::model::alert_policy::condition::sql_condition::Daily::execution_time].
                pub fn set_execution_time<
                    T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.execution_time = v.into();
                    self
                }
            }

            impl wkt::message::Message for Daily {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Daily"
                }
            }

            /// A test that checks if the number of rows in the result set
            /// violates some threshold.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct RowCountTest {
                /// Required. The comparison to apply between the number of rows returned
                /// by the query and the threshold.
                pub comparison: crate::model::ComparisonType,

                /// Required. The value against which to compare the row count.
                #[serde_as(as = "serde_with::DisplayFromStr")]
                pub threshold: i64,
            }

            impl RowCountTest {
                /// Sets the value of [comparison][crate::model::alert_policy::condition::sql_condition::RowCountTest::comparison].
                pub fn set_comparison<T: std::convert::Into<crate::model::ComparisonType>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.comparison = v.into();
                    self
                }

                /// Sets the value of [threshold][crate::model::alert_policy::condition::sql_condition::RowCountTest::threshold].
                pub fn set_threshold<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.threshold = v.into();
                    self
                }
            }

            impl wkt::message::Message for RowCountTest {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.RowCountTest"
                }
            }

            /// A test that uses an alerting result in a boolean column produced by
            /// the SQL query.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct BooleanTest {
                /// Required. The name of the column containing the boolean value. If the
                /// value in a row is NULL, that row is ignored.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub column: std::string::String,
            }

            impl BooleanTest {
                /// Sets the value of [column][crate::model::alert_policy::condition::sql_condition::BooleanTest::column].
                pub fn set_column<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.column = v.into();
                    self
                }
            }

            impl wkt::message::Message for BooleanTest {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.BooleanTest"
                }
            }

            /// The schedule indicates how often the query should be run.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Schedule {
                /// Schedule the query to execute every so many minutes.
                Minutes(
                    std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Minutes>,
                ),
                /// Schedule the query to execute every so many hours.
                Hourly(
                    std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Hourly>,
                ),
                /// Schedule the query to execute every so many days.
                Daily(std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Daily>),
            }

            /// The test to be run against the SQL result set.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Evaluate {
                /// Test the row count against a threshold.
                RowCountTest(
                    std::boxed::Box<
                        crate::model::alert_policy::condition::sql_condition::RowCountTest,
                    >,
                ),
                /// Test the boolean value in the indicated column.
                BooleanTest(
                    std::boxed::Box<
                        crate::model::alert_policy::condition::sql_condition::BooleanTest,
                    >,
                ),
            }
        }

        /// A condition control that determines how metric-threshold conditions
        /// are evaluated when data stops arriving.
        /// This control doesn't affect metric-absence policies.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct EvaluationMissingData(std::borrow::Cow<'static, str>);

        impl EvaluationMissingData {
            /// Creates a new EvaluationMissingData instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [EvaluationMissingData](EvaluationMissingData)
        pub mod evaluation_missing_data {
            use super::EvaluationMissingData;

            /// An unspecified evaluation missing data option.  Equivalent to
            /// EVALUATION_MISSING_DATA_NO_OP.
            pub const EVALUATION_MISSING_DATA_UNSPECIFIED: EvaluationMissingData =
                EvaluationMissingData::new("EVALUATION_MISSING_DATA_UNSPECIFIED");

            /// If there is no data to evaluate the condition, then evaluate the
            /// condition as false.
            pub const EVALUATION_MISSING_DATA_INACTIVE: EvaluationMissingData =
                EvaluationMissingData::new("EVALUATION_MISSING_DATA_INACTIVE");

            /// If there is no data to evaluate the condition, then evaluate the
            /// condition as true.
            pub const EVALUATION_MISSING_DATA_ACTIVE: EvaluationMissingData =
                EvaluationMissingData::new("EVALUATION_MISSING_DATA_ACTIVE");

            /// Do not evaluate the condition to any value if there is no data.
            pub const EVALUATION_MISSING_DATA_NO_OP: EvaluationMissingData =
                EvaluationMissingData::new("EVALUATION_MISSING_DATA_NO_OP");
        }

        impl std::convert::From<std::string::String> for EvaluationMissingData {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Only one of the following condition types will be specified.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Condition {
            /// A condition that compares a time series against a threshold.
            ConditionThreshold(
                std::boxed::Box<crate::model::alert_policy::condition::MetricThreshold>,
            ),
            /// A condition that checks that a time series continues to
            /// receive new data points.
            ConditionAbsent(std::boxed::Box<crate::model::alert_policy::condition::MetricAbsence>),
            /// A condition that checks for log messages matching given constraints. If
            /// set, no other conditions can be present.
            ConditionMatchedLog(std::boxed::Box<crate::model::alert_policy::condition::LogMatch>),
            /// A condition that uses the Monitoring Query Language to define
            /// alerts.
            ConditionMonitoringQueryLanguage(
                std::boxed::Box<
                    crate::model::alert_policy::condition::MonitoringQueryLanguageCondition,
                >,
            ),
            /// A condition that uses the Prometheus query language to define alerts.
            ConditionPrometheusQueryLanguage(
                std::boxed::Box<
                    crate::model::alert_policy::condition::PrometheusQueryLanguageCondition,
                >,
            ),
            /// A condition that periodically evaluates a SQL query result.
            ConditionSql(std::boxed::Box<crate::model::alert_policy::condition::SqlCondition>),
        }
    }

    /// Control over how the notification channels in `notification_channels`
    /// are notified when this alert fires.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AlertStrategy {
        /// Required for log-based alerting policies, i.e. policies with a `LogMatch`
        /// condition.
        ///
        /// This limit is not implemented for alerting policies that do not have
        /// a LogMatch condition.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub notification_rate_limit:
            std::option::Option<crate::model::alert_policy::alert_strategy::NotificationRateLimit>,

        /// For log-based alert policies, the notification prompts is always
        /// [OPENED]. For non log-based alert policies, the notification prompts can
        /// be [OPENED] or [OPENED, CLOSED].
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub notification_prompts:
            std::vec::Vec<crate::model::alert_policy::alert_strategy::NotificationPrompt>,

        /// If an alerting policy that was active has no data for this long, any open
        /// incidents will close
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub auto_close: std::option::Option<wkt::Duration>,

        /// Control how notifications will be sent out, on a per-channel basis.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub notification_channel_strategy:
            std::vec::Vec<crate::model::alert_policy::alert_strategy::NotificationChannelStrategy>,
    }

    impl AlertStrategy {
        /// Sets the value of [notification_rate_limit][crate::model::alert_policy::AlertStrategy::notification_rate_limit].
        pub fn set_notification_rate_limit<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::alert_policy::alert_strategy::NotificationRateLimit,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.notification_rate_limit = v.into();
            self
        }

        /// Sets the value of [auto_close][crate::model::alert_policy::AlertStrategy::auto_close].
        pub fn set_auto_close<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.auto_close = v.into();
            self
        }

        /// Sets the value of [notification_prompts][crate::model::alert_policy::AlertStrategy::notification_prompts].
        pub fn set_notification_prompts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::alert_policy::alert_strategy::NotificationPrompt>,
        {
            use std::iter::Iterator;
            self.notification_prompts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [notification_channel_strategy][crate::model::alert_policy::AlertStrategy::notification_channel_strategy].
        pub fn set_notification_channel_strategy<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::alert_policy::alert_strategy::NotificationChannelStrategy,
            >,
        {
            use std::iter::Iterator;
            self.notification_channel_strategy = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AlertStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.AlertPolicy.AlertStrategy"
        }
    }

    /// Defines additional types related to AlertStrategy
    pub mod alert_strategy {
        #[allow(unused_imports)]
        use super::*;

        /// Control over the rate of notifications sent to this alerting policy's
        /// notification channels.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct NotificationRateLimit {
            /// Not more than one notification per `period`.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub period: std::option::Option<wkt::Duration>,
        }

        impl NotificationRateLimit {
            /// Sets the value of [period][crate::model::alert_policy::alert_strategy::NotificationRateLimit::period].
            pub fn set_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
                mut self,
                v: T,
            ) -> Self {
                self.period = v.into();
                self
            }
        }

        impl wkt::message::Message for NotificationRateLimit {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit"
            }
        }

        /// Control over how the notification channels in `notification_channels`
        /// are notified when this alert fires, on a per-channel basis.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct NotificationChannelStrategy {
            /// The full REST resource name for the notification channels that these
            /// settings apply to. Each of these correspond to the name field in one
            /// of the NotificationChannel objects referenced in the
            /// notification_channels field of this AlertPolicy.
            /// The format is:
            ///
            /// ```norust
            /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
            /// ```
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub notification_channel_names: std::vec::Vec<std::string::String>,

            /// The frequency at which to send reminder notifications for open
            /// incidents.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub renotify_interval: std::option::Option<wkt::Duration>,
        }

        impl NotificationChannelStrategy {
            /// Sets the value of [renotify_interval][crate::model::alert_policy::alert_strategy::NotificationChannelStrategy::renotify_interval].
            pub fn set_renotify_interval<
                T: std::convert::Into<std::option::Option<wkt::Duration>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.renotify_interval = v.into();
                self
            }

            /// Sets the value of [notification_channel_names][crate::model::alert_policy::alert_strategy::NotificationChannelStrategy::notification_channel_names].
            pub fn set_notification_channel_names<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.notification_channel_names = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for NotificationChannelStrategy {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy"
            }
        }

        /// Control when notifications will be sent out.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct NotificationPrompt(std::borrow::Cow<'static, str>);

        impl NotificationPrompt {
            /// Creates a new NotificationPrompt instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [NotificationPrompt](NotificationPrompt)
        pub mod notification_prompt {
            use super::NotificationPrompt;

            /// No strategy specified. Treated as error.
            pub const NOTIFICATION_PROMPT_UNSPECIFIED: NotificationPrompt =
                NotificationPrompt::new("NOTIFICATION_PROMPT_UNSPECIFIED");

            /// Notify when an incident is opened.
            pub const OPENED: NotificationPrompt = NotificationPrompt::new("OPENED");

            /// Notify when an incident is closed.
            pub const CLOSED: NotificationPrompt = NotificationPrompt::new("CLOSED");
        }

        impl std::convert::From<std::string::String> for NotificationPrompt {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Operators for combining conditions.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConditionCombinerType(std::borrow::Cow<'static, str>);

    impl ConditionCombinerType {
        /// Creates a new ConditionCombinerType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ConditionCombinerType](ConditionCombinerType)
    pub mod condition_combiner_type {
        use super::ConditionCombinerType;

        /// An unspecified combiner.
        pub const COMBINE_UNSPECIFIED: ConditionCombinerType =
            ConditionCombinerType::new("COMBINE_UNSPECIFIED");

        /// Combine conditions using the logical `AND` operator. An
        /// incident is created only if all the conditions are met
        /// simultaneously. This combiner is satisfied if all conditions are
        /// met, even if they are met on completely different resources.
        pub const AND: ConditionCombinerType = ConditionCombinerType::new("AND");

        /// Combine conditions using the logical `OR` operator. An incident
        /// is created if any of the listed conditions is met.
        pub const OR: ConditionCombinerType = ConditionCombinerType::new("OR");

        /// Combine conditions using logical `AND` operator, but unlike the regular
        /// `AND` option, an incident is created only if all conditions are met
        /// simultaneously on at least one resource.
        pub const AND_WITH_MATCHING_RESOURCE: ConditionCombinerType =
            ConditionCombinerType::new("AND_WITH_MATCHING_RESOURCE");
    }

    impl std::convert::From<std::string::String> for ConditionCombinerType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// An enumeration of possible severity level for an alerting policy.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Severity(std::borrow::Cow<'static, str>);

    impl Severity {
        /// Creates a new Severity instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Severity](Severity)
    pub mod severity {
        use super::Severity;

        /// No severity is specified. This is the default value.
        pub const SEVERITY_UNSPECIFIED: Severity = Severity::new("SEVERITY_UNSPECIFIED");

        /// This is the highest severity level. Use this if the problem could
        /// cause significant damage or downtime.
        pub const CRITICAL: Severity = Severity::new("CRITICAL");

        /// This is the medium severity level. Use this if the problem could
        /// cause minor damage or downtime.
        pub const ERROR: Severity = Severity::new("ERROR");

        /// This is the lowest severity level. Use this if the problem is not causing
        /// any damage or downtime, but could potentially lead to a problem in the
        /// future.
        pub const WARNING: Severity = Severity::new("WARNING");
    }

    impl std::convert::From<std::string::String> for Severity {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// The protocol for the `CreateAlertPolicy` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAlertPolicyRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// to create the alerting policy. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// Note that this field names the parent container in which the alerting
    /// policy will be written, not the name of the created policy. |name| must be
    /// a host project of a Metrics Scope, otherwise INVALID_ARGUMENT error will
    /// return. The alerting policy that is returned will have a name that contains
    /// a normalized representation of this name as a prefix but adds a suffix of
    /// the form `/alertPolicies/[ALERT_POLICY_ID]`, identifying the policy in the
    /// container.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The requested alerting policy. You should omit the `name` field
    /// in this policy. The name will be returned in the new policy, including a
    /// new `[ALERT_POLICY_ID]` value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub alert_policy: std::option::Option<crate::model::AlertPolicy>,
}

impl CreateAlertPolicyRequest {
    /// Sets the value of [name][crate::model::CreateAlertPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [alert_policy][crate::model::CreateAlertPolicyRequest::alert_policy].
    pub fn set_alert_policy<
        T: std::convert::Into<std::option::Option<crate::model::AlertPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alert_policy = v.into();
        self
    }
}

impl wkt::message::Message for CreateAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateAlertPolicyRequest"
    }
}

/// The protocol for the `GetAlertPolicy` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAlertPolicyRequest {
    /// Required. The alerting policy to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAlertPolicyRequest {
    /// Sets the value of [name][crate::model::GetAlertPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetAlertPolicyRequest"
    }
}

/// The protocol for the `ListAlertPolicies` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAlertPoliciesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// alert policies are to be listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// Note that this field names the parent container in which the alerting
    /// policies to be listed are stored. To retrieve a single alerting policy
    /// by name, use the
    /// [GetAlertPolicy][google.monitoring.v3.AlertPolicyService.GetAlertPolicy]
    /// operation, instead.
    ///
    /// [google.monitoring.v3.AlertPolicyService.GetAlertPolicy]: crate::client::AlertPolicyService::get_alert_policy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, this field specifies the criteria that must be met
    /// by alert policies to be included in the response.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. A comma-separated list of fields by which to sort the result.
    /// Supports the same set of field references as the `filter` field. Entries
    /// can be prefixed with a minus sign to sort by the field in descending order.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The maximum number of results to return in a single response.
    pub page_size: i32,

    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return more results from the previous
    /// method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAlertPoliciesRequest {
    /// Sets the value of [name][crate::model::ListAlertPoliciesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAlertPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAlertPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAlertPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAlertPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAlertPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListAlertPoliciesRequest"
    }
}

/// The protocol for the `ListAlertPolicies` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAlertPoliciesResponse {
    /// The returned alert policies.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub alert_policies: std::vec::Vec<crate::model::AlertPolicy>,

    /// If there might be more results than were returned, then this field is set
    /// to a non-empty value. To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of alert policies in all pages. This number is only an
    /// estimate, and may change in subsequent pages. <https://aip.dev/158>
    pub total_size: i32,
}

impl ListAlertPoliciesResponse {
    /// Sets the value of [next_page_token][crate::model::ListAlertPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListAlertPoliciesResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [alert_policies][crate::model::ListAlertPoliciesResponse::alert_policies].
    pub fn set_alert_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AlertPolicy>,
    {
        use std::iter::Iterator;
        self.alert_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAlertPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListAlertPoliciesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAlertPoliciesResponse {
    type PageItem = crate::model::AlertPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.alert_policies
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The protocol for the `UpdateAlertPolicy` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAlertPolicyRequest {
    /// Optional. A list of alerting policy field names. If this field is not
    /// empty, each listed field in the existing alerting policy is set to the
    /// value of the corresponding field in the supplied policy (`alert_policy`),
    /// or to the field's default value if the field is not in the supplied
    /// alerting policy.  Fields not listed retain their previous value.
    ///
    /// Examples of valid field masks include `display_name`, `documentation`,
    /// `documentation.content`, `documentation.mime_type`, `user_labels`,
    /// `user_label.nameofkey`, `enabled`, `conditions`, `combiner`, etc.
    ///
    /// If this field is empty, then the supplied alerting policy replaces the
    /// existing policy. It is the same as deleting the existing policy and
    /// adding the supplied policy, except for the following:
    ///
    /// + The new policy will have the same `[ALERT_POLICY_ID]` as the former
    ///   policy. This gives you continuity with the former policy in your
    ///   notifications and incidents.
    /// + Conditions in the new policy will keep their former `[CONDITION_ID]` if
    ///   the supplied condition includes the `name` field with that
    ///   `[CONDITION_ID]`. If the supplied condition omits the `name` field,
    ///   then a new `[CONDITION_ID]` is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The updated alerting policy or the updated values for the
    /// fields listed in `update_mask`.
    /// If `update_mask` is not empty, any fields in this policy that are
    /// not in `update_mask` are ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub alert_policy: std::option::Option<crate::model::AlertPolicy>,
}

impl UpdateAlertPolicyRequest {
    /// Sets the value of [update_mask][crate::model::UpdateAlertPolicyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [alert_policy][crate::model::UpdateAlertPolicyRequest::alert_policy].
    pub fn set_alert_policy<
        T: std::convert::Into<std::option::Option<crate::model::AlertPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alert_policy = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateAlertPolicyRequest"
    }
}

/// The protocol for the `DeleteAlertPolicy` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAlertPolicyRequest {
    /// Required. The alerting policy to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    ///
    /// For more information, see [AlertPolicy][google.monitoring.v3.AlertPolicy].
    ///
    /// [google.monitoring.v3.AlertPolicy]: crate::model::AlertPolicy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteAlertPolicyRequest {
    /// Sets the value of [name][crate::model::DeleteAlertPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteAlertPolicyRequest"
    }
}

/// A single strongly-typed value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TypedValue {
    /// The typed value field.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::typed_value::Value>,
}

impl TypedValue {
    /// Sets the value of `value`.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::typed_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DistributionValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_distribution_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<api::model::Distribution>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DistributionValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::BoolValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::Int64Value(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::DoubleValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::StringValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DistributionValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_distribution_value<
        T: std::convert::Into<std::boxed::Box<api::model::Distribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::typed_value::Value::DistributionValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TypedValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TypedValue"
    }
}

/// Defines additional types related to TypedValue
pub mod typed_value {
    #[allow(unused_imports)]
    use super::*;

    /// The typed value field.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A Boolean value: `true` or `false`.
        BoolValue(bool),
        /// A 64-bit integer. Its range is approximately &plusmn;9.2x10\<sup\>18\</sup\>.
        Int64Value(i64),
        /// A 64-bit double-precision floating-point number. Its magnitude
        /// is approximately &plusmn;10\<sup\>&plusmn;300\</sup\> and it has 16
        /// significant digits of precision.
        DoubleValue(f64),
        /// A variable-length string value.
        StringValue(std::string::String),
        /// A distribution value.
        DistributionValue(std::boxed::Box<api::model::Distribution>),
    }
}

/// Describes a time interval:
///
/// * Reads: A half-open time interval. It includes the end time but
///   excludes the start time: `(startTime, endTime]`. The start time
///   must be specified, must be earlier than the end time, and should be
///   no older than the data retention period for the metric.
/// * Writes: A closed time interval. It extends from the start time to the end
///   time,
///   and includes both: `[startTime, endTime]`. Valid time intervals
///   depend on the
///   [`MetricKind`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind)
///   of the metric value. The end time must not be earlier than the start
///   time, and the end time must not be more than 25 hours in the past or more
///   than five minutes in the future.
///   * For `GAUGE` metrics, the `startTime` value is technically optional; if
///     no value is specified, the start time defaults to the value of the
///     end time, and the interval represents a single point in time. If both
///     start and end times are specified, they must be identical. Such an
///     interval is valid only for `GAUGE` metrics, which are point-in-time
///     measurements. The end time of a new interval must be at least a
///     millisecond after the end time of the previous interval.
///   * For `DELTA` metrics, the start time and end time must specify a
///     non-zero interval, with subsequent points specifying contiguous and
///     non-overlapping intervals. For `DELTA` metrics, the start time of
///     the next interval must be at least a millisecond after the end time
///     of the previous interval.
///   * For `CUMULATIVE` metrics, the start time and end time must specify a
///     non-zero interval, with subsequent points specifying the same
///     start time and increasing end times, until an event resets the
///     cumulative value to zero and sets a new start time for the following
///     points. The new start time must be at least a millisecond after the
///     end time of the previous interval.
///   * The start time of a new interval must be at least a millisecond after
///     the
///     end time of the previous interval because intervals are closed. If the
///     start time of a new interval is the same as the end time of the
///     previous interval, then data written at the new start time could
///     overwrite data written at the previous end time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeInterval {
    /// Required. The end of the time interval.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The beginning of the time interval.  The default value
    /// for the start time is the end time. The start time must not be
    /// later than the end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,
}

impl TimeInterval {
    /// Sets the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }
}

impl wkt::message::Message for TimeInterval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeInterval"
    }
}

/// Describes how to combine multiple time series to provide a different view of
/// the data.  Aggregation of time series is done in two steps. First, each time
/// series in the set is _aligned_ to the same time interval boundaries, then the
/// set of time series is optionally _reduced_ in number.
///
/// Alignment consists of applying the `per_series_aligner` operation
/// to each time series after its data has been divided into regular
/// `alignment_period` time intervals. This process takes _all_ of the data
/// points in an alignment period, applies a mathematical transformation such as
/// averaging, minimum, maximum, delta, etc., and converts them into a single
/// data point per period.
///
/// Reduction is when the aligned and transformed time series can optionally be
/// combined, reducing the number of time series through similar mathematical
/// transformations. Reduction involves applying a `cross_series_reducer` to
/// all the time series, optionally sorting the time series into subsets with
/// `group_by_fields`, and applying the reducer to each subset.
///
/// The raw time series data can contain a huge amount of information from
/// multiple sources. Alignment and reduction transforms this mass of data into
/// a more manageable and representative collection of data, for example "the
/// 95% latency across the average of all tasks in a cluster". This
/// representative data can be more easily graphed and comprehended, and the
/// individual time series data is still available for later drilldown. For more
/// details, see [Filtering and
/// aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Aggregation {
    /// The `alignment_period` specifies a time interval, in seconds, that is used
    /// to divide the data in all the
    /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
    /// time. This will be done before the per-series aligner can be applied to
    /// the data.
    ///
    /// The value must be at least 60 seconds. If a per-series
    /// aligner other than `ALIGN_NONE` is specified, this field is required or an
    /// error is returned. If no per-series aligner is specified, or the aligner
    /// `ALIGN_NONE` is specified, then this field is ignored.
    ///
    /// The maximum value of the `alignment_period` is 104 weeks (2 years) for
    /// charts, and 90,000 seconds (25 hours) for alerting policies.
    ///
    /// [google.monitoring.v3.TimeSeries]: crate::model::TimeSeries
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub alignment_period: std::option::Option<wkt::Duration>,

    /// An `Aligner` describes how to bring the data points in a single
    /// time series into temporal alignment. Except for `ALIGN_NONE`, all
    /// alignments cause all the data points in an `alignment_period` to be
    /// mathematically grouped together, resulting in a single data point for
    /// each `alignment_period` with end timestamp at the end of the period.
    ///
    /// Not all alignment operations may be applied to all time series. The valid
    /// choices depend on the `metric_kind` and `value_type` of the original time
    /// series. Alignment can change the `metric_kind` or the `value_type` of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `cross_series_reducer` is specified, then
    /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
    /// and `alignment_period` must be specified; otherwise, an error is
    /// returned.
    pub per_series_aligner: crate::model::aggregation::Aligner,

    /// The reduction operation to be used to combine time series into a single
    /// time series, where the value of each data point in the resulting series is
    /// a function of all the already aligned values in the input time series.
    ///
    /// Not all reducer operations can be applied to all time series. The valid
    /// choices depend on the `metric_kind` and the `value_type` of the original
    /// time series. Reduction can yield a time series with a different
    /// `metric_kind` or `value_type` than the input time series.
    ///
    /// Time series data must first be aligned (see `per_series_aligner`) in order
    /// to perform cross-time series reduction. If `cross_series_reducer` is
    /// specified, then `per_series_aligner` must be specified, and must not be
    /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
    /// error is returned.
    pub cross_series_reducer: crate::model::aggregation::Reducer,

    /// The set of fields to preserve when `cross_series_reducer` is
    /// specified. The `group_by_fields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// operation. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `cross_series_reducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `group_by_fields` are aggregated away.  If
    /// `group_by_fields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `cross_series_reducer` is not
    /// defined, this field is ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group_by_fields: std::vec::Vec<std::string::String>,
}

impl Aggregation {
    /// Sets the value of [alignment_period][crate::model::Aggregation::alignment_period].
    pub fn set_alignment_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.alignment_period = v.into();
        self
    }

    /// Sets the value of [per_series_aligner][crate::model::Aggregation::per_series_aligner].
    pub fn set_per_series_aligner<T: std::convert::Into<crate::model::aggregation::Aligner>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_series_aligner = v.into();
        self
    }

    /// Sets the value of [cross_series_reducer][crate::model::Aggregation::cross_series_reducer].
    pub fn set_cross_series_reducer<T: std::convert::Into<crate::model::aggregation::Reducer>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_series_reducer = v.into();
        self
    }

    /// Sets the value of [group_by_fields][crate::model::Aggregation::group_by_fields].
    pub fn set_group_by_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.group_by_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Aggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Aggregation"
    }
}

/// Defines additional types related to Aggregation
pub mod aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// The `Aligner` specifies the operation that will be applied to the data
    /// points in each alignment period in a time series. Except for
    /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
    /// operation replaces the set of data values in each alignment period with
    /// a single value: the result of applying the operation to the data values.
    /// An aligned time series has a single data value at the end of each
    /// `alignment_period`.
    ///
    /// An alignment operation can change the data type of the values, too. For
    /// example, if you apply a counting operation to boolean values, the data
    /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
    /// in the aligned result is `INT64`.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Aligner(std::borrow::Cow<'static, str>);

    impl Aligner {
        /// Creates a new Aligner instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Aligner](Aligner)
    pub mod aligner {
        use super::Aligner;

        /// No alignment. Raw data is returned. Not valid if cross-series reduction
        /// is requested. The `value_type` of the result is the same as the
        /// `value_type` of the input.
        pub const ALIGN_NONE: Aligner = Aligner::new("ALIGN_NONE");

        /// Align and convert to
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
        /// The output is `delta = y1 - y0`.
        ///
        /// This alignment is valid for
        /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
        /// `DELTA` metrics. If the selected alignment period results in periods
        /// with no data, then the aligned value for such a period is created by
        /// interpolation. The `value_type`  of the aligned result is the same as
        /// the `value_type` of the input.
        ///
        /// [google.api.MetricDescriptor.MetricKind.CUMULATIVE]: api::model::metric_descriptor::metric_kind::CUMULATIVE
        /// [google.api.MetricDescriptor.MetricKind.DELTA]: api::model::metric_descriptor::metric_kind::DELTA
        pub const ALIGN_DELTA: Aligner = Aligner::new("ALIGN_DELTA");

        /// Align and convert to a rate. The result is computed as
        /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
        /// Think of this aligner as providing the slope of the line that passes
        /// through the value at the start and at the end of the `alignment_period`.
        ///
        /// This aligner is valid for `CUMULATIVE`
        /// and `DELTA` metrics with numeric values. If the selected alignment
        /// period results in periods with no data, then the aligned value for
        /// such a period is created by interpolation. The output is a `GAUGE`
        /// metric with `value_type` `DOUBLE`.
        ///
        /// If, by "rate", you mean "percentage change", see the
        /// `ALIGN_PERCENT_CHANGE` aligner instead.
        pub const ALIGN_RATE: Aligner = Aligner::new("ALIGN_RATE");

        /// Align by interpolating between adjacent points around the alignment
        /// period boundary. This aligner is valid for `GAUGE` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as the
        /// `value_type` of the input.
        pub const ALIGN_INTERPOLATE: Aligner = Aligner::new("ALIGN_INTERPOLATE");

        /// Align by moving the most recent data point before the end of the
        /// alignment period to the boundary at the end of the alignment
        /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
        /// the aligned result is the same as the `value_type` of the input.
        pub const ALIGN_NEXT_OLDER: Aligner = Aligner::new("ALIGN_NEXT_OLDER");

        /// Align the time series by returning the minimum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        pub const ALIGN_MIN: Aligner = Aligner::new("ALIGN_MIN");

        /// Align the time series by returning the maximum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        pub const ALIGN_MAX: Aligner = Aligner::new("ALIGN_MAX");

        /// Align the time series by returning the mean value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
        pub const ALIGN_MEAN: Aligner = Aligner::new("ALIGN_MEAN");

        /// Align the time series by returning the number of values in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric or Boolean values. The `value_type` of the aligned result is
        /// `INT64`.
        pub const ALIGN_COUNT: Aligner = Aligner::new("ALIGN_COUNT");

        /// Align the time series by returning the sum of the values in each
        /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with numeric and distribution values. The `value_type` of the
        /// aligned result is the same as the `value_type` of the input.
        pub const ALIGN_SUM: Aligner = Aligner::new("ALIGN_SUM");

        /// Align the time series by returning the standard deviation of the values
        /// in each alignment period. This aligner is valid for `GAUGE` and
        /// `DELTA` metrics with numeric values. The `value_type` of the output is
        /// `DOUBLE`.
        pub const ALIGN_STDDEV: Aligner = Aligner::new("ALIGN_STDDEV");

        /// Align the time series by returning the number of `True` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        pub const ALIGN_COUNT_TRUE: Aligner = Aligner::new("ALIGN_COUNT_TRUE");

        /// Align the time series by returning the number of `False` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        pub const ALIGN_COUNT_FALSE: Aligner = Aligner::new("ALIGN_COUNT_FALSE");

        /// Align the time series by returning the ratio of the number of `True`
        /// values to the total number of values in each alignment period. This
        /// aligner is valid for `GAUGE` metrics with Boolean values. The output
        /// value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
        pub const ALIGN_FRACTION_TRUE: Aligner = Aligner::new("ALIGN_FRACTION_TRUE");

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 99th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_99: Aligner = Aligner::new("ALIGN_PERCENTILE_99");

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 95th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_95: Aligner = Aligner::new("ALIGN_PERCENTILE_95");

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 50th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_50: Aligner = Aligner::new("ALIGN_PERCENTILE_50");

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 5th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_05: Aligner = Aligner::new("ALIGN_PERCENTILE_05");

        /// Align and convert to a percentage change. This aligner is valid for
        /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
        /// `((current - previous)/previous) * 100`, where the value of `previous` is
        /// determined based on the `alignment_period`.
        ///
        /// If the values of `current` and `previous` are both 0, then the returned
        /// value is 0. If only `previous` is 0, the returned value is infinity.
        ///
        /// A 10-minute moving mean is computed at each point of the alignment period
        /// prior to the above calculation to smooth the metric and prevent false
        /// positives from very short-lived spikes. The moving mean is only
        /// applicable for data whose values are `>= 0`. Any values `< 0` are
        /// treated as a missing datapoint, and are ignored. While `DELTA`
        /// metrics are accepted by this alignment, special care should be taken that
        /// the values for the metric will always be positive. The output is a
        /// `GAUGE` metric with `value_type` `DOUBLE`.
        pub const ALIGN_PERCENT_CHANGE: Aligner = Aligner::new("ALIGN_PERCENT_CHANGE");
    }

    impl std::convert::From<std::string::String> for Aligner {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// A Reducer operation describes how to aggregate data points from multiple
    /// time series into a single time series, where the value of each data point
    /// in the resulting series is a function of all the already aligned values in
    /// the input time series.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Reducer(std::borrow::Cow<'static, str>);

    impl Reducer {
        /// Creates a new Reducer instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Reducer](Reducer)
    pub mod reducer {
        use super::Reducer;

        /// No cross-time series reduction. The output of the `Aligner` is
        /// returned.
        pub const REDUCE_NONE: Reducer = Reducer::new("REDUCE_NONE");

        /// Reduce by computing the mean value across time series for each
        /// alignment period. This reducer is valid for
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
        /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
        /// numeric or distribution values. The `value_type` of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        ///
        /// [google.api.MetricDescriptor.MetricKind.DELTA]: api::model::metric_descriptor::metric_kind::DELTA
        /// [google.api.MetricDescriptor.MetricKind.GAUGE]: api::model::metric_descriptor::metric_kind::GAUGE
        /// [google.api.MetricDescriptor.ValueType.DOUBLE]: api::model::metric_descriptor::value_type::DOUBLE
        pub const REDUCE_MEAN: Reducer = Reducer::new("REDUCE_MEAN");

        /// Reduce by computing the minimum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        pub const REDUCE_MIN: Reducer = Reducer::new("REDUCE_MIN");

        /// Reduce by computing the maximum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        pub const REDUCE_MAX: Reducer = Reducer::new("REDUCE_MAX");

        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric and distribution values. The `value_type` of the output is
        /// the same as the `value_type` of the input.
        pub const REDUCE_SUM: Reducer = Reducer::new("REDUCE_SUM");

        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics with numeric or distribution values. The `value_type`
        /// of the output is `DOUBLE`.
        pub const REDUCE_STDDEV: Reducer = Reducer::new("REDUCE_STDDEV");

        /// Reduce by computing the number of data points across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of numeric, Boolean, distribution, and string
        /// `value_type`. The `value_type` of the output is `INT64`.
        pub const REDUCE_COUNT: Reducer = Reducer::new("REDUCE_COUNT");

        /// Reduce by computing the number of `True`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        pub const REDUCE_COUNT_TRUE: Reducer = Reducer::new("REDUCE_COUNT_TRUE");

        /// Reduce by computing the number of `False`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        pub const REDUCE_COUNT_FALSE: Reducer = Reducer::new("REDUCE_COUNT_FALSE");

        /// Reduce by computing the ratio of the number of `True`-valued data points
        /// to the total number of data points for each alignment period. This
        /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
        /// The output value is in the range [0.0, 1.0] and has `value_type`
        /// `DOUBLE`.
        pub const REDUCE_FRACTION_TRUE: Reducer = Reducer::new("REDUCE_FRACTION_TRUE");

        /// Reduce by computing the [99th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_99: Reducer = Reducer::new("REDUCE_PERCENTILE_99");

        /// Reduce by computing the [95th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_95: Reducer = Reducer::new("REDUCE_PERCENTILE_95");

        /// Reduce by computing the [50th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_50: Reducer = Reducer::new("REDUCE_PERCENTILE_50");

        /// Reduce by computing the [5th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_05: Reducer = Reducer::new("REDUCE_PERCENTILE_05");
    }

    impl std::convert::From<std::string::String> for Reducer {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A set of (label, value) pairs that were removed from a Distribution
/// time series during aggregation and then added as an attachment to a
/// Distribution.Exemplar.
///
/// The full label set for the exemplars is constructed by using the dropped
/// pairs in combination with the label values that remain on the aggregated
/// Distribution time series. The constructed full label set can be used to
/// identify the specific entity, such as the instance or job, which might be
/// contributing to a long-tail. However, with dropped labels, the storage
/// requirements are reduced because only the aggregated distribution values for
/// a large group of time series are stored.
///
/// Note that there are no guarantees on ordering of the labels from
/// exemplar-to-exemplar and from distribution-to-distribution in the same
/// stream, and there may be duplicates.  It is up to clients to resolve any
/// ambiguities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DroppedLabels {
    /// Map from label to its value, for all labels dropped in any aggregation.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub label: std::collections::HashMap<std::string::String, std::string::String>,
}

impl DroppedLabels {
    /// Sets the value of [label][crate::model::DroppedLabels::label].
    pub fn set_label<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.label = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DroppedLabels {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DroppedLabels"
    }
}

/// The description of a dynamic collection of monitored resources. Each group
/// has a filter that is matched against monitored resources and their associated
/// metadata. If a group's filter matches an available monitored resource, then
/// that resource is a member of that group.  Groups can contain any number of
/// monitored resources, and each monitored resource can be a member of any
/// number of groups.
///
/// Groups can be nested in parent-child hierarchies. The `parentName` field
/// identifies an optional parent for each group.  If a group has a parent, then
/// the only monitored resources available to be matched by the group's filter
/// are the resources contained in the parent group.  In other words, a group
/// contains the monitored resources that match its filter and the filters of all
/// the group's ancestors.  A group without a parent can contain any monitored
/// resource.
///
/// For example, consider an infrastructure running a set of instances with two
/// user-defined tags: `"environment"` and `"role"`. A parent group has a filter,
/// `environment="production"`.  A child of that parent group has a filter,
/// `role="transcoder"`.  The parent group contains all instances in the
/// production environment, regardless of their roles.  The child group contains
/// instances that have the transcoder role *and* are in the production
/// environment.
///
/// The monitored resources contained in a group can change at any moment,
/// depending on what resources exist and what filters are associated with the
/// group and its ancestors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Group {
    /// Output only. The name of this group. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    ///
    /// When creating a group, this field is ignored and a new name is created
    /// consisting of the project specified in the call to `CreateGroup`
    /// and a unique `[GROUP_ID]` that is generated automatically.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A user-assigned name for this group, used only for display purposes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The name of the group's parent, if it has one. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    ///
    /// For groups with no parent, `parent_name` is the empty string, `""`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_name: std::string::String,

    /// The filter used to determine which monitored resources belong to this
    /// group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// If true, the members of this group are considered to be a cluster.
    /// The system can perform additional analysis on groups that are clusters.
    pub is_cluster: bool,
}

impl Group {
    /// Sets the value of [name][crate::model::Group::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Group::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [parent_name][crate::model::Group::parent_name].
    pub fn set_parent_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::Group::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [is_cluster][crate::model::Group::is_cluster].
    pub fn set_is_cluster<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_cluster = v.into();
        self
    }
}

impl wkt::message::Message for Group {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Group"
    }
}

/// The `ListGroup` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// groups are to be listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A positive number that is the maximum number of results to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `next_page_token` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// An optional filter consisting of a single group name.  The filters limit
    /// the groups returned based on their parent-child relationship with the
    /// specified group. If no filter is specified, all groups are returned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::list_groups_request::Filter>,
}

impl ListGroupsRequest {
    /// Sets the value of [name][crate::model::ListGroupsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::list_groups_request::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::ListGroupsRequest::filter]
    /// if it holds a `ChildrenOfGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_children_of_group(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::list_groups_request::Filter::ChildrenOfGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::ListGroupsRequest::filter]
    /// if it holds a `AncestorsOfGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_ancestors_of_group(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::list_groups_request::Filter::AncestorsOfGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::ListGroupsRequest::filter]
    /// if it holds a `DescendantsOfGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_descendants_of_group(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::list_groups_request::Filter::DescendantsOfGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter]
    /// to hold a `ChildrenOfGroup`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_children_of_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::list_groups_request::Filter::ChildrenOfGroup(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter]
    /// to hold a `AncestorsOfGroup`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_ancestors_of_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::list_groups_request::Filter::AncestorsOfGroup(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter]
    /// to hold a `DescendantsOfGroup`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_descendants_of_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::list_groups_request::Filter::DescendantsOfGroup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ListGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupsRequest"
    }
}

/// Defines additional types related to ListGroupsRequest
pub mod list_groups_request {
    #[allow(unused_imports)]
    use super::*;

    /// An optional filter consisting of a single group name.  The filters limit
    /// the groups returned based on their parent-child relationship with the
    /// specified group. If no filter is specified, all groups are returned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A group name. The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
        /// ```
        ///
        /// Returns groups whose `parent_name` field contains the group
        /// name.  If no groups have this parent, the results are empty.
        ChildrenOfGroup(std::string::String),
        /// A group name. The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
        /// ```
        ///
        /// Returns groups that are ancestors of the specified group.
        /// The groups are returned in order, starting with the immediate parent and
        /// ending with the most distant ancestor.  If the specified group has no
        /// immediate parent, the results are empty.
        AncestorsOfGroup(std::string::String),
        /// A group name. The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
        /// ```
        ///
        /// Returns the descendants of the specified group.  This is a superset of
        /// the results returned by the `children_of_group` filter, and includes
        /// children-of-children, and so forth.
        DescendantsOfGroup(std::string::String),
    }
}

/// The `ListGroups` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupsResponse {
    /// The groups that match the specified filters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group: std::vec::Vec<crate::model::Group>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListGroupsResponse {
    /// Sets the value of [next_page_token][crate::model::ListGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [group][crate::model::ListGroupsResponse::group].
    pub fn set_group<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Group>,
    {
        use std::iter::Iterator;
        self.group = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListGroupsResponse {
    type PageItem = crate::model::Group;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.group
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `GetGroup` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGroupRequest {
    /// Required. The group to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetGroupRequest {
    /// Sets the value of [name][crate::model::GetGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetGroupRequest"
    }
}

/// The `CreateGroup` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGroupRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// to create the group. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. A group definition. It is an error to define the `name` field
    /// because the system assigns the name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub group: std::option::Option<crate::model::Group>,

    /// If true, validate this request but do not create the group.
    pub validate_only: bool,
}

impl CreateGroupRequest {
    /// Sets the value of [name][crate::model::CreateGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::option::Option<crate::model::Group>>>(
        mut self,
        v: T,
    ) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateGroupRequest"
    }
}

/// The `UpdateGroup` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGroupRequest {
    /// Required. The new definition of the group.  All fields of the existing
    /// group, excepting `name`, are replaced with the corresponding fields of this
    /// group.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub group: std::option::Option<crate::model::Group>,

    /// If true, validate this request but do not update the existing group.
    pub validate_only: bool,
}

impl UpdateGroupRequest {
    /// Sets the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_group<T: std::convert::Into<std::option::Option<crate::model::Group>>>(
        mut self,
        v: T,
    ) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateGroupRequest"
    }
}

/// The `DeleteGroup` request. The default behavior is to be able to delete a
/// single group without any descendants.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGroupRequest {
    /// Required. The group to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If this field is true, then the request means to delete a group with all
    /// its descendants. Otherwise, the request means to delete a group only when
    /// it has no descendants. The default value is false.
    pub recursive: bool,
}

impl DeleteGroupRequest {
    /// Sets the value of [name][crate::model::DeleteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [recursive][crate::model::DeleteGroupRequest::recursive].
    pub fn set_recursive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.recursive = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteGroupRequest"
    }
}

/// The `ListGroupMembers` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupMembersRequest {
    /// Required. The group whose members are listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A positive number that is the maximum number of results to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `next_page_token` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// An optional [list
    /// filter](https://cloud.google.com/monitoring/api/learn_more#filtering)
    /// describing the members to be returned.  The filter may reference the type,
    /// labels, and metadata of monitored resources that comprise the group. For
    /// example, to return only resources representing Compute Engine VM instances,
    /// use this filter:
    ///
    /// ```norust
    /// `resource.type = "gce_instance"`
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// An optional time interval for which results should be returned. Only
    /// members that were part of the group during the specified interval are
    /// included in the response.  If no interval is provided then the group
    /// membership over the last minute is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<crate::model::TimeInterval>,
}

impl ListGroupMembersRequest {
    /// Sets the value of [name][crate::model::ListGroupMembersRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupMembersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupMembersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupMembersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListGroupMembersRequest::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<crate::model::TimeInterval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupMembersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupMembersRequest"
    }
}

/// The `ListGroupMembers` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupMembersResponse {
    /// A set of monitored resources in the group.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub members: std::vec::Vec<api::model::MonitoredResource>,

    /// If there are more results than have been returned, then this field is
    /// set to a non-empty value.  To see the additional results, use that value as
    /// `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of elements matching this request.
    pub total_size: i32,
}

impl ListGroupMembersResponse {
    /// Sets the value of [next_page_token][crate::model::ListGroupMembersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListGroupMembersResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [members][crate::model::ListGroupMembersResponse::members].
    pub fn set_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResource>,
    {
        use std::iter::Iterator;
        self.members = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGroupMembersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupMembersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListGroupMembersResponse {
    type PageItem = api::model::MonitoredResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.members
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A single data point in a time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Point {
    /// The time interval to which the data point applies.  For `GAUGE` metrics,
    /// the start time is optional, but if it is supplied, it must equal the
    /// end time.  For `DELTA` metrics, the start
    /// and end time should specify a non-zero interval, with subsequent points
    /// specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
    /// metrics, the start and end time should specify a non-zero interval, with
    /// subsequent points specifying the same start time and increasing end times,
    /// until an event resets the cumulative value to zero and sets a new start
    /// time for the following points.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// The value of the data point.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::TypedValue>,
}

impl Point {
    /// Sets the value of [interval][crate::model::Point::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<crate::model::TimeInterval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Point::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::TypedValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Point {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Point"
    }
}

/// A collection of data points that describes the time-varying values
/// of a metric. A time series is identified by a combination of a
/// fully-specified monitored resource and a fully-specified metric.
/// This type is used for both listing and creating time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeries {
    /// The associated metric. A fully-specified metric used to identify the time
    /// series.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric: std::option::Option<api::model::Metric>,

    /// The associated monitored resource.  Custom metrics can use only certain
    /// monitored resource types in their time series data. For more information,
    /// see [Monitored resources for custom
    /// metrics](https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<api::model::MonitoredResource>,

    /// Output only. The associated monitored resource metadata. When reading a
    /// time series, this field will include metadata labels that are explicitly
    /// named in the reduction. When creating a time series, this field is ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<api::model::MonitoredResourceMetadata>,

    /// The metric kind of the time series. When listing time series, this metric
    /// kind might be different from the metric kind of the associated metric if
    /// this time series is an alignment or reduction of other time series.
    ///
    /// When creating a time series, this field is optional. If present, it must be
    /// the same as the metric kind of the associated metric. If the associated
    /// metric's descriptor must be auto-created, then this field specifies the
    /// metric kind of the new descriptor and must be either `GAUGE` (the default)
    /// or `CUMULATIVE`.
    pub metric_kind: api::model::metric_descriptor::MetricKind,

    /// The value type of the time series. When listing time series, this value
    /// type might be different from the value type of the associated metric if
    /// this time series is an alignment or reduction of other time series.
    ///
    /// When creating a time series, this field is optional. If present, it must be
    /// the same as the type of the data in the `points` field.
    pub value_type: api::model::metric_descriptor::ValueType,

    /// The data points of this time series. When listing time series, points are
    /// returned in reverse time order.
    ///
    /// When creating a time series, this field must contain exactly one point and
    /// the point's type must be the same as the value type of the associated
    /// metric. If the associated metric's descriptor must be auto-created, then
    /// the value type of the descriptor is determined by the point's type, which
    /// must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub points: std::vec::Vec<crate::model::Point>,

    /// The units in which the metric value is reported. It is only applicable
    /// if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
    /// defines the representation of the stored metric values. This field can only
    /// be changed through CreateTimeSeries when it is empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub unit: std::string::String,

    /// Input only. A detailed description of the time series that will be
    /// associated with the
    /// [google.api.MetricDescriptor][google.api.MetricDescriptor] for the metric.
    /// Once set, this field cannot be changed through CreateTimeSeries.
    ///
    /// [google.api.MetricDescriptor]: api::model::MetricDescriptor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl TimeSeries {
    /// Sets the value of [metric][crate::model::TimeSeries::metric].
    pub fn set_metric<T: std::convert::Into<std::option::Option<api::model::Metric>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::TimeSeries::resource].
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<api::model::MonitoredResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::TimeSeries::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<api::model::MonitoredResourceMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [metric_kind][crate::model::TimeSeries::metric_kind].
    pub fn set_metric_kind<T: std::convert::Into<api::model::metric_descriptor::MetricKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_kind = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TimeSeries::value_type].
    pub fn set_value_type<T: std::convert::Into<api::model::metric_descriptor::ValueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [unit][crate::model::TimeSeries::unit].
    pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.unit = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TimeSeries::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [points][crate::model::TimeSeries::points].
    pub fn set_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Point>,
    {
        use std::iter::Iterator;
        self.points = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeries"
    }
}

/// A descriptor for the labels and points in a time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesDescriptor {
    /// Descriptors for the labels.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub label_descriptors: std::vec::Vec<api::model::LabelDescriptor>,

    /// Descriptors for the point data value columns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub point_descriptors: std::vec::Vec<crate::model::time_series_descriptor::ValueDescriptor>,
}

impl TimeSeriesDescriptor {
    /// Sets the value of [label_descriptors][crate::model::TimeSeriesDescriptor::label_descriptors].
    pub fn set_label_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::LabelDescriptor>,
    {
        use std::iter::Iterator;
        self.label_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [point_descriptors][crate::model::TimeSeriesDescriptor::point_descriptors].
    pub fn set_point_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_descriptor::ValueDescriptor>,
    {
        use std::iter::Iterator;
        self.point_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeriesDescriptor"
    }
}

/// Defines additional types related to TimeSeriesDescriptor
pub mod time_series_descriptor {
    #[allow(unused_imports)]
    use super::*;

    /// A descriptor for the value columns in a data point.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ValueDescriptor {
        /// The value key.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// The value type.
        pub value_type: api::model::metric_descriptor::ValueType,

        /// The value stream kind.
        pub metric_kind: api::model::metric_descriptor::MetricKind,

        /// The unit in which `time_series` point values are reported. `unit`
        /// follows the UCUM format for units as seen in
        /// <https://unitsofmeasure.org/ucum.html>.
        /// `unit` is only valid if `value_type` is INTEGER, DOUBLE, DISTRIBUTION.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub unit: std::string::String,
    }

    impl ValueDescriptor {
        /// Sets the value of [key][crate::model::time_series_descriptor::ValueDescriptor::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value_type][crate::model::time_series_descriptor::ValueDescriptor::value_type].
        pub fn set_value_type<T: std::convert::Into<api::model::metric_descriptor::ValueType>>(
            mut self,
            v: T,
        ) -> Self {
            self.value_type = v.into();
            self
        }

        /// Sets the value of [metric_kind][crate::model::time_series_descriptor::ValueDescriptor::metric_kind].
        pub fn set_metric_kind<T: std::convert::Into<api::model::metric_descriptor::MetricKind>>(
            mut self,
            v: T,
        ) -> Self {
            self.metric_kind = v.into();
            self
        }

        /// Sets the value of [unit][crate::model::time_series_descriptor::ValueDescriptor::unit].
        pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.unit = v.into();
            self
        }
    }

    impl wkt::message::Message for ValueDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor"
        }
    }
}

/// Represents the values of a time series associated with a
/// TimeSeriesDescriptor.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesData {
    /// The values of the labels in the time series identifier, given in the same
    /// order as the `label_descriptors` field of the TimeSeriesDescriptor
    /// associated with this object. Each value must have a value of the type
    /// given in the corresponding entry of `label_descriptors`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub label_values: std::vec::Vec<crate::model::LabelValue>,

    /// The points in the time series.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub point_data: std::vec::Vec<crate::model::time_series_data::PointData>,
}

impl TimeSeriesData {
    /// Sets the value of [label_values][crate::model::TimeSeriesData::label_values].
    pub fn set_label_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LabelValue>,
    {
        use std::iter::Iterator;
        self.label_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [point_data][crate::model::TimeSeriesData::point_data].
    pub fn set_point_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_data::PointData>,
    {
        use std::iter::Iterator;
        self.point_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeriesData"
    }
}

/// Defines additional types related to TimeSeriesData
pub mod time_series_data {
    #[allow(unused_imports)]
    use super::*;

    /// A point's value columns and time interval. Each point has one or more
    /// point values corresponding to the entries in `point_descriptors` field in
    /// the TimeSeriesDescriptor associated with this object.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PointData {
        /// The values that make up the point.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<crate::model::TypedValue>,

        /// The time interval associated with the point.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_interval: std::option::Option<crate::model::TimeInterval>,
    }

    impl PointData {
        /// Sets the value of [time_interval][crate::model::time_series_data::PointData::time_interval].
        pub fn set_time_interval<
            T: std::convert::Into<std::option::Option<crate::model::TimeInterval>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_interval = v.into();
            self
        }

        /// Sets the value of [values][crate::model::time_series_data::PointData::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::TypedValue>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PointData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.TimeSeriesData.PointData"
        }
    }
}

/// A label value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LabelValue {
    /// The label value can be a bool, int64, or string.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::label_value::Value>,
}

impl LabelValue {
    /// Sets the value of `value`.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::label_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::LabelValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::label_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::LabelValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::label_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::LabelValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::label_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::LabelValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::label_value::Value::BoolValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::LabelValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::label_value::Value::Int64Value(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::LabelValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::label_value::Value::StringValue(v.into()));
        self
    }
}

impl wkt::message::Message for LabelValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.LabelValue"
    }
}

/// Defines additional types related to LabelValue
pub mod label_value {
    #[allow(unused_imports)]
    use super::*;

    /// The label value can be a bool, int64, or string.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A bool label value.
        BoolValue(bool),
        /// An int64 label value.
        Int64Value(i64),
        /// A string label value.
        StringValue(std::string::String),
    }
}

/// An error associated with a query in the time series query language format.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryError {
    /// The location of the time series query language text that this error applies
    /// to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub locator: std::option::Option<crate::model::TextLocator>,

    /// The error message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl QueryError {
    /// Sets the value of [locator][crate::model::QueryError::locator].
    pub fn set_locator<T: std::convert::Into<std::option::Option<crate::model::TextLocator>>>(
        mut self,
        v: T,
    ) -> Self {
        self.locator = v.into();
        self
    }

    /// Sets the value of [message][crate::model::QueryError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for QueryError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryError"
    }
}

/// A locator for text. Indicates a particular part of the text of a request or
/// of an object referenced in the request.
///
/// For example, suppose the request field `text` contains:
///
/// text: "The quick brown fox jumps over the lazy dog."
///
/// Then the locator:
///
/// source: "text"
/// start_position {
/// line: 1
/// column: 17
/// }
/// end_position {
/// line: 1
/// column: 19
/// }
///
/// refers to the part of the text: "fox".
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TextLocator {
    /// The source of the text. The source may be a field in the request, in which
    /// case its format is the format of the
    /// google.rpc.BadRequest.FieldViolation.field field in
    /// <https://cloud.google.com/apis/design/errors#error_details>. It may also be
    /// be a source other than the request field (e.g. a macro definition
    /// referenced in the text of the query), in which case this is the name of
    /// the source (e.g. the macro name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    /// The position of the first byte within the text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_position: std::option::Option<crate::model::text_locator::Position>,

    /// The position of the last byte within the text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_position: std::option::Option<crate::model::text_locator::Position>,

    /// If `source`, `start_position`, and `end_position` describe a call on
    /// some object (e.g. a macro in the time series query language text) and a
    /// location is to be designated in that object's text, `nested_locator`
    /// identifies the location within that object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nested_locator: std::option::Option<std::boxed::Box<crate::model::TextLocator>>,

    /// When `nested_locator` is set, this field gives the reason for the nesting.
    /// Usually, the reason is a macro invocation. In that case, the macro name
    /// (including the leading '@') signals the location of the macro call
    /// in the text and a macro argument name (including the leading '$') signals
    /// the location of the macro argument inside the macro body that got
    /// substituted away.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nesting_reason: std::string::String,
}

impl TextLocator {
    /// Sets the value of [source][crate::model::TextLocator::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [start_position][crate::model::TextLocator::start_position].
    pub fn set_start_position<
        T: std::convert::Into<std::option::Option<crate::model::text_locator::Position>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_position = v.into();
        self
    }

    /// Sets the value of [end_position][crate::model::TextLocator::end_position].
    pub fn set_end_position<
        T: std::convert::Into<std::option::Option<crate::model::text_locator::Position>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.end_position = v.into();
        self
    }

    /// Sets the value of [nested_locator][crate::model::TextLocator::nested_locator].
    pub fn set_nested_locator<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::TextLocator>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nested_locator = v.into();
        self
    }

    /// Sets the value of [nesting_reason][crate::model::TextLocator::nesting_reason].
    pub fn set_nesting_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nesting_reason = v.into();
        self
    }
}

impl wkt::message::Message for TextLocator {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TextLocator"
    }
}

/// Defines additional types related to TextLocator
pub mod text_locator {
    #[allow(unused_imports)]
    use super::*;

    /// The position of a byte within the text.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Position {
        /// The line, starting with 1, where the byte is positioned.
        pub line: i32,

        /// The column within the line, starting with 1, where the byte is
        /// positioned. This is a byte index even though the text is UTF-8.
        pub column: i32,
    }

    impl Position {
        /// Sets the value of [line][crate::model::text_locator::Position::line].
        pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.line = v.into();
            self
        }

        /// Sets the value of [column][crate::model::text_locator::Position::column].
        pub fn set_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }
    }

    impl wkt::message::Message for Position {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.TextLocator.Position"
        }
    }
}

/// The `ListMonitoredResourceDescriptors` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An optional [filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// describing the descriptors to be returned.  The filter can reference the
    /// descriptor's type and labels. For example, the following filter returns
    /// only Google Compute Engine descriptors that have an `id` label:
    ///
    /// ```norust
    /// resource.type = starts_with("gce_") AND resource.label:id
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A positive number that is the maximum number of results to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListMonitoredResourceDescriptorsRequest {
    /// Sets the value of [name][crate::model::ListMonitoredResourceDescriptorsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMonitoredResourceDescriptorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMonitoredResourceDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMonitoredResourceDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMonitoredResourceDescriptorsRequest"
    }
}

/// The `ListMonitoredResourceDescriptors` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsResponse {
    /// The monitored resource descriptors that are available to this project
    /// and that match `filter`, if present.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_descriptors: std::vec::Vec<api::model::MonitoredResourceDescriptor>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListMonitoredResourceDescriptorsResponse {
    /// Sets the value of [next_page_token][crate::model::ListMonitoredResourceDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [resource_descriptors][crate::model::ListMonitoredResourceDescriptorsResponse::resource_descriptors].
    pub fn set_resource_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResourceDescriptor>,
    {
        use std::iter::Iterator;
        self.resource_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMonitoredResourceDescriptorsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMonitoredResourceDescriptorsResponse {
    type PageItem = api::model::MonitoredResourceDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resource_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `GetMonitoredResourceDescriptor` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMonitoredResourceDescriptorRequest {
    /// Required. The monitored resource descriptor to get.  The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE]
    /// ```
    ///
    /// The `[RESOURCE_TYPE]` is a predefined type, such as
    /// `cloudsql_database`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMonitoredResourceDescriptorRequest {
    /// Sets the value of [name][crate::model::GetMonitoredResourceDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMonitoredResourceDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetMonitoredResourceDescriptorRequest"
    }
}

/// The `ListMetricDescriptors` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetricDescriptorsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If this field is empty, all custom and
    /// system-defined metric descriptors are returned.
    /// Otherwise, the [filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifies which metric descriptors are to be
    /// returned. For example, the following filter matches all
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics):
    ///
    /// ```norust
    /// metric.type = starts_with("custom.googleapis.com/")
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. A positive number that is the maximum number of results to
    /// return. The default and maximum value is 10,000. If a page_size <= 0 or >
    /// 10,000 is submitted, will instead return a maximum of 10,000 results.
    pub page_size: i32,

    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return additional results from the previous
    /// method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. If true, only metrics and monitored resource types that have
    /// recent data (within roughly 25 hours) will be included in the response.
    ///
    /// - If a metric descriptor enumerates monitored resource types, only the
    ///   monitored resource types for which the metric type has recent data will
    ///   be included in the returned metric descriptor, and if none of them have
    ///   recent data, the metric descriptor will not be returned.
    /// - If a metric descriptor does not enumerate the compatible monitored
    ///   resource types, it will be returned only if the metric type has recent
    ///   data for some monitored resource type. The returned descriptor will not
    ///   enumerate any monitored resource types.
    pub active_only: bool,
}

impl ListMetricDescriptorsRequest {
    /// Sets the value of [name][crate::model::ListMetricDescriptorsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMetricDescriptorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetricDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetricDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [active_only][crate::model::ListMetricDescriptorsRequest::active_only].
    pub fn set_active_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.active_only = v.into();
        self
    }
}

impl wkt::message::Message for ListMetricDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMetricDescriptorsRequest"
    }
}

/// The `ListMetricDescriptors` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetricDescriptorsResponse {
    /// The metric descriptors that are available to the project
    /// and that match the value of `filter`, if present.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metric_descriptors: std::vec::Vec<api::model::MetricDescriptor>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListMetricDescriptorsResponse {
    /// Sets the value of [next_page_token][crate::model::ListMetricDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metric_descriptors][crate::model::ListMetricDescriptorsResponse::metric_descriptors].
    pub fn set_metric_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MetricDescriptor>,
    {
        use std::iter::Iterator;
        self.metric_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMetricDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMetricDescriptorsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMetricDescriptorsResponse {
    type PageItem = api::model::MetricDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metric_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `GetMetricDescriptor` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMetricDescriptorRequest {
    /// Required. The metric descriptor on which to execute the request. The format
    /// is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
    /// ```
    ///
    /// An example value of `[METRIC_ID]` is
    /// `"compute.googleapis.com/instance/disk/read_bytes_count"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMetricDescriptorRequest {
    /// Sets the value of [name][crate::model::GetMetricDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetricDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetMetricDescriptorRequest"
    }
}

/// The `CreateMetricDescriptor` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetricDescriptorRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    /// 4
    /// projects/[PROJECT_ID_OR_NUMBER]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new [custom
    /// metric](https://cloud.google.com/monitoring/custom-metrics) descriptor.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_descriptor: std::option::Option<api::model::MetricDescriptor>,
}

impl CreateMetricDescriptorRequest {
    /// Sets the value of [name][crate::model::CreateMetricDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [metric_descriptor][crate::model::CreateMetricDescriptorRequest::metric_descriptor].
    pub fn set_metric_descriptor<
        T: std::convert::Into<std::option::Option<api::model::MetricDescriptor>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_descriptor = v.into();
        self
    }
}

impl wkt::message::Message for CreateMetricDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateMetricDescriptorRequest"
    }
}

/// The `DeleteMetricDescriptor` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMetricDescriptorRequest {
    /// Required. The metric descriptor on which to execute the request. The format
    /// is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
    /// ```
    ///
    /// An example of `[METRIC_ID]` is:
    /// `"custom.googleapis.com/my_test_metric"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteMetricDescriptorRequest {
    /// Sets the value of [name][crate::model::DeleteMetricDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMetricDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteMetricDescriptorRequest"
    }
}

/// The `ListTimeSeries` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTimeSeriesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name),
    /// organization or folder on which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// organizations/[ORGANIZATION_ID]
    /// folders/[FOLDER_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. A [monitoring
    /// filter](https://cloud.google.com/monitoring/api/v3/filters) that specifies
    /// which time series should be returned.  The filter must specify a single
    /// metric type, and can additionally specify metric labels and other
    /// information. For example:
    ///
    /// ```norust
    /// metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
    ///     metric.labels.instance_name = "my-instance-name"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Required. The time interval for which results should be returned. Only time
    /// series that contain data points in the specified interval are included in
    /// the response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// Specifies the alignment of data points in individual time series as
    /// well as how to combine the retrieved time series across specified labels.
    ///
    /// By default (if no `aggregation` is explicitly specified), the raw time
    /// series data is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aggregation: std::option::Option<crate::model::Aggregation>,

    /// Apply a second aggregation after `aggregation` is applied. May only be
    /// specified if `aggregation` is specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Unsupported: must be left blank. The points in each time series are
    /// currently returned in reverse time order (most recent to oldest).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Required. Specifies which information is returned about the time series.
    pub view: crate::model::list_time_series_request::TimeSeriesView,

    /// A positive number that is the maximum number of results to return. If
    /// `page_size` is empty or more than 100,000 results, the effective
    /// `page_size` is 100,000 results. If `view` is set to `FULL`, this is the
    /// maximum number of `Points` returned. If `view` is set to `HEADERS`, this is
    /// the maximum number of `TimeSeries` returned.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListTimeSeriesRequest {
    /// Sets the value of [name][crate::model::ListTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTimeSeriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListTimeSeriesRequest::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<crate::model::TimeInterval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }

    /// Sets the value of [aggregation][crate::model::ListTimeSeriesRequest::aggregation].
    pub fn set_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation = v.into();
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::ListTimeSeriesRequest::secondary_aggregation].
    pub fn set_secondary_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_aggregation = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTimeSeriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListTimeSeriesRequest::view].
    pub fn set_view<
        T: std::convert::Into<crate::model::list_time_series_request::TimeSeriesView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTimeSeriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTimeSeriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListTimeSeriesRequest"
    }
}

/// Defines additional types related to ListTimeSeriesRequest
pub mod list_time_series_request {
    #[allow(unused_imports)]
    use super::*;

    /// Controls which fields are returned by `ListTimeSeries*`.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TimeSeriesView(std::borrow::Cow<'static, str>);

    impl TimeSeriesView {
        /// Creates a new TimeSeriesView instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [TimeSeriesView](TimeSeriesView)
    pub mod time_series_view {
        use super::TimeSeriesView;

        /// Returns the identity of the metric(s), the time series,
        /// and the time series data.
        pub const FULL: TimeSeriesView = TimeSeriesView::new("FULL");

        /// Returns the identity of the metric and the time series resource,
        /// but not the time series data.
        pub const HEADERS: TimeSeriesView = TimeSeriesView::new("HEADERS");
    }

    impl std::convert::From<std::string::String> for TimeSeriesView {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// The `ListTimeSeries` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTimeSeriesResponse {
    /// One or more time series that match the filter included in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series: std::vec::Vec<crate::model::TimeSeries>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Query execution errors that may have caused the time series data returned
    /// to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub execution_errors: std::vec::Vec<rpc::model::Status>,

    /// The unit in which all `time_series` point values are reported. `unit`
    /// follows the UCUM format for units as seen in
    /// <https://unitsofmeasure.org/ucum.html>.
    /// If different `time_series` have different units (for example, because they
    /// come from different metric types, or a unit is absent), then `unit` will be
    /// "{not_a_unit}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub unit: std::string::String,
}

impl ListTimeSeriesResponse {
    /// Sets the value of [next_page_token][crate::model::ListTimeSeriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unit][crate::model::ListTimeSeriesResponse::unit].
    pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.unit = v.into();
        self
    }

    /// Sets the value of [time_series][crate::model::ListTimeSeriesResponse::time_series].
    pub fn set_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [execution_errors][crate::model::ListTimeSeriesResponse::execution_errors].
    pub fn set_execution_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.execution_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListTimeSeriesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTimeSeriesResponse {
    type PageItem = crate::model::TimeSeries;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.time_series
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `CreateTimeSeries` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTimeSeriesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new data to be added to a list of time series.
    /// Adds at most one data point to each of several time series.  The new data
    /// point must be more recent than any other point in its time series.  Each
    /// `TimeSeries` value must fully specify a unique time series by supplying
    /// all label values for the metric and the monitored resource.
    ///
    /// The maximum number of `TimeSeries` objects per `Create` request is 200.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series: std::vec::Vec<crate::model::TimeSeries>,
}

impl CreateTimeSeriesRequest {
    /// Sets the value of [name][crate::model::CreateTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [time_series][crate::model::CreateTimeSeriesRequest::time_series].
    pub fn set_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesRequest"
    }
}

/// DEPRECATED. Used to hold per-time-series error status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTimeSeriesError {
    /// DEPRECATED. Time series ID that resulted in the `status` error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_series: std::option::Option<crate::model::TimeSeries>,

    /// DEPRECATED. The status of the requested write operation for `time_series`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,
}

impl CreateTimeSeriesError {
    /// Sets the value of [time_series][crate::model::CreateTimeSeriesError::time_series].
    pub fn set_time_series<T: std::convert::Into<std::option::Option<crate::model::TimeSeries>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_series = v.into();
        self
    }

    /// Sets the value of [status][crate::model::CreateTimeSeriesError::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for CreateTimeSeriesError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesError"
    }
}

/// Summary of the result of a failed request to write data to a time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTimeSeriesSummary {
    /// The number of points in the request.
    pub total_point_count: i32,

    /// The number of points that were successfully written.
    pub success_point_count: i32,

    /// The number of points that failed to be written. Order is not guaranteed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::create_time_series_summary::Error>,
}

impl CreateTimeSeriesSummary {
    /// Sets the value of [total_point_count][crate::model::CreateTimeSeriesSummary::total_point_count].
    pub fn set_total_point_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_point_count = v.into();
        self
    }

    /// Sets the value of [success_point_count][crate::model::CreateTimeSeriesSummary::success_point_count].
    pub fn set_success_point_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.success_point_count = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::CreateTimeSeriesSummary::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::create_time_series_summary::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateTimeSeriesSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesSummary"
    }
}

/// Defines additional types related to CreateTimeSeriesSummary
pub mod create_time_series_summary {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed information about an error category.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Error {
        /// The status of the requested write operation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,

        /// The number of points that couldn't be written because of `status`.
        pub point_count: i32,
    }

    impl Error {
        /// Sets the value of [status][crate::model::create_time_series_summary::Error::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [point_count][crate::model::create_time_series_summary::Error::point_count].
        pub fn set_point_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.point_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Error {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesSummary.Error"
        }
    }
}

/// The `QueryTimeSeries` request. For information about the status of
/// Monitoring Query Language (MQL), see the [MQL deprecation
/// notice](https://cloud.google.com/stackdriver/docs/deprecations/mql).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryTimeSeriesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The query in the [Monitoring Query
    /// Language](https://cloud.google.com/monitoring/mql/reference) format.
    /// The default time zone is in UTC.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// A positive number that is the maximum number of time_series_data to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl QueryTimeSeriesRequest {
    /// Sets the value of [name][crate::model::QueryTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::QueryTimeSeriesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryTimeSeriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryTimeSeriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryTimeSeriesRequest"
    }
}

/// The `QueryTimeSeries` response. For information about the status of
/// Monitoring Query Language (MQL), see the [MQL deprecation
/// notice](https://cloud.google.com/stackdriver/docs/deprecations/mql).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryTimeSeriesResponse {
    /// The descriptor for the time series data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_series_descriptor: std::option::Option<crate::model::TimeSeriesDescriptor>,

    /// The time series data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series_data: std::vec::Vec<crate::model::TimeSeriesData>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results, use that value as
    /// `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Query execution errors that may have caused the time series data returned
    /// to be incomplete. The available data will be available in the
    /// response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,
}

impl QueryTimeSeriesResponse {
    /// Sets the value of [time_series_descriptor][crate::model::QueryTimeSeriesResponse::time_series_descriptor].
    pub fn set_time_series_descriptor<
        T: std::convert::Into<std::option::Option<crate::model::TimeSeriesDescriptor>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_series_descriptor = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::QueryTimeSeriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [time_series_data][crate::model::QueryTimeSeriesResponse::time_series_data].
    pub fn set_time_series_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesData>,
    {
        use std::iter::Iterator;
        self.time_series_data = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_errors][crate::model::QueryTimeSeriesResponse::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryTimeSeriesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for QueryTimeSeriesResponse {
    type PageItem = crate::model::TimeSeriesData;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.time_series_data
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// This is an error detail intended to be used with INVALID_ARGUMENT errors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryErrorList {
    /// Errors in parsing the time series query language text. The number of errors
    /// in the response may be limited.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::QueryError>,

    /// A summary of all the errors.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_summary: std::string::String,
}

impl QueryErrorList {
    /// Sets the value of [error_summary][crate::model::QueryErrorList::error_summary].
    pub fn set_error_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_summary = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::QueryErrorList::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryErrorList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryErrorList"
    }
}

/// Describes a change made to a configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutationRecord {
    /// When the change occurred.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mutate_time: std::option::Option<wkt::Timestamp>,

    /// The email address of the user making the change.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mutated_by: std::string::String,
}

impl MutationRecord {
    /// Sets the value of [mutate_time][crate::model::MutationRecord::mutate_time].
    pub fn set_mutate_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mutate_time = v.into();
        self
    }

    /// Sets the value of [mutated_by][crate::model::MutationRecord::mutated_by].
    pub fn set_mutated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mutated_by = v.into();
        self
    }
}

impl wkt::message::Message for MutationRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.MutationRecord"
    }
}

/// A description of a notification channel. The descriptor includes
/// the properties of the channel and the set of labels or fields that
/// must be specified to configure channels of a given type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotificationChannelDescriptor {
    /// The full REST resource name for this descriptor. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[TYPE]
    /// ```
    ///
    /// In the above, `[TYPE]` is the value of the `type` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The type of notification channel, such as "email" and "sms". To view the
    /// full list of channels, see
    /// [Channel
    /// descriptors](https://cloud.google.com/monitoring/alerts/using-channels-api#ncd).
    /// Notification channel types are globally unique.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// A human-readable name for the notification channel type.  This
    /// form of the name is suitable for a user interface.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// A human-readable description of the notification channel
    /// type. The description may include a description of the properties
    /// of the channel and pointers to external documentation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The set of labels that must be defined to identify a particular
    /// channel of the corresponding type. Each label includes a
    /// description for how that field should be populated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub labels: std::vec::Vec<api::model::LabelDescriptor>,

    /// The tiers that support this notification channel; the project service tier
    /// must be one of the supported_tiers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_tiers: std::vec::Vec<crate::model::ServiceTier>,

    /// The product launch stage for channels of this type.
    pub launch_stage: api::model::LaunchStage,
}

impl NotificationChannelDescriptor {
    /// Sets the value of [name][crate::model::NotificationChannelDescriptor::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::NotificationChannelDescriptor::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotificationChannelDescriptor::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotificationChannelDescriptor::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::NotificationChannelDescriptor::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NotificationChannelDescriptor::labels].
    pub fn set_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::LabelDescriptor>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_tiers][crate::model::NotificationChannelDescriptor::supported_tiers].
    pub fn set_supported_tiers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceTier>,
    {
        use std::iter::Iterator;
        self.supported_tiers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NotificationChannelDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.NotificationChannelDescriptor"
    }
}

/// A `NotificationChannel` is a medium through which an alert is
/// delivered when a policy violation is detected. Examples of channels
/// include email, SMS, and third-party messaging applications. Fields
/// containing sensitive information like authentication tokens or
/// contact info are only partially populated on retrieval.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotificationChannel {
    /// The type of the notification channel. This field matches the
    /// value of the
    /// [NotificationChannelDescriptor.type][google.monitoring.v3.NotificationChannelDescriptor.type]
    /// field.
    ///
    /// [google.monitoring.v3.NotificationChannelDescriptor.type]: crate::model::NotificationChannelDescriptor::type
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Identifier. The full REST resource name for this channel. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    ///
    /// The `[CHANNEL_ID]` is automatically assigned by the server on creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An optional human-readable name for this notification channel. It is
    /// recommended that you specify a non-empty and unique name in order to
    /// make it easier to identify the channels in your project, though this is
    /// not enforced. The display name is limited to 512 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// An optional human-readable description of this notification channel. This
    /// description may provide additional details, beyond the display
    /// name, for the channel. This may not exceed 1024 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Configuration fields that define the channel and its behavior. The
    /// permissible and required labels are specified in the
    /// [NotificationChannelDescriptor.labels][google.monitoring.v3.NotificationChannelDescriptor.labels]
    /// of the `NotificationChannelDescriptor` corresponding to the `type` field.
    ///
    /// [google.monitoring.v3.NotificationChannelDescriptor.labels]: crate::model::NotificationChannelDescriptor::labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User-supplied key/value data that does not need to conform to
    /// the corresponding `NotificationChannelDescriptor`'s schema, unlike
    /// the `labels` field. This field is intended to be used for organizing
    /// and identifying the `NotificationChannel` objects.
    ///
    /// The field can contain up to 64 entries. Each key and value is limited to
    /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
    /// values can contain only lowercase letters, numerals, underscores, and
    /// dashes. Keys must begin with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Indicates whether this channel has been verified or not. On a
    /// [`ListNotificationChannels`][google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
    /// or
    /// [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
    /// operation, this field is expected to be populated.
    ///
    /// If the value is `UNVERIFIED`, then it indicates that the channel is
    /// non-functioning (it both requires verification and lacks verification);
    /// otherwise, it is assumed that the channel works.
    ///
    /// If the channel is neither `VERIFIED` nor `UNVERIFIED`, it implies that
    /// the channel is of a type that does not require verification or that
    /// this specific channel has been exempted from verification because it was
    /// created prior to verification being required for channels of this type.
    ///
    /// This field cannot be modified using a standard
    /// [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
    /// operation. To change the value of this field, you must call
    /// [`VerifyNotificationChannel`][google.monitoring.v3.NotificationChannelService.VerifyNotificationChannel].
    ///
    /// [google.monitoring.v3.NotificationChannelService.GetNotificationChannel]: crate::client::NotificationChannelService::get_notification_channel
    /// [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]: crate::client::NotificationChannelService::list_notification_channels
    /// [google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]: crate::client::NotificationChannelService::update_notification_channel
    /// [google.monitoring.v3.NotificationChannelService.VerifyNotificationChannel]: crate::client::NotificationChannelService::verify_notification_channel
    pub verification_status: crate::model::notification_channel::VerificationStatus,

    /// Whether notifications are forwarded to the described channel. This makes
    /// it possible to disable delivery of notifications to a particular channel
    /// without removing the channel from all alerting policies that reference
    /// the channel. This is a more convenient approach when the change is
    /// temporary and you want to receive notifications from the same set
    /// of alerting policies on the channel at some point in the future.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<wkt::BoolValue>,

    /// Record of the creation of this channel.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub creation_record: std::option::Option<crate::model::MutationRecord>,

    /// Records of the modification of this channel.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mutation_records: std::vec::Vec<crate::model::MutationRecord>,
}

impl NotificationChannel {
    /// Sets the value of [r#type][crate::model::NotificationChannel::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::NotificationChannel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotificationChannel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotificationChannel::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [verification_status][crate::model::NotificationChannel::verification_status].
    pub fn set_verification_status<
        T: std::convert::Into<crate::model::notification_channel::VerificationStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.verification_status = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::NotificationChannel::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [creation_record][crate::model::NotificationChannel::creation_record].
    pub fn set_creation_record<
        T: std::convert::Into<std::option::Option<crate::model::MutationRecord>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.creation_record = v.into();
        self
    }

    /// Sets the value of [mutation_records][crate::model::NotificationChannel::mutation_records].
    pub fn set_mutation_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MutationRecord>,
    {
        use std::iter::Iterator;
        self.mutation_records = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NotificationChannel::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::NotificationChannel::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NotificationChannel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.NotificationChannel"
    }
}

/// Defines additional types related to NotificationChannel
pub mod notification_channel {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether the channel has been verified or not. It is illegal
    /// to specify this field in a
    /// [`CreateNotificationChannel`][google.monitoring.v3.NotificationChannelService.CreateNotificationChannel]
    /// or an
    /// [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
    /// operation.
    ///
    /// [google.monitoring.v3.NotificationChannelService.CreateNotificationChannel]: crate::client::NotificationChannelService::create_notification_channel
    /// [google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]: crate::client::NotificationChannelService::update_notification_channel
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct VerificationStatus(std::borrow::Cow<'static, str>);

    impl VerificationStatus {
        /// Creates a new VerificationStatus instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [VerificationStatus](VerificationStatus)
    pub mod verification_status {
        use super::VerificationStatus;

        /// Sentinel value used to indicate that the state is unknown, omitted, or
        /// is not applicable (as in the case of channels that neither support
        /// nor require verification in order to function).
        pub const VERIFICATION_STATUS_UNSPECIFIED: VerificationStatus =
            VerificationStatus::new("VERIFICATION_STATUS_UNSPECIFIED");

        /// The channel has yet to be verified and requires verification to function.
        /// Note that this state also applies to the case where the verification
        /// process has been initiated by sending a verification code but where
        /// the verification code has not been submitted to complete the process.
        pub const UNVERIFIED: VerificationStatus = VerificationStatus::new("UNVERIFIED");

        /// It has been proven that notifications can be received on this
        /// notification channel and that someone on the project has access
        /// to messages that are delivered to that channel.
        pub const VERIFIED: VerificationStatus = VerificationStatus::new("VERIFIED");
    }

    impl std::convert::From<std::string::String> for VerificationStatus {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// The `ListNotificationChannelDescriptors` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotificationChannelDescriptorsRequest {
    /// Required. The REST resource name of the parent from which to retrieve
    /// the notification channel descriptors. The expected syntax is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// Note that this
    /// [names](https://cloud.google.com/monitoring/api/v3#project_name) the parent
    /// container in which to look for the descriptors; to retrieve a single
    /// descriptor by name, use the
    /// [GetNotificationChannelDescriptor][google.monitoring.v3.NotificationChannelService.GetNotificationChannelDescriptor]
    /// operation, instead.
    ///
    /// [google.monitoring.v3.NotificationChannelService.GetNotificationChannelDescriptor]: crate::client::NotificationChannelService::get_notification_channel_descriptor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The maximum number of results to return in a single response. If
    /// not set to a positive number, a reasonable value will be chosen by the
    /// service.
    pub page_size: i32,

    /// If non-empty, `page_token` must contain a value returned as the
    /// `next_page_token` in a previous response to request the next set
    /// of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListNotificationChannelDescriptorsRequest {
    /// Sets the value of [name][crate::model::ListNotificationChannelDescriptorsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotificationChannelDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotificationChannelDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelDescriptorsRequest"
    }
}

/// The `ListNotificationChannelDescriptors` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotificationChannelDescriptorsResponse {
    /// The monitored resource descriptors supported for the specified
    /// project, optionally filtered.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub channel_descriptors: std::vec::Vec<crate::model::NotificationChannelDescriptor>,

    /// If not empty, indicates that there may be more results that match
    /// the request. Use the value in the `page_token` field in a
    /// subsequent request to fetch the next set of results. If empty,
    /// all results have been returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListNotificationChannelDescriptorsResponse {
    /// Sets the value of [next_page_token][crate::model::ListNotificationChannelDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [channel_descriptors][crate::model::ListNotificationChannelDescriptorsResponse::channel_descriptors].
    pub fn set_channel_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotificationChannelDescriptor>,
    {
        use std::iter::Iterator;
        self.channel_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelDescriptorsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNotificationChannelDescriptorsResponse {
    type PageItem = crate::model::NotificationChannelDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.channel_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `GetNotificationChannelDescriptor` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotificationChannelDescriptorRequest {
    /// Required. The channel type for which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNotificationChannelDescriptorRequest {
    /// Sets the value of [name][crate::model::GetNotificationChannelDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNotificationChannelDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelDescriptorRequest"
    }
}

/// The `CreateNotificationChannel` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotificationChannelRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// This names the container into which the channel will be
    /// written, this does not name the newly created channel. The resulting
    /// channel's name will have a normalized version of this field as a prefix,
    /// but will add `/notificationChannels/[CHANNEL_ID]` to identify the channel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The definition of the `NotificationChannel` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
}

impl CreateNotificationChannelRequest {
    /// Sets the value of [name][crate::model::CreateNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [notification_channel][crate::model::CreateNotificationChannelRequest::notification_channel].
    pub fn set_notification_channel<
        T: std::convert::Into<std::option::Option<crate::model::NotificationChannel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notification_channel = v.into();
        self
    }
}

impl wkt::message::Message for CreateNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateNotificationChannelRequest"
    }
}

/// The `ListNotificationChannels` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotificationChannelsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// This names the container
    /// in which to look for the notification channels; it does not name a
    /// specific channel. To query a specific channel by REST resource name, use
    /// the
    /// [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
    /// operation.
    ///
    /// [google.monitoring.v3.NotificationChannelService.GetNotificationChannel]: crate::client::NotificationChannelService::get_notification_channel
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, this field specifies the criteria that must be met
    /// by notification channels to be included in the response.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. A comma-separated list of fields by which to sort the result.
    /// Supports the same set of fields as in `filter`. Entries can be prefixed
    /// with a minus sign to sort in descending rather than ascending order.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The maximum number of results to return in a single response. If
    /// not set to a positive number, a reasonable value will be chosen by the
    /// service.
    pub page_size: i32,

    /// Optional. If non-empty, `page_token` must contain a value returned as the
    /// `next_page_token` in a previous response to request the next set
    /// of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListNotificationChannelsRequest {
    /// Sets the value of [name][crate::model::ListNotificationChannelsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotificationChannelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotificationChannelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotificationChannelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotificationChannelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelsRequest"
    }
}

/// The `ListNotificationChannels` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotificationChannelsResponse {
    /// The notification channels defined for the specified project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notification_channels: std::vec::Vec<crate::model::NotificationChannel>,

    /// If not empty, indicates that there may be more results that match
    /// the request. Use the value in the `page_token` field in a
    /// subsequent request to fetch the next set of results. If empty,
    /// all results have been returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of notification channels in all pages. This number is only
    /// an estimate, and may change in subsequent pages. <https://aip.dev/158>
    pub total_size: i32,
}

impl ListNotificationChannelsResponse {
    /// Sets the value of [next_page_token][crate::model::ListNotificationChannelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListNotificationChannelsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [notification_channels][crate::model::ListNotificationChannelsResponse::notification_channels].
    pub fn set_notification_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotificationChannel>,
    {
        use std::iter::Iterator;
        self.notification_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNotificationChannelsResponse {
    type PageItem = crate::model::NotificationChannel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notification_channels
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `GetNotificationChannel` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotificationChannelRequest {
    /// Required. The channel for which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNotificationChannelRequest {
    /// Sets the value of [name][crate::model::GetNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelRequest"
    }
}

/// The `UpdateNotificationChannel` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNotificationChannelRequest {
    /// Optional. The fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A description of the changes to be applied to the specified
    /// notification channel. The description must provide a definition for
    /// fields to be updated; the names of these fields should also be
    /// included in the `update_mask`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,
}

impl UpdateNotificationChannelRequest {
    /// Sets the value of [update_mask][crate::model::UpdateNotificationChannelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [notification_channel][crate::model::UpdateNotificationChannelRequest::notification_channel].
    pub fn set_notification_channel<
        T: std::convert::Into<std::option::Option<crate::model::NotificationChannel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notification_channel = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateNotificationChannelRequest"
    }
}

/// The `DeleteNotificationChannel` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNotificationChannelRequest {
    /// Required. The channel for which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If true, the notification channel will be deleted regardless of its
    /// use in alert policies (the policies will be updated to remove the
    /// channel). If false, this operation will fail if the notification channel
    /// is referenced by existing alerting policies.
    pub force: bool,
}

impl DeleteNotificationChannelRequest {
    /// Sets the value of [name][crate::model::DeleteNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteNotificationChannelRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteNotificationChannelRequest"
    }
}

/// The `SendNotificationChannelVerificationCode` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SendNotificationChannelVerificationCodeRequest {
    /// Required. The notification channel to which to send a verification code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl SendNotificationChannelVerificationCodeRequest {
    /// Sets the value of [name][crate::model::SendNotificationChannelVerificationCodeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SendNotificationChannelVerificationCodeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.SendNotificationChannelVerificationCodeRequest"
    }
}

/// The `GetNotificationChannelVerificationCode` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotificationChannelVerificationCodeRequest {
    /// Required. The notification channel for which a verification code is to be
    /// generated and retrieved. This must name a channel that is already verified;
    /// if the specified channel is not verified, the request will fail.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The desired expiration time. If specified, the API will guarantee that
    /// the returned code will not be valid after the specified timestamp;
    /// however, the API cannot guarantee that the returned code will be
    /// valid for at least as long as the requested time (the API puts an upper
    /// bound on the amount of time for which a code may be valid). If omitted,
    /// a default expiration will be used, which may be less than the max
    /// permissible expiration (so specifying an expiration may extend the
    /// code's lifetime over omitting an expiration, even though the API does
    /// impose an upper limit on the maximum expiration that is permitted).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,
}

impl GetNotificationChannelVerificationCodeRequest {
    /// Sets the value of [name][crate::model::GetNotificationChannelVerificationCodeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GetNotificationChannelVerificationCodeRequest::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for GetNotificationChannelVerificationCodeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelVerificationCodeRequest"
    }
}

/// The `GetNotificationChannelVerificationCode` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotificationChannelVerificationCodeResponse {
    /// The verification code, which may be used to verify other channels
    /// that have an equivalent identity (i.e. other channels of the same
    /// type with the same fingerprint such as other email channels with
    /// the same email address or other sms channels with the same number).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    /// The expiration time associated with the code that was returned. If
    /// an expiration was provided in the request, this is the minimum of the
    /// requested expiration in the request and the max permitted expiration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,
}

impl GetNotificationChannelVerificationCodeResponse {
    /// Sets the value of [code][crate::model::GetNotificationChannelVerificationCodeResponse::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GetNotificationChannelVerificationCodeResponse::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for GetNotificationChannelVerificationCodeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelVerificationCodeResponse"
    }
}

/// The `VerifyNotificationChannel` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyNotificationChannelRequest {
    /// Required. The notification channel to verify.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The verification code that was delivered to the channel as
    /// a result of invoking the `SendNotificationChannelVerificationCode` API
    /// method or that was retrieved from a verified channel via
    /// `GetNotificationChannelVerificationCode`. For example, one might have
    /// "G-123456" or "TKNZGhhd2EyN3I1MnRnMjRv" (in general, one is only
    /// guaranteed that the code is valid UTF-8; one should not
    /// make any assumptions regarding the structure or format of the code).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,
}

impl VerifyNotificationChannelRequest {
    /// Sets the value of [name][crate::model::VerifyNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [code][crate::model::VerifyNotificationChannelRequest::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for VerifyNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.VerifyNotificationChannelRequest"
    }
}

/// A `Service` is a discrete, autonomous, and network-accessible unit, designed
/// to solve an individual concern
/// ([Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)). In
/// Cloud Monitoring, a `Service` acts as the root resource under which
/// operational aspects of the service are accessible.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Service {
    /// Identifier. Resource name for this Service. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Name used for UI elements listing this Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Message that contains the service type and service labels of this service
    /// if it is a basic service.
    /// Documentation and examples
    /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub basic_service: std::option::Option<crate::model::service::BasicService>,

    /// Configuration for how to query telemetry on a Service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub telemetry: std::option::Option<crate::model::service::Telemetry>,

    /// Labels which have been used to annotate the service. Label keys must start
    /// with a letter. Label keys and values may contain lowercase letters,
    /// numbers, underscores, and dashes. Label keys and values have a maximum
    /// length of 63 characters, and must be less than 128 bytes in size. Up to 64
    /// label entries may be stored. For labels which do not have a semantic value,
    /// the empty string may be supplied for the label value.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// REQUIRED. Service-identifying atoms specifying the underlying service.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub identifier: std::option::Option<crate::model::service::Identifier>,
}

impl Service {
    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Service::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [basic_service][crate::model::Service::basic_service].
    pub fn set_basic_service<
        T: std::convert::Into<std::option::Option<crate::model::service::BasicService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.basic_service = v.into();
        self
    }

    /// Sets the value of [telemetry][crate::model::Service::telemetry].
    pub fn set_telemetry<
        T: std::convert::Into<std::option::Option<crate::model::service::Telemetry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.telemetry = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::Service::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `identifier`.
    pub fn set_identifier<
        T: std::convert::Into<std::option::Option<crate::model::service::Identifier>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier = v.into();
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `Custom`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_custom(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::Custom>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::Custom(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `AppEngine`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_app_engine(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::AppEngine>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::AppEngine(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `CloudEndpoints`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_endpoints(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::CloudEndpoints>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::CloudEndpoints(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `ClusterIstio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cluster_istio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::ClusterIstio>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::ClusterIstio(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `MeshIstio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_mesh_istio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::MeshIstio>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::MeshIstio(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `IstioCanonicalService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_istio_canonical_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::IstioCanonicalService>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::IstioCanonicalService(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `CloudRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::CloudRun>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::CloudRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `GkeNamespace`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gke_namespace(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::GkeNamespace>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::GkeNamespace(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `GkeWorkload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gke_workload(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::GkeWorkload>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::GkeWorkload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `GkeService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gke_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::GkeService>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::GkeService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `Custom`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_custom<T: std::convert::Into<std::boxed::Box<crate::model::service::Custom>>>(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::Custom(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `AppEngine`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_app_engine<
        T: std::convert::Into<std::boxed::Box<crate::model::service::AppEngine>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::AppEngine(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `CloudEndpoints`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_cloud_endpoints<
        T: std::convert::Into<std::boxed::Box<crate::model::service::CloudEndpoints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::CloudEndpoints(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `ClusterIstio`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_cluster_istio<
        T: std::convert::Into<std::boxed::Box<crate::model::service::ClusterIstio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::ClusterIstio(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `MeshIstio`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_mesh_istio<
        T: std::convert::Into<std::boxed::Box<crate::model::service::MeshIstio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::MeshIstio(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `IstioCanonicalService`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_istio_canonical_service<
        T: std::convert::Into<std::boxed::Box<crate::model::service::IstioCanonicalService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier = std::option::Option::Some(
            crate::model::service::Identifier::IstioCanonicalService(v.into()),
        );
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `CloudRun`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_cloud_run<
        T: std::convert::Into<std::boxed::Box<crate::model::service::CloudRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::CloudRun(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `GkeNamespace`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_gke_namespace<
        T: std::convert::Into<std::boxed::Box<crate::model::service::GkeNamespace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::GkeNamespace(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `GkeWorkload`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_gke_workload<
        T: std::convert::Into<std::boxed::Box<crate::model::service::GkeWorkload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::GkeWorkload(v.into()));
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `GkeService`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_gke_service<
        T: std::convert::Into<std::boxed::Box<crate::model::service::GkeService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::GkeService(v.into()));
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Service"
    }
}

/// Defines additional types related to Service
pub mod service {
    #[allow(unused_imports)]
    use super::*;

    /// Use a custom service to designate a service that you want to monitor
    /// when none of the other service types (like App Engine, Cloud Run, or
    /// a GKE type) matches your intended service.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Custom {}

    impl Custom {}

    impl wkt::message::Message for Custom {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.Custom"
        }
    }

    /// App Engine service. Learn more at <https://cloud.google.com/appengine>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AppEngine {
        /// The ID of the App Engine module underlying this service. Corresponds to
        /// the `module_id` resource label in the [`gae_app` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_gae_app).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub module_id: std::string::String,
    }

    impl AppEngine {
        /// Sets the value of [module_id][crate::model::service::AppEngine::module_id].
        pub fn set_module_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.module_id = v.into();
            self
        }
    }

    impl wkt::message::Message for AppEngine {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.AppEngine"
        }
    }

    /// Cloud Endpoints service. Learn more at <https://cloud.google.com/endpoints>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CloudEndpoints {
        /// The name of the Cloud Endpoints service underlying this service.
        /// Corresponds to the `service` resource label in the [`api` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_api).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service: std::string::String,
    }

    impl CloudEndpoints {
        /// Sets the value of [service][crate::model::service::CloudEndpoints::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudEndpoints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.CloudEndpoints"
        }
    }

    /// Istio service scoped to a single Kubernetes cluster. Learn more at
    /// <https://istio.io>. Clusters running OSS Istio will have their services
    /// ingested as this type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClusterIstio {
        /// The location of the Kubernetes cluster in which this Istio service is
        /// defined. Corresponds to the `location` resource label in `k8s_cluster`
        /// resources.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        /// The name of the Kubernetes cluster in which this Istio service is
        /// defined. Corresponds to the `cluster_name` resource label in
        /// `k8s_cluster` resources.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster_name: std::string::String,

        /// The namespace of the Istio service underlying this service. Corresponds
        /// to the `destination_service_namespace` metric label in Istio metrics.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_namespace: std::string::String,

        /// The name of the Istio service underlying this service. Corresponds to the
        /// `destination_service_name` metric label in Istio metrics.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_name: std::string::String,
    }

    impl ClusterIstio {
        /// Sets the value of [location][crate::model::service::ClusterIstio::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::ClusterIstio::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [service_namespace][crate::model::service::ClusterIstio::service_namespace].
        pub fn set_service_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_namespace = v.into();
            self
        }

        /// Sets the value of [service_name][crate::model::service::ClusterIstio::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }
    }

    impl wkt::message::Message for ClusterIstio {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.ClusterIstio"
        }
    }

    /// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8
    /// will have their services ingested as this type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MeshIstio {
        /// Identifier for the mesh in which this Istio service is defined.
        /// Corresponds to the `mesh_uid` metric label in Istio metrics.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub mesh_uid: std::string::String,

        /// The namespace of the Istio service underlying this service. Corresponds
        /// to the `destination_service_namespace` metric label in Istio metrics.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_namespace: std::string::String,

        /// The name of the Istio service underlying this service. Corresponds to the
        /// `destination_service_name` metric label in Istio metrics.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_name: std::string::String,
    }

    impl MeshIstio {
        /// Sets the value of [mesh_uid][crate::model::service::MeshIstio::mesh_uid].
        pub fn set_mesh_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mesh_uid = v.into();
            self
        }

        /// Sets the value of [service_namespace][crate::model::service::MeshIstio::service_namespace].
        pub fn set_service_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_namespace = v.into();
            self
        }

        /// Sets the value of [service_name][crate::model::service::MeshIstio::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }
    }

    impl wkt::message::Message for MeshIstio {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.MeshIstio"
        }
    }

    /// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >=
    /// 1.6.8 will have their services ingested as this type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IstioCanonicalService {
        /// Identifier for the Istio mesh in which this canonical service is defined.
        /// Corresponds to the `mesh_uid` metric label in
        /// [Istio metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub mesh_uid: std::string::String,

        /// The namespace of the canonical service underlying this service.
        /// Corresponds to the `destination_canonical_service_namespace` metric
        /// label in [Istio
        /// metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub canonical_service_namespace: std::string::String,

        /// The name of the canonical service underlying this service.
        /// Corresponds to the `destination_canonical_service_name` metric label in
        /// label in [Istio
        /// metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub canonical_service: std::string::String,
    }

    impl IstioCanonicalService {
        /// Sets the value of [mesh_uid][crate::model::service::IstioCanonicalService::mesh_uid].
        pub fn set_mesh_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mesh_uid = v.into();
            self
        }

        /// Sets the value of [canonical_service_namespace][crate::model::service::IstioCanonicalService::canonical_service_namespace].
        pub fn set_canonical_service_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.canonical_service_namespace = v.into();
            self
        }

        /// Sets the value of [canonical_service][crate::model::service::IstioCanonicalService::canonical_service].
        pub fn set_canonical_service<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.canonical_service = v.into();
            self
        }
    }

    impl wkt::message::Message for IstioCanonicalService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.IstioCanonicalService"
        }
    }

    /// Cloud Run service. Learn more at <https://cloud.google.com/run>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CloudRun {
        /// The name of the Cloud Run service. Corresponds to the `service_name`
        /// resource label in the [`cloud_run_revision` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_name: std::string::String,

        /// The location the service is run. Corresponds to the `location`
        /// resource label in the [`cloud_run_revision` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,
    }

    impl CloudRun {
        /// Sets the value of [service_name][crate::model::service::CloudRun::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::CloudRun::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudRun {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.CloudRun"
        }
    }

    /// GKE Namespace. The field names correspond to the resource metadata labels
    /// on monitored resources that fall under a namespace (for example,
    /// `k8s_container` or `k8s_pod`).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GkeNamespace {
        /// Output only. The project this resource lives in. For legacy services
        /// migrated from the `Custom` type, this may be a distinct project from the
        /// one parenting the service itself.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,

        /// The location of the parent cluster. This may be a zone or region.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        /// The name of the parent cluster.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster_name: std::string::String,

        /// The name of this namespace.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespace_name: std::string::String,
    }

    impl GkeNamespace {
        /// Sets the value of [project_id][crate::model::service::GkeNamespace::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::GkeNamespace::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::GkeNamespace::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [namespace_name][crate::model::service::GkeNamespace::namespace_name].
        pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespace_name = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNamespace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.GkeNamespace"
        }
    }

    /// A GKE Workload (Deployment, StatefulSet, etc). The field names correspond
    /// to the metadata labels on monitored resources that fall under a workload
    /// (for example, `k8s_container` or `k8s_pod`).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GkeWorkload {
        /// Output only. The project this resource lives in. For legacy services
        /// migrated from the `Custom` type, this may be a distinct project from the
        /// one parenting the service itself.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,

        /// The location of the parent cluster. This may be a zone or region.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        /// The name of the parent cluster.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster_name: std::string::String,

        /// The name of the parent namespace.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespace_name: std::string::String,

        /// The type of this workload (for example, "Deployment" or "DaemonSet")
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub top_level_controller_type: std::string::String,

        /// The name of this workload.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub top_level_controller_name: std::string::String,
    }

    impl GkeWorkload {
        /// Sets the value of [project_id][crate::model::service::GkeWorkload::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::GkeWorkload::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::GkeWorkload::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [namespace_name][crate::model::service::GkeWorkload::namespace_name].
        pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespace_name = v.into();
            self
        }

        /// Sets the value of [top_level_controller_type][crate::model::service::GkeWorkload::top_level_controller_type].
        pub fn set_top_level_controller_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.top_level_controller_type = v.into();
            self
        }

        /// Sets the value of [top_level_controller_name][crate::model::service::GkeWorkload::top_level_controller_name].
        pub fn set_top_level_controller_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.top_level_controller_name = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeWorkload {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.GkeWorkload"
        }
    }

    /// GKE Service. The "service" here represents a
    /// [Kubernetes service
    /// object](https://kubernetes.io/docs/concepts/services-networking/service).
    /// The field names correspond to the resource labels on [`k8s_service`
    /// monitored
    /// resources](https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GkeService {
        /// Output only. The project this resource lives in. For legacy services
        /// migrated from the `Custom` type, this may be a distinct project from the
        /// one parenting the service itself.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,

        /// The location of the parent cluster. This may be a zone or region.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        /// The name of the parent cluster.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster_name: std::string::String,

        /// The name of the parent namespace.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespace_name: std::string::String,

        /// The name of this service.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_name: std::string::String,
    }

    impl GkeService {
        /// Sets the value of [project_id][crate::model::service::GkeService::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::GkeService::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::GkeService::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [namespace_name][crate::model::service::GkeService::namespace_name].
        pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespace_name = v.into();
            self
        }

        /// Sets the value of [service_name][crate::model::service::GkeService::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.GkeService"
        }
    }

    /// A well-known service type, defined by its service type and service labels.
    /// Documentation and examples
    /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BasicService {
        /// The type of service that this basic service defines, e.g.
        /// APP_ENGINE service type.
        /// Documentation and valid values
        /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_type: std::string::String,

        /// Labels that specify the resource that emits the monitoring data which
        /// is used for SLO reporting of this `Service`.
        /// Documentation and valid values for given service types
        /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub service_labels: std::collections::HashMap<std::string::String, std::string::String>,
    }

    impl BasicService {
        /// Sets the value of [service_type][crate::model::service::BasicService::service_type].
        pub fn set_service_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_type = v.into();
            self
        }

        /// Sets the value of [service_labels][crate::model::service::BasicService::service_labels].
        pub fn set_service_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.service_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for BasicService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.BasicService"
        }
    }

    /// Configuration for how to query telemetry on a Service.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Telemetry {
        /// The full name of the resource that defines this service. Formatted as
        /// described in <https://cloud.google.com/apis/design/resource_names>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub resource_name: std::string::String,
    }

    impl Telemetry {
        /// Sets the value of [resource_name][crate::model::service::Telemetry::resource_name].
        pub fn set_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_name = v.into();
            self
        }
    }

    impl wkt::message::Message for Telemetry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.Telemetry"
        }
    }

    /// REQUIRED. Service-identifying atoms specifying the underlying service.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Identifier {
        /// Custom service type.
        Custom(std::boxed::Box<crate::model::service::Custom>),
        /// Type used for App Engine services.
        AppEngine(std::boxed::Box<crate::model::service::AppEngine>),
        /// Type used for Cloud Endpoints services.
        CloudEndpoints(std::boxed::Box<crate::model::service::CloudEndpoints>),
        /// Type used for Istio services that live in a Kubernetes cluster.
        ClusterIstio(std::boxed::Box<crate::model::service::ClusterIstio>),
        /// Type used for Istio services scoped to an Istio mesh.
        MeshIstio(std::boxed::Box<crate::model::service::MeshIstio>),
        /// Type used for canonical services scoped to an Istio mesh.
        /// Metrics for Istio are
        /// [documented here](https://istio.io/latest/docs/reference/config/metrics/)
        IstioCanonicalService(std::boxed::Box<crate::model::service::IstioCanonicalService>),
        /// Type used for Cloud Run services.
        CloudRun(std::boxed::Box<crate::model::service::CloudRun>),
        /// Type used for GKE Namespaces.
        GkeNamespace(std::boxed::Box<crate::model::service::GkeNamespace>),
        /// Type used for GKE Workloads.
        GkeWorkload(std::boxed::Box<crate::model::service::GkeWorkload>),
        /// Type used for GKE Services (the Kubernetes concept of a service).
        GkeService(std::boxed::Box<crate::model::service::GkeService>),
    }
}

/// A Service-Level Objective (SLO) describes a level of desired good service. It
/// consists of a service-level indicator (SLI), a performance goal, and a period
/// over which the objective is to be evaluated against that goal. The SLO can
/// use SLIs defined in a number of different manners. Typical SLOs might include
/// "99% of requests in each rolling week have latency below 200 milliseconds" or
/// "99.5% of requests in each calendar month return successfully."
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceLevelObjective {
    /// Identifier. Resource name for this `ServiceLevelObjective`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Name used for UI elements listing this SLO.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The definition of good service, used to measure and calculate the quality
    /// of the `Service`'s performance with respect to a single aspect of service
    /// quality.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_level_indicator: std::option::Option<crate::model::ServiceLevelIndicator>,

    /// The fraction of service that must be good in order for this objective to be
    /// met. `0 < goal <= 0.9999`.
    pub goal: f64,

    /// Labels which have been used to annotate the service-level objective. Label
    /// keys must start with a letter. Label keys and values may contain lowercase
    /// letters, numbers, underscores, and dashes. Label keys and values have a
    /// maximum length of 63 characters, and must be less than 128 bytes in size.
    /// Up to 64 label entries may be stored. For labels which do not have a
    /// semantic value, the empty string may be supplied for the label value.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The time period over which the objective will be evaluated.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub period: std::option::Option<crate::model::service_level_objective::Period>,
}

impl ServiceLevelObjective {
    /// Sets the value of [name][crate::model::ServiceLevelObjective::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ServiceLevelObjective::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [service_level_indicator][crate::model::ServiceLevelObjective::service_level_indicator].
    pub fn set_service_level_indicator<
        T: std::convert::Into<std::option::Option<crate::model::ServiceLevelIndicator>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_level_indicator = v.into();
        self
    }

    /// Sets the value of [goal][crate::model::ServiceLevelObjective::goal].
    pub fn set_goal<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.goal = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::ServiceLevelObjective::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `period`.
    pub fn set_period<
        T: std::convert::Into<std::option::Option<crate::model::service_level_objective::Period>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.period = v.into();
        self
    }

    /// The value of [period][crate::model::ServiceLevelObjective::period]
    /// if it holds a `RollingPeriod`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_rolling_period(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.period.as_ref().and_then(|v| match v {
            crate::model::service_level_objective::Period::RollingPeriod(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [period][crate::model::ServiceLevelObjective::period]
    /// if it holds a `CalendarPeriod`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_calendar_period(&self) -> std::option::Option<&gtype::model::CalendarPeriod> {
        #[allow(unreachable_patterns)]
        self.period.as_ref().and_then(|v| match v {
            crate::model::service_level_objective::Period::CalendarPeriod(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [period][crate::model::ServiceLevelObjective::period]
    /// to hold a `RollingPeriod`.
    ///
    /// Note that all the setters affecting `period` are
    /// mutually exclusive.
    pub fn set_rolling_period<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.period = std::option::Option::Some(
            crate::model::service_level_objective::Period::RollingPeriod(v.into()),
        );
        self
    }

    /// Sets the value of [period][crate::model::ServiceLevelObjective::period]
    /// to hold a `CalendarPeriod`.
    ///
    /// Note that all the setters affecting `period` are
    /// mutually exclusive.
    pub fn set_calendar_period<T: std::convert::Into<gtype::model::CalendarPeriod>>(
        mut self,
        v: T,
    ) -> Self {
        self.period = std::option::Option::Some(
            crate::model::service_level_objective::Period::CalendarPeriod(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ServiceLevelObjective {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ServiceLevelObjective"
    }
}

/// Defines additional types related to ServiceLevelObjective
pub mod service_level_objective {
    #[allow(unused_imports)]
    use super::*;

    /// `ServiceLevelObjective.View` determines what form of
    /// `ServiceLevelObjective` is returned from `GetServiceLevelObjective`,
    /// `ListServiceLevelObjectives`, and `ListServiceLevelObjectiveVersions` RPCs.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct View(std::borrow::Cow<'static, str>);

    impl View {
        /// Creates a new View instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [View](View)
    pub mod view {
        use super::View;

        /// Same as FULL.
        pub const VIEW_UNSPECIFIED: View = View::new("VIEW_UNSPECIFIED");

        /// Return the embedded `ServiceLevelIndicator` in the form in which it was
        /// defined. If it was defined using a `BasicSli`, return that `BasicSli`.
        pub const FULL: View = View::new("FULL");

        /// For `ServiceLevelIndicator`s using `BasicSli` articulation, instead
        /// return the `ServiceLevelIndicator` with its mode of computation fully
        /// spelled out as a `RequestBasedSli`. For `ServiceLevelIndicator`s using
        /// `RequestBasedSli` or `WindowsBasedSli`, return the
        /// `ServiceLevelIndicator` as it was provided.
        pub const EXPLICIT: View = View::new("EXPLICIT");
    }

    impl std::convert::From<std::string::String> for View {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The time period over which the objective will be evaluated.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Period {
        /// A rolling time period, semantically "in the past `<rolling_period>`".
        /// Must be an integer multiple of 1 day no larger than 30 days.
        RollingPeriod(std::boxed::Box<wkt::Duration>),
        /// A calendar period, semantically "since the start of the current
        /// `<calendar_period>`". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and
        /// `MONTH` are supported.
        CalendarPeriod(gtype::model::CalendarPeriod),
    }
}

/// A Service-Level Indicator (SLI) describes the "performance" of a service. For
/// some services, the SLI is well-defined. In such cases, the SLI can be
/// described easily by referencing the well-known SLI and providing the needed
/// parameters. Alternatively, a "custom" SLI can be defined with a query to the
/// underlying metric store. An SLI is defined to be `good_service /
/// total_service` over any queried time interval. The value of performance
/// always falls into the range `0 <= performance <= 1`. A custom SLI describes
/// how to compute this ratio, whether this is by dividing values from a pair of
/// time series, cutting a `Distribution` into good and bad counts, or counting
/// time windows in which the service complies with a criterion. For separation
/// of concerns, a single Service-Level Indicator measures performance for only
/// one aspect of service quality, such as fraction of successful queries or
/// fast-enough queries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceLevelIndicator {
    /// Service level indicators can be grouped by whether the "unit" of service
    /// being measured is based on counts of good requests or on counts of good
    /// time windows
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::service_level_indicator::Type>,
}

impl ServiceLevelIndicator {
    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::service_level_indicator::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// if it holds a `BasicSli`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_basic_sli(&self) -> std::option::Option<&std::boxed::Box<crate::model::BasicSli>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::service_level_indicator::Type::BasicSli(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// if it holds a `RequestBased`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_request_based(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RequestBasedSli>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::service_level_indicator::Type::RequestBased(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// if it holds a `WindowsBased`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_windows_based(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WindowsBasedSli>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::service_level_indicator::Type::WindowsBased(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// to hold a `BasicSli`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_basic_sli<T: std::convert::Into<std::boxed::Box<crate::model::BasicSli>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::service_level_indicator::Type::BasicSli(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// to hold a `RequestBased`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_request_based<
        T: std::convert::Into<std::boxed::Box<crate::model::RequestBasedSli>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::service_level_indicator::Type::RequestBased(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// to hold a `WindowsBased`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_windows_based<
        T: std::convert::Into<std::boxed::Box<crate::model::WindowsBasedSli>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::service_level_indicator::Type::WindowsBased(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ServiceLevelIndicator {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ServiceLevelIndicator"
    }
}

/// Defines additional types related to ServiceLevelIndicator
pub mod service_level_indicator {
    #[allow(unused_imports)]
    use super::*;

    /// Service level indicators can be grouped by whether the "unit" of service
    /// being measured is based on counts of good requests or on counts of good
    /// time windows
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Basic SLI on a well-known service type.
        BasicSli(std::boxed::Box<crate::model::BasicSli>),
        /// Request-based SLIs
        RequestBased(std::boxed::Box<crate::model::RequestBasedSli>),
        /// Windows-based SLIs
        WindowsBased(std::boxed::Box<crate::model::WindowsBasedSli>),
    }
}

/// An SLI measuring performance on a well-known service type. Performance will
/// be computed on the basis of pre-defined metrics. The type of the
/// `service_resource` determines the metrics to use and the
/// `service_resource.labels` and `metric_labels` are used to construct a
/// monitoring filter to filter that metric down to just the data relevant to
/// this service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BasicSli {
    /// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from
    /// other methods will not be used to calculate performance for this SLI. If
    /// omitted, this SLI applies to all the Service's methods. For service types
    /// that don't support breaking down by method, setting this field will result
    /// in an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub method: std::vec::Vec<std::string::String>,

    /// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry
    /// from other locations will not be used to calculate performance for this
    /// SLI. If omitted, this SLI applies to all locations in which the Service has
    /// activity. For service types that don't support breaking down by location,
    /// setting this field will result in an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub location: std::vec::Vec<std::string::String>,

    /// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry
    /// from other API versions will not be used to calculate performance for this
    /// SLI. If omitted, this SLI applies to all API versions. For service types
    /// that don't support breaking down by version, setting this field will result
    /// in an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version: std::vec::Vec<std::string::String>,

    /// This SLI can be evaluated on the basis of availability or latency.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sli_criteria: std::option::Option<crate::model::basic_sli::SliCriteria>,
}

impl BasicSli {
    /// Sets the value of [method][crate::model::BasicSli::method].
    pub fn set_method<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.method = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location][crate::model::BasicSli::location].
    pub fn set_location<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.location = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version][crate::model::BasicSli::version].
    pub fn set_version<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `sli_criteria`.
    pub fn set_sli_criteria<
        T: std::convert::Into<std::option::Option<crate::model::basic_sli::SliCriteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sli_criteria = v.into();
        self
    }

    /// The value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// if it holds a `Availability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_availability(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::basic_sli::AvailabilityCriteria>> {
        #[allow(unreachable_patterns)]
        self.sli_criteria.as_ref().and_then(|v| match v {
            crate::model::basic_sli::SliCriteria::Availability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// if it holds a `Latency`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_latency(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::basic_sli::LatencyCriteria>> {
        #[allow(unreachable_patterns)]
        self.sli_criteria.as_ref().and_then(|v| match v {
            crate::model::basic_sli::SliCriteria::Latency(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// to hold a `Availability`.
    ///
    /// Note that all the setters affecting `sli_criteria` are
    /// mutually exclusive.
    pub fn set_availability<
        T: std::convert::Into<std::boxed::Box<crate::model::basic_sli::AvailabilityCriteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sli_criteria =
            std::option::Option::Some(crate::model::basic_sli::SliCriteria::Availability(v.into()));
        self
    }

    /// Sets the value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// to hold a `Latency`.
    ///
    /// Note that all the setters affecting `sli_criteria` are
    /// mutually exclusive.
    pub fn set_latency<
        T: std::convert::Into<std::boxed::Box<crate::model::basic_sli::LatencyCriteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sli_criteria =
            std::option::Option::Some(crate::model::basic_sli::SliCriteria::Latency(v.into()));
        self
    }
}

impl wkt::message::Message for BasicSli {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.BasicSli"
    }
}

/// Defines additional types related to BasicSli
pub mod basic_sli {
    #[allow(unused_imports)]
    use super::*;

    /// Future parameters for the availability SLI.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AvailabilityCriteria {}

    impl AvailabilityCriteria {}

    impl wkt::message::Message for AvailabilityCriteria {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.BasicSli.AvailabilityCriteria"
        }
    }

    /// Parameters for a latency threshold SLI.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LatencyCriteria {
        /// Good service is defined to be the count of requests made to this service
        /// that return in no more than `threshold`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threshold: std::option::Option<wkt::Duration>,
    }

    impl LatencyCriteria {
        /// Sets the value of [threshold][crate::model::basic_sli::LatencyCriteria::threshold].
        pub fn set_threshold<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.threshold = v.into();
            self
        }
    }

    impl wkt::message::Message for LatencyCriteria {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.BasicSli.LatencyCriteria"
        }
    }

    /// This SLI can be evaluated on the basis of availability or latency.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SliCriteria {
        /// Good service is defined to be the count of requests made to this service
        /// that return successfully.
        Availability(std::boxed::Box<crate::model::basic_sli::AvailabilityCriteria>),
        /// Good service is defined to be the count of requests made to this service
        /// that are fast enough with respect to `latency.threshold`.
        Latency(std::boxed::Box<crate::model::basic_sli::LatencyCriteria>),
    }
}

/// Range of numerical values within `min` and `max`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Range {
    /// Range minimum.
    pub min: f64,

    /// Range maximum.
    pub max: f64,
}

impl Range {
    /// Sets the value of [min][crate::model::Range::min].
    pub fn set_min<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min = v.into();
        self
    }

    /// Sets the value of [max][crate::model::Range::max].
    pub fn set_max<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max = v.into();
        self
    }
}

impl wkt::message::Message for Range {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Range"
    }
}

/// Service Level Indicators for which atomic units of service are counted
/// directly.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RequestBasedSli {
    /// The means to compute a ratio of `good_service` to `total_service`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method: std::option::Option<crate::model::request_based_sli::Method>,
}

impl RequestBasedSli {
    /// Sets the value of `method`.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::request_based_sli::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::RequestBasedSli::method]
    /// if it holds a `GoodTotalRatio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_good_total_ratio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesRatio>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::request_based_sli::Method::GoodTotalRatio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::RequestBasedSli::method]
    /// if it holds a `DistributionCut`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_distribution_cut(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DistributionCut>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::request_based_sli::Method::DistributionCut(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::RequestBasedSli::method]
    /// to hold a `GoodTotalRatio`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_good_total_ratio<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesRatio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::request_based_sli::Method::GoodTotalRatio(v.into()),
        );
        self
    }

    /// Sets the value of [method][crate::model::RequestBasedSli::method]
    /// to hold a `DistributionCut`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_distribution_cut<
        T: std::convert::Into<std::boxed::Box<crate::model::DistributionCut>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::request_based_sli::Method::DistributionCut(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RequestBasedSli {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.RequestBasedSli"
    }
}

/// Defines additional types related to RequestBasedSli
pub mod request_based_sli {
    #[allow(unused_imports)]
    use super::*;

    /// The means to compute a ratio of `good_service` to `total_service`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Method {
        /// `good_total_ratio` is used when the ratio of `good_service` to
        /// `total_service` is computed from two `TimeSeries`.
        GoodTotalRatio(std::boxed::Box<crate::model::TimeSeriesRatio>),
        /// `distribution_cut` is used when `good_service` is a count of values
        /// aggregated in a `Distribution` that fall into a good range. The
        /// `total_service` is the total count of all values aggregated in the
        /// `Distribution`.
        DistributionCut(std::boxed::Box<crate::model::DistributionCut>),
    }
}

/// A `TimeSeriesRatio` specifies two `TimeSeries` to use for computing the
/// `good_service / total_service` ratio. The specified `TimeSeries` must have
/// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
/// DELTA` or `MetricKind = CUMULATIVE`. The `TimeSeriesRatio` must specify
/// exactly two of good, bad, and total, and the relationship `good_service +
/// bad_service = total_service` will be assumed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesRatio {
    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` quantifying good service provided. Must have
    /// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
    /// DELTA` or `MetricKind = CUMULATIVE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub good_service_filter: std::string::String,

    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` quantifying bad service, either demanded service
    /// that was not provided or demanded service that was of inadequate quality.
    /// Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have
    /// `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bad_service_filter: std::string::String,

    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` quantifying total demanded service. Must have
    /// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
    /// DELTA` or `MetricKind = CUMULATIVE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub total_service_filter: std::string::String,
}

impl TimeSeriesRatio {
    /// Sets the value of [good_service_filter][crate::model::TimeSeriesRatio::good_service_filter].
    pub fn set_good_service_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.good_service_filter = v.into();
        self
    }

    /// Sets the value of [bad_service_filter][crate::model::TimeSeriesRatio::bad_service_filter].
    pub fn set_bad_service_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bad_service_filter = v.into();
        self
    }

    /// Sets the value of [total_service_filter][crate::model::TimeSeriesRatio::total_service_filter].
    pub fn set_total_service_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_service_filter = v.into();
        self
    }
}

impl wkt::message::Message for TimeSeriesRatio {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeriesRatio"
    }
}

/// A `DistributionCut` defines a `TimeSeries` and thresholds used for measuring
/// good service and total service. The `TimeSeries` must have `ValueType =
/// DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`. The
/// computed `good_service` will be the estimated count of values in the
/// `Distribution` that fall within the specified `min` and `max`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DistributionCut {
    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` aggregating values. Must have `ValueType =
    /// DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub distribution_filter: std::string::String,

    /// Range of values considered "good." For a one-sided range, set one bound to
    /// an infinite value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range: std::option::Option<crate::model::Range>,
}

impl DistributionCut {
    /// Sets the value of [distribution_filter][crate::model::DistributionCut::distribution_filter].
    pub fn set_distribution_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.distribution_filter = v.into();
        self
    }

    /// Sets the value of [range][crate::model::DistributionCut::range].
    pub fn set_range<T: std::convert::Into<std::option::Option<crate::model::Range>>>(
        mut self,
        v: T,
    ) -> Self {
        self.range = v.into();
        self
    }
}

impl wkt::message::Message for DistributionCut {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DistributionCut"
    }
}

/// A `WindowsBasedSli` defines `good_service` as the count of time windows for
/// which the provided service was of good quality. Criteria for determining
/// if service was good are embedded in the `window_criterion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WindowsBasedSli {
    /// Duration over which window quality is evaluated. Must be an integer
    /// fraction of a day and at least `60s`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window_period: std::option::Option<wkt::Duration>,

    /// The criterion to use for evaluating window goodness.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub window_criterion: std::option::Option<crate::model::windows_based_sli::WindowCriterion>,
}

impl WindowsBasedSli {
    /// Sets the value of [window_period][crate::model::WindowsBasedSli::window_period].
    pub fn set_window_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.window_period = v.into();
        self
    }

    /// Sets the value of `window_criterion`.
    pub fn set_window_criterion<
        T: std::convert::Into<std::option::Option<crate::model::windows_based_sli::WindowCriterion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = v.into();
        self
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `GoodBadMetricFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_good_bad_metric_filter(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::GoodBadMetricFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `GoodTotalRatioThreshold`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_good_total_ratio_threshold(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::windows_based_sli::PerformanceThreshold>>
    {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::GoodTotalRatioThreshold(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `MetricMeanInRange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_metric_mean_in_range(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::windows_based_sli::MetricRange>> {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::MetricMeanInRange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `MetricSumInRange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_metric_sum_in_range(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::windows_based_sli::MetricRange>> {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::MetricSumInRange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `GoodBadMetricFilter`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_good_bad_metric_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::GoodBadMetricFilter(v.into()),
        );
        self
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `GoodTotalRatioThreshold`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_good_total_ratio_threshold<
        T: std::convert::Into<std::boxed::Box<crate::model::windows_based_sli::PerformanceThreshold>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::GoodTotalRatioThreshold(v.into()),
        );
        self
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `MetricMeanInRange`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_metric_mean_in_range<
        T: std::convert::Into<std::boxed::Box<crate::model::windows_based_sli::MetricRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::MetricMeanInRange(v.into()),
        );
        self
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `MetricSumInRange`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_metric_sum_in_range<
        T: std::convert::Into<std::boxed::Box<crate::model::windows_based_sli::MetricRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::MetricSumInRange(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WindowsBasedSli {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.WindowsBasedSli"
    }
}

/// Defines additional types related to WindowsBasedSli
pub mod windows_based_sli {
    #[allow(unused_imports)]
    use super::*;

    /// A `PerformanceThreshold` is used when each window is good when that window
    /// has a sufficiently high `performance`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerformanceThreshold {
        /// If window `performance >= threshold`, the window is counted as good.
        pub threshold: f64,

        /// The means, either a request-based SLI or a basic SLI, by which to compute
        /// performance over a window.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub r#type:
            std::option::Option<crate::model::windows_based_sli::performance_threshold::Type>,
    }

    impl PerformanceThreshold {
        /// Sets the value of [threshold][crate::model::windows_based_sli::PerformanceThreshold::threshold].
        pub fn set_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.threshold = v.into();
            self
        }

        /// Sets the value of `r#type`.
        pub fn set_type<
            T: std::convert::Into<
                std::option::Option<crate::model::windows_based_sli::performance_threshold::Type>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// if it holds a `Performance`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_performance(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::RequestBasedSli>> {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::windows_based_sli::performance_threshold::Type::Performance(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// if it holds a `BasicSliPerformance`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_basic_sli_performance(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BasicSli>> {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::windows_based_sli::performance_threshold::Type::BasicSliPerformance(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// to hold a `Performance`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_performance<
            T: std::convert::Into<std::boxed::Box<crate::model::RequestBasedSli>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::windows_based_sli::performance_threshold::Type::Performance(v.into()),
            );
            self
        }

        /// Sets the value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// to hold a `BasicSliPerformance`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_basic_sli_performance<
            T: std::convert::Into<std::boxed::Box<crate::model::BasicSli>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::windows_based_sli::performance_threshold::Type::BasicSliPerformance(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for PerformanceThreshold {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.WindowsBasedSli.PerformanceThreshold"
        }
    }

    /// Defines additional types related to PerformanceThreshold
    pub mod performance_threshold {
        #[allow(unused_imports)]
        use super::*;

        /// The means, either a request-based SLI or a basic SLI, by which to compute
        /// performance over a window.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Type {
            /// `RequestBasedSli` to evaluate to judge window quality.
            Performance(std::boxed::Box<crate::model::RequestBasedSli>),
            /// `BasicSli` to evaluate to judge window quality.
            BasicSliPerformance(std::boxed::Box<crate::model::BasicSli>),
        }
    }

    /// A `MetricRange` is used when each window is good when the value x of a
    /// single `TimeSeries` satisfies `range.min <= x <= range.max`. The provided
    /// `TimeSeries` must have `ValueType = INT64` or `ValueType = DOUBLE` and
    /// `MetricKind = GAUGE`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MetricRange {
        /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        /// specifying the `TimeSeries` to use for evaluating window quality.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub time_series: std::string::String,

        /// Range of values considered "good." For a one-sided range, set one bound
        /// to an infinite value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub range: std::option::Option<crate::model::Range>,
    }

    impl MetricRange {
        /// Sets the value of [time_series][crate::model::windows_based_sli::MetricRange::time_series].
        pub fn set_time_series<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.time_series = v.into();
            self
        }

        /// Sets the value of [range][crate::model::windows_based_sli::MetricRange::range].
        pub fn set_range<T: std::convert::Into<std::option::Option<crate::model::Range>>>(
            mut self,
            v: T,
        ) -> Self {
            self.range = v.into();
            self
        }
    }

    impl wkt::message::Message for MetricRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.WindowsBasedSli.MetricRange"
        }
    }

    /// The criterion to use for evaluating window goodness.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum WindowCriterion {
        /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        /// specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if
        /// any `true` values appear in the window.
        GoodBadMetricFilter(std::string::String),
        /// A window is good if its `performance` is high enough.
        GoodTotalRatioThreshold(
            std::boxed::Box<crate::model::windows_based_sli::PerformanceThreshold>,
        ),
        /// A window is good if the metric's value is in a good range, averaged
        /// across returned streams.
        MetricMeanInRange(std::boxed::Box<crate::model::windows_based_sli::MetricRange>),
        /// A window is good if the metric's value is in a good range, summed across
        /// returned streams.
        MetricSumInRange(std::boxed::Box<crate::model::windows_based_sli::MetricRange>),
    }
}

/// The `CreateService` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateServiceRequest {
    /// Required. Resource
    /// [name](https://cloud.google.com/monitoring/api/v3#project_name) of the
    /// parent Metrics Scope. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The Service id to use for this Service. If omitted, an id will be
    /// generated instead. Must match the pattern `[a-z0-9\-]+`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_id: std::string::String,

    /// Required. The `Service` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,
}

impl CreateServiceRequest {
    /// Sets the value of [parent][crate::model::CreateServiceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service_id][crate::model::CreateServiceRequest::service_id].
    pub fn set_service_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_id = v.into();
        self
    }

    /// Sets the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<crate::model::Service>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for CreateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateServiceRequest"
    }
}

/// The `GetService` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Required. Resource name of the `Service`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetServiceRequest {
    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetServiceRequest"
    }
}

/// The `ListServices` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Required. Resource name of the parent containing the listed services,
    /// either a [project](https://cloud.google.com/monitoring/api/v3#project_name)
    /// or a Monitoring Metrics Scope. The formats are:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// workspaces/[HOST_PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A filter specifying what `Service`s to return. The filter supports
    /// filtering on a particular service-identifier type or one of its attributes.
    ///
    /// To filter on a particular service-identifier type, the `identifier_case`
    /// refers to which option in the `identifier` field is populated. For example,
    /// the filter `identifier_case = "CUSTOM"` would match all services with a
    /// value for the `custom` field. Valid options include "CUSTOM", "APP_ENGINE",
    /// "MESH_ISTIO", and the other options listed at
    /// <https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#Service>
    ///
    /// To filter on an attribute of a service-identifier type, apply the filter
    /// name by using the snake case of the service-identifier type and the
    /// attribute of that service-identifier type, and join the two with a period.
    /// For example, to filter by the `meshUid` field of the `MeshIstio`
    /// service-identifier type, you must filter on `mesh_istio.mesh_uid =
    /// "123"` to match all services with mesh UID "123". Service-identifier types
    /// and their attributes are described at
    /// <https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#Service>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A non-negative number that is the maximum number of results to return.
    /// When 0, use default page size.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListServicesRequest {
    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServicesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServicesRequest"
    }
}

/// The `ListServices` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The `Service`s matching the specified filter.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services: std::vec::Vec<crate::model::Service>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListServicesResponse {
    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServicesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `UpdateService` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Required. The `Service` to draw updates from.
    /// The given `name` specifies the resource to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    /// A set of field paths defining which fields to use for the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateServiceRequest {
    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<crate::model::Service>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateServiceRequest"
    }
}

/// The `DeleteService` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Required. Resource name of the `Service` to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteServiceRequest {
    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteServiceRequest"
    }
}

/// The `CreateServiceLevelObjective` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateServiceLevelObjectiveRequest {
    /// Required. Resource name of the parent `Service`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The ServiceLevelObjective id to use for this
    /// ServiceLevelObjective. If omitted, an id will be generated instead. Must
    /// match the pattern `^[a-zA-Z0-9-_:.]+$`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_level_objective_id: std::string::String,

    /// Required. The `ServiceLevelObjective` to create.
    /// The provided `name` will be respected if no `ServiceLevelObjective` exists
    /// with this name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_level_objective: std::option::Option<crate::model::ServiceLevelObjective>,
}

impl CreateServiceLevelObjectiveRequest {
    /// Sets the value of [parent][crate::model::CreateServiceLevelObjectiveRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service_level_objective_id][crate::model::CreateServiceLevelObjectiveRequest::service_level_objective_id].
    pub fn set_service_level_objective_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_level_objective_id = v.into();
        self
    }

    /// Sets the value of [service_level_objective][crate::model::CreateServiceLevelObjectiveRequest::service_level_objective].
    pub fn set_service_level_objective<
        T: std::convert::Into<std::option::Option<crate::model::ServiceLevelObjective>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_level_objective = v.into();
        self
    }
}

impl wkt::message::Message for CreateServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateServiceLevelObjectiveRequest"
    }
}

/// The `GetServiceLevelObjective` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceLevelObjectiveRequest {
    /// Required. Resource name of the `ServiceLevelObjective` to get. The format
    /// is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// View of the `ServiceLevelObjective` to return. If `DEFAULT`, return the
    /// `ServiceLevelObjective` as originally defined. If `EXPLICIT` and the
    /// `ServiceLevelObjective` is defined in terms of a `BasicSli`, replace the
    /// `BasicSli` with a `RequestBasedSli` spelling out how the SLI is computed.
    pub view: crate::model::service_level_objective::View,
}

impl GetServiceLevelObjectiveRequest {
    /// Sets the value of [name][crate::model::GetServiceLevelObjectiveRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetServiceLevelObjectiveRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::service_level_objective::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetServiceLevelObjectiveRequest"
    }
}

/// The `ListServiceLevelObjectives` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServiceLevelObjectivesRequest {
    /// Required. Resource name of the parent containing the listed SLOs, either a
    /// project or a Monitoring Metrics Scope. The formats are:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A filter specifying what `ServiceLevelObjective`s to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A non-negative number that is the maximum number of results to return.
    /// When 0, use default page size.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// View of the `ServiceLevelObjective`s to return. If `DEFAULT`, return each
    /// `ServiceLevelObjective` as originally defined. If `EXPLICIT` and the
    /// `ServiceLevelObjective` is defined in terms of a `BasicSli`, replace the
    /// `BasicSli` with a `RequestBasedSli` spelling out how the SLI is computed.
    pub view: crate::model::service_level_objective::View,
}

impl ListServiceLevelObjectivesRequest {
    /// Sets the value of [parent][crate::model::ListServiceLevelObjectivesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServiceLevelObjectivesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServiceLevelObjectivesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServiceLevelObjectivesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListServiceLevelObjectivesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::service_level_objective::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceLevelObjectivesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServiceLevelObjectivesRequest"
    }
}

/// The `ListServiceLevelObjectives` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServiceLevelObjectivesResponse {
    /// The `ServiceLevelObjective`s matching the specified filter.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_level_objectives: std::vec::Vec<crate::model::ServiceLevelObjective>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListServiceLevelObjectivesResponse {
    /// Sets the value of [next_page_token][crate::model::ListServiceLevelObjectivesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [service_level_objectives][crate::model::ListServiceLevelObjectivesResponse::service_level_objectives].
    pub fn set_service_level_objectives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceLevelObjective>,
    {
        use std::iter::Iterator;
        self.service_level_objectives = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListServiceLevelObjectivesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServiceLevelObjectivesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListServiceLevelObjectivesResponse {
    type PageItem = crate::model::ServiceLevelObjective;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.service_level_objectives
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `UpdateServiceLevelObjective` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceLevelObjectiveRequest {
    /// Required. The `ServiceLevelObjective` to draw updates from.
    /// The given `name` specifies the resource to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_level_objective: std::option::Option<crate::model::ServiceLevelObjective>,

    /// A set of field paths defining which fields to use for the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateServiceLevelObjectiveRequest {
    /// Sets the value of [service_level_objective][crate::model::UpdateServiceLevelObjectiveRequest::service_level_objective].
    pub fn set_service_level_objective<
        T: std::convert::Into<std::option::Option<crate::model::ServiceLevelObjective>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_level_objective = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceLevelObjectiveRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateServiceLevelObjectiveRequest"
    }
}

/// The `DeleteServiceLevelObjective` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteServiceLevelObjectiveRequest {
    /// Required. Resource name of the `ServiceLevelObjective` to delete. The
    /// format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteServiceLevelObjectiveRequest {
    /// Sets the value of [name][crate::model::DeleteServiceLevelObjectiveRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteServiceLevelObjectiveRequest"
    }
}

/// A `Snooze` will prevent any alerts from being opened, and close any that
/// are already open. The `Snooze` will work on alerts that match the
/// criteria defined in the `Snooze`. The `Snooze` will be active from
/// `interval.start_time` through `interval.end_time`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Snooze {
    /// Required. Identifier. The name of the `Snooze`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
    /// ```
    ///
    /// The ID of the `Snooze` will be generated by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. This defines the criteria for applying the `Snooze`. See
    /// `Criteria` for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub criteria: std::option::Option<crate::model::snooze::Criteria>,

    /// Required. The `Snooze` will be active from `interval.start_time` through
    /// `interval.end_time`.
    /// `interval.start_time` cannot be in the past. There is a 15 second clock
    /// skew to account for the time it takes for a request to reach the API from
    /// the UI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// Required. A display name for the `Snooze`. This can be, at most, 512
    /// unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,
}

impl Snooze {
    /// Sets the value of [name][crate::model::Snooze::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [criteria][crate::model::Snooze::criteria].
    pub fn set_criteria<
        T: std::convert::Into<std::option::Option<crate::model::snooze::Criteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.criteria = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::Snooze::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<crate::model::TimeInterval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Snooze::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Snooze {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Snooze"
    }
}

/// Defines additional types related to Snooze
pub mod snooze {
    #[allow(unused_imports)]
    use super::*;

    /// Criteria specific to the `AlertPolicy`s that this `Snooze` applies to. The
    /// `Snooze` will suppress alerts that come from one of the `AlertPolicy`s
    /// whose names are supplied.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Criteria {
        /// The specific `AlertPolicy` names for the alert that should be snoozed.
        /// The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]
        /// ```
        ///
        /// There is a limit of 16 policies per snooze. This limit is checked during
        /// snooze creation.
        /// Exactly 1 alert policy is required if `filter` is specified at the same
        /// time.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub policies: std::vec::Vec<std::string::String>,

        /// Optional. The filter string to match on Alert fields when silencing the
        /// alerts. It follows the standard <https://google.aip.dev/160> syntax.
        /// A filter string used to apply the snooze to specific incidents
        /// that have matching filter values.
        /// Filters can be defined for snoozes that apply to one alerting
        /// policy.
        /// Filters must be a string formatted as one or more resource labels with
        /// specific label values. If multiple resource labels are used, then they
        /// must be connected with an AND operator. For example, the following filter
        /// applies the snooze to incidents that have an instance ID of
        /// `1234567890` and a zone of `us-central1-a`:
        ///
        /// ```norust
        /// resource.labels.instance_id="1234567890" AND
        /// resource.labels.zone="us-central1-a"
        /// ```
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,
    }

    impl Criteria {
        /// Sets the value of [filter][crate::model::snooze::Criteria::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }

        /// Sets the value of [policies][crate::model::snooze::Criteria::policies].
        pub fn set_policies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.policies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Criteria {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Snooze.Criteria"
        }
    }
}

/// The message definition for creating a `Snooze`. Users must provide the body
/// of the `Snooze` to be created but must omit the `Snooze` field, `name`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSnoozeRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// a `Snooze` should be created. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The `Snooze` to create. Omit the `name` field, as it will be
    /// filled in by the API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snooze: std::option::Option<crate::model::Snooze>,
}

impl CreateSnoozeRequest {
    /// Sets the value of [parent][crate::model::CreateSnoozeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [snooze][crate::model::CreateSnoozeRequest::snooze].
    pub fn set_snooze<T: std::convert::Into<std::option::Option<crate::model::Snooze>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snooze = v.into();
        self
    }
}

impl wkt::message::Message for CreateSnoozeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateSnoozeRequest"
    }
}

/// The message definition for listing `Snooze`s associated with the given
/// `parent`, satisfying the optional `filter`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnoozesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// `Snooze`s should be listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Optional filter to restrict results to the given criteria. The
    /// following fields are supported.
    ///
    /// * `interval.start_time`
    /// * `interval.end_time`
    ///
    /// For example:
    ///
    /// ```norust
    /// interval.start_time > "2022-03-11T00:00:00-08:00" AND
    ///     interval.end_time < "2022-03-12T00:00:00-08:00"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The maximum number of results to return for a single query. The
    /// server may further constrain the maximum number of results returned in a
    /// single page. The value should be in the range [1, 1000]. If the value given
    /// is outside this range, the server will decide the number of results to be
    /// returned.
    pub page_size: i32,

    /// Optional. The `next_page_token` from a previous call to
    /// `ListSnoozesRequest` to get the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListSnoozesRequest {
    /// Sets the value of [parent][crate::model::ListSnoozesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSnoozesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnoozesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnoozesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnoozesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListSnoozesRequest"
    }
}

/// The results of a successful `ListSnoozes` call, containing the matching
/// `Snooze`s.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnoozesResponse {
    /// `Snooze`s matching this list call.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub snoozes: std::vec::Vec<crate::model::Snooze>,

    /// Page token for repeated calls to `ListSnoozes`, to fetch additional pages
    /// of results. If this is empty or missing, there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSnoozesResponse {
    /// Sets the value of [next_page_token][crate::model::ListSnoozesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [snoozes][crate::model::ListSnoozesResponse::snoozes].
    pub fn set_snoozes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snooze>,
    {
        use std::iter::Iterator;
        self.snoozes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSnoozesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListSnoozesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListSnoozesResponse {
    type PageItem = crate::model::Snooze;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snoozes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The message definition for retrieving a `Snooze`. Users must specify the
/// field, `name`, which identifies the `Snooze`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSnoozeRequest {
    /// Required. The ID of the `Snooze` to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSnoozeRequest {
    /// Sets the value of [name][crate::model::GetSnoozeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnoozeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetSnoozeRequest"
    }
}

/// The message definition for updating a `Snooze`. The field, `snooze.name`
/// identifies the `Snooze` to be updated. The remainder of `snooze` gives the
/// content the `Snooze` in question will be assigned.
///
/// What fields can be updated depends on the start time and end time of the
/// `Snooze`.
///
/// * end time is in the past: These `Snooze`s are considered
///   read-only and cannot be updated.
/// * start time is in the past and end time is in the future: `display_name`
///   and `interval.end_time` can be updated.
/// * start time is in the future: `display_name`, `interval.start_time` and
///   `interval.end_time` can be updated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSnoozeRequest {
    /// Required. The `Snooze` to update. Must have the name field present.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snooze: std::option::Option<crate::model::Snooze>,

    /// Required. The fields to update.
    ///
    /// For each field listed in `update_mask`:
    ///
    /// * If the `Snooze` object supplied in the `UpdateSnoozeRequest` has a
    ///   value for that field, the value of the field in the existing `Snooze`
    ///   will be set to the value of the field in the supplied `Snooze`.
    /// * If the field does not have a value in the supplied `Snooze`, the field
    ///   in the existing `Snooze` is set to its default value.
    ///
    /// Fields not listed retain their existing value.
    ///
    /// The following are the field names that are accepted in `update_mask`:
    ///
    /// * `display_name`
    /// * `interval.start_time`
    /// * `interval.end_time`
    ///
    /// That said, the start time and end time of the `Snooze` determines which
    /// fields can legally be updated. Before attempting an update, users should
    /// consult the documentation for `UpdateSnoozeRequest`, which talks about
    /// which fields can be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateSnoozeRequest {
    /// Sets the value of [snooze][crate::model::UpdateSnoozeRequest::snooze].
    pub fn set_snooze<T: std::convert::Into<std::option::Option<crate::model::Snooze>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snooze = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnoozeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSnoozeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateSnoozeRequest"
    }
}

/// The context of a span. This is attached to an
/// [Exemplar][google.api.Distribution.Exemplar]
/// in [Distribution][google.api.Distribution] values during aggregation.
///
/// It contains the name of a span with format:
///
/// ```norust
/// projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID]
/// ```
///
/// [google.api.Distribution]: api::model::Distribution
/// [google.api.Distribution.Exemplar]: api::model::distribution::Exemplar
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpanContext {
    /// The resource name of the span. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID]
    /// ```
    ///
    /// `[TRACE_ID]` is a unique identifier for a trace within a project;
    /// it is a 32-character hexadecimal encoding of a 16-byte array.
    ///
    /// `[SPAN_ID]` is a unique identifier for a span within a trace; it
    /// is a 16-character hexadecimal encoding of an 8-byte array.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub span_name: std::string::String,
}

impl SpanContext {
    /// Sets the value of [span_name][crate::model::SpanContext::span_name].
    pub fn set_span_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.span_name = v.into();
        self
    }
}

impl wkt::message::Message for SpanContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.SpanContext"
    }
}

/// An internal checker allows Uptime checks to run on private/internal GCP
/// resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InternalChecker {
    /// A unique resource name for this InternalChecker. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]
    /// ```
    ///
    /// `[PROJECT_ID_OR_NUMBER]` is the Cloud Monitoring Metrics Scope project for
    /// the Uptime check config associated with the internal checker.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The checker's human-readable name. The display name
    /// should be unique within a Cloud Monitoring Metrics Scope in order to make
    /// it easier to identify; however, uniqueness is not enforced.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The [GCP VPC network](https://cloud.google.com/vpc/docs/vpc) where the
    /// internal resource lives (ex: "default").
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// The GCP zone the Uptime check should egress from. Only respected for
    /// internal Uptime checks, where internal_network is specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_zone: std::string::String,

    /// The GCP project ID where the internal checker lives. Not necessary
    /// the same as the Metrics Scope project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_project_id: std::string::String,

    /// The current operational state of the internal checker.
    pub state: crate::model::internal_checker::State,
}

impl InternalChecker {
    /// Sets the value of [name][crate::model::InternalChecker::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InternalChecker::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [network][crate::model::InternalChecker::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [gcp_zone][crate::model::InternalChecker::gcp_zone].
    pub fn set_gcp_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_zone = v.into();
        self
    }

    /// Sets the value of [peer_project_id][crate::model::InternalChecker::peer_project_id].
    pub fn set_peer_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_project_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::InternalChecker::state].
    pub fn set_state<T: std::convert::Into<crate::model::internal_checker::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for InternalChecker {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.InternalChecker"
    }
}

/// Defines additional types related to InternalChecker
pub mod internal_checker {
    #[allow(unused_imports)]
    use super::*;

    /// Operational states for an internal checker.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// An internal checker should never be in the unspecified state.
        pub const UNSPECIFIED: State = State::new("UNSPECIFIED");

        /// The checker is being created, provisioned, and configured. A checker in
        /// this state can be returned by `ListInternalCheckers` or
        /// `GetInternalChecker`, as well as by examining the [long running
        /// Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
        /// that created it.
        pub const CREATING: State = State::new("CREATING");

        /// The checker is running and available for use. A checker in this state
        /// can be returned by `ListInternalCheckers` or `GetInternalChecker` as
        /// well as by examining the [long running
        /// Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
        /// that created it.
        /// If a checker is being torn down, it is neither visible nor usable, so
        /// there is no "deleting" or "down" state.
        pub const RUNNING: State = State::new("RUNNING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Describes a Synthetic Monitor to be invoked by Uptime.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyntheticMonitorTarget {
    /// Specifies a Synthetic Monitor's execution stack.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::synthetic_monitor_target::Target>,
}

impl SyntheticMonitorTarget {
    /// Sets the value of `target`.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::synthetic_monitor_target::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::SyntheticMonitorTarget::target]
    /// if it holds a `CloudFunctionV2`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_function_v2(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::synthetic_monitor_target::CloudFunctionV2Target>,
    > {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::synthetic_monitor_target::Target::CloudFunctionV2(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::SyntheticMonitorTarget::target]
    /// to hold a `CloudFunctionV2`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_function_v2<
        T: std::convert::Into<
            std::boxed::Box<crate::model::synthetic_monitor_target::CloudFunctionV2Target>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::synthetic_monitor_target::Target::CloudFunctionV2(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SyntheticMonitorTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.SyntheticMonitorTarget"
    }
}

/// Defines additional types related to SyntheticMonitorTarget
pub mod synthetic_monitor_target {
    #[allow(unused_imports)]
    use super::*;

    /// A Synthetic Monitor deployed to a Cloud Functions V2 instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CloudFunctionV2Target {
        /// Required. Fully qualified GCFv2 resource name
        /// i.e. `projects/{project}/locations/{location}/functions/{function}`
        /// Required.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Output only. The `cloud_run_revision` Monitored Resource associated with
        /// the GCFv2. The Synthetic Monitor execution results (metrics, logs, and
        /// spans) are reported against this Monitored Resource. This field is output
        /// only.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub cloud_run_revision: std::option::Option<api::model::MonitoredResource>,
    }

    impl CloudFunctionV2Target {
        /// Sets the value of [name][crate::model::synthetic_monitor_target::CloudFunctionV2Target::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [cloud_run_revision][crate::model::synthetic_monitor_target::CloudFunctionV2Target::cloud_run_revision].
        pub fn set_cloud_run_revision<
            T: std::convert::Into<std::option::Option<api::model::MonitoredResource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.cloud_run_revision = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudFunctionV2Target {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.SyntheticMonitorTarget.CloudFunctionV2Target"
        }
    }

    /// Specifies a Synthetic Monitor's execution stack.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Target {
        /// Target a Synthetic Monitor GCFv2 instance.
        CloudFunctionV2(
            std::boxed::Box<crate::model::synthetic_monitor_target::CloudFunctionV2Target>,
        ),
    }
}

/// This message configures which resources and services to monitor for
/// availability.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UptimeCheckConfig {
    /// Identifier. A unique resource name for this Uptime check configuration. The
    /// format is:
    ///
    /// ```norust
    ///  projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
    /// ```
    ///
    /// `[PROJECT_ID_OR_NUMBER]` is the Workspace host project associated with the
    /// Uptime check.
    ///
    /// This field should be omitted when creating the Uptime check configuration;
    /// on create, the resource name is assigned by the server and included in the
    /// response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A human-friendly name for the Uptime check configuration. The display name
    /// should be unique within a Cloud Monitoring Workspace in order to make it
    /// easier to identify; however, uniqueness is not enforced. Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// How often, in seconds, the Uptime check is performed.
    /// Currently, the only supported values are `60s` (1 minute), `300s`
    /// (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
    /// defaults to `60s`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub period: std::option::Option<wkt::Duration>,

    /// The maximum amount of time to wait for the request to complete (must be
    /// between 1 and 60 seconds). Required.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// The content that is expected to appear in the data returned by the target
    /// server against which the check is run.  Currently, only the first entry
    /// in the `content_matchers` list is supported, and additional entries will
    /// be ignored. This field is optional and should only be specified if a
    /// content match is required as part of the/ Uptime check.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content_matchers: std::vec::Vec<crate::model::uptime_check_config::ContentMatcher>,

    /// The type of checkers to use to execute the Uptime check.
    pub checker_type: crate::model::uptime_check_config::CheckerType,

    /// The list of regions from which the check will be run.
    /// Some regions contain one location, and others contain more than one.
    /// If this field is specified, enough regions must be provided to include a
    /// minimum of 3 locations.  Not specifying this field will result in Uptime
    /// checks running from all available regions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub selected_regions: std::vec::Vec<crate::model::UptimeCheckRegion>,

    /// If this is `true`, then checks are made only from the 'internal_checkers'.
    /// If it is `false`, then checks are made only from the 'selected_regions'.
    /// It is an error to provide 'selected_regions' when is_internal is `true`,
    /// or to provide 'internal_checkers' when is_internal is `false`.
    pub is_internal: bool,

    /// The internal checkers that this check will egress from. If `is_internal` is
    /// `true` and this list is empty, the check will egress from all the
    /// InternalCheckers configured for the project that owns this
    /// `UptimeCheckConfig`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub internal_checkers: std::vec::Vec<crate::model::InternalChecker>,

    /// User-supplied key/value data to be used for organizing and
    /// identifying the `UptimeCheckConfig` objects.
    ///
    /// The field can contain up to 64 entries. Each key and value is limited to
    /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
    /// values can contain only lowercase letters, numerals, underscores, and
    /// dashes. Keys must begin with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The resource the check is checking. Required.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::uptime_check_config::Resource>,

    /// The type of Uptime check request.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub check_request_type:
        std::option::Option<crate::model::uptime_check_config::CheckRequestType>,
}

impl UptimeCheckConfig {
    /// Sets the value of [name][crate::model::UptimeCheckConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::UptimeCheckConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [period][crate::model::UptimeCheckConfig::period].
    pub fn set_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.period = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::UptimeCheckConfig::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [checker_type][crate::model::UptimeCheckConfig::checker_type].
    pub fn set_checker_type<
        T: std::convert::Into<crate::model::uptime_check_config::CheckerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.checker_type = v.into();
        self
    }

    /// Sets the value of [is_internal][crate::model::UptimeCheckConfig::is_internal].
    pub fn set_is_internal<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_internal = v.into();
        self
    }

    /// Sets the value of [content_matchers][crate::model::UptimeCheckConfig::content_matchers].
    pub fn set_content_matchers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::uptime_check_config::ContentMatcher>,
    {
        use std::iter::Iterator;
        self.content_matchers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [selected_regions][crate::model::UptimeCheckConfig::selected_regions].
    pub fn set_selected_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UptimeCheckRegion>,
    {
        use std::iter::Iterator;
        self.selected_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [internal_checkers][crate::model::UptimeCheckConfig::internal_checkers].
    pub fn set_internal_checkers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InternalChecker>,
    {
        use std::iter::Iterator;
        self.internal_checkers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::UptimeCheckConfig::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `resource`.
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::uptime_check_config::Resource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::UptimeCheckConfig::resource]
    /// if it holds a `MonitoredResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_monitored_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<api::model::MonitoredResource>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::Resource::MonitoredResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::UptimeCheckConfig::resource]
    /// if it holds a `ResourceGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_resource_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::uptime_check_config::ResourceGroup>>
    {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::Resource::ResourceGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::UptimeCheckConfig::resource]
    /// if it holds a `SyntheticMonitor`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_synthetic_monitor(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SyntheticMonitorTarget>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::Resource::SyntheticMonitor(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::UptimeCheckConfig::resource]
    /// to hold a `MonitoredResource`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_monitored_resource<
        T: std::convert::Into<std::boxed::Box<api::model::MonitoredResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::uptime_check_config::Resource::MonitoredResource(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::UptimeCheckConfig::resource]
    /// to hold a `ResourceGroup`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_resource_group<
        T: std::convert::Into<std::boxed::Box<crate::model::uptime_check_config::ResourceGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::uptime_check_config::Resource::ResourceGroup(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::UptimeCheckConfig::resource]
    /// to hold a `SyntheticMonitor`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_synthetic_monitor<
        T: std::convert::Into<std::boxed::Box<crate::model::SyntheticMonitorTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::uptime_check_config::Resource::SyntheticMonitor(v.into()),
        );
        self
    }

    /// Sets the value of `check_request_type`.
    pub fn set_check_request_type<
        T: std::convert::Into<
            std::option::Option<crate::model::uptime_check_config::CheckRequestType>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_request_type = v.into();
        self
    }

    /// The value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// if it holds a `HttpCheck`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_http_check(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::uptime_check_config::HttpCheck>> {
        #[allow(unreachable_patterns)]
        self.check_request_type.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::CheckRequestType::HttpCheck(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// if it holds a `TcpCheck`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tcp_check(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::uptime_check_config::TcpCheck>> {
        #[allow(unreachable_patterns)]
        self.check_request_type.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::CheckRequestType::TcpCheck(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// to hold a `HttpCheck`.
    ///
    /// Note that all the setters affecting `check_request_type` are
    /// mutually exclusive.
    pub fn set_http_check<
        T: std::convert::Into<std::boxed::Box<crate::model::uptime_check_config::HttpCheck>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_request_type = std::option::Option::Some(
            crate::model::uptime_check_config::CheckRequestType::HttpCheck(v.into()),
        );
        self
    }

    /// Sets the value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// to hold a `TcpCheck`.
    ///
    /// Note that all the setters affecting `check_request_type` are
    /// mutually exclusive.
    pub fn set_tcp_check<
        T: std::convert::Into<std::boxed::Box<crate::model::uptime_check_config::TcpCheck>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_request_type = std::option::Option::Some(
            crate::model::uptime_check_config::CheckRequestType::TcpCheck(v.into()),
        );
        self
    }
}

impl wkt::message::Message for UptimeCheckConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig"
    }
}

/// Defines additional types related to UptimeCheckConfig
pub mod uptime_check_config {
    #[allow(unused_imports)]
    use super::*;

    /// The resource submessage for group checks. It can be used instead of a
    /// monitored resource, when multiple resources are being monitored.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceGroup {
        /// The group of resources being monitored. Should be only the `[GROUP_ID]`,
        /// and not the full-path
        /// `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub group_id: std::string::String,

        /// The resource type of the group members.
        pub resource_type: crate::model::GroupResourceType,
    }

    impl ResourceGroup {
        /// Sets the value of [group_id][crate::model::uptime_check_config::ResourceGroup::group_id].
        pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group_id = v.into();
            self
        }

        /// Sets the value of [resource_type][crate::model::uptime_check_config::ResourceGroup::resource_type].
        pub fn set_resource_type<T: std::convert::Into<crate::model::GroupResourceType>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceGroup {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.ResourceGroup"
        }
    }

    /// Information involved in sending ICMP pings alongside public HTTP/TCP
    /// checks. For HTTP, the pings are performed for each part of the redirect
    /// chain.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PingConfig {
        /// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        pub pings_count: i32,
    }

    impl PingConfig {
        /// Sets the value of [pings_count][crate::model::uptime_check_config::PingConfig::pings_count].
        pub fn set_pings_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.pings_count = v.into();
            self
        }
    }

    impl wkt::message::Message for PingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.PingConfig"
        }
    }

    /// Information involved in an HTTP/HTTPS Uptime check request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HttpCheck {
        /// The HTTP request method to use for the check. If set to
        /// `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
        pub request_method: crate::model::uptime_check_config::http_check::RequestMethod,

        /// If `true`, use HTTPS instead of HTTP to run the check.
        pub use_ssl: bool,

        /// Optional (defaults to "/"). The path to the page against which to run
        /// the check. Will be combined with the `host` (specified within the
        /// `monitored_resource`) and `port` to construct the full URL. If the
        /// provided path does not begin with "/", a "/" will be prepended
        /// automatically.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub path: std::string::String,

        /// Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
        /// `use_ssl` is `true`). The TCP port on the HTTP server against which to
        /// run the check. Will be combined with host (specified within the
        /// `monitored_resource`) and `path` to construct the full URL.
        pub port: i32,

        /// The authentication information. Optional when creating an HTTP check;
        /// defaults to empty.
        /// Do not set both `auth_method` and `auth_info`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub auth_info:
            std::option::Option<crate::model::uptime_check_config::http_check::BasicAuthentication>,

        /// Boolean specifying whether to encrypt the header information.
        /// Encryption should be specified for any headers related to authentication
        /// that you do not wish to be seen when retrieving the configuration. The
        /// server will be responsible for encrypting the headers.
        /// On Get/List calls, if `mask_headers` is set to `true` then the headers
        /// will be obscured with `******.`
        pub mask_headers: bool,

        /// The list of headers to send as part of the Uptime check request.
        /// If two headers have the same key and different values, they should
        /// be entered as a single header, with the value being a comma-separated
        /// list of all the desired values as described at
        /// <https://www.w3.org/Protocols/rfc2616/rfc2616.txt> (page 31).
        /// Entering two separate headers with the same key in a Create call will
        /// cause the first to be overwritten by the second.
        /// The maximum number of headers allowed is 100.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub headers: std::collections::HashMap<std::string::String, std::string::String>,

        /// The content type header to use for the check. The following
        /// configurations result in errors:
        ///
        /// . Content type is specified in both the `headers` field and the
        ///   `content_type` field.
        /// . Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
        /// . Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
        /// . Request method is `POST` and a "Content-Type" header is provided via
        ///   `headers` field. The `content_type` field should be used instead.
        pub content_type: crate::model::uptime_check_config::http_check::ContentType,

        /// A user provided content type header to use for the check. The invalid
        /// configurations outlined in the `content_type` field apply to
        /// `custom_content_type`, as well as the following:
        ///
        /// . `content_type` is `URL_ENCODED` and `custom_content_type` is set.
        /// . `content_type` is `USER_PROVIDED` and `custom_content_type` is not
        ///   set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub custom_content_type: std::string::String,

        /// Boolean specifying whether to include SSL certificate validation as a
        /// part of the Uptime check. Only applies to checks where
        /// `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
        /// setting `validate_ssl` to `true` has no effect.
        pub validate_ssl: bool,

        /// The request body associated with the HTTP POST request. If `content_type`
        /// is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
        /// provide a `Content-Length` header via the `headers` field or the API will
        /// do so. If the `request_method` is `GET` and `body` is not empty, the API
        /// will return an error. The maximum byte size is 1 megabyte.
        ///
        /// Note: If client libraries aren't used (which performs the conversion
        /// automatically) base64 encode your `body` data since the field is of
        /// `bytes` type.
        #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub body: bytes::Bytes,

        /// If present, the check will only pass if the HTTP response status code is
        /// in this set of status codes. If empty, the HTTP status code will only
        /// pass if the HTTP status code is 200-299.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub accepted_response_status_codes:
            std::vec::Vec<crate::model::uptime_check_config::http_check::ResponseStatusCode>,

        /// Contains information needed to add pings to an HTTP check.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ping_config: std::option::Option<crate::model::uptime_check_config::PingConfig>,

        /// This field is optional and should be set only by users interested in
        /// an authenticated uptime check.
        /// Do not set both `auth_method` and `auth_info`.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub auth_method:
            std::option::Option<crate::model::uptime_check_config::http_check::AuthMethod>,
    }

    impl HttpCheck {
        /// Sets the value of [request_method][crate::model::uptime_check_config::HttpCheck::request_method].
        pub fn set_request_method<
            T: std::convert::Into<crate::model::uptime_check_config::http_check::RequestMethod>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.request_method = v.into();
            self
        }

        /// Sets the value of [use_ssl][crate::model::uptime_check_config::HttpCheck::use_ssl].
        pub fn set_use_ssl<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_ssl = v.into();
            self
        }

        /// Sets the value of [path][crate::model::uptime_check_config::HttpCheck::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [port][crate::model::uptime_check_config::HttpCheck::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [auth_info][crate::model::uptime_check_config::HttpCheck::auth_info].
        pub fn set_auth_info<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::uptime_check_config::http_check::BasicAuthentication,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auth_info = v.into();
            self
        }

        /// Sets the value of [mask_headers][crate::model::uptime_check_config::HttpCheck::mask_headers].
        pub fn set_mask_headers<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.mask_headers = v.into();
            self
        }

        /// Sets the value of [content_type][crate::model::uptime_check_config::HttpCheck::content_type].
        pub fn set_content_type<
            T: std::convert::Into<crate::model::uptime_check_config::http_check::ContentType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.content_type = v.into();
            self
        }

        /// Sets the value of [custom_content_type][crate::model::uptime_check_config::HttpCheck::custom_content_type].
        pub fn set_custom_content_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_content_type = v.into();
            self
        }

        /// Sets the value of [validate_ssl][crate::model::uptime_check_config::HttpCheck::validate_ssl].
        pub fn set_validate_ssl<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.validate_ssl = v.into();
            self
        }

        /// Sets the value of [body][crate::model::uptime_check_config::HttpCheck::body].
        pub fn set_body<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
            self.body = v.into();
            self
        }

        /// Sets the value of [ping_config][crate::model::uptime_check_config::HttpCheck::ping_config].
        pub fn set_ping_config<
            T: std::convert::Into<std::option::Option<crate::model::uptime_check_config::PingConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ping_config = v.into();
            self
        }

        /// Sets the value of [accepted_response_status_codes][crate::model::uptime_check_config::HttpCheck::accepted_response_status_codes].
        pub fn set_accepted_response_status_codes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::uptime_check_config::http_check::ResponseStatusCode,
            >,
        {
            use std::iter::Iterator;
            self.accepted_response_status_codes = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [headers][crate::model::uptime_check_config::HttpCheck::headers].
        pub fn set_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of `auth_method`.
        pub fn set_auth_method<
            T: std::convert::Into<
                std::option::Option<crate::model::uptime_check_config::http_check::AuthMethod>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auth_method = v.into();
            self
        }

        /// The value of [auth_method][crate::model::uptime_check_config::HttpCheck::auth_method]
        /// if it holds a `ServiceAgentAuthentication`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_service_agent_authentication(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::uptime_check_config::http_check::ServiceAgentAuthentication,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.auth_method.as_ref().and_then(|v| match v {
                crate::model::uptime_check_config::http_check::AuthMethod::ServiceAgentAuthentication(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [auth_method][crate::model::uptime_check_config::HttpCheck::auth_method]
        /// to hold a `ServiceAgentAuthentication`.
        ///
        /// Note that all the setters affecting `auth_method` are
        /// mutually exclusive.
        pub fn set_service_agent_authentication<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::uptime_check_config::http_check::ServiceAgentAuthentication,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auth_method = std::option::Option::Some(
                crate::model::uptime_check_config::http_check::AuthMethod::ServiceAgentAuthentication(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for HttpCheck {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck"
        }
    }

    /// Defines additional types related to HttpCheck
    pub mod http_check {
        #[allow(unused_imports)]
        use super::*;

        /// The authentication parameters to provide to the specified resource or
        /// URL that requires a username and password. Currently, only
        /// [Basic HTTP authentication](https://tools.ietf.org/html/rfc7617) is
        /// supported in Uptime checks.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BasicAuthentication {
            /// The username to use when authenticating with the HTTP server.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub username: std::string::String,

            /// The password to use when authenticating with the HTTP server.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub password: std::string::String,
        }

        impl BasicAuthentication {
            /// Sets the value of [username][crate::model::uptime_check_config::http_check::BasicAuthentication::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::uptime_check_config::http_check::BasicAuthentication::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }
        }

        impl wkt::message::Message for BasicAuthentication {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication"
            }
        }

        /// A status to accept. Either a status code class like "2xx", or an integer
        /// status code like "200".
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ResponseStatusCode {
            /// Either a specific value or a class of status codes.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub status_code: std::option::Option<
                crate::model::uptime_check_config::http_check::response_status_code::StatusCode,
            >,
        }

        impl ResponseStatusCode {
            /// Sets the value of `status_code`.
            pub fn set_status_code<T: std::convert::Into<std::option::Option<crate::model::uptime_check_config::http_check::response_status_code::StatusCode>>>(mut self, v: T) -> Self
            {
                self.status_code = v.into();
                self
            }

            /// The value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// if it holds a `StatusValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_status_value(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.status_code.as_ref().and_then(|v| match v {
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// if it holds a `StatusClass`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_status_class(
                &self,
            ) -> std::option::Option<
                &crate::model::uptime_check_config::http_check::response_status_code::StatusClass,
            > {
                #[allow(unreachable_patterns)]
                self.status_code.as_ref().and_then(|v| match v {
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusClass(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// to hold a `StatusValue`.
            ///
            /// Note that all the setters affecting `status_code` are
            /// mutually exclusive.
            pub fn set_status_value<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.status_code = std::option::Option::Some(
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusValue(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// to hold a `StatusClass`.
            ///
            /// Note that all the setters affecting `status_code` are
            /// mutually exclusive.
            pub fn set_status_class<T: std::convert::Into<crate::model::uptime_check_config::http_check::response_status_code::StatusClass>>(mut self, v: T) -> Self{
                self.status_code = std::option::Option::Some(
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusClass(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for ResponseStatusCode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode"
            }
        }

        /// Defines additional types related to ResponseStatusCode
        pub mod response_status_code {
            #[allow(unused_imports)]
            use super::*;

            /// An HTTP status code class.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct StatusClass(std::borrow::Cow<'static, str>);

            impl StatusClass {
                /// Creates a new StatusClass instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [StatusClass](StatusClass)
            pub mod status_class {
                use super::StatusClass;

                /// Default value that matches no status codes.
                pub const STATUS_CLASS_UNSPECIFIED: StatusClass =
                    StatusClass::new("STATUS_CLASS_UNSPECIFIED");

                /// The class of status codes between 100 and 199.
                pub const STATUS_CLASS_1XX: StatusClass = StatusClass::new("STATUS_CLASS_1XX");

                /// The class of status codes between 200 and 299.
                pub const STATUS_CLASS_2XX: StatusClass = StatusClass::new("STATUS_CLASS_2XX");

                /// The class of status codes between 300 and 399.
                pub const STATUS_CLASS_3XX: StatusClass = StatusClass::new("STATUS_CLASS_3XX");

                /// The class of status codes between 400 and 499.
                pub const STATUS_CLASS_4XX: StatusClass = StatusClass::new("STATUS_CLASS_4XX");

                /// The class of status codes between 500 and 599.
                pub const STATUS_CLASS_5XX: StatusClass = StatusClass::new("STATUS_CLASS_5XX");

                /// The class of all status codes.
                pub const STATUS_CLASS_ANY: StatusClass = StatusClass::new("STATUS_CLASS_ANY");
            }

            impl std::convert::From<std::string::String> for StatusClass {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }

            /// Either a specific value or a class of status codes.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum StatusCode {
                /// A status code to accept.
                StatusValue(i32),
                /// A class of status codes to accept.
                StatusClass(crate::model::uptime_check_config::http_check::response_status_code::StatusClass),
            }
        }

        /// Contains information needed for generating either an
        /// [OpenID Connect
        /// token](https://developers.google.com/identity/protocols/OpenIDConnect) or
        /// [OAuth token](https://developers.google.com/identity/protocols/oauth2).
        /// The token will be generated for the Monitoring service agent service
        /// account.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ServiceAgentAuthentication {

            /// Type of authentication.
            #[serde(rename = "type")]
            pub r#type: crate::model::uptime_check_config::http_check::service_agent_authentication::ServiceAgentAuthenticationType,
        }

        impl ServiceAgentAuthentication {
            /// Sets the value of [r#type][crate::model::uptime_check_config::http_check::ServiceAgentAuthentication::type].
            pub fn set_type<T: std::convert::Into<crate::model::uptime_check_config::http_check::service_agent_authentication::ServiceAgentAuthenticationType>>(mut self, v: T) -> Self{
                self.r#type = v.into();
                self
            }
        }

        impl wkt::message::Message for ServiceAgentAuthentication {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication"
            }
        }

        /// Defines additional types related to ServiceAgentAuthentication
        pub mod service_agent_authentication {
            #[allow(unused_imports)]
            use super::*;

            /// Type of authentication.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct ServiceAgentAuthenticationType(std::borrow::Cow<'static, str>);

            impl ServiceAgentAuthenticationType {
                /// Creates a new ServiceAgentAuthenticationType instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [ServiceAgentAuthenticationType](ServiceAgentAuthenticationType)
            pub mod service_agent_authentication_type {
                use super::ServiceAgentAuthenticationType;

                /// Default value, will result in OIDC Authentication.
                pub const SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED:
                    ServiceAgentAuthenticationType = ServiceAgentAuthenticationType::new(
                    "SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED",
                );

                /// OIDC Authentication
                pub const OIDC_TOKEN: ServiceAgentAuthenticationType =
                    ServiceAgentAuthenticationType::new("OIDC_TOKEN");
            }

            impl std::convert::From<std::string::String> for ServiceAgentAuthenticationType {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }
        }

        /// The HTTP request method options.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct RequestMethod(std::borrow::Cow<'static, str>);

        impl RequestMethod {
            /// Creates a new RequestMethod instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [RequestMethod](RequestMethod)
        pub mod request_method {
            use super::RequestMethod;

            /// No request method specified.
            pub const METHOD_UNSPECIFIED: RequestMethod = RequestMethod::new("METHOD_UNSPECIFIED");

            /// GET request.
            pub const GET: RequestMethod = RequestMethod::new("GET");

            /// POST request.
            pub const POST: RequestMethod = RequestMethod::new("POST");
        }

        impl std::convert::From<std::string::String> for RequestMethod {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Header options corresponding to the content type of a HTTP request body.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ContentType(std::borrow::Cow<'static, str>);

        impl ContentType {
            /// Creates a new ContentType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ContentType](ContentType)
        pub mod content_type {
            use super::ContentType;

            /// No content type specified.
            pub const TYPE_UNSPECIFIED: ContentType = ContentType::new("TYPE_UNSPECIFIED");

            /// `body` is in URL-encoded form. Equivalent to setting the `Content-Type`
            /// to `application/x-www-form-urlencoded` in the HTTP request.
            pub const URL_ENCODED: ContentType = ContentType::new("URL_ENCODED");

            /// `body` is in `custom_content_type` form. Equivalent to setting the
            /// `Content-Type` to the contents of `custom_content_type` in the HTTP
            /// request.
            pub const USER_PROVIDED: ContentType = ContentType::new("USER_PROVIDED");
        }

        impl std::convert::From<std::string::String> for ContentType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// This field is optional and should be set only by users interested in
        /// an authenticated uptime check.
        /// Do not set both `auth_method` and `auth_info`.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum AuthMethod {
            /// If specified, Uptime will generate and attach an OIDC JWT token for the
            /// Monitoring service agent service account as an `Authorization` header
            /// in the HTTP request when probing.
            ServiceAgentAuthentication(
                std::boxed::Box<
                    crate::model::uptime_check_config::http_check::ServiceAgentAuthentication,
                >,
            ),
        }
    }

    /// Information required for a TCP Uptime check request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TcpCheck {
        /// The TCP port on the server against which to run the check. Will be
        /// combined with host (specified within the `monitored_resource`) to
        /// construct the full URL. Required.
        pub port: i32,

        /// Contains information needed to add pings to a TCP check.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ping_config: std::option::Option<crate::model::uptime_check_config::PingConfig>,
    }

    impl TcpCheck {
        /// Sets the value of [port][crate::model::uptime_check_config::TcpCheck::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [ping_config][crate::model::uptime_check_config::TcpCheck::ping_config].
        pub fn set_ping_config<
            T: std::convert::Into<std::option::Option<crate::model::uptime_check_config::PingConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ping_config = v.into();
            self
        }
    }

    impl wkt::message::Message for TcpCheck {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.TcpCheck"
        }
    }

    /// Optional. Used to perform content matching. This allows matching based on
    /// substrings and regular expressions, together with their negations. Only the
    /// first 4&nbsp;MB of an HTTP or HTTPS check's response (and the first
    /// 1&nbsp;MB of a TCP check's response) are examined for purposes of content
    /// matching.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ContentMatcher {
        /// String, regex or JSON content to match. Maximum 1024 bytes. An empty
        /// `content` string indicates no content matching is to be performed.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub content: std::string::String,

        /// The type of content matcher that will be applied to the server output,
        /// compared to the `content` string when the check is run.
        pub matcher: crate::model::uptime_check_config::content_matcher::ContentMatcherOption,

        /// Certain `ContentMatcherOption` types require additional information.
        /// `MATCHES_JSON_PATH` or `NOT_MATCHES_JSON_PATH` require a
        /// `JsonPathMatcher`; not used for other options.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub additional_matcher_info: std::option::Option<
            crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo,
        >,
    }

    impl ContentMatcher {
        /// Sets the value of [content][crate::model::uptime_check_config::ContentMatcher::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }

        /// Sets the value of [matcher][crate::model::uptime_check_config::ContentMatcher::matcher].
        pub fn set_matcher<
            T: std::convert::Into<
                crate::model::uptime_check_config::content_matcher::ContentMatcherOption,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.matcher = v.into();
            self
        }

        /// Sets the value of `additional_matcher_info`.
        pub fn set_additional_matcher_info<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.additional_matcher_info = v.into();
            self
        }

        /// The value of [additional_matcher_info][crate::model::uptime_check_config::ContentMatcher::additional_matcher_info]
        /// if it holds a `JsonPathMatcher`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_json_path_matcher(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::uptime_check_config::content_matcher::JsonPathMatcher>,
        > {
            #[allow(unreachable_patterns)]
            self.additional_matcher_info.as_ref().and_then(|v| match v {
                crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo::JsonPathMatcher(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [additional_matcher_info][crate::model::uptime_check_config::ContentMatcher::additional_matcher_info]
        /// to hold a `JsonPathMatcher`.
        ///
        /// Note that all the setters affecting `additional_matcher_info` are
        /// mutually exclusive.
        pub fn set_json_path_matcher<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::uptime_check_config::content_matcher::JsonPathMatcher,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.additional_matcher_info = std::option::Option::Some(
                crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo::JsonPathMatcher(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ContentMatcher {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.ContentMatcher"
        }
    }

    /// Defines additional types related to ContentMatcher
    pub mod content_matcher {
        #[allow(unused_imports)]
        use super::*;

        /// Information needed to perform a JSONPath content match.
        /// Used for `ContentMatcherOption::MATCHES_JSON_PATH` and
        /// `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JsonPathMatcher {

            /// JSONPath within the response output pointing to the expected
            /// `ContentMatcher::content` to match against.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub json_path: std::string::String,

            /// The type of JSONPath match that will be applied to the JSON output
            /// (`ContentMatcher.content`)
            pub json_matcher: crate::model::uptime_check_config::content_matcher::json_path_matcher::JsonPathMatcherOption,
        }

        impl JsonPathMatcher {
            /// Sets the value of [json_path][crate::model::uptime_check_config::content_matcher::JsonPathMatcher::json_path].
            pub fn set_json_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.json_path = v.into();
                self
            }

            /// Sets the value of [json_matcher][crate::model::uptime_check_config::content_matcher::JsonPathMatcher::json_matcher].
            pub fn set_json_matcher<T: std::convert::Into<crate::model::uptime_check_config::content_matcher::json_path_matcher::JsonPathMatcherOption>>(mut self, v: T) -> Self{
                self.json_matcher = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonPathMatcher {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher"
            }
        }

        /// Defines additional types related to JsonPathMatcher
        pub mod json_path_matcher {
            #[allow(unused_imports)]
            use super::*;

            /// Options to perform JSONPath content matching.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct JsonPathMatcherOption(std::borrow::Cow<'static, str>);

            impl JsonPathMatcherOption {
                /// Creates a new JsonPathMatcherOption instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [JsonPathMatcherOption](JsonPathMatcherOption)
            pub mod json_path_matcher_option {
                use super::JsonPathMatcherOption;

                /// No JSONPath matcher type specified (not valid).
                pub const JSON_PATH_MATCHER_OPTION_UNSPECIFIED: JsonPathMatcherOption =
                    JsonPathMatcherOption::new("JSON_PATH_MATCHER_OPTION_UNSPECIFIED");

                /// Selects 'exact string' matching. The match succeeds if the content at
                /// the `json_path` within the output is exactly the same as the
                /// `content` string.
                pub const EXACT_MATCH: JsonPathMatcherOption =
                    JsonPathMatcherOption::new("EXACT_MATCH");

                /// Selects regular-expression matching. The match succeeds if the
                /// content at the `json_path` within the output matches the regular
                /// expression specified in the `content` string.
                pub const REGEX_MATCH: JsonPathMatcherOption =
                    JsonPathMatcherOption::new("REGEX_MATCH");
            }

            impl std::convert::From<std::string::String> for JsonPathMatcherOption {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }
        }

        /// Options to perform content matching.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ContentMatcherOption(std::borrow::Cow<'static, str>);

        impl ContentMatcherOption {
            /// Creates a new ContentMatcherOption instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ContentMatcherOption](ContentMatcherOption)
        pub mod content_matcher_option {
            use super::ContentMatcherOption;

            /// No content matcher type specified (maintained for backward
            /// compatibility, but deprecated for future use).
            /// Treated as `CONTAINS_STRING`.
            pub const CONTENT_MATCHER_OPTION_UNSPECIFIED: ContentMatcherOption =
                ContentMatcherOption::new("CONTENT_MATCHER_OPTION_UNSPECIFIED");

            /// Selects substring matching. The match succeeds if the output contains
            /// the `content` string.  This is the default value for checks without
            /// a `matcher` option, or where the value of `matcher` is
            /// `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
            pub const CONTAINS_STRING: ContentMatcherOption =
                ContentMatcherOption::new("CONTAINS_STRING");

            /// Selects negation of substring matching. The match succeeds if the
            /// output does _NOT_ contain the `content` string.
            pub const NOT_CONTAINS_STRING: ContentMatcherOption =
                ContentMatcherOption::new("NOT_CONTAINS_STRING");

            /// Selects regular-expression matching. The match succeeds if the output
            /// matches the regular expression specified in the `content` string.
            /// Regex matching is only supported for HTTP/HTTPS checks.
            pub const MATCHES_REGEX: ContentMatcherOption =
                ContentMatcherOption::new("MATCHES_REGEX");

            /// Selects negation of regular-expression matching. The match succeeds if
            /// the output does _NOT_ match the regular expression specified in the
            /// `content` string. Regex matching is only supported for HTTP/HTTPS
            /// checks.
            pub const NOT_MATCHES_REGEX: ContentMatcherOption =
                ContentMatcherOption::new("NOT_MATCHES_REGEX");

            /// Selects JSONPath matching. See `JsonPathMatcher` for details on when
            /// the match succeeds. JSONPath matching is only supported for HTTP/HTTPS
            /// checks.
            pub const MATCHES_JSON_PATH: ContentMatcherOption =
                ContentMatcherOption::new("MATCHES_JSON_PATH");

            /// Selects JSONPath matching. See `JsonPathMatcher` for details on when
            /// the match succeeds. Succeeds when output does _NOT_ match as specified.
            /// JSONPath is only supported for HTTP/HTTPS checks.
            pub const NOT_MATCHES_JSON_PATH: ContentMatcherOption =
                ContentMatcherOption::new("NOT_MATCHES_JSON_PATH");
        }

        impl std::convert::From<std::string::String> for ContentMatcherOption {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Certain `ContentMatcherOption` types require additional information.
        /// `MATCHES_JSON_PATH` or `NOT_MATCHES_JSON_PATH` require a
        /// `JsonPathMatcher`; not used for other options.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum AdditionalMatcherInfo {
            /// Matcher information for `MATCHES_JSON_PATH` and `NOT_MATCHES_JSON_PATH`
            JsonPathMatcher(
                std::boxed::Box<
                    crate::model::uptime_check_config::content_matcher::JsonPathMatcher,
                >,
            ),
        }
    }

    /// What kind of checkers are available to be used by the check.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CheckerType(std::borrow::Cow<'static, str>);

    impl CheckerType {
        /// Creates a new CheckerType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CheckerType](CheckerType)
    pub mod checker_type {
        use super::CheckerType;

        /// The default checker type. Currently converted to `STATIC_IP_CHECKERS`
        /// on creation, the default conversion behavior may change in the future.
        pub const CHECKER_TYPE_UNSPECIFIED: CheckerType =
            CheckerType::new("CHECKER_TYPE_UNSPECIFIED");

        /// `STATIC_IP_CHECKERS` are used for uptime checks that perform egress
        /// across the public internet. `STATIC_IP_CHECKERS` use the static IP
        /// addresses returned by `ListUptimeCheckIps`.
        pub const STATIC_IP_CHECKERS: CheckerType = CheckerType::new("STATIC_IP_CHECKERS");

        /// `VPC_CHECKERS` are used for uptime checks that perform egress using
        /// Service Directory and private network access. When using `VPC_CHECKERS`,
        /// the monitored resource type must be `servicedirectory_service`.
        pub const VPC_CHECKERS: CheckerType = CheckerType::new("VPC_CHECKERS");
    }

    impl std::convert::From<std::string::String> for CheckerType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The resource the check is checking. Required.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Resource {
        /// The [monitored
        /// resource](https://cloud.google.com/monitoring/api/resources) associated
        /// with the configuration.
        /// The following monitored resource types are valid for this field:
        /// `uptime_url`,
        /// `gce_instance`,
        /// `gae_app`,
        /// `aws_ec2_instance`,
        /// `aws_elb_load_balancer`
        /// `k8s_service`
        /// `servicedirectory_service`
        /// `cloud_run_revision`
        MonitoredResource(std::boxed::Box<api::model::MonitoredResource>),
        /// The group resource associated with the configuration.
        ResourceGroup(std::boxed::Box<crate::model::uptime_check_config::ResourceGroup>),
        /// Specifies a Synthetic Monitor to invoke.
        SyntheticMonitor(std::boxed::Box<crate::model::SyntheticMonitorTarget>),
    }

    /// The type of Uptime check request.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum CheckRequestType {
        /// Contains information needed to make an HTTP or HTTPS check.
        HttpCheck(std::boxed::Box<crate::model::uptime_check_config::HttpCheck>),
        /// Contains information needed to make a TCP check.
        TcpCheck(std::boxed::Box<crate::model::uptime_check_config::TcpCheck>),
    }
}

/// Contains the region, location, and list of IP
/// addresses where checkers in the location run from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UptimeCheckIp {
    /// A broad region category in which the IP address is located.
    pub region: crate::model::UptimeCheckRegion,

    /// A more specific location within the region that typically encodes
    /// a particular city/town/metro (and its containing state/province or country)
    /// within the broader umbrella region category.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The IP address from which the Uptime check originates. This is a fully
    /// specified IP address (not an IP address range). Most IP addresses, as of
    /// this publication, are in IPv4 format; however, one should not rely on the
    /// IP addresses being in IPv4 format indefinitely, and should support
    /// interpreting this field in either IPv4 or IPv6 format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,
}

impl UptimeCheckIp {
    /// Sets the value of [region][crate::model::UptimeCheckIp::region].
    pub fn set_region<T: std::convert::Into<crate::model::UptimeCheckRegion>>(
        mut self,
        v: T,
    ) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [location][crate::model::UptimeCheckIp::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::UptimeCheckIp::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for UptimeCheckIp {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UptimeCheckIp"
    }
}

/// The protocol for the `ListUptimeCheckConfigs` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUptimeCheckConfigsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// Uptime check configurations are listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// If provided, this field specifies the criteria that must be met by
    /// uptime checks to be included in the response.
    ///
    /// For more details, see [Filtering
    /// syntax](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering#filter_syntax).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of results to return in a single response. The server
    /// may further constrain the maximum number of results returned in a single
    /// page. If the page_size is <=0, the server will decide the number of results
    /// to be returned.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return more results from the previous method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListUptimeCheckConfigsRequest {
    /// Sets the value of [parent][crate::model::ListUptimeCheckConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUptimeCheckConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUptimeCheckConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUptimeCheckConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckConfigsRequest"
    }
}

/// The protocol for the `ListUptimeCheckConfigs` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUptimeCheckConfigsResponse {
    /// The returned Uptime check configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uptime_check_configs: std::vec::Vec<crate::model::UptimeCheckConfig>,

    /// This field represents the pagination token to retrieve the next page of
    /// results. If the value is empty, it means no further results for the
    /// request. To retrieve the next page of results, the value of the
    /// next_page_token is passed to the subsequent List method call (in the
    /// request message's page_token field).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of Uptime check configurations for the project,
    /// irrespective of any pagination.
    pub total_size: i32,
}

impl ListUptimeCheckConfigsResponse {
    /// Sets the value of [next_page_token][crate::model::ListUptimeCheckConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListUptimeCheckConfigsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [uptime_check_configs][crate::model::ListUptimeCheckConfigsResponse::uptime_check_configs].
    pub fn set_uptime_check_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UptimeCheckConfig>,
    {
        use std::iter::Iterator;
        self.uptime_check_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckConfigsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListUptimeCheckConfigsResponse {
    type PageItem = crate::model::UptimeCheckConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.uptime_check_configs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The protocol for the `GetUptimeCheckConfig` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetUptimeCheckConfigRequest {
    /// Required. The Uptime check configuration to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetUptimeCheckConfigRequest {
    /// Sets the value of [name][crate::model::GetUptimeCheckConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetUptimeCheckConfigRequest"
    }
}

/// The protocol for the `CreateUptimeCheckConfig` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateUptimeCheckConfigRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// to create the Uptime check. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The new Uptime check configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub uptime_check_config: std::option::Option<crate::model::UptimeCheckConfig>,
}

impl CreateUptimeCheckConfigRequest {
    /// Sets the value of [parent][crate::model::CreateUptimeCheckConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [uptime_check_config][crate::model::CreateUptimeCheckConfigRequest::uptime_check_config].
    pub fn set_uptime_check_config<
        T: std::convert::Into<std::option::Option<crate::model::UptimeCheckConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.uptime_check_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateUptimeCheckConfigRequest"
    }
}

/// The protocol for the `UpdateUptimeCheckConfig` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateUptimeCheckConfigRequest {
    /// Optional. If present, only the listed fields in the current Uptime check
    /// configuration are updated with values from the new configuration. If this
    /// field is empty, then the current configuration is completely replaced with
    /// the new configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. If an `updateMask` has been specified, this field gives
    /// the values for the set of fields mentioned in the `updateMask`. If an
    /// `updateMask` has not been given, this Uptime check configuration replaces
    /// the current configuration. If a field is mentioned in `updateMask` but
    /// the corresponding field is omitted in this partial Uptime check
    /// configuration, it has the effect of deleting/clearing the field from the
    /// configuration on the server.
    ///
    /// The following fields can be updated: `display_name`,
    /// `http_check`, `tcp_check`, `timeout`, `content_matchers`, and
    /// `selected_regions`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub uptime_check_config: std::option::Option<crate::model::UptimeCheckConfig>,
}

impl UpdateUptimeCheckConfigRequest {
    /// Sets the value of [update_mask][crate::model::UpdateUptimeCheckConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [uptime_check_config][crate::model::UpdateUptimeCheckConfigRequest::uptime_check_config].
    pub fn set_uptime_check_config<
        T: std::convert::Into<std::option::Option<crate::model::UptimeCheckConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.uptime_check_config = v.into();
        self
    }
}

impl wkt::message::Message for UpdateUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateUptimeCheckConfigRequest"
    }
}

/// The protocol for the `DeleteUptimeCheckConfig` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteUptimeCheckConfigRequest {
    /// Required. The Uptime check configuration to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteUptimeCheckConfigRequest {
    /// Sets the value of [name][crate::model::DeleteUptimeCheckConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteUptimeCheckConfigRequest"
    }
}

/// The protocol for the `ListUptimeCheckIps` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUptimeCheckIpsRequest {
    /// The maximum number of results to return in a single response. The server
    /// may further constrain the maximum number of results returned in a single
    /// page. If the page_size is <=0, the server will decide the number of results
    /// to be returned.
    /// NOTE: this field is not yet implemented
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return more results from the previous method call.
    /// NOTE: this field is not yet implemented
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListUptimeCheckIpsRequest {
    /// Sets the value of [page_size][crate::model::ListUptimeCheckIpsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUptimeCheckIpsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckIpsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckIpsRequest"
    }
}

/// The protocol for the `ListUptimeCheckIps` response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUptimeCheckIpsResponse {
    /// The returned list of IP addresses (including region and location) that the
    /// checkers run from.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uptime_check_ips: std::vec::Vec<crate::model::UptimeCheckIp>,

    /// This field represents the pagination token to retrieve the next page of
    /// results. If the value is empty, it means no further results for the
    /// request. To retrieve the next page of results, the value of the
    /// next_page_token is passed to the subsequent List method call (in the
    /// request message's page_token field).
    /// NOTE: this field is not yet implemented
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListUptimeCheckIpsResponse {
    /// Sets the value of [next_page_token][crate::model::ListUptimeCheckIpsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [uptime_check_ips][crate::model::ListUptimeCheckIpsResponse::uptime_check_ips].
    pub fn set_uptime_check_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UptimeCheckIp>,
    {
        use std::iter::Iterator;
        self.uptime_check_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckIpsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckIpsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListUptimeCheckIpsResponse {
    type PageItem = crate::model::UptimeCheckIp;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.uptime_check_ips
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Specifies an ordering relationship on two arguments, called `left` and
/// `right`.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ComparisonType(std::borrow::Cow<'static, str>);

impl ComparisonType {
    /// Creates a new ComparisonType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ComparisonType](ComparisonType)
pub mod comparison_type {
    use super::ComparisonType;

    /// No ordering relationship is specified.
    pub const COMPARISON_UNSPECIFIED: ComparisonType =
        ComparisonType::new("COMPARISON_UNSPECIFIED");

    /// True if the left argument is greater than the right argument.
    pub const COMPARISON_GT: ComparisonType = ComparisonType::new("COMPARISON_GT");

    /// True if the left argument is greater than or equal to the right argument.
    pub const COMPARISON_GE: ComparisonType = ComparisonType::new("COMPARISON_GE");

    /// True if the left argument is less than the right argument.
    pub const COMPARISON_LT: ComparisonType = ComparisonType::new("COMPARISON_LT");

    /// True if the left argument is less than or equal to the right argument.
    pub const COMPARISON_LE: ComparisonType = ComparisonType::new("COMPARISON_LE");

    /// True if the left argument is equal to the right argument.
    pub const COMPARISON_EQ: ComparisonType = ComparisonType::new("COMPARISON_EQ");

    /// True if the left argument is not equal to the right argument.
    pub const COMPARISON_NE: ComparisonType = ComparisonType::new("COMPARISON_NE");
}

impl std::convert::From<std::string::String> for ComparisonType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// The tier of service for a Metrics Scope. Please see the
/// [service tiers
/// documentation](https://cloud.google.com/monitoring/workspaces/tiers) for more
/// details.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ServiceTier(std::borrow::Cow<'static, str>);

impl ServiceTier {
    /// Creates a new ServiceTier instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ServiceTier](ServiceTier)
pub mod service_tier {
    use super::ServiceTier;

    /// An invalid sentinel value, used to indicate that a tier has not
    /// been provided explicitly.
    pub const SERVICE_TIER_UNSPECIFIED: ServiceTier = ServiceTier::new("SERVICE_TIER_UNSPECIFIED");

    /// The Cloud Monitoring Basic tier, a free tier of service that provides basic
    /// features, a moderate allotment of logs, and access to built-in metrics.
    /// A number of features are not available in this tier. For more details,
    /// see [the service tiers
    /// documentation](https://cloud.google.com/monitoring/workspaces/tiers).
    pub const SERVICE_TIER_BASIC: ServiceTier = ServiceTier::new("SERVICE_TIER_BASIC");

    /// The Cloud Monitoring Premium tier, a higher, more expensive tier of service
    /// that provides access to all Cloud Monitoring features, lets you use Cloud
    /// Monitoring with AWS accounts, and has a larger allotments for logs and
    /// metrics. For more details, see [the service tiers
    /// documentation](https://cloud.google.com/monitoring/workspaces/tiers).
    pub const SERVICE_TIER_PREMIUM: ServiceTier = ServiceTier::new("SERVICE_TIER_PREMIUM");
}

impl std::convert::From<std::string::String> for ServiceTier {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// The regions from which an Uptime check can be run.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct UptimeCheckRegion(std::borrow::Cow<'static, str>);

impl UptimeCheckRegion {
    /// Creates a new UptimeCheckRegion instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [UptimeCheckRegion](UptimeCheckRegion)
pub mod uptime_check_region {
    use super::UptimeCheckRegion;

    /// Default value if no region is specified. Will result in Uptime checks
    /// running from all regions.
    pub const REGION_UNSPECIFIED: UptimeCheckRegion = UptimeCheckRegion::new("REGION_UNSPECIFIED");

    /// Allows checks to run from locations within the United States of America.
    pub const USA: UptimeCheckRegion = UptimeCheckRegion::new("USA");

    /// Allows checks to run from locations within the continent of Europe.
    pub const EUROPE: UptimeCheckRegion = UptimeCheckRegion::new("EUROPE");

    /// Allows checks to run from locations within the continent of South
    /// America.
    pub const SOUTH_AMERICA: UptimeCheckRegion = UptimeCheckRegion::new("SOUTH_AMERICA");

    /// Allows checks to run from locations within the Asia Pacific area (ex:
    /// Singapore).
    pub const ASIA_PACIFIC: UptimeCheckRegion = UptimeCheckRegion::new("ASIA_PACIFIC");

    /// Allows checks to run from locations within the western United States of
    /// America
    pub const USA_OREGON: UptimeCheckRegion = UptimeCheckRegion::new("USA_OREGON");

    /// Allows checks to run from locations within the central United States of
    /// America
    pub const USA_IOWA: UptimeCheckRegion = UptimeCheckRegion::new("USA_IOWA");

    /// Allows checks to run from locations within the eastern United States of
    /// America
    pub const USA_VIRGINIA: UptimeCheckRegion = UptimeCheckRegion::new("USA_VIRGINIA");
}

impl std::convert::From<std::string::String> for UptimeCheckRegion {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// The supported resource types that can be used as values of
/// `group_resource.resource_type`.
/// `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
/// The resource types `gae_app` and `uptime_url` are not valid here because
/// group checks on App Engine modules and URLs are not allowed.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct GroupResourceType(std::borrow::Cow<'static, str>);

impl GroupResourceType {
    /// Creates a new GroupResourceType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [GroupResourceType](GroupResourceType)
pub mod group_resource_type {
    use super::GroupResourceType;

    /// Default value (not valid).
    pub const RESOURCE_TYPE_UNSPECIFIED: GroupResourceType =
        GroupResourceType::new("RESOURCE_TYPE_UNSPECIFIED");

    /// A group of instances from Google Cloud Platform (GCP) or
    /// Amazon Web Services (AWS).
    pub const INSTANCE: GroupResourceType = GroupResourceType::new("INSTANCE");

    /// A group of Amazon ELB load balancers.
    pub const AWS_ELB_LOAD_BALANCER: GroupResourceType =
        GroupResourceType::new("AWS_ELB_LOAD_BALANCER");
}

impl std::convert::From<std::string::String> for GroupResourceType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}
