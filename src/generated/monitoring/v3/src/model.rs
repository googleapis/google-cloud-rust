// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A description of the conditions under which some aspect of your system is
/// considered to be "unhealthy" and the ways to notify people or services about
/// this state. For an overview of alerting policies, see
/// [Introduction to Alerting](https://cloud.google.com/monitoring/alerts/).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AlertPolicy {
    /// Identifier. Required if the policy exists. The resource name for this
    /// policy. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    ///
    /// `[ALERT_POLICY_ID]` is assigned by Cloud Monitoring when the policy
    /// is created. When calling the
    /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
    /// method, do not include the `name` field in the alerting policy passed as
    /// part of the request.
    ///
    /// [google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]: crate::client::AlertPolicyService::create_alert_policy
    pub name: std::string::String,

    /// A short name or phrase used to identify the policy in dashboards,
    /// notifications, and incidents. To avoid confusion, don't use the same
    /// display name for multiple policies in the same project. The name is
    /// limited to 512 Unicode characters.
    ///
    /// The convention for the display_name of a PrometheusQueryLanguageCondition
    /// is "{rule group name}/{alert name}", where the {rule group name} and
    /// {alert name} should be taken from the corresponding Prometheus
    /// configuration file. This convention is not enforced.
    /// In any case the display_name is not a unique key of the AlertPolicy.
    pub display_name: std::string::String,

    /// Documentation that is included with notifications and incidents related to
    /// this policy. Best practice is for the documentation to include information
    /// to help responders understand, mitigate, escalate, and correct the
    /// underlying problems detected by the alerting policy. Notification channels
    /// that have limited capacity might not show this documentation.
    pub documentation: std::option::Option<crate::model::alert_policy::Documentation>,

    /// User-supplied key/value data to be used for organizing and
    /// identifying the `AlertPolicy` objects.
    ///
    /// The field can contain up to 64 entries. Each key and value is limited to
    /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
    /// values can contain only lowercase letters, numerals, underscores, and
    /// dashes. Keys must begin with a letter.
    ///
    /// Note that Prometheus {alert name} is a
    /// [valid Prometheus label
    /// names](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels),
    /// whereas Prometheus {rule group} is an unrestricted UTF-8 string.
    /// This means that they cannot be stored as-is in user labels, because
    /// they may contain characters that are not allowed in user-label values.
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A list of conditions for the policy. The conditions are combined by AND or
    /// OR according to the `combiner` field. If the combined conditions evaluate
    /// to true, then an incident is created. A policy can have from one to six
    /// conditions.
    /// If `condition_time_series_query_language` is present, it must be the only
    /// `condition`.
    /// If `condition_monitoring_query_language` is present, it must be the only
    /// `condition`.
    pub conditions: std::vec::Vec<crate::model::alert_policy::Condition>,

    /// How to combine the results of multiple conditions to determine if an
    /// incident should be opened.
    /// If `condition_time_series_query_language` is present, this must be
    /// `COMBINE_UNSPECIFIED`.
    pub combiner: crate::model::alert_policy::ConditionCombinerType,

    /// Whether or not the policy is enabled. On write, the default interpretation
    /// if unset is that the policy is enabled. On read, clients should not make
    /// any assumption about the state if it has not been populated. The
    /// field should always be populated on List and Get operations, unless
    /// a field projection has been specified that strips it out.
    pub enabled: std::option::Option<wkt::BoolValue>,

    /// Read-only description of how the alerting policy is invalid. This field is
    /// only set when the alerting policy is invalid. An invalid alerting policy
    /// will not generate incidents.
    pub validity: std::option::Option<rpc::model::Status>,

    /// Identifies the notification channels to which notifications should be sent
    /// when incidents are opened or closed or when new violations occur on
    /// an already opened incident. Each element of this array corresponds to
    /// the `name` field in each of the
    /// [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
    /// objects that are returned from the [`ListNotificationChannels`]
    /// [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
    /// method. The format of the entries in this field is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    ///
    /// [google.monitoring.v3.NotificationChannel]: crate::model::NotificationChannel
    pub notification_channels: std::vec::Vec<std::string::String>,

    /// A read-only record of the creation of the alerting policy. If provided
    /// in a call to create or update, this field will be ignored.
    pub creation_record: std::option::Option<crate::model::MutationRecord>,

    /// A read-only record of the most recent change to the alerting policy. If
    /// provided in a call to create or update, this field will be ignored.
    pub mutation_record: std::option::Option<crate::model::MutationRecord>,

    /// Control over how this alerting policy's notification channels are notified.
    pub alert_strategy: std::option::Option<crate::model::alert_policy::AlertStrategy>,

    /// Optional. The severity of an alerting policy indicates how important
    /// incidents generated by that policy are. The severity level will be
    /// displayed on the Incident detail page and in notifications.
    pub severity: crate::model::alert_policy::Severity,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlertPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AlertPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AlertPolicy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [documentation][crate::model::AlertPolicy::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::alert_policy::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::AlertPolicy::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::alert_policy::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_labels][crate::model::AlertPolicy::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::AlertPolicy::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::alert_policy::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [combiner][crate::model::AlertPolicy::combiner].
    pub fn set_combiner<
        T: std::convert::Into<crate::model::alert_policy::ConditionCombinerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.combiner = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::AlertPolicy::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::AlertPolicy::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validity][crate::model::AlertPolicy::validity].
    pub fn set_validity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.validity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [validity][crate::model::AlertPolicy::validity].
    pub fn set_or_clear_validity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.validity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_channels][crate::model::AlertPolicy::notification_channels].
    pub fn set_notification_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.notification_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creation_record][crate::model::AlertPolicy::creation_record].
    pub fn set_creation_record<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MutationRecord>,
    {
        self.creation_record = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_record][crate::model::AlertPolicy::creation_record].
    pub fn set_or_clear_creation_record<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MutationRecord>,
    {
        self.creation_record = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mutation_record][crate::model::AlertPolicy::mutation_record].
    pub fn set_mutation_record<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MutationRecord>,
    {
        self.mutation_record = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mutation_record][crate::model::AlertPolicy::mutation_record].
    pub fn set_or_clear_mutation_record<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MutationRecord>,
    {
        self.mutation_record = v.map(|x| x.into());
        self
    }

    /// Sets the value of [alert_strategy][crate::model::AlertPolicy::alert_strategy].
    pub fn set_alert_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::alert_policy::AlertStrategy>,
    {
        self.alert_strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [alert_strategy][crate::model::AlertPolicy::alert_strategy].
    pub fn set_or_clear_alert_strategy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::alert_policy::AlertStrategy>,
    {
        self.alert_strategy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [severity][crate::model::AlertPolicy::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::alert_policy::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for AlertPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.AlertPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AlertPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __documentation,
            __user_labels,
            __conditions,
            __combiner,
            __enabled,
            __validity,
            __notification_channels,
            __creation_record,
            __mutation_record,
            __alert_strategy,
            __severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AlertPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "userLabels" => Ok(__FieldTag::__user_labels),
                            "user_labels" => Ok(__FieldTag::__user_labels),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "combiner" => Ok(__FieldTag::__combiner),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "validity" => Ok(__FieldTag::__validity),
                            "notificationChannels" => Ok(__FieldTag::__notification_channels),
                            "notification_channels" => Ok(__FieldTag::__notification_channels),
                            "creationRecord" => Ok(__FieldTag::__creation_record),
                            "creation_record" => Ok(__FieldTag::__creation_record),
                            "mutationRecord" => Ok(__FieldTag::__mutation_record),
                            "mutation_record" => Ok(__FieldTag::__mutation_record),
                            "alertStrategy" => Ok(__FieldTag::__alert_strategy),
                            "alert_strategy" => Ok(__FieldTag::__alert_strategy),
                            "severity" => Ok(__FieldTag::__severity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AlertPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AlertPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation = map.next_value::<std::option::Option<crate::model::alert_policy::Documentation>>()?
                                ;
                        }
                        __FieldTag::__user_labels => {
                            if !fields.insert(__FieldTag::__user_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_labels",
                                ));
                            }
                            result.user_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::alert_policy::Condition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__combiner => {
                            if !fields.insert(__FieldTag::__combiner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for combiner",
                                ));
                            }
                            result.combiner = map
                                .next_value::<std::option::Option<
                                    crate::model::alert_policy::ConditionCombinerType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__validity => {
                            if !fields.insert(__FieldTag::__validity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validity",
                                ));
                            }
                            result.validity =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__notification_channels => {
                            if !fields.insert(__FieldTag::__notification_channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_channels",
                                ));
                            }
                            result.notification_channels = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creation_record => {
                            if !fields.insert(__FieldTag::__creation_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_record",
                                ));
                            }
                            result.creation_record = map
                                .next_value::<std::option::Option<crate::model::MutationRecord>>(
                                )?;
                        }
                        __FieldTag::__mutation_record => {
                            if !fields.insert(__FieldTag::__mutation_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mutation_record",
                                ));
                            }
                            result.mutation_record = map
                                .next_value::<std::option::Option<crate::model::MutationRecord>>(
                                )?;
                        }
                        __FieldTag::__alert_strategy => {
                            if !fields.insert(__FieldTag::__alert_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alert_strategy",
                                ));
                            }
                            result.alert_strategy = map.next_value::<std::option::Option<crate::model::alert_policy::AlertStrategy>>()?
                                ;
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<crate::model::alert_policy::Severity>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AlertPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !wkt::internal::is_default(&self.combiner) {
            state.serialize_entry("combiner", &self.combiner)?;
        }
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.validity.is_some() {
            state.serialize_entry("validity", &self.validity)?;
        }
        if !self.notification_channels.is_empty() {
            state.serialize_entry("notificationChannels", &self.notification_channels)?;
        }
        if self.creation_record.is_some() {
            state.serialize_entry("creationRecord", &self.creation_record)?;
        }
        if self.mutation_record.is_some() {
            state.serialize_entry("mutationRecord", &self.mutation_record)?;
        }
        if self.alert_strategy.is_some() {
            state.serialize_entry("alertStrategy", &self.alert_strategy)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AlertPolicy].
pub mod alert_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Documentation that is included in the notifications and incidents
    /// pertaining to this policy.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Documentation {
        /// The body of the documentation, interpreted according to `mime_type`.
        /// The content may not exceed 8,192 Unicode characters and may not exceed
        /// more than 10,240 bytes when encoded in UTF-8 format, whichever is
        /// smaller. This text can be [templatized by using
        /// variables](https://cloud.google.com/monitoring/alerts/doc-variables#doc-vars).
        pub content: std::string::String,

        /// The format of the `content` field. Presently, only the value
        /// `"text/markdown"` is supported. See
        /// [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
        pub mime_type: std::string::String,

        /// Optional. The subject line of the notification. The subject line may not
        /// exceed 10,240 bytes. In notifications generated by this policy, the
        /// contents of the subject line after variable expansion will be truncated
        /// to 255 bytes or shorter at the latest UTF-8 character boundary. The
        /// 255-byte limit is recommended by [this
        /// thread](https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit).
        /// It is both the limit imposed by some third-party ticketing products and
        /// it is common to define textual fields in databases as VARCHAR(255).
        ///
        /// The contents of the subject line can be [templatized by using
        /// variables](https://cloud.google.com/monitoring/alerts/doc-variables#doc-vars).
        /// If this field is missing or empty, a default subject line will be
        /// generated.
        pub subject: std::string::String,

        /// Optional. Links to content such as playbooks, repositories, and other
        /// resources. This field can contain up to 3 entries.
        pub links: std::vec::Vec<crate::model::alert_policy::documentation::Link>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Documentation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [content][crate::model::alert_policy::Documentation::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }

        /// Sets the value of [mime_type][crate::model::alert_policy::Documentation::mime_type].
        pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mime_type = v.into();
            self
        }

        /// Sets the value of [subject][crate::model::alert_policy::Documentation::subject].
        pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subject = v.into();
            self
        }

        /// Sets the value of [links][crate::model::alert_policy::Documentation::links].
        pub fn set_links<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::alert_policy::documentation::Link>,
        {
            use std::iter::Iterator;
            self.links = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Documentation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.AlertPolicy.Documentation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Documentation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __content,
                __mime_type,
                __subject,
                __links,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Documentation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "content" => Ok(__FieldTag::__content),
                                "mimeType" => Ok(__FieldTag::__mime_type),
                                "mime_type" => Ok(__FieldTag::__mime_type),
                                "subject" => Ok(__FieldTag::__subject),
                                "links" => Ok(__FieldTag::__links),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Documentation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Documentation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__content => {
                                if !fields.insert(__FieldTag::__content) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for content",
                                    ));
                                }
                                result.content = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mime_type => {
                                if !fields.insert(__FieldTag::__mime_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mime_type",
                                    ));
                                }
                                result.mime_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__subject => {
                                if !fields.insert(__FieldTag::__subject) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subject",
                                    ));
                                }
                                result.subject = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__links => {
                                if !fields.insert(__FieldTag::__links) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for links",
                                    ));
                                }
                                result.links = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::alert_policy::documentation::Link,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Documentation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.content.is_empty() {
                state.serialize_entry("content", &self.content)?;
            }
            if !self.mime_type.is_empty() {
                state.serialize_entry("mimeType", &self.mime_type)?;
            }
            if !self.subject.is_empty() {
                state.serialize_entry("subject", &self.subject)?;
            }
            if !self.links.is_empty() {
                state.serialize_entry("links", &self.links)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Documentation].
    pub mod documentation {
        #[allow(unused_imports)]
        use super::*;

        /// Links to content such as playbooks, repositories, and other resources.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Link {
            /// A short display name for the link. The display name must not be empty
            /// or exceed 63 characters. Example: "playbook".
            pub display_name: std::string::String,

            /// The url of a webpage.
            /// A url can be templatized by using variables
            /// in the path or the query parameters. The total length of a URL should
            /// not exceed 2083 characters before and after variable expansion.
            /// Example: `https://my_domain.com/playbook?name=${resource.name}`
            pub url: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Link {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [display_name][crate::model::alert_policy::documentation::Link::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [url][crate::model::alert_policy::documentation::Link::url].
            pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.url = v.into();
                self
            }
        }

        impl wkt::message::Message for Link {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Documentation.Link"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Link {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __display_name,
                    __url,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Link")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "url" => Ok(__FieldTag::__url),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Link;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Link")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__url => {
                                    if !fields.insert(__FieldTag::__url) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for url"),
                                        );
                                    }
                                    result.url = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Link {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.url.is_empty() {
                    state.serialize_entry("url", &self.url)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// A condition is a true/false test that determines when an alerting policy
    /// should open an incident. If a condition evaluates to true, it signifies
    /// that something is wrong.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Condition {
        /// Required if the condition exists. The unique resource name for this
        /// condition. Its format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
        /// ```
        ///
        /// `[CONDITION_ID]` is assigned by Cloud Monitoring when the
        /// condition is created as part of a new or updated alerting policy.
        ///
        /// When calling the
        /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
        /// method, do not include the `name` field in the conditions of the
        /// requested alerting policy. Cloud Monitoring creates the
        /// condition identifiers and includes them in the new policy.
        ///
        /// When calling the
        /// [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
        /// method to update a policy, including a condition `name` causes the
        /// existing condition to be updated. Conditions without names are added to
        /// the updated policy. Existing conditions are deleted if they are not
        /// updated.
        ///
        /// Best practice is to preserve `[CONDITION_ID]` if you make only small
        /// changes, such as those to condition thresholds, durations, or trigger
        /// values.  Otherwise, treat the change as a new condition and let the
        /// existing condition be deleted.
        ///
        /// [google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]: crate::client::AlertPolicyService::create_alert_policy
        /// [google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]: crate::client::AlertPolicyService::update_alert_policy
        pub name: std::string::String,

        /// A short name or phrase used to identify the condition in dashboards,
        /// notifications, and incidents. To avoid confusion, don't use the same
        /// display name for multiple conditions in the same policy.
        pub display_name: std::string::String,

        /// Only one of the following condition types will be specified.
        pub condition: std::option::Option<crate::model::alert_policy::condition::Condition>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Condition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::alert_policy::Condition::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::alert_policy::Condition::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition].
        ///
        /// Note that all the setters affecting `condition` are mutually
        /// exclusive.
        pub fn set_condition<
            T: std::convert::Into<
                    std::option::Option<crate::model::alert_policy::condition::Condition>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = v.into();
            self
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn condition_threshold(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::alert_policy::condition::MetricThreshold>,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionThreshold(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionThreshold`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_threshold<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::alert_policy::condition::MetricThreshold>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionThreshold(v.into()),
            );
            self
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionAbsent`, `None` if the field is not set or
        /// holds a different branch.
        pub fn condition_absent(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::alert_policy::condition::MetricAbsence>,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionAbsent(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionAbsent`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_absent<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::alert_policy::condition::MetricAbsence>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionAbsent(v.into()),
            );
            self
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionMatchedLog`, `None` if the field is not set or
        /// holds a different branch.
        pub fn condition_matched_log(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::alert_policy::condition::LogMatch>>
        {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionMatchedLog(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionMatchedLog`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_matched_log<
            T: std::convert::Into<std::boxed::Box<crate::model::alert_policy::condition::LogMatch>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionMatchedLog(v.into()),
            );
            self
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionMonitoringQueryLanguage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn condition_monitoring_query_language(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::alert_policy::condition::MonitoringQueryLanguageCondition,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionMonitoringQueryLanguage(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionMonitoringQueryLanguage`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_monitoring_query_language<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::alert_policy::condition::MonitoringQueryLanguageCondition,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionMonitoringQueryLanguage(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionPrometheusQueryLanguage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn condition_prometheus_query_language(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::alert_policy::condition::PrometheusQueryLanguageCondition,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionPrometheusQueryLanguage(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionPrometheusQueryLanguage`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_prometheus_query_language<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::alert_policy::condition::PrometheusQueryLanguageCondition,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionPrometheusQueryLanguage(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [condition][crate::model::alert_policy::Condition::condition]
        /// if it holds a `ConditionSql`, `None` if the field is not set or
        /// holds a different branch.
        pub fn condition_sql(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::alert_policy::condition::SqlCondition>,
        > {
            #[allow(unreachable_patterns)]
            self.condition.as_ref().and_then(|v| match v {
                crate::model::alert_policy::condition::Condition::ConditionSql(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [condition][crate::model::alert_policy::Condition::condition]
        /// to hold a `ConditionSql`.
        ///
        /// Note that all the setters affecting `condition` are
        /// mutually exclusive.
        pub fn set_condition_sql<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::alert_policy::condition::SqlCondition>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = std::option::Option::Some(
                crate::model::alert_policy::condition::Condition::ConditionSql(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Condition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Condition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __display_name,
                __condition_threshold,
                __condition_absent,
                __condition_matched_log,
                __condition_monitoring_query_language,
                __condition_prometheus_query_language,
                __condition_sql,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Condition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "conditionThreshold" => Ok(__FieldTag::__condition_threshold),
                                "condition_threshold" => Ok(__FieldTag::__condition_threshold),
                                "conditionAbsent" => Ok(__FieldTag::__condition_absent),
                                "condition_absent" => Ok(__FieldTag::__condition_absent),
                                "conditionMatchedLog" => Ok(__FieldTag::__condition_matched_log),
                                "condition_matched_log" => Ok(__FieldTag::__condition_matched_log),
                                "conditionMonitoringQueryLanguage" => {
                                    Ok(__FieldTag::__condition_monitoring_query_language)
                                }
                                "condition_monitoring_query_language" => {
                                    Ok(__FieldTag::__condition_monitoring_query_language)
                                }
                                "conditionPrometheusQueryLanguage" => {
                                    Ok(__FieldTag::__condition_prometheus_query_language)
                                }
                                "condition_prometheus_query_language" => {
                                    Ok(__FieldTag::__condition_prometheus_query_language)
                                }
                                "conditionSql" => Ok(__FieldTag::__condition_sql),
                                "condition_sql" => Ok(__FieldTag::__condition_sql),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Condition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Condition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__condition_threshold => {
                                if !fields.insert(__FieldTag::__condition_threshold) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_threshold",
                                    ));
                                }
                                if result.condition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `condition`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.condition_threshold, latest field was conditionThreshold",
                                    ));
                                }
                                result.condition = std::option::Option::Some(
                                    crate::model::alert_policy::condition::Condition::ConditionThreshold(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::MetricThreshold>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__condition_absent => {
                                if !fields.insert(__FieldTag::__condition_absent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_absent",
                                    ));
                                }
                                if result.condition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `condition`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.condition_absent, latest field was conditionAbsent",
                                    ));
                                }
                                result.condition = std::option::Option::Some(
                                    crate::model::alert_policy::condition::Condition::ConditionAbsent(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::MetricAbsence>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__condition_matched_log => {
                                if !fields.insert(__FieldTag::__condition_matched_log) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_matched_log",
                                    ));
                                }
                                if result.condition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `condition`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.condition_matched_log, latest field was conditionMatchedLog",
                                    ));
                                }
                                result.condition = std::option::Option::Some(
                                    crate::model::alert_policy::condition::Condition::ConditionMatchedLog(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::LogMatch>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__condition_monitoring_query_language => {
                                if !fields.insert(__FieldTag::__condition_monitoring_query_language)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_monitoring_query_language",
                                    ));
                                }
                                if result.condition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `condition`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.condition_monitoring_query_language, latest field was conditionMonitoringQueryLanguage",
                                    ));
                                }
                                result.condition = std::option::Option::Some(
                                    crate::model::alert_policy::condition::Condition::ConditionMonitoringQueryLanguage(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::MonitoringQueryLanguageCondition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__condition_prometheus_query_language => {
                                if !fields.insert(__FieldTag::__condition_prometheus_query_language)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_prometheus_query_language",
                                    ));
                                }
                                if result.condition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `condition`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.condition_prometheus_query_language, latest field was conditionPrometheusQueryLanguage",
                                    ));
                                }
                                result.condition = std::option::Option::Some(
                                    crate::model::alert_policy::condition::Condition::ConditionPrometheusQueryLanguage(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::PrometheusQueryLanguageCondition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__condition_sql => {
                                if !fields.insert(__FieldTag::__condition_sql) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_sql",
                                    ));
                                }
                                if result.condition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `condition`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.condition_sql, latest field was conditionSql",
                                    ));
                                }
                                result.condition = std::option::Option::Some(
                                    crate::model::alert_policy::condition::Condition::ConditionSql(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::alert_policy::condition::SqlCondition,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Condition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if let Some(value) = self.condition_threshold() {
                state.serialize_entry("conditionThreshold", value)?;
            }
            if let Some(value) = self.condition_absent() {
                state.serialize_entry("conditionAbsent", value)?;
            }
            if let Some(value) = self.condition_matched_log() {
                state.serialize_entry("conditionMatchedLog", value)?;
            }
            if let Some(value) = self.condition_monitoring_query_language() {
                state.serialize_entry("conditionMonitoringQueryLanguage", value)?;
            }
            if let Some(value) = self.condition_prometheus_query_language() {
                state.serialize_entry("conditionPrometheusQueryLanguage", value)?;
            }
            if let Some(value) = self.condition_sql() {
                state.serialize_entry("conditionSql", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Condition].
    pub mod condition {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how many time series must fail a predicate to trigger a
        /// condition. If not specified, then a `{count: 1}` trigger is used.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Trigger {
            /// A type of trigger.
            pub r#type: std::option::Option<crate::model::alert_policy::condition::trigger::Type>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Trigger {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::alert_policy::condition::Trigger::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<
                T: std::convert::Into<
                        std::option::Option<crate::model::alert_policy::condition::trigger::Type>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// if it holds a `Count`, `None` if the field is not set or
            /// holds a different branch.
            pub fn count(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::trigger::Type::Count(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// to hold a `Count`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::alert_policy::condition::trigger::Type::Count(v.into()),
                );
                self
            }

            /// The value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// if it holds a `Percent`, `None` if the field is not set or
            /// holds a different branch.
            pub fn percent(&self) -> std::option::Option<&f64> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::trigger::Type::Percent(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::alert_policy::condition::Trigger::r#type]
            /// to hold a `Percent`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_percent<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::alert_policy::condition::trigger::Type::Percent(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Trigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.Trigger"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Trigger {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __count,
                    __percent,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Trigger")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "count" => Ok(__FieldTag::__count),
                                    "percent" => Ok(__FieldTag::__percent),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Trigger;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Trigger")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__count => {
                                    if !fields.insert(__FieldTag::__count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for count"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.Trigger.count, latest field was count",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::alert_policy::condition::trigger::Type::Count(
                                            map.next_value::<__With>()?.0.unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__percent => {
                                    if !fields.insert(__FieldTag::__percent) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for percent",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.Trigger.percent, latest field was percent",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::alert_policy::condition::trigger::Type::Percent(
                                            map.next_value::<__With>()?.0.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Trigger {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.count() {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("count", &__With(value))?;
                }
                if let Some(value) = self.percent() {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("percent", &__With(value))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Trigger].
        pub mod trigger {
            #[allow(unused_imports)]
            use super::*;

            /// A type of trigger.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// The absolute number of time series that must fail
                /// the predicate for the condition to be triggered.
                Count(i32),
                /// The percentage of time series that must fail the
                /// predicate for the condition to be triggered.
                Percent(f64),
            }
        }

        /// A condition type that compares a collection of time series
        /// against a threshold.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MetricThreshold {
            /// Required. A
            /// [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            /// identifies which time series should be compared with the threshold.
            ///
            /// The filter is similar to the one that is specified in the
            /// [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
            /// (that call is useful to verify the time series that will be retrieved /
            /// processed). The filter must specify the metric type and the resource
            /// type. Optionally, it can specify resource labels and metric labels.
            /// This field must not exceed 2048 Unicode characters in length.
            pub filter: std::string::String,

            /// Specifies the alignment of data points in individual time series as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resources). Multiple aggregations
            /// are applied in the order specified.
            ///
            /// This field is similar to the one in the [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
            /// It is advisable to use the `ListTimeSeries` method when debugging this
            /// field.
            pub aggregations: std::vec::Vec<crate::model::Aggregation>,

            /// A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            /// identifies a time series that should be used as the denominator of a
            /// ratio that will be compared with the threshold. If a
            /// `denominator_filter` is specified, the time series specified by the
            /// `filter` field will be used as the numerator.
            ///
            /// The filter must specify the metric type and optionally may contain
            /// restrictions on resource type, resource labels, and metric labels.
            /// This field may not exceed 2048 Unicode characters in length.
            pub denominator_filter: std::string::String,

            /// Specifies the alignment of data points in individual time series
            /// selected by `denominatorFilter` as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resources).
            ///
            /// When computing ratios, the `aggregations` and
            /// `denominator_aggregations` fields must use the same alignment period
            /// and produce time series that have the same periodicity and labels.
            pub denominator_aggregations: std::vec::Vec<crate::model::Aggregation>,

            /// When this field is present, the `MetricThreshold` condition forecasts
            /// whether the time series is predicted to violate the threshold within
            /// the `forecast_horizon`. When this field is not set, the
            /// `MetricThreshold` tests the current value of the timeseries against the
            /// threshold.
            pub forecast_options: std::option::Option<
                crate::model::alert_policy::condition::metric_threshold::ForecastOptions,
            >,

            /// The comparison to apply between the time series (indicated by `filter`
            /// and `aggregation`) and the threshold (indicated by `threshold_value`).
            /// The comparison is applied on each time series, with the time series
            /// on the left-hand side and the threshold on the right-hand side.
            ///
            /// Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
            pub comparison: crate::model::ComparisonType,

            /// A value against which to compare the time series.
            pub threshold_value: f64,

            /// The amount of time that a time series must violate the
            /// threshold to be considered failing. Currently, only values
            /// that are a multiple of a minute--e.g., 0, 60, 120, or 300
            /// seconds--are supported. If an invalid value is given, an
            /// error will be returned. When choosing a duration, it is useful to
            /// keep in mind the frequency of the underlying time series data
            /// (which may also be affected by any alignments specified in the
            /// `aggregations` field); a good duration is long enough so that a single
            /// outlier does not generate spurious alerts, but short enough that
            /// unhealthy states are detected and alerted on quickly.
            pub duration: std::option::Option<wkt::Duration>,

            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`,
            /// or by the ratio, if `denominator_filter` and `denominator_aggregations`
            /// are specified.
            pub trigger: std::option::Option<crate::model::alert_policy::condition::Trigger>,

            /// A condition control that determines how metric-threshold conditions
            /// are evaluated when data stops arriving. To use this control, the value
            /// of the `duration` field must be greater than or equal to 60 seconds.
            pub evaluation_missing_data:
                crate::model::alert_policy::condition::EvaluationMissingData,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MetricThreshold {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [filter][crate::model::alert_policy::condition::MetricThreshold::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [aggregations][crate::model::alert_policy::condition::MetricThreshold::aggregations].
            pub fn set_aggregations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Aggregation>,
            {
                use std::iter::Iterator;
                self.aggregations = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [denominator_filter][crate::model::alert_policy::condition::MetricThreshold::denominator_filter].
            pub fn set_denominator_filter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.denominator_filter = v.into();
                self
            }

            /// Sets the value of [denominator_aggregations][crate::model::alert_policy::condition::MetricThreshold::denominator_aggregations].
            pub fn set_denominator_aggregations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Aggregation>,
            {
                use std::iter::Iterator;
                self.denominator_aggregations = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [forecast_options][crate::model::alert_policy::condition::MetricThreshold::forecast_options].
            pub fn set_forecast_options<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::alert_policy::condition::metric_threshold::ForecastOptions,
                    >,
            {
                self.forecast_options = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [forecast_options][crate::model::alert_policy::condition::MetricThreshold::forecast_options].
            pub fn set_or_clear_forecast_options<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::alert_policy::condition::metric_threshold::ForecastOptions,
                    >,
            {
                self.forecast_options = v.map(|x| x.into());
                self
            }

            /// Sets the value of [comparison][crate::model::alert_policy::condition::MetricThreshold::comparison].
            pub fn set_comparison<T: std::convert::Into<crate::model::ComparisonType>>(
                mut self,
                v: T,
            ) -> Self {
                self.comparison = v.into();
                self
            }

            /// Sets the value of [threshold_value][crate::model::alert_policy::condition::MetricThreshold::threshold_value].
            pub fn set_threshold_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.threshold_value = v.into();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::MetricThreshold::duration].
            pub fn set_duration<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [duration][crate::model::alert_policy::condition::MetricThreshold::duration].
            pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = v.map(|x| x.into());
                self
            }

            /// Sets the value of [trigger][crate::model::alert_policy::condition::MetricThreshold::trigger].
            pub fn set_trigger<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::alert_policy::condition::Trigger>,
            {
                self.trigger = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [trigger][crate::model::alert_policy::condition::MetricThreshold::trigger].
            pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::alert_policy::condition::Trigger>,
            {
                self.trigger = v.map(|x| x.into());
                self
            }

            /// Sets the value of [evaluation_missing_data][crate::model::alert_policy::condition::MetricThreshold::evaluation_missing_data].
            pub fn set_evaluation_missing_data<
                T: std::convert::Into<crate::model::alert_policy::condition::EvaluationMissingData>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluation_missing_data = v.into();
                self
            }
        }

        impl wkt::message::Message for MetricThreshold {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MetricThreshold"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MetricThreshold {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __filter,
                    __aggregations,
                    __denominator_filter,
                    __denominator_aggregations,
                    __forecast_options,
                    __comparison,
                    __threshold_value,
                    __duration,
                    __trigger,
                    __evaluation_missing_data,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MetricThreshold")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "filter" => Ok(__FieldTag::__filter),
                                    "aggregations" => Ok(__FieldTag::__aggregations),
                                    "denominatorFilter" => Ok(__FieldTag::__denominator_filter),
                                    "denominator_filter" => Ok(__FieldTag::__denominator_filter),
                                    "denominatorAggregations" => {
                                        Ok(__FieldTag::__denominator_aggregations)
                                    }
                                    "denominator_aggregations" => {
                                        Ok(__FieldTag::__denominator_aggregations)
                                    }
                                    "forecastOptions" => Ok(__FieldTag::__forecast_options),
                                    "forecast_options" => Ok(__FieldTag::__forecast_options),
                                    "comparison" => Ok(__FieldTag::__comparison),
                                    "thresholdValue" => Ok(__FieldTag::__threshold_value),
                                    "threshold_value" => Ok(__FieldTag::__threshold_value),
                                    "duration" => Ok(__FieldTag::__duration),
                                    "trigger" => Ok(__FieldTag::__trigger),
                                    "evaluationMissingData" => {
                                        Ok(__FieldTag::__evaluation_missing_data)
                                    }
                                    "evaluation_missing_data" => {
                                        Ok(__FieldTag::__evaluation_missing_data)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MetricThreshold;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MetricThreshold")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__filter => {
                                    if !fields.insert(__FieldTag::__filter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for filter"),
                                        );
                                    }
                                    result.filter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__aggregations => {
                                    if !fields.insert(__FieldTag::__aggregations) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for aggregations",
                                            ),
                                        );
                                    }
                                    result.aggregations = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::Aggregation>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__denominator_filter => {
                                    if !fields.insert(__FieldTag::__denominator_filter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for denominator_filter",
                                            ),
                                        );
                                    }
                                    result.denominator_filter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__denominator_aggregations => {
                                    if !fields.insert(__FieldTag::__denominator_aggregations) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for denominator_aggregations",
                                            ),
                                        );
                                    }
                                    result.denominator_aggregations = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::Aggregation>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__forecast_options => {
                                    if !fields.insert(__FieldTag::__forecast_options) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for forecast_options",
                                            ),
                                        );
                                    }
                                    result.forecast_options = map.next_value::<std::option::Option<crate::model::alert_policy::condition::metric_threshold::ForecastOptions>>()?
                                        ;
                                }
                                __FieldTag::__comparison => {
                                    if !fields.insert(__FieldTag::__comparison) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for comparison",
                                            ),
                                        );
                                    }
                                    result.comparison = map.next_value::<std::option::Option<crate::model::ComparisonType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__threshold_value => {
                                    if !fields.insert(__FieldTag::__threshold_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for threshold_value",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.threshold_value =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__duration => {
                                    if !fields.insert(__FieldTag::__duration) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for duration",
                                            ),
                                        );
                                    }
                                    result.duration =
                                        map.next_value::<std::option::Option<wkt::Duration>>()?;
                                }
                                __FieldTag::__trigger => {
                                    if !fields.insert(__FieldTag::__trigger) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for trigger",
                                            ),
                                        );
                                    }
                                    result.trigger = map.next_value::<std::option::Option<
                                        crate::model::alert_policy::condition::Trigger,
                                    >>()?;
                                }
                                __FieldTag::__evaluation_missing_data => {
                                    if !fields.insert(__FieldTag::__evaluation_missing_data) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for evaluation_missing_data",
                                            ),
                                        );
                                    }
                                    result.evaluation_missing_data = map.next_value::<std::option::Option<crate::model::alert_policy::condition::EvaluationMissingData>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MetricThreshold {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.filter.is_empty() {
                    state.serialize_entry("filter", &self.filter)?;
                }
                if !self.aggregations.is_empty() {
                    state.serialize_entry("aggregations", &self.aggregations)?;
                }
                if !self.denominator_filter.is_empty() {
                    state.serialize_entry("denominatorFilter", &self.denominator_filter)?;
                }
                if !self.denominator_aggregations.is_empty() {
                    state.serialize_entry(
                        "denominatorAggregations",
                        &self.denominator_aggregations,
                    )?;
                }
                if self.forecast_options.is_some() {
                    state.serialize_entry("forecastOptions", &self.forecast_options)?;
                }
                if !wkt::internal::is_default(&self.comparison) {
                    state.serialize_entry("comparison", &self.comparison)?;
                }
                if !wkt::internal::is_default(&self.threshold_value) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("thresholdValue", &__With(&self.threshold_value))?;
                }
                if self.duration.is_some() {
                    state.serialize_entry("duration", &self.duration)?;
                }
                if self.trigger.is_some() {
                    state.serialize_entry("trigger", &self.trigger)?;
                }
                if !wkt::internal::is_default(&self.evaluation_missing_data) {
                    state
                        .serialize_entry("evaluationMissingData", &self.evaluation_missing_data)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [MetricThreshold].
        pub mod metric_threshold {
            #[allow(unused_imports)]
            use super::*;

            /// Options used when forecasting the time series and testing
            /// the predicted value against the threshold.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ForecastOptions {
                /// Required. The length of time into the future to forecast whether a
                /// time series will violate the threshold. If the predicted value is
                /// found to violate the threshold, and the violation is observed in all
                /// forecasts made for the configured `duration`, then the time series is
                /// considered to be failing.
                /// The forecast horizon can range from 1 hour to 60 hours.
                pub forecast_horizon: std::option::Option<wkt::Duration>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ForecastOptions {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [forecast_horizon][crate::model::alert_policy::condition::metric_threshold::ForecastOptions::forecast_horizon].
                pub fn set_forecast_horizon<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.forecast_horizon = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [forecast_horizon][crate::model::alert_policy::condition::metric_threshold::ForecastOptions::forecast_horizon].
                pub fn set_or_clear_forecast_horizon<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.forecast_horizon = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ForecastOptions {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ForecastOptions {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __forecast_horizon,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ForecastOptions")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "forecastHorizon" => Ok(__FieldTag::__forecast_horizon),
                                        "forecast_horizon" => Ok(__FieldTag::__forecast_horizon),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ForecastOptions;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ForecastOptions")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__forecast_horizon => {
                                        if !fields.insert(__FieldTag::__forecast_horizon) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for forecast_horizon",
                                                ),
                                            );
                                        }
                                        result.forecast_horizon =
                                            map.next_value::<std::option::Option<wkt::Duration>>()?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ForecastOptions {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.forecast_horizon.is_some() {
                        state.serialize_entry("forecastHorizon", &self.forecast_horizon)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// A condition type that checks that monitored resources
        /// are reporting data. The configuration defines a metric and
        /// a set of monitored resources. The predicate is considered in violation
        /// when a time series for the specified metric of a monitored
        /// resource does not include any data in the specified `duration`.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MetricAbsence {
            /// Required. A
            /// [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            /// identifies which time series should be compared with the threshold.
            ///
            /// The filter is similar to the one that is specified in the
            /// [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
            /// (that call is useful to verify the time series that will be retrieved /
            /// processed). The filter must specify the metric type and the resource
            /// type. Optionally, it can specify resource labels and metric labels.
            /// This field must not exceed 2048 Unicode characters in length.
            pub filter: std::string::String,

            /// Specifies the alignment of data points in individual time series as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resources). Multiple aggregations
            /// are applied in the order specified.
            ///
            /// This field is similar to the one in the [`ListTimeSeries`
            /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
            /// It is advisable to use the `ListTimeSeries` method when debugging this
            /// field.
            pub aggregations: std::vec::Vec<crate::model::Aggregation>,

            /// The amount of time that a time series must fail to report new
            /// data to be considered failing. The minimum value of this field
            /// is 120 seconds. Larger values that are a multiple of a
            /// minute--for example, 240 or 300 seconds--are supported.
            /// If an invalid value is given, an
            /// error will be returned. The `Duration.nanos` field is
            /// ignored.
            pub duration: std::option::Option<wkt::Duration>,

            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`.
            pub trigger: std::option::Option<crate::model::alert_policy::condition::Trigger>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MetricAbsence {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [filter][crate::model::alert_policy::condition::MetricAbsence::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [aggregations][crate::model::alert_policy::condition::MetricAbsence::aggregations].
            pub fn set_aggregations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Aggregation>,
            {
                use std::iter::Iterator;
                self.aggregations = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::MetricAbsence::duration].
            pub fn set_duration<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [duration][crate::model::alert_policy::condition::MetricAbsence::duration].
            pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = v.map(|x| x.into());
                self
            }

            /// Sets the value of [trigger][crate::model::alert_policy::condition::MetricAbsence::trigger].
            pub fn set_trigger<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::alert_policy::condition::Trigger>,
            {
                self.trigger = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [trigger][crate::model::alert_policy::condition::MetricAbsence::trigger].
            pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::alert_policy::condition::Trigger>,
            {
                self.trigger = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for MetricAbsence {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MetricAbsence"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MetricAbsence {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __filter,
                    __aggregations,
                    __duration,
                    __trigger,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MetricAbsence")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "filter" => Ok(__FieldTag::__filter),
                                    "aggregations" => Ok(__FieldTag::__aggregations),
                                    "duration" => Ok(__FieldTag::__duration),
                                    "trigger" => Ok(__FieldTag::__trigger),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MetricAbsence;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MetricAbsence")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__filter => {
                                    if !fields.insert(__FieldTag::__filter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for filter"),
                                        );
                                    }
                                    result.filter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__aggregations => {
                                    if !fields.insert(__FieldTag::__aggregations) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for aggregations",
                                            ),
                                        );
                                    }
                                    result.aggregations = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::Aggregation>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__duration => {
                                    if !fields.insert(__FieldTag::__duration) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for duration",
                                            ),
                                        );
                                    }
                                    result.duration =
                                        map.next_value::<std::option::Option<wkt::Duration>>()?;
                                }
                                __FieldTag::__trigger => {
                                    if !fields.insert(__FieldTag::__trigger) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for trigger",
                                            ),
                                        );
                                    }
                                    result.trigger = map.next_value::<std::option::Option<
                                        crate::model::alert_policy::condition::Trigger,
                                    >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MetricAbsence {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.filter.is_empty() {
                    state.serialize_entry("filter", &self.filter)?;
                }
                if !self.aggregations.is_empty() {
                    state.serialize_entry("aggregations", &self.aggregations)?;
                }
                if self.duration.is_some() {
                    state.serialize_entry("duration", &self.duration)?;
                }
                if self.trigger.is_some() {
                    state.serialize_entry("trigger", &self.trigger)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// A condition type that checks whether a log message in the [scoping
        /// project](https://cloud.google.com/monitoring/api/v3#project_name)
        /// satisfies the given filter. Logs from other projects in the metrics
        /// scope are not evaluated.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct LogMatch {
            /// Required. A logs-based filter. See [Advanced Logs
            /// Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
            /// for how this filter should be constructed.
            pub filter: std::string::String,

            /// Optional. A map from a label key to an extractor expression, which is
            /// used to extract the value for this label key. Each entry in this map is
            /// a specification for how data should be extracted from log entries that
            /// match `filter`. Each combination of extracted values is treated as a
            /// separate rule for the purposes of triggering notifications. Label keys
            /// and corresponding values can be used in notifications generated by this
            /// condition.
            ///
            /// Please see [the documentation on logs-based metric
            /// `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
            /// for syntax and examples.
            pub label_extractors:
                std::collections::HashMap<std::string::String, std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LogMatch {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [filter][crate::model::alert_policy::condition::LogMatch::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [label_extractors][crate::model::alert_policy::condition::LogMatch::label_extractors].
            pub fn set_label_extractors<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.label_extractors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for LogMatch {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.LogMatch"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for LogMatch {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __filter,
                    __label_extractors,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for LogMatch")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "filter" => Ok(__FieldTag::__filter),
                                    "labelExtractors" => Ok(__FieldTag::__label_extractors),
                                    "label_extractors" => Ok(__FieldTag::__label_extractors),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = LogMatch;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct LogMatch")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__filter => {
                                    if !fields.insert(__FieldTag::__filter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for filter"),
                                        );
                                    }
                                    result.filter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__label_extractors => {
                                    if !fields.insert(__FieldTag::__label_extractors) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for label_extractors",
                                            ),
                                        );
                                    }
                                    result.label_extractors = map
                                        .next_value::<std::option::Option<
                                            std::collections::HashMap<
                                                std::string::String,
                                                std::string::String,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for LogMatch {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.filter.is_empty() {
                    state.serialize_entry("filter", &self.filter)?;
                }
                if !self.label_extractors.is_empty() {
                    state.serialize_entry("labelExtractors", &self.label_extractors)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// A condition type that allows alerting policies to be defined using
        /// [Monitoring Query Language](https://cloud.google.com/monitoring/mql).
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MonitoringQueryLanguageCondition {
            /// [Monitoring Query Language](https://cloud.google.com/monitoring/mql)
            /// query that outputs a boolean stream.
            pub query: std::string::String,

            /// The amount of time that a time series must violate the
            /// threshold to be considered failing. Currently, only values
            /// that are a multiple of a minute--e.g., 0, 60, 120, or 300
            /// seconds--are supported. If an invalid value is given, an
            /// error will be returned. When choosing a duration, it is useful to
            /// keep in mind the frequency of the underlying time series data
            /// (which may also be affected by any alignments specified in the
            /// `aggregations` field); a good duration is long enough so that a single
            /// outlier does not generate spurious alerts, but short enough that
            /// unhealthy states are detected and alerted on quickly.
            pub duration: std::option::Option<wkt::Duration>,

            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`,
            /// or by the ratio, if `denominator_filter` and `denominator_aggregations`
            /// are specified.
            pub trigger: std::option::Option<crate::model::alert_policy::condition::Trigger>,

            /// A condition control that determines how metric-threshold conditions
            /// are evaluated when data stops arriving.
            pub evaluation_missing_data:
                crate::model::alert_policy::condition::EvaluationMissingData,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MonitoringQueryLanguageCondition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [query][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::duration].
            pub fn set_duration<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [duration][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::duration].
            pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = v.map(|x| x.into());
                self
            }

            /// Sets the value of [trigger][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::trigger].
            pub fn set_trigger<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::alert_policy::condition::Trigger>,
            {
                self.trigger = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [trigger][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::trigger].
            pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::alert_policy::condition::Trigger>,
            {
                self.trigger = v.map(|x| x.into());
                self
            }

            /// Sets the value of [evaluation_missing_data][crate::model::alert_policy::condition::MonitoringQueryLanguageCondition::evaluation_missing_data].
            pub fn set_evaluation_missing_data<
                T: std::convert::Into<crate::model::alert_policy::condition::EvaluationMissingData>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluation_missing_data = v.into();
                self
            }
        }

        impl wkt::message::Message for MonitoringQueryLanguageCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MonitoringQueryLanguageCondition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __query,
                    __duration,
                    __trigger,
                    __evaluation_missing_data,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for MonitoringQueryLanguageCondition")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "query" => Ok(__FieldTag::__query),
                                    "duration" => Ok(__FieldTag::__duration),
                                    "trigger" => Ok(__FieldTag::__trigger),
                                    "evaluationMissingData" => {
                                        Ok(__FieldTag::__evaluation_missing_data)
                                    }
                                    "evaluation_missing_data" => {
                                        Ok(__FieldTag::__evaluation_missing_data)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MonitoringQueryLanguageCondition;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MonitoringQueryLanguageCondition")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__query => {
                                    if !fields.insert(__FieldTag::__query) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for query"),
                                        );
                                    }
                                    result.query = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__duration => {
                                    if !fields.insert(__FieldTag::__duration) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for duration",
                                            ),
                                        );
                                    }
                                    result.duration =
                                        map.next_value::<std::option::Option<wkt::Duration>>()?;
                                }
                                __FieldTag::__trigger => {
                                    if !fields.insert(__FieldTag::__trigger) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for trigger",
                                            ),
                                        );
                                    }
                                    result.trigger = map.next_value::<std::option::Option<
                                        crate::model::alert_policy::condition::Trigger,
                                    >>()?;
                                }
                                __FieldTag::__evaluation_missing_data => {
                                    if !fields.insert(__FieldTag::__evaluation_missing_data) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for evaluation_missing_data",
                                            ),
                                        );
                                    }
                                    result.evaluation_missing_data = map.next_value::<std::option::Option<crate::model::alert_policy::condition::EvaluationMissingData>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MonitoringQueryLanguageCondition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.query.is_empty() {
                    state.serialize_entry("query", &self.query)?;
                }
                if self.duration.is_some() {
                    state.serialize_entry("duration", &self.duration)?;
                }
                if self.trigger.is_some() {
                    state.serialize_entry("trigger", &self.trigger)?;
                }
                if !wkt::internal::is_default(&self.evaluation_missing_data) {
                    state
                        .serialize_entry("evaluationMissingData", &self.evaluation_missing_data)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// A condition type that allows alerting policies to be defined using
        /// [Prometheus Query Language
        /// (PromQL)](https://prometheus.io/docs/prometheus/latest/querying/basics/).
        ///
        /// The PrometheusQueryLanguageCondition message contains information
        /// from a Prometheus alerting rule and its associated rule group.
        ///
        /// A Prometheus alerting rule is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/).
        /// The semantics of a Prometheus alerting rule is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).
        ///
        /// A Prometheus rule group is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/).
        /// The semantics of a Prometheus rule group is described
        /// [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).
        ///
        /// Because Cloud Alerting has no representation of a Prometheus rule
        /// group resource, we must embed the information of the parent rule
        /// group inside each of the conditions that refer to it. We must also
        /// update the contents of all Prometheus alerts in case the information
        /// of their rule group changes.
        ///
        /// The PrometheusQueryLanguageCondition protocol buffer combines the
        /// information of the corresponding rule group and alerting rule.
        /// The structure of the PrometheusQueryLanguageCondition protocol buffer
        /// does NOT mimic the structure of the Prometheus rule group and alerting
        /// rule YAML declarations. The PrometheusQueryLanguageCondition protocol
        /// buffer may change in the future to support future rule group and/or
        /// alerting rule features. There are no new such features at the present
        /// time (2023-06-26).
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PrometheusQueryLanguageCondition {
            /// Required. The PromQL expression to evaluate. Every evaluation cycle
            /// this expression is evaluated at the current time, and all resultant
            /// time series become pending/firing alerts. This field must not be empty.
            pub query: std::string::String,

            /// Optional. Alerts are considered firing once their PromQL expression was
            /// evaluated to be "true" for this long.
            /// Alerts whose PromQL expression was not evaluated to be "true" for
            /// long enough are considered pending.
            /// Must be a non-negative duration or missing.
            /// This field is optional. Its default value is zero.
            pub duration: std::option::Option<wkt::Duration>,

            /// Optional. How often this rule should be evaluated.
            /// Must be a positive multiple of 30 seconds or missing.
            /// This field is optional. Its default value is 30 seconds.
            /// If this PrometheusQueryLanguageCondition was generated from a
            /// Prometheus alerting rule, then this value should be taken from the
            /// enclosing rule group.
            pub evaluation_interval: std::option::Option<wkt::Duration>,

            /// Optional. Labels to add to or overwrite in the PromQL query result.
            /// Label names [must be
            /// valid](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
            /// Label values can be [templatized by using
            /// variables](https://cloud.google.com/monitoring/alerts/doc-variables#doc-vars).
            /// The only available variable names are the names of the labels in the
            /// PromQL result, including "__name__" and "value". "labels" may be empty.
            pub labels: std::collections::HashMap<std::string::String, std::string::String>,

            /// Optional. The rule group name of this alert in the corresponding
            /// Prometheus configuration file.
            ///
            /// Some external tools may require this field to be populated correctly
            /// in order to refer to the original Prometheus configuration file.
            /// The rule group name and the alert name are necessary to update the
            /// relevant AlertPolicies in case the definition of the rule group changes
            /// in the future.
            ///
            /// This field is optional. If this field is not empty, then it must
            /// contain a valid UTF-8 string.
            /// This field may not exceed 2048 Unicode characters in length.
            pub rule_group: std::string::String,

            /// Optional. The alerting rule name of this alert in the corresponding
            /// Prometheus configuration file.
            ///
            /// Some external tools may require this field to be populated correctly
            /// in order to refer to the original Prometheus configuration file.
            /// The rule group name and the alert name are necessary to update the
            /// relevant AlertPolicies in case the definition of the rule group changes
            /// in the future.
            ///
            /// This field is optional. If this field is not empty, then it must be a
            /// [valid Prometheus label
            /// name](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
            /// This field may not exceed 2048 Unicode characters in length.
            pub alert_rule: std::string::String,

            /// Optional. Whether to disable metric existence validation for this
            /// condition.
            ///
            /// This allows alerting policies to be defined on metrics that do not yet
            /// exist, improving advanced customer workflows such as configuring
            /// alerting policies using Terraform.
            ///
            /// Users with the `monitoring.alertPolicyViewer` role are able to see the
            /// name of the non-existent metric in the alerting policy condition.
            pub disable_metric_validation: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PrometheusQueryLanguageCondition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [query][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [duration][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::duration].
            pub fn set_duration<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [duration][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::duration].
            pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.duration = v.map(|x| x.into());
                self
            }

            /// Sets the value of [evaluation_interval][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::evaluation_interval].
            pub fn set_evaluation_interval<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.evaluation_interval = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [evaluation_interval][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::evaluation_interval].
            pub fn set_or_clear_evaluation_interval<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.evaluation_interval = v.map(|x| x.into());
                self
            }

            /// Sets the value of [labels][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::labels].
            pub fn set_labels<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }

            /// Sets the value of [rule_group][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::rule_group].
            pub fn set_rule_group<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.rule_group = v.into();
                self
            }

            /// Sets the value of [alert_rule][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::alert_rule].
            pub fn set_alert_rule<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.alert_rule = v.into();
                self
            }

            /// Sets the value of [disable_metric_validation][crate::model::alert_policy::condition::PrometheusQueryLanguageCondition::disable_metric_validation].
            pub fn set_disable_metric_validation<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.disable_metric_validation = v.into();
                self
            }
        }

        impl wkt::message::Message for PrometheusQueryLanguageCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.PrometheusQueryLanguageCondition"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PrometheusQueryLanguageCondition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __query,
                    __duration,
                    __evaluation_interval,
                    __labels,
                    __rule_group,
                    __alert_rule,
                    __disable_metric_validation,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for PrometheusQueryLanguageCondition")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "query" => Ok(__FieldTag::__query),
                                    "duration" => Ok(__FieldTag::__duration),
                                    "evaluationInterval" => Ok(__FieldTag::__evaluation_interval),
                                    "evaluation_interval" => Ok(__FieldTag::__evaluation_interval),
                                    "labels" => Ok(__FieldTag::__labels),
                                    "ruleGroup" => Ok(__FieldTag::__rule_group),
                                    "rule_group" => Ok(__FieldTag::__rule_group),
                                    "alertRule" => Ok(__FieldTag::__alert_rule),
                                    "alert_rule" => Ok(__FieldTag::__alert_rule),
                                    "disableMetricValidation" => {
                                        Ok(__FieldTag::__disable_metric_validation)
                                    }
                                    "disable_metric_validation" => {
                                        Ok(__FieldTag::__disable_metric_validation)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PrometheusQueryLanguageCondition;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PrometheusQueryLanguageCondition")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__query => {
                                    if !fields.insert(__FieldTag::__query) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for query"),
                                        );
                                    }
                                    result.query = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__duration => {
                                    if !fields.insert(__FieldTag::__duration) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for duration",
                                            ),
                                        );
                                    }
                                    result.duration =
                                        map.next_value::<std::option::Option<wkt::Duration>>()?;
                                }
                                __FieldTag::__evaluation_interval => {
                                    if !fields.insert(__FieldTag::__evaluation_interval) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for evaluation_interval",
                                            ),
                                        );
                                    }
                                    result.evaluation_interval =
                                        map.next_value::<std::option::Option<wkt::Duration>>()?;
                                }
                                __FieldTag::__labels => {
                                    if !fields.insert(__FieldTag::__labels) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for labels"),
                                        );
                                    }
                                    result.labels = map
                                        .next_value::<std::option::Option<
                                            std::collections::HashMap<
                                                std::string::String,
                                                std::string::String,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__rule_group => {
                                    if !fields.insert(__FieldTag::__rule_group) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for rule_group",
                                            ),
                                        );
                                    }
                                    result.rule_group = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__alert_rule => {
                                    if !fields.insert(__FieldTag::__alert_rule) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for alert_rule",
                                            ),
                                        );
                                    }
                                    result.alert_rule = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__disable_metric_validation => {
                                    if !fields.insert(__FieldTag::__disable_metric_validation) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disable_metric_validation",
                                            ),
                                        );
                                    }
                                    result.disable_metric_validation = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PrometheusQueryLanguageCondition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.query.is_empty() {
                    state.serialize_entry("query", &self.query)?;
                }
                if self.duration.is_some() {
                    state.serialize_entry("duration", &self.duration)?;
                }
                if self.evaluation_interval.is_some() {
                    state.serialize_entry("evaluationInterval", &self.evaluation_interval)?;
                }
                if !self.labels.is_empty() {
                    state.serialize_entry("labels", &self.labels)?;
                }
                if !self.rule_group.is_empty() {
                    state.serialize_entry("ruleGroup", &self.rule_group)?;
                }
                if !self.alert_rule.is_empty() {
                    state.serialize_entry("alertRule", &self.alert_rule)?;
                }
                if !wkt::internal::is_default(&self.disable_metric_validation) {
                    state.serialize_entry(
                        "disableMetricValidation",
                        &self.disable_metric_validation,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// A condition that allows alerting policies to be defined using GoogleSQL.
        /// SQL conditions examine a sliding window of logs using GoogleSQL.
        /// Alert policies with SQL conditions may incur additional billing.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SqlCondition {
            /// Required. The Log Analytics SQL query to run, as a string.  The query
            /// must conform to the required shape. Specifically, the query must not
            /// try to filter the input by time.  A filter will automatically be
            /// applied to filter the input so that the query receives all rows
            /// received since the last time the query was run.
            ///
            /// For example, the following query extracts all log entries containing an
            /// HTTP request:
            ///
            /// ```norust
            /// SELECT
            ///   timestamp, log_name, severity, http_request, resource, labels
            /// FROM
            ///   my-project.global._Default._AllLogs
            /// WHERE
            ///   http_request IS NOT NULL
            /// ```
            pub query: std::string::String,

            /// The schedule indicates how often the query should be run.
            pub schedule:
                std::option::Option<crate::model::alert_policy::condition::sql_condition::Schedule>,

            /// The test to be run against the SQL result set.
            pub evaluate:
                std::option::Option<crate::model::alert_policy::condition::sql_condition::Evaluate>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SqlCondition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [query][crate::model::alert_policy::condition::SqlCondition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule].
            ///
            /// Note that all the setters affecting `schedule` are mutually
            /// exclusive.
            pub fn set_schedule<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::alert_policy::condition::sql_condition::Schedule,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = v.into();
                self
            }

            /// The value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// if it holds a `Minutes`, `None` if the field is not set or
            /// holds a different branch.
            pub fn minutes(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Minutes>,
            > {
                #[allow(unreachable_patterns)]
                self.schedule.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Schedule::Minutes(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// to hold a `Minutes`.
            ///
            /// Note that all the setters affecting `schedule` are
            /// mutually exclusive.
            pub fn set_minutes<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::alert_policy::condition::sql_condition::Minutes,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Schedule::Minutes(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// if it holds a `Hourly`, `None` if the field is not set or
            /// holds a different branch.
            pub fn hourly(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Hourly>,
            > {
                #[allow(unreachable_patterns)]
                self.schedule.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Schedule::Hourly(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// to hold a `Hourly`.
            ///
            /// Note that all the setters affecting `schedule` are
            /// mutually exclusive.
            pub fn set_hourly<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::alert_policy::condition::sql_condition::Hourly,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Schedule::Hourly(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// if it holds a `Daily`, `None` if the field is not set or
            /// holds a different branch.
            pub fn daily(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Daily>,
            > {
                #[allow(unreachable_patterns)]
                self.schedule.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Schedule::Daily(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [schedule][crate::model::alert_policy::condition::SqlCondition::schedule]
            /// to hold a `Daily`.
            ///
            /// Note that all the setters affecting `schedule` are
            /// mutually exclusive.
            pub fn set_daily<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::alert_policy::condition::sql_condition::Daily,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.schedule = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Schedule::Daily(v.into()),
                );
                self
            }

            /// Sets the value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate].
            ///
            /// Note that all the setters affecting `evaluate` are mutually
            /// exclusive.
            pub fn set_evaluate<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::alert_policy::condition::sql_condition::Evaluate,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluate = v.into();
                self
            }

            /// The value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// if it holds a `RowCountTest`, `None` if the field is not set or
            /// holds a different branch.
            pub fn row_count_test(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::alert_policy::condition::sql_condition::RowCountTest,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.evaluate.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Evaluate::RowCountTest(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// to hold a `RowCountTest`.
            ///
            /// Note that all the setters affecting `evaluate` are
            /// mutually exclusive.
            pub fn set_row_count_test<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::alert_policy::condition::sql_condition::RowCountTest,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluate = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Evaluate::RowCountTest(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// if it holds a `BooleanTest`, `None` if the field is not set or
            /// holds a different branch.
            pub fn boolean_test(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::alert_policy::condition::sql_condition::BooleanTest>,
            > {
                #[allow(unreachable_patterns)]
                self.evaluate.as_ref().and_then(|v| match v {
                    crate::model::alert_policy::condition::sql_condition::Evaluate::BooleanTest(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [evaluate][crate::model::alert_policy::condition::SqlCondition::evaluate]
            /// to hold a `BooleanTest`.
            ///
            /// Note that all the setters affecting `evaluate` are
            /// mutually exclusive.
            pub fn set_boolean_test<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::alert_policy::condition::sql_condition::BooleanTest,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.evaluate = std::option::Option::Some(
                    crate::model::alert_policy::condition::sql_condition::Evaluate::BooleanTest(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for SqlCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SqlCondition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __query,
                    __minutes,
                    __hourly,
                    __daily,
                    __row_count_test,
                    __boolean_test,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SqlCondition")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "query" => Ok(__FieldTag::__query),
                                    "minutes" => Ok(__FieldTag::__minutes),
                                    "hourly" => Ok(__FieldTag::__hourly),
                                    "daily" => Ok(__FieldTag::__daily),
                                    "rowCountTest" => Ok(__FieldTag::__row_count_test),
                                    "row_count_test" => Ok(__FieldTag::__row_count_test),
                                    "booleanTest" => Ok(__FieldTag::__boolean_test),
                                    "boolean_test" => Ok(__FieldTag::__boolean_test),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SqlCondition;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SqlCondition")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__query => {
                                    if !fields.insert(__FieldTag::__query) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for query"),
                                        );
                                    }
                                    result.query = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__minutes => {
                                    if !fields.insert(__FieldTag::__minutes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for minutes",
                                            ),
                                        );
                                    }
                                    if result.schedule.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `schedule`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.SqlCondition.minutes, latest field was minutes",
                                            ),
                                        );
                                    }
                                    result.schedule = std::option::Option::Some(
                                        crate::model::alert_policy::condition::sql_condition::Schedule::Minutes(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Minutes>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__hourly => {
                                    if !fields.insert(__FieldTag::__hourly) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for hourly"),
                                        );
                                    }
                                    if result.schedule.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `schedule`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.SqlCondition.hourly, latest field was hourly",
                                            ),
                                        );
                                    }
                                    result.schedule = std::option::Option::Some(
                                        crate::model::alert_policy::condition::sql_condition::Schedule::Hourly(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Hourly>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__daily => {
                                    if !fields.insert(__FieldTag::__daily) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for daily"),
                                        );
                                    }
                                    if result.schedule.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `schedule`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.SqlCondition.daily, latest field was daily",
                                            ),
                                        );
                                    }
                                    result.schedule = std::option::Option::Some(
                                        crate::model::alert_policy::condition::sql_condition::Schedule::Daily(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Daily>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__row_count_test => {
                                    if !fields.insert(__FieldTag::__row_count_test) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for row_count_test",
                                            ),
                                        );
                                    }
                                    if result.evaluate.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `evaluate`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.SqlCondition.row_count_test, latest field was rowCountTest",
                                            ),
                                        );
                                    }
                                    result.evaluate = std::option::Option::Some(
                                        crate::model::alert_policy::condition::sql_condition::Evaluate::RowCountTest(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::sql_condition::RowCountTest>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__boolean_test => {
                                    if !fields.insert(__FieldTag::__boolean_test) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for boolean_test",
                                            ),
                                        );
                                    }
                                    if result.evaluate.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `evaluate`, a oneof with full ID .google.monitoring.v3.AlertPolicy.Condition.SqlCondition.boolean_test, latest field was booleanTest",
                                            ),
                                        );
                                    }
                                    result.evaluate = std::option::Option::Some(
                                        crate::model::alert_policy::condition::sql_condition::Evaluate::BooleanTest(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::alert_policy::condition::sql_condition::BooleanTest>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for SqlCondition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.query.is_empty() {
                    state.serialize_entry("query", &self.query)?;
                }
                if let Some(value) = self.minutes() {
                    state.serialize_entry("minutes", value)?;
                }
                if let Some(value) = self.hourly() {
                    state.serialize_entry("hourly", value)?;
                }
                if let Some(value) = self.daily() {
                    state.serialize_entry("daily", value)?;
                }
                if let Some(value) = self.row_count_test() {
                    state.serialize_entry("rowCountTest", value)?;
                }
                if let Some(value) = self.boolean_test() {
                    state.serialize_entry("booleanTest", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [SqlCondition].
        pub mod sql_condition {
            #[allow(unused_imports)]
            use super::*;

            /// Used to schedule the query to run every so many minutes.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Minutes {
                /// Required. Number of minutes between runs. The interval must be
                /// greater than or equal to 5 minutes and less than or equal to 1440
                /// minutes.
                pub periodicity: i32,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Minutes {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [periodicity][crate::model::alert_policy::condition::sql_condition::Minutes::periodicity].
                pub fn set_periodicity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.periodicity = v.into();
                    self
                }
            }

            impl wkt::message::Message for Minutes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Minutes"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Minutes {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __periodicity,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Minutes")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "periodicity" => Ok(__FieldTag::__periodicity),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Minutes;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Minutes")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__periodicity => {
                                        if !fields.insert(__FieldTag::__periodicity) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for periodicity",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.periodicity =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Minutes {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.periodicity) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("periodicity", &__With(&self.periodicity))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Used to schedule the query to run every so many hours.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Hourly {
                /// Required. The number of hours between runs. Must be greater than or
                /// equal to 1 hour and less than or equal to 48 hours.
                pub periodicity: i32,

                /// Optional. The number of minutes after the hour (in UTC) to run the
                /// query. Must be greater than or equal to 0 minutes and less than or
                /// equal to 59 minutes.  If left unspecified, then an arbitrary offset
                /// is used.
                pub minute_offset: std::option::Option<i32>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Hourly {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [periodicity][crate::model::alert_policy::condition::sql_condition::Hourly::periodicity].
                pub fn set_periodicity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.periodicity = v.into();
                    self
                }

                /// Sets the value of [minute_offset][crate::model::alert_policy::condition::sql_condition::Hourly::minute_offset].
                pub fn set_minute_offset<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.minute_offset = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [minute_offset][crate::model::alert_policy::condition::sql_condition::Hourly::minute_offset].
                pub fn set_or_clear_minute_offset<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.minute_offset = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for Hourly {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Hourly"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Hourly {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __periodicity,
                        __minute_offset,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Hourly")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "periodicity" => Ok(__FieldTag::__periodicity),
                                        "minuteOffset" => Ok(__FieldTag::__minute_offset),
                                        "minute_offset" => Ok(__FieldTag::__minute_offset),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Hourly;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Hourly")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__periodicity => {
                                        if !fields.insert(__FieldTag::__periodicity) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for periodicity",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.periodicity =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__minute_offset => {
                                        if !fields.insert(__FieldTag::__minute_offset) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for minute_offset",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.minute_offset = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Hourly {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.periodicity) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("periodicity", &__With(&self.periodicity))?;
                    }
                    if self.minute_offset.is_some() {
                        struct __With<'a>(&'a std::option::Option<i32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry("minuteOffset", &__With(&self.minute_offset))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Used to schedule the query to run every so many days.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Daily {
                /// Required. The number of days between runs. Must be greater than or
                /// equal to 1 day and less than or equal to 31 days.
                pub periodicity: i32,

                /// Optional. The time of day (in UTC) at which the query should run. If
                /// left unspecified, the server picks an arbitrary time of day and runs
                /// the query at the same time each day.
                pub execution_time: std::option::Option<gtype::model::TimeOfDay>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Daily {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [periodicity][crate::model::alert_policy::condition::sql_condition::Daily::periodicity].
                pub fn set_periodicity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.periodicity = v.into();
                    self
                }

                /// Sets the value of [execution_time][crate::model::alert_policy::condition::sql_condition::Daily::execution_time].
                pub fn set_execution_time<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<gtype::model::TimeOfDay>,
                {
                    self.execution_time = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [execution_time][crate::model::alert_policy::condition::sql_condition::Daily::execution_time].
                pub fn set_or_clear_execution_time<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<gtype::model::TimeOfDay>,
                {
                    self.execution_time = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for Daily {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Daily"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Daily {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __periodicity,
                        __execution_time,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Daily")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "periodicity" => Ok(__FieldTag::__periodicity),
                                        "executionTime" => Ok(__FieldTag::__execution_time),
                                        "execution_time" => Ok(__FieldTag::__execution_time),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Daily;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Daily")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__periodicity => {
                                        if !fields.insert(__FieldTag::__periodicity) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for periodicity",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.periodicity =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__execution_time => {
                                        if !fields.insert(__FieldTag::__execution_time) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for execution_time",
                                                ),
                                            );
                                        }
                                        result.execution_time = map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?
                                            ;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Daily {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.periodicity) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("periodicity", &__With(&self.periodicity))?;
                    }
                    if self.execution_time.is_some() {
                        state.serialize_entry("executionTime", &self.execution_time)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// A test that checks if the number of rows in the result set
            /// violates some threshold.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct RowCountTest {
                /// Required. The comparison to apply between the number of rows returned
                /// by the query and the threshold.
                pub comparison: crate::model::ComparisonType,

                /// Required. The value against which to compare the row count.
                pub threshold: i64,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl RowCountTest {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [comparison][crate::model::alert_policy::condition::sql_condition::RowCountTest::comparison].
                pub fn set_comparison<T: std::convert::Into<crate::model::ComparisonType>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.comparison = v.into();
                    self
                }

                /// Sets the value of [threshold][crate::model::alert_policy::condition::sql_condition::RowCountTest::threshold].
                pub fn set_threshold<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.threshold = v.into();
                    self
                }
            }

            impl wkt::message::Message for RowCountTest {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.RowCountTest"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for RowCountTest {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __comparison,
                        __threshold,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for RowCountTest")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "comparison" => Ok(__FieldTag::__comparison),
                                        "threshold" => Ok(__FieldTag::__threshold),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = RowCountTest;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct RowCountTest")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__comparison => {
                                        if !fields.insert(__FieldTag::__comparison) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for comparison",
                                                ),
                                            );
                                        }
                                        result.comparison = map.next_value::<std::option::Option<crate::model::ComparisonType>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__threshold => {
                                        if !fields.insert(__FieldTag::__threshold) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for threshold",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.threshold =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for RowCountTest {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.comparison) {
                        state.serialize_entry("comparison", &self.comparison)?;
                    }
                    if !wkt::internal::is_default(&self.threshold) {
                        struct __With<'a>(&'a i64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("threshold", &__With(&self.threshold))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// A test that uses an alerting result in a boolean column produced by
            /// the SQL query.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct BooleanTest {
                /// Required. The name of the column containing the boolean value. If the
                /// value in a row is NULL, that row is ignored.
                pub column: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl BooleanTest {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [column][crate::model::alert_policy::condition::sql_condition::BooleanTest::column].
                pub fn set_column<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.column = v.into();
                    self
                }
            }

            impl wkt::message::Message for BooleanTest {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.monitoring.v3.AlertPolicy.Condition.SqlCondition.BooleanTest"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for BooleanTest {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __column,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for BooleanTest")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "column" => Ok(__FieldTag::__column),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = BooleanTest;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct BooleanTest")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__column => {
                                        if !fields.insert(__FieldTag::__column) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for column",
                                                ),
                                            );
                                        }
                                        result.column = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for BooleanTest {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.column.is_empty() {
                        state.serialize_entry("column", &self.column)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// The schedule indicates how often the query should be run.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Schedule {
                /// Schedule the query to execute every so many minutes.
                Minutes(
                    std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Minutes>,
                ),
                /// Schedule the query to execute every so many hours.
                Hourly(
                    std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Hourly>,
                ),
                /// Schedule the query to execute every so many days.
                Daily(std::boxed::Box<crate::model::alert_policy::condition::sql_condition::Daily>),
            }

            /// The test to be run against the SQL result set.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Evaluate {
                /// Test the row count against a threshold.
                RowCountTest(
                    std::boxed::Box<
                        crate::model::alert_policy::condition::sql_condition::RowCountTest,
                    >,
                ),
                /// Test the boolean value in the indicated column.
                BooleanTest(
                    std::boxed::Box<
                        crate::model::alert_policy::condition::sql_condition::BooleanTest,
                    >,
                ),
            }
        }

        /// A condition control that determines how metric-threshold conditions
        /// are evaluated when data stops arriving.
        /// This control doesn't affect metric-absence policies.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EvaluationMissingData {
            /// An unspecified evaluation missing data option.  Equivalent to
            /// EVALUATION_MISSING_DATA_NO_OP.
            Unspecified,
            /// If there is no data to evaluate the condition, then evaluate the
            /// condition as false.
            Inactive,
            /// If there is no data to evaluate the condition, then evaluate the
            /// condition as true.
            Active,
            /// Do not evaluate the condition to any value if there is no data.
            NoOp,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EvaluationMissingData::value] or
            /// [EvaluationMissingData::name].
            UnknownValue(evaluation_missing_data::UnknownValue),
        }

        #[doc(hidden)]
        pub mod evaluation_missing_data {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EvaluationMissingData {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Inactive => std::option::Option::Some(1),
                    Self::Active => std::option::Option::Some(2),
                    Self::NoOp => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("EVALUATION_MISSING_DATA_UNSPECIFIED")
                    }
                    Self::Inactive => std::option::Option::Some("EVALUATION_MISSING_DATA_INACTIVE"),
                    Self::Active => std::option::Option::Some("EVALUATION_MISSING_DATA_ACTIVE"),
                    Self::NoOp => std::option::Option::Some("EVALUATION_MISSING_DATA_NO_OP"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EvaluationMissingData {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EvaluationMissingData {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EvaluationMissingData {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Inactive,
                    2 => Self::Active,
                    3 => Self::NoOp,
                    _ => Self::UnknownValue(evaluation_missing_data::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EvaluationMissingData {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "EVALUATION_MISSING_DATA_UNSPECIFIED" => Self::Unspecified,
                    "EVALUATION_MISSING_DATA_INACTIVE" => Self::Inactive,
                    "EVALUATION_MISSING_DATA_ACTIVE" => Self::Active,
                    "EVALUATION_MISSING_DATA_NO_OP" => Self::NoOp,
                    _ => Self::UnknownValue(evaluation_missing_data::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EvaluationMissingData {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Inactive => serializer.serialize_i32(1),
                    Self::Active => serializer.serialize_i32(2),
                    Self::NoOp => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EvaluationMissingData {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(
                    wkt::internal::EnumVisitor::<EvaluationMissingData>::new(
                        ".google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData",
                    ),
                )
            }
        }

        /// Only one of the following condition types will be specified.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Condition {
            /// A condition that compares a time series against a threshold.
            ConditionThreshold(
                std::boxed::Box<crate::model::alert_policy::condition::MetricThreshold>,
            ),
            /// A condition that checks that a time series continues to
            /// receive new data points.
            ConditionAbsent(std::boxed::Box<crate::model::alert_policy::condition::MetricAbsence>),
            /// A condition that checks for log messages matching given constraints. If
            /// set, no other conditions can be present.
            ConditionMatchedLog(std::boxed::Box<crate::model::alert_policy::condition::LogMatch>),
            /// A condition that uses the Monitoring Query Language to define
            /// alerts.
            ConditionMonitoringQueryLanguage(
                std::boxed::Box<
                    crate::model::alert_policy::condition::MonitoringQueryLanguageCondition,
                >,
            ),
            /// A condition that uses the Prometheus query language to define alerts.
            ConditionPrometheusQueryLanguage(
                std::boxed::Box<
                    crate::model::alert_policy::condition::PrometheusQueryLanguageCondition,
                >,
            ),
            /// A condition that periodically evaluates a SQL query result.
            ConditionSql(std::boxed::Box<crate::model::alert_policy::condition::SqlCondition>),
        }
    }

    /// Control over how the notification channels in `notification_channels`
    /// are notified when this alert fires.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AlertStrategy {
        /// Required for log-based alerting policies, i.e. policies with a `LogMatch`
        /// condition.
        ///
        /// This limit is not implemented for alerting policies that do not have
        /// a LogMatch condition.
        pub notification_rate_limit:
            std::option::Option<crate::model::alert_policy::alert_strategy::NotificationRateLimit>,

        /// For log-based alert policies, the notification prompts is always
        /// [OPENED]. For non log-based alert policies, the notification prompts can
        /// be [OPENED] or [OPENED, CLOSED].
        pub notification_prompts:
            std::vec::Vec<crate::model::alert_policy::alert_strategy::NotificationPrompt>,

        /// If an alerting policy that was active has no data for this long, any open
        /// incidents will close
        pub auto_close: std::option::Option<wkt::Duration>,

        /// Control how notifications will be sent out, on a per-channel basis.
        pub notification_channel_strategy:
            std::vec::Vec<crate::model::alert_policy::alert_strategy::NotificationChannelStrategy>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AlertStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [notification_rate_limit][crate::model::alert_policy::AlertStrategy::notification_rate_limit].
        pub fn set_notification_rate_limit<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::alert_policy::alert_strategy::NotificationRateLimit,
                >,
        {
            self.notification_rate_limit = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [notification_rate_limit][crate::model::alert_policy::AlertStrategy::notification_rate_limit].
        pub fn set_or_clear_notification_rate_limit<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::alert_policy::alert_strategy::NotificationRateLimit,
                >,
        {
            self.notification_rate_limit = v.map(|x| x.into());
            self
        }

        /// Sets the value of [notification_prompts][crate::model::alert_policy::AlertStrategy::notification_prompts].
        pub fn set_notification_prompts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::alert_policy::alert_strategy::NotificationPrompt>,
        {
            use std::iter::Iterator;
            self.notification_prompts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [auto_close][crate::model::alert_policy::AlertStrategy::auto_close].
        pub fn set_auto_close<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.auto_close = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [auto_close][crate::model::alert_policy::AlertStrategy::auto_close].
        pub fn set_or_clear_auto_close<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.auto_close = v.map(|x| x.into());
            self
        }

        /// Sets the value of [notification_channel_strategy][crate::model::alert_policy::AlertStrategy::notification_channel_strategy].
        pub fn set_notification_channel_strategy<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::alert_policy::alert_strategy::NotificationChannelStrategy,
                >,
        {
            use std::iter::Iterator;
            self.notification_channel_strategy = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AlertStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.AlertPolicy.AlertStrategy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AlertStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __notification_rate_limit,
                __notification_prompts,
                __auto_close,
                __notification_channel_strategy,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AlertStrategy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "notificationRateLimit" => {
                                    Ok(__FieldTag::__notification_rate_limit)
                                }
                                "notification_rate_limit" => {
                                    Ok(__FieldTag::__notification_rate_limit)
                                }
                                "notificationPrompts" => Ok(__FieldTag::__notification_prompts),
                                "notification_prompts" => Ok(__FieldTag::__notification_prompts),
                                "autoClose" => Ok(__FieldTag::__auto_close),
                                "auto_close" => Ok(__FieldTag::__auto_close),
                                "notificationChannelStrategy" => {
                                    Ok(__FieldTag::__notification_channel_strategy)
                                }
                                "notification_channel_strategy" => {
                                    Ok(__FieldTag::__notification_channel_strategy)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AlertStrategy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AlertStrategy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__notification_rate_limit => {
                                if !fields.insert(__FieldTag::__notification_rate_limit) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for notification_rate_limit",
                                    ));
                                }
                                result.notification_rate_limit = map.next_value::<std::option::Option<crate::model::alert_policy::alert_strategy::NotificationRateLimit>>()?
                                    ;
                            }
                            __FieldTag::__notification_prompts => {
                                if !fields.insert(__FieldTag::__notification_prompts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for notification_prompts",
                                    ));
                                }
                                result.notification_prompts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::alert_policy::alert_strategy::NotificationPrompt>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__auto_close => {
                                if !fields.insert(__FieldTag::__auto_close) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auto_close",
                                    ));
                                }
                                result.auto_close =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__notification_channel_strategy => {
                                if !fields.insert(__FieldTag::__notification_channel_strategy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for notification_channel_strategy",
                                    ));
                                }
                                result.notification_channel_strategy = map.next_value::<std::option::Option<std::vec::Vec<crate::model::alert_policy::alert_strategy::NotificationChannelStrategy>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AlertStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.notification_rate_limit.is_some() {
                state.serialize_entry("notificationRateLimit", &self.notification_rate_limit)?;
            }
            if !self.notification_prompts.is_empty() {
                state.serialize_entry("notificationPrompts", &self.notification_prompts)?;
            }
            if self.auto_close.is_some() {
                state.serialize_entry("autoClose", &self.auto_close)?;
            }
            if !self.notification_channel_strategy.is_empty() {
                state.serialize_entry(
                    "notificationChannelStrategy",
                    &self.notification_channel_strategy,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [AlertStrategy].
    pub mod alert_strategy {
        #[allow(unused_imports)]
        use super::*;

        /// Control over the rate of notifications sent to this alerting policy's
        /// notification channels.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NotificationRateLimit {
            /// Not more than one notification per `period`.
            pub period: std::option::Option<wkt::Duration>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NotificationRateLimit {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [period][crate::model::alert_policy::alert_strategy::NotificationRateLimit::period].
            pub fn set_period<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.period = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [period][crate::model::alert_policy::alert_strategy::NotificationRateLimit::period].
            pub fn set_or_clear_period<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.period = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for NotificationRateLimit {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for NotificationRateLimit {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __period,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for NotificationRateLimit")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "period" => Ok(__FieldTag::__period),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = NotificationRateLimit;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct NotificationRateLimit")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__period => {
                                    if !fields.insert(__FieldTag::__period) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for period"),
                                        );
                                    }
                                    result.period =
                                        map.next_value::<std::option::Option<wkt::Duration>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for NotificationRateLimit {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.period.is_some() {
                    state.serialize_entry("period", &self.period)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Control over how the notification channels in `notification_channels`
        /// are notified when this alert fires, on a per-channel basis.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NotificationChannelStrategy {
            /// The full REST resource name for the notification channels that these
            /// settings apply to. Each of these correspond to the name field in one
            /// of the NotificationChannel objects referenced in the
            /// notification_channels field of this AlertPolicy.
            /// The format is:
            ///
            /// ```norust
            /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
            /// ```
            pub notification_channel_names: std::vec::Vec<std::string::String>,

            /// The frequency at which to send reminder notifications for open
            /// incidents.
            pub renotify_interval: std::option::Option<wkt::Duration>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NotificationChannelStrategy {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [notification_channel_names][crate::model::alert_policy::alert_strategy::NotificationChannelStrategy::notification_channel_names].
            pub fn set_notification_channel_names<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.notification_channel_names = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [renotify_interval][crate::model::alert_policy::alert_strategy::NotificationChannelStrategy::renotify_interval].
            pub fn set_renotify_interval<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.renotify_interval = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [renotify_interval][crate::model::alert_policy::alert_strategy::NotificationChannelStrategy::renotify_interval].
            pub fn set_or_clear_renotify_interval<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Duration>,
            {
                self.renotify_interval = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for NotificationChannelStrategy {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for NotificationChannelStrategy {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __notification_channel_names,
                    __renotify_interval,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for NotificationChannelStrategy")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "notificationChannelNames" => {
                                        Ok(__FieldTag::__notification_channel_names)
                                    }
                                    "notification_channel_names" => {
                                        Ok(__FieldTag::__notification_channel_names)
                                    }
                                    "renotifyInterval" => Ok(__FieldTag::__renotify_interval),
                                    "renotify_interval" => Ok(__FieldTag::__renotify_interval),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = NotificationChannelStrategy;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct NotificationChannelStrategy")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__notification_channel_names => {
                                    if !fields.insert(__FieldTag::__notification_channel_names) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for notification_channel_names",
                                            ),
                                        );
                                    }
                                    result.notification_channel_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__renotify_interval => {
                                    if !fields.insert(__FieldTag::__renotify_interval) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for renotify_interval",
                                            ),
                                        );
                                    }
                                    result.renotify_interval =
                                        map.next_value::<std::option::Option<wkt::Duration>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for NotificationChannelStrategy {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.notification_channel_names.is_empty() {
                    state.serialize_entry(
                        "notificationChannelNames",
                        &self.notification_channel_names,
                    )?;
                }
                if self.renotify_interval.is_some() {
                    state.serialize_entry("renotifyInterval", &self.renotify_interval)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Control when notifications will be sent out.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum NotificationPrompt {
            /// No strategy specified. Treated as error.
            Unspecified,
            /// Notify when an incident is opened.
            Opened,
            /// Notify when an incident is closed.
            Closed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [NotificationPrompt::value] or
            /// [NotificationPrompt::name].
            UnknownValue(notification_prompt::UnknownValue),
        }

        #[doc(hidden)]
        pub mod notification_prompt {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl NotificationPrompt {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Opened => std::option::Option::Some(1),
                    Self::Closed => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("NOTIFICATION_PROMPT_UNSPECIFIED")
                    }
                    Self::Opened => std::option::Option::Some("OPENED"),
                    Self::Closed => std::option::Option::Some("CLOSED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for NotificationPrompt {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for NotificationPrompt {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for NotificationPrompt {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Opened,
                    3 => Self::Closed,
                    _ => Self::UnknownValue(notification_prompt::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for NotificationPrompt {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "NOTIFICATION_PROMPT_UNSPECIFIED" => Self::Unspecified,
                    "OPENED" => Self::Opened,
                    "CLOSED" => Self::Closed,
                    _ => Self::UnknownValue(notification_prompt::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for NotificationPrompt {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Opened => serializer.serialize_i32(1),
                    Self::Closed => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for NotificationPrompt {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<NotificationPrompt>::new(
                    ".google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationPrompt",
                ))
            }
        }
    }

    /// Operators for combining conditions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConditionCombinerType {
        /// An unspecified combiner.
        CombineUnspecified,
        /// Combine conditions using the logical `AND` operator. An
        /// incident is created only if all the conditions are met
        /// simultaneously. This combiner is satisfied if all conditions are
        /// met, even if they are met on completely different resources.
        And,
        /// Combine conditions using the logical `OR` operator. An incident
        /// is created if any of the listed conditions is met.
        Or,
        /// Combine conditions using logical `AND` operator, but unlike the regular
        /// `AND` option, an incident is created only if all conditions are met
        /// simultaneously on at least one resource.
        AndWithMatchingResource,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConditionCombinerType::value] or
        /// [ConditionCombinerType::name].
        UnknownValue(condition_combiner_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod condition_combiner_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConditionCombinerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::CombineUnspecified => std::option::Option::Some(0),
                Self::And => std::option::Option::Some(1),
                Self::Or => std::option::Option::Some(2),
                Self::AndWithMatchingResource => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::CombineUnspecified => std::option::Option::Some("COMBINE_UNSPECIFIED"),
                Self::And => std::option::Option::Some("AND"),
                Self::Or => std::option::Option::Some("OR"),
                Self::AndWithMatchingResource => {
                    std::option::Option::Some("AND_WITH_MATCHING_RESOURCE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConditionCombinerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConditionCombinerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConditionCombinerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::CombineUnspecified,
                1 => Self::And,
                2 => Self::Or,
                3 => Self::AndWithMatchingResource,
                _ => Self::UnknownValue(condition_combiner_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConditionCombinerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMBINE_UNSPECIFIED" => Self::CombineUnspecified,
                "AND" => Self::And,
                "OR" => Self::Or,
                "AND_WITH_MATCHING_RESOURCE" => Self::AndWithMatchingResource,
                _ => Self::UnknownValue(condition_combiner_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConditionCombinerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::CombineUnspecified => serializer.serialize_i32(0),
                Self::And => serializer.serialize_i32(1),
                Self::Or => serializer.serialize_i32(2),
                Self::AndWithMatchingResource => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConditionCombinerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConditionCombinerType>::new(
                ".google.monitoring.v3.AlertPolicy.ConditionCombinerType",
            ))
        }
    }

    /// An enumeration of possible severity level for an alerting policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// No severity is specified. This is the default value.
        Unspecified,
        /// This is the highest severity level. Use this if the problem could
        /// cause significant damage or downtime.
        Critical,
        /// This is the medium severity level. Use this if the problem could
        /// cause minor damage or downtime.
        Error,
        /// This is the lowest severity level. Use this if the problem is not causing
        /// any damage or downtime, but could potentially lead to a problem in the
        /// future.
        Warning,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Critical => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::Warning => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Critical,
                2 => Self::Error,
                3 => Self::Warning,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "CRITICAL" => Self::Critical,
                "ERROR" => Self::Error,
                "WARNING" => Self::Warning,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Critical => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::Warning => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.monitoring.v3.AlertPolicy.Severity",
            ))
        }
    }
}

/// The protocol for the `CreateAlertPolicy` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAlertPolicyRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// to create the alerting policy. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// Note that this field names the parent container in which the alerting
    /// policy will be written, not the name of the created policy. |name| must be
    /// a host project of a Metrics Scope, otherwise INVALID_ARGUMENT error will
    /// return. The alerting policy that is returned will have a name that contains
    /// a normalized representation of this name as a prefix but adds a suffix of
    /// the form `/alertPolicies/[ALERT_POLICY_ID]`, identifying the policy in the
    /// container.
    pub name: std::string::String,

    /// Required. The requested alerting policy. You should omit the `name` field
    /// in this policy. The name will be returned in the new policy, including a
    /// new `[ALERT_POLICY_ID]` value.
    pub alert_policy: std::option::Option<crate::model::AlertPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAlertPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateAlertPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [alert_policy][crate::model::CreateAlertPolicyRequest::alert_policy].
    pub fn set_alert_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AlertPolicy>,
    {
        self.alert_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [alert_policy][crate::model::CreateAlertPolicyRequest::alert_policy].
    pub fn set_or_clear_alert_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AlertPolicy>,
    {
        self.alert_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateAlertPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAlertPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __alert_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAlertPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "alertPolicy" => Ok(__FieldTag::__alert_policy),
                            "alert_policy" => Ok(__FieldTag::__alert_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAlertPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAlertPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__alert_policy => {
                            if !fields.insert(__FieldTag::__alert_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alert_policy",
                                ));
                            }
                            result.alert_policy =
                                map.next_value::<std::option::Option<crate::model::AlertPolicy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAlertPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.alert_policy.is_some() {
            state.serialize_entry("alertPolicy", &self.alert_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `GetAlertPolicy` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAlertPolicyRequest {
    /// Required. The alerting policy to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAlertPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAlertPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetAlertPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAlertPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAlertPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAlertPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAlertPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAlertPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `ListAlertPolicies` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAlertPoliciesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// alert policies are to be listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// Note that this field names the parent container in which the alerting
    /// policies to be listed are stored. To retrieve a single alerting policy
    /// by name, use the
    /// [GetAlertPolicy][google.monitoring.v3.AlertPolicyService.GetAlertPolicy]
    /// operation, instead.
    ///
    /// [google.monitoring.v3.AlertPolicyService.GetAlertPolicy]: crate::client::AlertPolicyService::get_alert_policy
    pub name: std::string::String,

    /// Optional. If provided, this field specifies the criteria that must be met
    /// by alert policies to be included in the response.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    pub filter: std::string::String,

    /// Optional. A comma-separated list of fields by which to sort the result.
    /// Supports the same set of field references as the `filter` field. Entries
    /// can be prefixed with a minus sign to sort by the field in descending order.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    pub order_by: std::string::String,

    /// Optional. The maximum number of results to return in a single response.
    pub page_size: i32,

    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return more results from the previous
    /// method call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAlertPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListAlertPoliciesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAlertPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAlertPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAlertPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAlertPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAlertPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListAlertPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAlertPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __order_by,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAlertPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAlertPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAlertPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAlertPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `ListAlertPolicies` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAlertPoliciesResponse {
    /// The returned alert policies.
    pub alert_policies: std::vec::Vec<crate::model::AlertPolicy>,

    /// If there might be more results than were returned, then this field is set
    /// to a non-empty value. To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    /// The total number of alert policies in all pages. This number is only an
    /// estimate, and may change in subsequent pages. <https://aip.dev/158>
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAlertPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alert_policies][crate::model::ListAlertPoliciesResponse::alert_policies].
    pub fn set_alert_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AlertPolicy>,
    {
        use std::iter::Iterator;
        self.alert_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAlertPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListAlertPoliciesResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListAlertPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListAlertPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAlertPoliciesResponse {
    type PageItem = crate::model::AlertPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.alert_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAlertPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alert_policies,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAlertPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alertPolicies" => Ok(__FieldTag::__alert_policies),
                            "alert_policies" => Ok(__FieldTag::__alert_policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAlertPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAlertPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alert_policies => {
                            if !fields.insert(__FieldTag::__alert_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alert_policies",
                                ));
                            }
                            result.alert_policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AlertPolicy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAlertPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.alert_policies.is_empty() {
            state.serialize_entry("alertPolicies", &self.alert_policies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `UpdateAlertPolicy` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAlertPolicyRequest {
    /// Optional. A list of alerting policy field names. If this field is not
    /// empty, each listed field in the existing alerting policy is set to the
    /// value of the corresponding field in the supplied policy (`alert_policy`),
    /// or to the field's default value if the field is not in the supplied
    /// alerting policy.  Fields not listed retain their previous value.
    ///
    /// Examples of valid field masks include `display_name`, `documentation`,
    /// `documentation.content`, `documentation.mime_type`, `user_labels`,
    /// `user_label.nameofkey`, `enabled`, `conditions`, `combiner`, etc.
    ///
    /// If this field is empty, then the supplied alerting policy replaces the
    /// existing policy. It is the same as deleting the existing policy and
    /// adding the supplied policy, except for the following:
    ///
    /// + The new policy will have the same `[ALERT_POLICY_ID]` as the former
    ///   policy. This gives you continuity with the former policy in your
    ///   notifications and incidents.
    /// + Conditions in the new policy will keep their former `[CONDITION_ID]` if
    ///   the supplied condition includes the `name` field with that
    ///   `[CONDITION_ID]`. If the supplied condition omits the `name` field,
    ///   then a new `[CONDITION_ID]` is created.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The updated alerting policy or the updated values for the
    /// fields listed in `update_mask`.
    /// If `update_mask` is not empty, any fields in this policy that are
    /// not in `update_mask` are ignored.
    pub alert_policy: std::option::Option<crate::model::AlertPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAlertPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAlertPolicyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAlertPolicyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [alert_policy][crate::model::UpdateAlertPolicyRequest::alert_policy].
    pub fn set_alert_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AlertPolicy>,
    {
        self.alert_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [alert_policy][crate::model::UpdateAlertPolicyRequest::alert_policy].
    pub fn set_or_clear_alert_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AlertPolicy>,
    {
        self.alert_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateAlertPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAlertPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __alert_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAlertPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "alertPolicy" => Ok(__FieldTag::__alert_policy),
                            "alert_policy" => Ok(__FieldTag::__alert_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAlertPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAlertPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__alert_policy => {
                            if !fields.insert(__FieldTag::__alert_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alert_policy",
                                ));
                            }
                            result.alert_policy =
                                map.next_value::<std::option::Option<crate::model::AlertPolicy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAlertPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.alert_policy.is_some() {
            state.serialize_entry("alertPolicy", &self.alert_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `DeleteAlertPolicy` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAlertPolicyRequest {
    /// Required. The alerting policy to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    ///
    /// For more information, see [AlertPolicy][google.monitoring.v3.AlertPolicy].
    ///
    /// [google.monitoring.v3.AlertPolicy]: crate::model::AlertPolicy
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAlertPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAlertPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAlertPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteAlertPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAlertPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAlertPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAlertPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAlertPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAlertPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single strongly-typed value.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TypedValue {
    /// The typed value field.
    pub value: std::option::Option<crate::model::typed_value::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TypedValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TypedValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::typed_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::Int64Value(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::DoubleValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DistributionValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn distribution_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<api::model::Distribution>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DistributionValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DistributionValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_distribution_value<
        T: std::convert::Into<std::boxed::Box<api::model::Distribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::typed_value::Value::DistributionValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TypedValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TypedValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TypedValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bool_value,
            __int64_value,
            __double_value,
            __string_value,
            __distribution_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TypedValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "int64Value" => Ok(__FieldTag::__int64_value),
                            "int64_value" => Ok(__FieldTag::__int64_value),
                            "doubleValue" => Ok(__FieldTag::__double_value),
                            "double_value" => Ok(__FieldTag::__double_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "distributionValue" => Ok(__FieldTag::__distribution_value),
                            "distribution_value" => Ok(__FieldTag::__distribution_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TypedValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TypedValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.TypedValue.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int64_value => {
                            if !fields.insert(__FieldTag::__int64_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int64_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.TypedValue.int64_value, latest field was int64Value",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::Int64Value(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_value => {
                            if !fields.insert(__FieldTag::__double_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.TypedValue.double_value, latest field was doubleValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::DoubleValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.TypedValue.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__distribution_value => {
                            if !fields.insert(__FieldTag::__distribution_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.TypedValue.distribution_value, latest field was distributionValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::DistributionValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<api::model::Distribution>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TypedValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.int64_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("int64Value", &__With(value))?;
        }
        if let Some(value) = self.double_value() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("doubleValue", &__With(value))?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.distribution_value() {
            state.serialize_entry("distributionValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TypedValue].
pub mod typed_value {
    #[allow(unused_imports)]
    use super::*;

    /// The typed value field.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// A Boolean value: `true` or `false`.
        BoolValue(bool),
        /// A 64-bit integer. Its range is approximately &plusmn;9.2x10\<sup\>18\</sup\>.
        Int64Value(i64),
        /// A 64-bit double-precision floating-point number. Its magnitude
        /// is approximately &plusmn;10\<sup\>&plusmn;300\</sup\> and it has 16
        /// significant digits of precision.
        DoubleValue(f64),
        /// A variable-length string value.
        StringValue(std::string::String),
        /// A distribution value.
        DistributionValue(std::boxed::Box<api::model::Distribution>),
    }
}

/// Describes a time interval:
///
/// * Reads: A half-open time interval. It includes the end time but
///   excludes the start time: `(startTime, endTime]`. The start time
///   must be specified, must be earlier than the end time, and should be
///   no older than the data retention period for the metric.
/// * Writes: A closed time interval. It extends from the start time to the end
///   time,
///   and includes both: `[startTime, endTime]`. Valid time intervals
///   depend on the
///   [`MetricKind`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind)
///   of the metric value. The end time must not be earlier than the start
///   time, and the end time must not be more than 25 hours in the past or more
///   than five minutes in the future.
///   * For `GAUGE` metrics, the `startTime` value is technically optional; if
///     no value is specified, the start time defaults to the value of the
///     end time, and the interval represents a single point in time. If both
///     start and end times are specified, they must be identical. Such an
///     interval is valid only for `GAUGE` metrics, which are point-in-time
///     measurements. The end time of a new interval must be at least a
///     millisecond after the end time of the previous interval.
///   * For `DELTA` metrics, the start time and end time must specify a
///     non-zero interval, with subsequent points specifying contiguous and
///     non-overlapping intervals. For `DELTA` metrics, the start time of
///     the next interval must be at least a millisecond after the end time
///     of the previous interval.
///   * For `CUMULATIVE` metrics, the start time and end time must specify a
///     non-zero interval, with subsequent points specifying the same
///     start time and increasing end times, until an event resets the
///     cumulative value to zero and sets a new start time for the following
///     points. The new start time must be at least a millisecond after the
///     end time of the previous interval.
///   * The start time of a new interval must be at least a millisecond after
///     the
///     end time of the previous interval because intervals are closed. If the
///     start time of a new interval is the same as the end time of the
///     previous interval, then data written at the new start time could
///     overwrite data written at the previous end time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeInterval {
    /// Required. The end of the time interval.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The beginning of the time interval.  The default value
    /// for the start time is the end time. The start time must not be
    /// later than the end time.
    pub start_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeInterval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeInterval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeInterval"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeInterval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __end_time,
            __start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeInterval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeInterval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeInterval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeInterval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes how to combine multiple time series to provide a different view of
/// the data.  Aggregation of time series is done in two steps. First, each time
/// series in the set is _aligned_ to the same time interval boundaries, then the
/// set of time series is optionally _reduced_ in number.
///
/// Alignment consists of applying the `per_series_aligner` operation
/// to each time series after its data has been divided into regular
/// `alignment_period` time intervals. This process takes _all_ of the data
/// points in an alignment period, applies a mathematical transformation such as
/// averaging, minimum, maximum, delta, etc., and converts them into a single
/// data point per period.
///
/// Reduction is when the aligned and transformed time series can optionally be
/// combined, reducing the number of time series through similar mathematical
/// transformations. Reduction involves applying a `cross_series_reducer` to
/// all the time series, optionally sorting the time series into subsets with
/// `group_by_fields`, and applying the reducer to each subset.
///
/// The raw time series data can contain a huge amount of information from
/// multiple sources. Alignment and reduction transforms this mass of data into
/// a more manageable and representative collection of data, for example "the
/// 95% latency across the average of all tasks in a cluster". This
/// representative data can be more easily graphed and comprehended, and the
/// individual time series data is still available for later drilldown. For more
/// details, see [Filtering and
/// aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Aggregation {
    /// The `alignment_period` specifies a time interval, in seconds, that is used
    /// to divide the data in all the
    /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
    /// time. This will be done before the per-series aligner can be applied to
    /// the data.
    ///
    /// The value must be at least 60 seconds. If a per-series
    /// aligner other than `ALIGN_NONE` is specified, this field is required or an
    /// error is returned. If no per-series aligner is specified, or the aligner
    /// `ALIGN_NONE` is specified, then this field is ignored.
    ///
    /// The maximum value of the `alignment_period` is 104 weeks (2 years) for
    /// charts, and 90,000 seconds (25 hours) for alerting policies.
    ///
    /// [google.monitoring.v3.TimeSeries]: crate::model::TimeSeries
    pub alignment_period: std::option::Option<wkt::Duration>,

    /// An `Aligner` describes how to bring the data points in a single
    /// time series into temporal alignment. Except for `ALIGN_NONE`, all
    /// alignments cause all the data points in an `alignment_period` to be
    /// mathematically grouped together, resulting in a single data point for
    /// each `alignment_period` with end timestamp at the end of the period.
    ///
    /// Not all alignment operations may be applied to all time series. The valid
    /// choices depend on the `metric_kind` and `value_type` of the original time
    /// series. Alignment can change the `metric_kind` or the `value_type` of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `cross_series_reducer` is specified, then
    /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
    /// and `alignment_period` must be specified; otherwise, an error is
    /// returned.
    pub per_series_aligner: crate::model::aggregation::Aligner,

    /// The reduction operation to be used to combine time series into a single
    /// time series, where the value of each data point in the resulting series is
    /// a function of all the already aligned values in the input time series.
    ///
    /// Not all reducer operations can be applied to all time series. The valid
    /// choices depend on the `metric_kind` and the `value_type` of the original
    /// time series. Reduction can yield a time series with a different
    /// `metric_kind` or `value_type` than the input time series.
    ///
    /// Time series data must first be aligned (see `per_series_aligner`) in order
    /// to perform cross-time series reduction. If `cross_series_reducer` is
    /// specified, then `per_series_aligner` must be specified, and must not be
    /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
    /// error is returned.
    pub cross_series_reducer: crate::model::aggregation::Reducer,

    /// The set of fields to preserve when `cross_series_reducer` is
    /// specified. The `group_by_fields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// operation. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `cross_series_reducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `group_by_fields` are aggregated away.  If
    /// `group_by_fields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `cross_series_reducer` is not
    /// defined, this field is ignored.
    pub group_by_fields: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Aggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alignment_period][crate::model::Aggregation::alignment_period].
    pub fn set_alignment_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.alignment_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [alignment_period][crate::model::Aggregation::alignment_period].
    pub fn set_or_clear_alignment_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.alignment_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [per_series_aligner][crate::model::Aggregation::per_series_aligner].
    pub fn set_per_series_aligner<T: std::convert::Into<crate::model::aggregation::Aligner>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_series_aligner = v.into();
        self
    }

    /// Sets the value of [cross_series_reducer][crate::model::Aggregation::cross_series_reducer].
    pub fn set_cross_series_reducer<T: std::convert::Into<crate::model::aggregation::Reducer>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_series_reducer = v.into();
        self
    }

    /// Sets the value of [group_by_fields][crate::model::Aggregation::group_by_fields].
    pub fn set_group_by_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.group_by_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Aggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Aggregation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Aggregation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alignment_period,
            __per_series_aligner,
            __cross_series_reducer,
            __group_by_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Aggregation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alignmentPeriod" => Ok(__FieldTag::__alignment_period),
                            "alignment_period" => Ok(__FieldTag::__alignment_period),
                            "perSeriesAligner" => Ok(__FieldTag::__per_series_aligner),
                            "per_series_aligner" => Ok(__FieldTag::__per_series_aligner),
                            "crossSeriesReducer" => Ok(__FieldTag::__cross_series_reducer),
                            "cross_series_reducer" => Ok(__FieldTag::__cross_series_reducer),
                            "groupByFields" => Ok(__FieldTag::__group_by_fields),
                            "group_by_fields" => Ok(__FieldTag::__group_by_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Aggregation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Aggregation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alignment_period => {
                            if !fields.insert(__FieldTag::__alignment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alignment_period",
                                ));
                            }
                            result.alignment_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__per_series_aligner => {
                            if !fields.insert(__FieldTag::__per_series_aligner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for per_series_aligner",
                                ));
                            }
                            result.per_series_aligner = map.next_value::<std::option::Option<crate::model::aggregation::Aligner>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cross_series_reducer => {
                            if !fields.insert(__FieldTag::__cross_series_reducer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_series_reducer",
                                ));
                            }
                            result.cross_series_reducer = map.next_value::<std::option::Option<crate::model::aggregation::Reducer>>()?.unwrap_or_default();
                        }
                        __FieldTag::__group_by_fields => {
                            if !fields.insert(__FieldTag::__group_by_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_by_fields",
                                ));
                            }
                            result.group_by_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Aggregation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.alignment_period.is_some() {
            state.serialize_entry("alignmentPeriod", &self.alignment_period)?;
        }
        if !wkt::internal::is_default(&self.per_series_aligner) {
            state.serialize_entry("perSeriesAligner", &self.per_series_aligner)?;
        }
        if !wkt::internal::is_default(&self.cross_series_reducer) {
            state.serialize_entry("crossSeriesReducer", &self.cross_series_reducer)?;
        }
        if !self.group_by_fields.is_empty() {
            state.serialize_entry("groupByFields", &self.group_by_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Aggregation].
pub mod aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// The `Aligner` specifies the operation that will be applied to the data
    /// points in each alignment period in a time series. Except for
    /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
    /// operation replaces the set of data values in each alignment period with
    /// a single value: the result of applying the operation to the data values.
    /// An aligned time series has a single data value at the end of each
    /// `alignment_period`.
    ///
    /// An alignment operation can change the data type of the values, too. For
    /// example, if you apply a counting operation to boolean values, the data
    /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
    /// in the aligned result is `INT64`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Aligner {
        /// No alignment. Raw data is returned. Not valid if cross-series reduction
        /// is requested. The `value_type` of the result is the same as the
        /// `value_type` of the input.
        AlignNone,
        /// Align and convert to
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
        /// The output is `delta = y1 - y0`.
        ///
        /// This alignment is valid for
        /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
        /// `DELTA` metrics. If the selected alignment period results in periods
        /// with no data, then the aligned value for such a period is created by
        /// interpolation. The `value_type`  of the aligned result is the same as
        /// the `value_type` of the input.
        ///
        /// [google.api.MetricDescriptor.MetricKind.CUMULATIVE]: api::model::metric_descriptor::MetricKind::Cumulative
        /// [google.api.MetricDescriptor.MetricKind.DELTA]: api::model::metric_descriptor::MetricKind::Delta
        AlignDelta,
        /// Align and convert to a rate. The result is computed as
        /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
        /// Think of this aligner as providing the slope of the line that passes
        /// through the value at the start and at the end of the `alignment_period`.
        ///
        /// This aligner is valid for `CUMULATIVE`
        /// and `DELTA` metrics with numeric values. If the selected alignment
        /// period results in periods with no data, then the aligned value for
        /// such a period is created by interpolation. The output is a `GAUGE`
        /// metric with `value_type` `DOUBLE`.
        ///
        /// If, by "rate", you mean "percentage change", see the
        /// `ALIGN_PERCENT_CHANGE` aligner instead.
        AlignRate,
        /// Align by interpolating between adjacent points around the alignment
        /// period boundary. This aligner is valid for `GAUGE` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as the
        /// `value_type` of the input.
        AlignInterpolate,
        /// Align by moving the most recent data point before the end of the
        /// alignment period to the boundary at the end of the alignment
        /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
        /// the aligned result is the same as the `value_type` of the input.
        AlignNextOlder,
        /// Align the time series by returning the minimum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMin,
        /// Align the time series by returning the maximum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMax,
        /// Align the time series by returning the mean value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
        AlignMean,
        /// Align the time series by returning the number of values in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric or Boolean values. The `value_type` of the aligned result is
        /// `INT64`.
        AlignCount,
        /// Align the time series by returning the sum of the values in each
        /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with numeric and distribution values. The `value_type` of the
        /// aligned result is the same as the `value_type` of the input.
        AlignSum,
        /// Align the time series by returning the standard deviation of the values
        /// in each alignment period. This aligner is valid for `GAUGE` and
        /// `DELTA` metrics with numeric values. The `value_type` of the output is
        /// `DOUBLE`.
        AlignStddev,
        /// Align the time series by returning the number of `True` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountTrue,
        /// Align the time series by returning the number of `False` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountFalse,
        /// Align the time series by returning the ratio of the number of `True`
        /// values to the total number of values in each alignment period. This
        /// aligner is valid for `GAUGE` metrics with Boolean values. The output
        /// value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
        AlignFractionTrue,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 99th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile99,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 95th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile95,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 50th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile50,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 5th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile05,
        /// Align and convert to a percentage change. This aligner is valid for
        /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
        /// `((current - previous)/previous) * 100`, where the value of `previous` is
        /// determined based on the `alignment_period`.
        ///
        /// If the values of `current` and `previous` are both 0, then the returned
        /// value is 0. If only `previous` is 0, the returned value is infinity.
        ///
        /// A 10-minute moving mean is computed at each point of the alignment period
        /// prior to the above calculation to smooth the metric and prevent false
        /// positives from very short-lived spikes. The moving mean is only
        /// applicable for data whose values are `>= 0`. Any values `< 0` are
        /// treated as a missing datapoint, and are ignored. While `DELTA`
        /// metrics are accepted by this alignment, special care should be taken that
        /// the values for the metric will always be positive. The output is a
        /// `GAUGE` metric with `value_type` `DOUBLE`.
        AlignPercentChange,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Aligner::value] or
        /// [Aligner::name].
        UnknownValue(aligner::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aligner {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Aligner {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AlignNone => std::option::Option::Some(0),
                Self::AlignDelta => std::option::Option::Some(1),
                Self::AlignRate => std::option::Option::Some(2),
                Self::AlignInterpolate => std::option::Option::Some(3),
                Self::AlignNextOlder => std::option::Option::Some(4),
                Self::AlignMin => std::option::Option::Some(10),
                Self::AlignMax => std::option::Option::Some(11),
                Self::AlignMean => std::option::Option::Some(12),
                Self::AlignCount => std::option::Option::Some(13),
                Self::AlignSum => std::option::Option::Some(14),
                Self::AlignStddev => std::option::Option::Some(15),
                Self::AlignCountTrue => std::option::Option::Some(16),
                Self::AlignCountFalse => std::option::Option::Some(24),
                Self::AlignFractionTrue => std::option::Option::Some(17),
                Self::AlignPercentile99 => std::option::Option::Some(18),
                Self::AlignPercentile95 => std::option::Option::Some(19),
                Self::AlignPercentile50 => std::option::Option::Some(20),
                Self::AlignPercentile05 => std::option::Option::Some(21),
                Self::AlignPercentChange => std::option::Option::Some(23),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AlignNone => std::option::Option::Some("ALIGN_NONE"),
                Self::AlignDelta => std::option::Option::Some("ALIGN_DELTA"),
                Self::AlignRate => std::option::Option::Some("ALIGN_RATE"),
                Self::AlignInterpolate => std::option::Option::Some("ALIGN_INTERPOLATE"),
                Self::AlignNextOlder => std::option::Option::Some("ALIGN_NEXT_OLDER"),
                Self::AlignMin => std::option::Option::Some("ALIGN_MIN"),
                Self::AlignMax => std::option::Option::Some("ALIGN_MAX"),
                Self::AlignMean => std::option::Option::Some("ALIGN_MEAN"),
                Self::AlignCount => std::option::Option::Some("ALIGN_COUNT"),
                Self::AlignSum => std::option::Option::Some("ALIGN_SUM"),
                Self::AlignStddev => std::option::Option::Some("ALIGN_STDDEV"),
                Self::AlignCountTrue => std::option::Option::Some("ALIGN_COUNT_TRUE"),
                Self::AlignCountFalse => std::option::Option::Some("ALIGN_COUNT_FALSE"),
                Self::AlignFractionTrue => std::option::Option::Some("ALIGN_FRACTION_TRUE"),
                Self::AlignPercentile99 => std::option::Option::Some("ALIGN_PERCENTILE_99"),
                Self::AlignPercentile95 => std::option::Option::Some("ALIGN_PERCENTILE_95"),
                Self::AlignPercentile50 => std::option::Option::Some("ALIGN_PERCENTILE_50"),
                Self::AlignPercentile05 => std::option::Option::Some("ALIGN_PERCENTILE_05"),
                Self::AlignPercentChange => std::option::Option::Some("ALIGN_PERCENT_CHANGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Aligner {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Aligner {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Aligner {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AlignNone,
                1 => Self::AlignDelta,
                2 => Self::AlignRate,
                3 => Self::AlignInterpolate,
                4 => Self::AlignNextOlder,
                10 => Self::AlignMin,
                11 => Self::AlignMax,
                12 => Self::AlignMean,
                13 => Self::AlignCount,
                14 => Self::AlignSum,
                15 => Self::AlignStddev,
                16 => Self::AlignCountTrue,
                17 => Self::AlignFractionTrue,
                18 => Self::AlignPercentile99,
                19 => Self::AlignPercentile95,
                20 => Self::AlignPercentile50,
                21 => Self::AlignPercentile05,
                23 => Self::AlignPercentChange,
                24 => Self::AlignCountFalse,
                _ => Self::UnknownValue(aligner::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Aligner {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALIGN_NONE" => Self::AlignNone,
                "ALIGN_DELTA" => Self::AlignDelta,
                "ALIGN_RATE" => Self::AlignRate,
                "ALIGN_INTERPOLATE" => Self::AlignInterpolate,
                "ALIGN_NEXT_OLDER" => Self::AlignNextOlder,
                "ALIGN_MIN" => Self::AlignMin,
                "ALIGN_MAX" => Self::AlignMax,
                "ALIGN_MEAN" => Self::AlignMean,
                "ALIGN_COUNT" => Self::AlignCount,
                "ALIGN_SUM" => Self::AlignSum,
                "ALIGN_STDDEV" => Self::AlignStddev,
                "ALIGN_COUNT_TRUE" => Self::AlignCountTrue,
                "ALIGN_COUNT_FALSE" => Self::AlignCountFalse,
                "ALIGN_FRACTION_TRUE" => Self::AlignFractionTrue,
                "ALIGN_PERCENTILE_99" => Self::AlignPercentile99,
                "ALIGN_PERCENTILE_95" => Self::AlignPercentile95,
                "ALIGN_PERCENTILE_50" => Self::AlignPercentile50,
                "ALIGN_PERCENTILE_05" => Self::AlignPercentile05,
                "ALIGN_PERCENT_CHANGE" => Self::AlignPercentChange,
                _ => Self::UnknownValue(aligner::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Aligner {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AlignNone => serializer.serialize_i32(0),
                Self::AlignDelta => serializer.serialize_i32(1),
                Self::AlignRate => serializer.serialize_i32(2),
                Self::AlignInterpolate => serializer.serialize_i32(3),
                Self::AlignNextOlder => serializer.serialize_i32(4),
                Self::AlignMin => serializer.serialize_i32(10),
                Self::AlignMax => serializer.serialize_i32(11),
                Self::AlignMean => serializer.serialize_i32(12),
                Self::AlignCount => serializer.serialize_i32(13),
                Self::AlignSum => serializer.serialize_i32(14),
                Self::AlignStddev => serializer.serialize_i32(15),
                Self::AlignCountTrue => serializer.serialize_i32(16),
                Self::AlignCountFalse => serializer.serialize_i32(24),
                Self::AlignFractionTrue => serializer.serialize_i32(17),
                Self::AlignPercentile99 => serializer.serialize_i32(18),
                Self::AlignPercentile95 => serializer.serialize_i32(19),
                Self::AlignPercentile50 => serializer.serialize_i32(20),
                Self::AlignPercentile05 => serializer.serialize_i32(21),
                Self::AlignPercentChange => serializer.serialize_i32(23),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Aligner {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Aligner>::new(
                ".google.monitoring.v3.Aggregation.Aligner",
            ))
        }
    }

    /// A Reducer operation describes how to aggregate data points from multiple
    /// time series into a single time series, where the value of each data point
    /// in the resulting series is a function of all the already aligned values in
    /// the input time series.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reducer {
        /// No cross-time series reduction. The output of the `Aligner` is
        /// returned.
        ReduceNone,
        /// Reduce by computing the mean value across time series for each
        /// alignment period. This reducer is valid for
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
        /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
        /// numeric or distribution values. The `value_type` of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        ///
        /// [google.api.MetricDescriptor.MetricKind.DELTA]: api::model::metric_descriptor::MetricKind::Delta
        /// [google.api.MetricDescriptor.MetricKind.GAUGE]: api::model::metric_descriptor::MetricKind::Gauge
        /// [google.api.MetricDescriptor.ValueType.DOUBLE]: api::model::metric_descriptor::ValueType::Double
        ReduceMean,
        /// Reduce by computing the minimum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMin,
        /// Reduce by computing the maximum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMax,
        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric and distribution values. The `value_type` of the output is
        /// the same as the `value_type` of the input.
        ReduceSum,
        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics with numeric or distribution values. The `value_type`
        /// of the output is `DOUBLE`.
        ReduceStddev,
        /// Reduce by computing the number of data points across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of numeric, Boolean, distribution, and string
        /// `value_type`. The `value_type` of the output is `INT64`.
        ReduceCount,
        /// Reduce by computing the number of `True`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountTrue,
        /// Reduce by computing the number of `False`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountFalse,
        /// Reduce by computing the ratio of the number of `True`-valued data points
        /// to the total number of data points for each alignment period. This
        /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
        /// The output value is in the range [0.0, 1.0] and has `value_type`
        /// `DOUBLE`.
        ReduceFractionTrue,
        /// Reduce by computing the [99th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile99,
        /// Reduce by computing the [95th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile95,
        /// Reduce by computing the [50th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile50,
        /// Reduce by computing the [5th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile05,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Reducer::value] or
        /// [Reducer::name].
        UnknownValue(reducer::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reducer {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Reducer {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ReduceNone => std::option::Option::Some(0),
                Self::ReduceMean => std::option::Option::Some(1),
                Self::ReduceMin => std::option::Option::Some(2),
                Self::ReduceMax => std::option::Option::Some(3),
                Self::ReduceSum => std::option::Option::Some(4),
                Self::ReduceStddev => std::option::Option::Some(5),
                Self::ReduceCount => std::option::Option::Some(6),
                Self::ReduceCountTrue => std::option::Option::Some(7),
                Self::ReduceCountFalse => std::option::Option::Some(15),
                Self::ReduceFractionTrue => std::option::Option::Some(8),
                Self::ReducePercentile99 => std::option::Option::Some(9),
                Self::ReducePercentile95 => std::option::Option::Some(10),
                Self::ReducePercentile50 => std::option::Option::Some(11),
                Self::ReducePercentile05 => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ReduceNone => std::option::Option::Some("REDUCE_NONE"),
                Self::ReduceMean => std::option::Option::Some("REDUCE_MEAN"),
                Self::ReduceMin => std::option::Option::Some("REDUCE_MIN"),
                Self::ReduceMax => std::option::Option::Some("REDUCE_MAX"),
                Self::ReduceSum => std::option::Option::Some("REDUCE_SUM"),
                Self::ReduceStddev => std::option::Option::Some("REDUCE_STDDEV"),
                Self::ReduceCount => std::option::Option::Some("REDUCE_COUNT"),
                Self::ReduceCountTrue => std::option::Option::Some("REDUCE_COUNT_TRUE"),
                Self::ReduceCountFalse => std::option::Option::Some("REDUCE_COUNT_FALSE"),
                Self::ReduceFractionTrue => std::option::Option::Some("REDUCE_FRACTION_TRUE"),
                Self::ReducePercentile99 => std::option::Option::Some("REDUCE_PERCENTILE_99"),
                Self::ReducePercentile95 => std::option::Option::Some("REDUCE_PERCENTILE_95"),
                Self::ReducePercentile50 => std::option::Option::Some("REDUCE_PERCENTILE_50"),
                Self::ReducePercentile05 => std::option::Option::Some("REDUCE_PERCENTILE_05"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Reducer {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Reducer {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Reducer {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ReduceNone,
                1 => Self::ReduceMean,
                2 => Self::ReduceMin,
                3 => Self::ReduceMax,
                4 => Self::ReduceSum,
                5 => Self::ReduceStddev,
                6 => Self::ReduceCount,
                7 => Self::ReduceCountTrue,
                8 => Self::ReduceFractionTrue,
                9 => Self::ReducePercentile99,
                10 => Self::ReducePercentile95,
                11 => Self::ReducePercentile50,
                12 => Self::ReducePercentile05,
                15 => Self::ReduceCountFalse,
                _ => Self::UnknownValue(reducer::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Reducer {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDUCE_NONE" => Self::ReduceNone,
                "REDUCE_MEAN" => Self::ReduceMean,
                "REDUCE_MIN" => Self::ReduceMin,
                "REDUCE_MAX" => Self::ReduceMax,
                "REDUCE_SUM" => Self::ReduceSum,
                "REDUCE_STDDEV" => Self::ReduceStddev,
                "REDUCE_COUNT" => Self::ReduceCount,
                "REDUCE_COUNT_TRUE" => Self::ReduceCountTrue,
                "REDUCE_COUNT_FALSE" => Self::ReduceCountFalse,
                "REDUCE_FRACTION_TRUE" => Self::ReduceFractionTrue,
                "REDUCE_PERCENTILE_99" => Self::ReducePercentile99,
                "REDUCE_PERCENTILE_95" => Self::ReducePercentile95,
                "REDUCE_PERCENTILE_50" => Self::ReducePercentile50,
                "REDUCE_PERCENTILE_05" => Self::ReducePercentile05,
                _ => Self::UnknownValue(reducer::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Reducer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ReduceNone => serializer.serialize_i32(0),
                Self::ReduceMean => serializer.serialize_i32(1),
                Self::ReduceMin => serializer.serialize_i32(2),
                Self::ReduceMax => serializer.serialize_i32(3),
                Self::ReduceSum => serializer.serialize_i32(4),
                Self::ReduceStddev => serializer.serialize_i32(5),
                Self::ReduceCount => serializer.serialize_i32(6),
                Self::ReduceCountTrue => serializer.serialize_i32(7),
                Self::ReduceCountFalse => serializer.serialize_i32(15),
                Self::ReduceFractionTrue => serializer.serialize_i32(8),
                Self::ReducePercentile99 => serializer.serialize_i32(9),
                Self::ReducePercentile95 => serializer.serialize_i32(10),
                Self::ReducePercentile50 => serializer.serialize_i32(11),
                Self::ReducePercentile05 => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Reducer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reducer>::new(
                ".google.monitoring.v3.Aggregation.Reducer",
            ))
        }
    }
}

/// A set of (label, value) pairs that were removed from a Distribution
/// time series during aggregation and then added as an attachment to a
/// Distribution.Exemplar.
///
/// The full label set for the exemplars is constructed by using the dropped
/// pairs in combination with the label values that remain on the aggregated
/// Distribution time series. The constructed full label set can be used to
/// identify the specific entity, such as the instance or job, which might be
/// contributing to a long-tail. However, with dropped labels, the storage
/// requirements are reduced because only the aggregated distribution values for
/// a large group of time series are stored.
///
/// Note that there are no guarantees on ordering of the labels from
/// exemplar-to-exemplar and from distribution-to-distribution in the same
/// stream, and there may be duplicates.  It is up to clients to resolve any
/// ambiguities.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DroppedLabels {
    /// Map from label to its value, for all labels dropped in any aggregation.
    pub label: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DroppedLabels {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label][crate::model::DroppedLabels::label].
    pub fn set_label<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.label = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DroppedLabels {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DroppedLabels"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DroppedLabels {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DroppedLabels")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "label" => Ok(__FieldTag::__label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DroppedLabels;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DroppedLabels")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DroppedLabels {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The description of a dynamic collection of monitored resources. Each group
/// has a filter that is matched against monitored resources and their associated
/// metadata. If a group's filter matches an available monitored resource, then
/// that resource is a member of that group.  Groups can contain any number of
/// monitored resources, and each monitored resource can be a member of any
/// number of groups.
///
/// Groups can be nested in parent-child hierarchies. The `parentName` field
/// identifies an optional parent for each group.  If a group has a parent, then
/// the only monitored resources available to be matched by the group's filter
/// are the resources contained in the parent group.  In other words, a group
/// contains the monitored resources that match its filter and the filters of all
/// the group's ancestors.  A group without a parent can contain any monitored
/// resource.
///
/// For example, consider an infrastructure running a set of instances with two
/// user-defined tags: `"environment"` and `"role"`. A parent group has a filter,
/// `environment="production"`.  A child of that parent group has a filter,
/// `role="transcoder"`.  The parent group contains all instances in the
/// production environment, regardless of their roles.  The child group contains
/// instances that have the transcoder role *and* are in the production
/// environment.
///
/// The monitored resources contained in a group can change at any moment,
/// depending on what resources exist and what filters are associated with the
/// group and its ancestors.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Group {
    /// Output only. The name of this group. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    ///
    /// When creating a group, this field is ignored and a new name is created
    /// consisting of the project specified in the call to `CreateGroup`
    /// and a unique `[GROUP_ID]` that is generated automatically.
    pub name: std::string::String,

    /// A user-assigned name for this group, used only for display purposes.
    pub display_name: std::string::String,

    /// The name of the group's parent, if it has one. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    ///
    /// For groups with no parent, `parent_name` is the empty string, `""`.
    pub parent_name: std::string::String,

    /// The filter used to determine which monitored resources belong to this
    /// group.
    pub filter: std::string::String,

    /// If true, the members of this group are considered to be a cluster.
    /// The system can perform additional analysis on groups that are clusters.
    pub is_cluster: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Group {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Group::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Group::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [parent_name][crate::model::Group::parent_name].
    pub fn set_parent_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::Group::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [is_cluster][crate::model::Group::is_cluster].
    pub fn set_is_cluster<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_cluster = v.into();
        self
    }
}

impl wkt::message::Message for Group {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Group"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Group {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __parent_name,
            __filter,
            __is_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Group")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "parentName" => Ok(__FieldTag::__parent_name),
                            "parent_name" => Ok(__FieldTag::__parent_name),
                            "filter" => Ok(__FieldTag::__filter),
                            "isCluster" => Ok(__FieldTag::__is_cluster),
                            "is_cluster" => Ok(__FieldTag::__is_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Group;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Group")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_name => {
                            if !fields.insert(__FieldTag::__parent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_name",
                                ));
                            }
                            result.parent_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_cluster => {
                            if !fields.insert(__FieldTag::__is_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_cluster",
                                ));
                            }
                            result.is_cluster = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Group {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.parent_name.is_empty() {
            state.serialize_entry("parentName", &self.parent_name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.is_cluster) {
            state.serialize_entry("isCluster", &self.is_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListGroup` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// groups are to be listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub name: std::string::String,

    /// A positive number that is the maximum number of results to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `next_page_token` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    pub page_token: std::string::String,

    /// An optional filter consisting of a single group name.  The filters limit
    /// the groups returned based on their parent-child relationship with the
    /// specified group. If no filter is specified, all groups are returned.
    pub filter: std::option::Option<crate::model::list_groups_request::Filter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListGroupsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::list_groups_request::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::ListGroupsRequest::filter]
    /// if it holds a `ChildrenOfGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn children_of_group(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::list_groups_request::Filter::ChildrenOfGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter]
    /// to hold a `ChildrenOfGroup`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_children_of_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::list_groups_request::Filter::ChildrenOfGroup(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::ListGroupsRequest::filter]
    /// if it holds a `AncestorsOfGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ancestors_of_group(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::list_groups_request::Filter::AncestorsOfGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter]
    /// to hold a `AncestorsOfGroup`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_ancestors_of_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::list_groups_request::Filter::AncestorsOfGroup(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::ListGroupsRequest::filter]
    /// if it holds a `DescendantsOfGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn descendants_of_group(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::list_groups_request::Filter::DescendantsOfGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter]
    /// to hold a `DescendantsOfGroup`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_descendants_of_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::list_groups_request::Filter::DescendantsOfGroup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ListGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __children_of_group,
            __ancestors_of_group,
            __descendants_of_group,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "childrenOfGroup" => Ok(__FieldTag::__children_of_group),
                            "children_of_group" => Ok(__FieldTag::__children_of_group),
                            "ancestorsOfGroup" => Ok(__FieldTag::__ancestors_of_group),
                            "ancestors_of_group" => Ok(__FieldTag::__ancestors_of_group),
                            "descendantsOfGroup" => Ok(__FieldTag::__descendants_of_group),
                            "descendants_of_group" => Ok(__FieldTag::__descendants_of_group),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__children_of_group => {
                            if !fields.insert(__FieldTag::__children_of_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for children_of_group",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.monitoring.v3.ListGroupsRequest.children_of_group, latest field was childrenOfGroup",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::list_groups_request::Filter::ChildrenOfGroup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ancestors_of_group => {
                            if !fields.insert(__FieldTag::__ancestors_of_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ancestors_of_group",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.monitoring.v3.ListGroupsRequest.ancestors_of_group, latest field was ancestorsOfGroup",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::list_groups_request::Filter::AncestorsOfGroup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__descendants_of_group => {
                            if !fields.insert(__FieldTag::__descendants_of_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for descendants_of_group",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.monitoring.v3.ListGroupsRequest.descendants_of_group, latest field was descendantsOfGroup",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::list_groups_request::Filter::DescendantsOfGroup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.children_of_group() {
            state.serialize_entry("childrenOfGroup", value)?;
        }
        if let Some(value) = self.ancestors_of_group() {
            state.serialize_entry("ancestorsOfGroup", value)?;
        }
        if let Some(value) = self.descendants_of_group() {
            state.serialize_entry("descendantsOfGroup", value)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ListGroupsRequest].
pub mod list_groups_request {
    #[allow(unused_imports)]
    use super::*;

    /// An optional filter consisting of a single group name.  The filters limit
    /// the groups returned based on their parent-child relationship with the
    /// specified group. If no filter is specified, all groups are returned.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// A group name. The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
        /// ```
        ///
        /// Returns groups whose `parent_name` field contains the group
        /// name.  If no groups have this parent, the results are empty.
        ChildrenOfGroup(std::string::String),
        /// A group name. The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
        /// ```
        ///
        /// Returns groups that are ancestors of the specified group.
        /// The groups are returned in order, starting with the immediate parent and
        /// ending with the most distant ancestor.  If the specified group has no
        /// immediate parent, the results are empty.
        AncestorsOfGroup(std::string::String),
        /// A group name. The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
        /// ```
        ///
        /// Returns the descendants of the specified group.  This is a superset of
        /// the results returned by the `children_of_group` filter, and includes
        /// children-of-children, and so forth.
        DescendantsOfGroup(std::string::String),
    }
}

/// The `ListGroups` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsResponse {
    /// The groups that match the specified filters.
    pub group: std::vec::Vec<crate::model::Group>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::ListGroupsResponse::group].
    pub fn set_group<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Group>,
    {
        use std::iter::Iterator;
        self.group = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGroupsResponse {
    type PageItem = crate::model::Group;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.group
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Group>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetGroup` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGroupRequest {
    /// Required. The group to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `CreateGroup` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGroupRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// to create the group. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub name: std::string::String,

    /// Required. A group definition. It is an error to define the `name` field
    /// because the system assigns the name.
    pub group: std::option::Option<crate::model::Group>,

    /// If true, validate this request but do not create the group.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __group,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "group" => Ok(__FieldTag::__group),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `UpdateGroup` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGroupRequest {
    /// Required. The new definition of the group.  All fields of the existing
    /// group, excepting `name`, are replaced with the corresponding fields of this
    /// group.
    pub group: std::option::Option<crate::model::Group>,

    /// If true, validate this request but do not update the existing group.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `DeleteGroup` request. The default behavior is to be able to delete a
/// single group without any descendants.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGroupRequest {
    /// Required. The group to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    pub name: std::string::String,

    /// If this field is true, then the request means to delete a group with all
    /// its descendants. Otherwise, the request means to delete a group only when
    /// it has no descendants. The default value is false.
    pub recursive: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [recursive][crate::model::DeleteGroupRequest::recursive].
    pub fn set_recursive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.recursive = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __recursive,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "recursive" => Ok(__FieldTag::__recursive),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recursive => {
                            if !fields.insert(__FieldTag::__recursive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recursive",
                                ));
                            }
                            result.recursive = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.recursive) {
            state.serialize_entry("recursive", &self.recursive)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListGroupMembers` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupMembersRequest {
    /// Required. The group whose members are listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    /// ```
    pub name: std::string::String,

    /// A positive number that is the maximum number of results to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `next_page_token` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    pub page_token: std::string::String,

    /// An optional [list
    /// filter](https://cloud.google.com/monitoring/api/learn_more#filtering)
    /// describing the members to be returned.  The filter may reference the type,
    /// labels, and metadata of monitored resources that comprise the group. For
    /// example, to return only resources representing Compute Engine VM instances,
    /// use this filter:
    ///
    /// ```norust
    /// `resource.type = "gce_instance"`
    /// ```
    pub filter: std::string::String,

    /// An optional time interval for which results should be returned. Only
    /// members that were part of the group during the specified interval are
    /// included in the response.  If no interval is provided then the group
    /// membership over the last minute is returned.
    pub interval: std::option::Option<crate::model::TimeInterval>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupMembersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListGroupMembersRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupMembersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupMembersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupMembersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListGroupMembersRequest::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::ListGroupMembersRequest::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListGroupMembersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupMembersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupMembersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            __filter,
            __interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupMembersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "interval" => Ok(__FieldTag::__interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupMembersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupMembersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval = map
                                .next_value::<std::option::Option<crate::model::TimeInterval>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupMembersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListGroupMembers` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupMembersResponse {
    /// A set of monitored resources in the group.
    pub members: std::vec::Vec<api::model::MonitoredResource>,

    /// If there are more results than have been returned, then this field is
    /// set to a non-empty value.  To see the additional results, use that value as
    /// `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    /// The total number of elements matching this request.
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupMembersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [members][crate::model::ListGroupMembersResponse::members].
    pub fn set_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResource>,
    {
        use std::iter::Iterator;
        self.members = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGroupMembersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListGroupMembersResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupMembersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListGroupMembersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGroupMembersResponse {
    type PageItem = api::model::MonitoredResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.members
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupMembersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __members,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupMembersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "members" => Ok(__FieldTag::__members),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupMembersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupMembersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__members => {
                            if !fields.insert(__FieldTag::__members) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for members",
                                ));
                            }
                            result.members =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<api::model::MonitoredResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupMembersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.members.is_empty() {
            state.serialize_entry("members", &self.members)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single data point in a time series.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Point {
    /// The time interval to which the data point applies.  For `GAUGE` metrics,
    /// the start time is optional, but if it is supplied, it must equal the
    /// end time.  For `DELTA` metrics, the start
    /// and end time should specify a non-zero interval, with subsequent points
    /// specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
    /// metrics, the start and end time should specify a non-zero interval, with
    /// subsequent points specifying the same start time and increasing end times,
    /// until an event resets the cumulative value to zero and sets a new start
    /// time for the following points.
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// The value of the data point.
    pub value: std::option::Option<crate::model::TypedValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Point {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [interval][crate::model::Point::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::Point::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::Point::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TypedValue>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::Point::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TypedValue>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Point {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Point"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Point {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __interval,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Point")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "interval" => Ok(__FieldTag::__interval),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Point;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Point")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval = map
                                .next_value::<std::option::Option<crate::model::TimeInterval>>()?;
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<crate::model::TypedValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Point {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A collection of data points that describes the time-varying values
/// of a metric. A time series is identified by a combination of a
/// fully-specified monitored resource and a fully-specified metric.
/// This type is used for both listing and creating time series.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeries {
    /// The associated metric. A fully-specified metric used to identify the time
    /// series.
    pub metric: std::option::Option<api::model::Metric>,

    /// The associated monitored resource.  Custom metrics can use only certain
    /// monitored resource types in their time series data. For more information,
    /// see [Monitored resources for custom
    /// metrics](https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
    pub resource: std::option::Option<api::model::MonitoredResource>,

    /// Output only. The associated monitored resource metadata. When reading a
    /// time series, this field will include metadata labels that are explicitly
    /// named in the reduction. When creating a time series, this field is ignored.
    pub metadata: std::option::Option<api::model::MonitoredResourceMetadata>,

    /// The metric kind of the time series. When listing time series, this metric
    /// kind might be different from the metric kind of the associated metric if
    /// this time series is an alignment or reduction of other time series.
    ///
    /// When creating a time series, this field is optional. If present, it must be
    /// the same as the metric kind of the associated metric. If the associated
    /// metric's descriptor must be auto-created, then this field specifies the
    /// metric kind of the new descriptor and must be either `GAUGE` (the default)
    /// or `CUMULATIVE`.
    pub metric_kind: api::model::metric_descriptor::MetricKind,

    /// The value type of the time series. When listing time series, this value
    /// type might be different from the value type of the associated metric if
    /// this time series is an alignment or reduction of other time series.
    ///
    /// When creating a time series, this field is optional. If present, it must be
    /// the same as the type of the data in the `points` field.
    pub value_type: api::model::metric_descriptor::ValueType,

    /// The data points of this time series. When listing time series, points are
    /// returned in reverse time order.
    ///
    /// When creating a time series, this field must contain exactly one point and
    /// the point's type must be the same as the value type of the associated
    /// metric. If the associated metric's descriptor must be auto-created, then
    /// the value type of the descriptor is determined by the point's type, which
    /// must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
    pub points: std::vec::Vec<crate::model::Point>,

    /// The units in which the metric value is reported. It is only applicable
    /// if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
    /// defines the representation of the stored metric values. This field can only
    /// be changed through CreateTimeSeries when it is empty.
    pub unit: std::string::String,

    /// Input only. A detailed description of the time series that will be
    /// associated with the
    /// [google.api.MetricDescriptor][google.api.MetricDescriptor] for the metric.
    /// Once set, this field cannot be changed through CreateTimeSeries.
    ///
    /// [google.api.MetricDescriptor]: api::model::MetricDescriptor
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric][crate::model::TimeSeries::metric].
    pub fn set_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Metric>,
    {
        self.metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric][crate::model::TimeSeries::metric].
    pub fn set_or_clear_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Metric>,
    {
        self.metric = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource][crate::model::TimeSeries::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::TimeSeries::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::TimeSeries::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResourceMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::TimeSeries::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResourceMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metric_kind][crate::model::TimeSeries::metric_kind].
    pub fn set_metric_kind<T: std::convert::Into<api::model::metric_descriptor::MetricKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_kind = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TimeSeries::value_type].
    pub fn set_value_type<T: std::convert::Into<api::model::metric_descriptor::ValueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [points][crate::model::TimeSeries::points].
    pub fn set_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Point>,
    {
        use std::iter::Iterator;
        self.points = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unit][crate::model::TimeSeries::unit].
    pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.unit = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TimeSeries::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for TimeSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeries"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeries {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric,
            __resource,
            __metadata,
            __metric_kind,
            __value_type,
            __points,
            __unit,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeries")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metric" => Ok(__FieldTag::__metric),
                            "resource" => Ok(__FieldTag::__resource),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "metricKind" => Ok(__FieldTag::__metric_kind),
                            "metric_kind" => Ok(__FieldTag::__metric_kind),
                            "valueType" => Ok(__FieldTag::__value_type),
                            "value_type" => Ok(__FieldTag::__value_type),
                            "points" => Ok(__FieldTag::__points),
                            "unit" => Ok(__FieldTag::__unit),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeries;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeries")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric",
                                ));
                            }
                            result.metric =
                                map.next_value::<std::option::Option<api::model::Metric>>()?;
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<api::model::MonitoredResource>>(
                                )?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<api::model::MonitoredResourceMetadata>>()?
                                ;
                        }
                        __FieldTag::__metric_kind => {
                            if !fields.insert(__FieldTag::__metric_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_kind",
                                ));
                            }
                            result.metric_kind = map.next_value::<std::option::Option<api::model::metric_descriptor::MetricKind>>()?.unwrap_or_default();
                        }
                        __FieldTag::__value_type => {
                            if !fields.insert(__FieldTag::__value_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_type",
                                ));
                            }
                            result.value_type = map.next_value::<std::option::Option<api::model::metric_descriptor::ValueType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__points => {
                            if !fields.insert(__FieldTag::__points) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for points",
                                ));
                            }
                            result.points = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Point>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unit => {
                            if !fields.insert(__FieldTag::__unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unit",
                                ));
                            }
                            result.unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeries {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.metric.is_some() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !wkt::internal::is_default(&self.metric_kind) {
            state.serialize_entry("metricKind", &self.metric_kind)?;
        }
        if !wkt::internal::is_default(&self.value_type) {
            state.serialize_entry("valueType", &self.value_type)?;
        }
        if !self.points.is_empty() {
            state.serialize_entry("points", &self.points)?;
        }
        if !self.unit.is_empty() {
            state.serialize_entry("unit", &self.unit)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A descriptor for the labels and points in a time series.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeriesDescriptor {
    /// Descriptors for the labels.
    pub label_descriptors: std::vec::Vec<api::model::LabelDescriptor>,

    /// Descriptors for the point data value columns.
    pub point_descriptors: std::vec::Vec<crate::model::time_series_descriptor::ValueDescriptor>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_descriptors][crate::model::TimeSeriesDescriptor::label_descriptors].
    pub fn set_label_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::LabelDescriptor>,
    {
        use std::iter::Iterator;
        self.label_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [point_descriptors][crate::model::TimeSeriesDescriptor::point_descriptors].
    pub fn set_point_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_descriptor::ValueDescriptor>,
    {
        use std::iter::Iterator;
        self.point_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeriesDescriptor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeriesDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label_descriptors,
            __point_descriptors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labelDescriptors" => Ok(__FieldTag::__label_descriptors),
                            "label_descriptors" => Ok(__FieldTag::__label_descriptors),
                            "pointDescriptors" => Ok(__FieldTag::__point_descriptors),
                            "point_descriptors" => Ok(__FieldTag::__point_descriptors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeriesDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label_descriptors => {
                            if !fields.insert(__FieldTag::__label_descriptors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_descriptors",
                                ));
                            }
                            result.label_descriptors = map.next_value::<std::option::Option<std::vec::Vec<api::model::LabelDescriptor>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__point_descriptors => {
                            if !fields.insert(__FieldTag::__point_descriptors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for point_descriptors",
                                ));
                            }
                            result.point_descriptors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::time_series_descriptor::ValueDescriptor,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeriesDescriptor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.label_descriptors.is_empty() {
            state.serialize_entry("labelDescriptors", &self.label_descriptors)?;
        }
        if !self.point_descriptors.is_empty() {
            state.serialize_entry("pointDescriptors", &self.point_descriptors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TimeSeriesDescriptor].
pub mod time_series_descriptor {
    #[allow(unused_imports)]
    use super::*;

    /// A descriptor for the value columns in a data point.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ValueDescriptor {
        /// The value key.
        pub key: std::string::String,

        /// The value type.
        pub value_type: api::model::metric_descriptor::ValueType,

        /// The value stream kind.
        pub metric_kind: api::model::metric_descriptor::MetricKind,

        /// The unit in which `time_series` point values are reported. `unit`
        /// follows the UCUM format for units as seen in
        /// <https://unitsofmeasure.org/ucum.html>.
        /// `unit` is only valid if `value_type` is INTEGER, DOUBLE, DISTRIBUTION.
        pub unit: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ValueDescriptor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::time_series_descriptor::ValueDescriptor::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value_type][crate::model::time_series_descriptor::ValueDescriptor::value_type].
        pub fn set_value_type<T: std::convert::Into<api::model::metric_descriptor::ValueType>>(
            mut self,
            v: T,
        ) -> Self {
            self.value_type = v.into();
            self
        }

        /// Sets the value of [metric_kind][crate::model::time_series_descriptor::ValueDescriptor::metric_kind].
        pub fn set_metric_kind<T: std::convert::Into<api::model::metric_descriptor::MetricKind>>(
            mut self,
            v: T,
        ) -> Self {
            self.metric_kind = v.into();
            self
        }

        /// Sets the value of [unit][crate::model::time_series_descriptor::ValueDescriptor::unit].
        pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.unit = v.into();
            self
        }
    }

    impl wkt::message::Message for ValueDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ValueDescriptor {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __value_type,
                __metric_kind,
                __unit,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ValueDescriptor")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "valueType" => Ok(__FieldTag::__value_type),
                                "value_type" => Ok(__FieldTag::__value_type),
                                "metricKind" => Ok(__FieldTag::__metric_kind),
                                "metric_kind" => Ok(__FieldTag::__metric_kind),
                                "unit" => Ok(__FieldTag::__unit),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ValueDescriptor;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ValueDescriptor")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value_type => {
                                if !fields.insert(__FieldTag::__value_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value_type",
                                    ));
                                }
                                result.value_type =
                                    map.next_value::<std::option::Option<
                                        api::model::metric_descriptor::ValueType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__metric_kind => {
                                if !fields.insert(__FieldTag::__metric_kind) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metric_kind",
                                    ));
                                }
                                result.metric_kind =
                                    map.next_value::<std::option::Option<
                                        api::model::metric_descriptor::MetricKind,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__unit => {
                                if !fields.insert(__FieldTag::__unit) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for unit",
                                    ));
                                }
                                result.unit = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ValueDescriptor {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if !wkt::internal::is_default(&self.value_type) {
                state.serialize_entry("valueType", &self.value_type)?;
            }
            if !wkt::internal::is_default(&self.metric_kind) {
                state.serialize_entry("metricKind", &self.metric_kind)?;
            }
            if !self.unit.is_empty() {
                state.serialize_entry("unit", &self.unit)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Represents the values of a time series associated with a
/// TimeSeriesDescriptor.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeriesData {
    /// The values of the labels in the time series identifier, given in the same
    /// order as the `label_descriptors` field of the TimeSeriesDescriptor
    /// associated with this object. Each value must have a value of the type
    /// given in the corresponding entry of `label_descriptors`.
    pub label_values: std::vec::Vec<crate::model::LabelValue>,

    /// The points in the time series.
    pub point_data: std::vec::Vec<crate::model::time_series_data::PointData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_values][crate::model::TimeSeriesData::label_values].
    pub fn set_label_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LabelValue>,
    {
        use std::iter::Iterator;
        self.label_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [point_data][crate::model::TimeSeriesData::point_data].
    pub fn set_point_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_data::PointData>,
    {
        use std::iter::Iterator;
        self.point_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeriesData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeriesData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label_values,
            __point_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labelValues" => Ok(__FieldTag::__label_values),
                            "label_values" => Ok(__FieldTag::__label_values),
                            "pointData" => Ok(__FieldTag::__point_data),
                            "point_data" => Ok(__FieldTag::__point_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeriesData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label_values => {
                            if !fields.insert(__FieldTag::__label_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_values",
                                ));
                            }
                            result.label_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LabelValue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__point_data => {
                            if !fields.insert(__FieldTag::__point_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for point_data",
                                ));
                            }
                            result.point_data = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::time_series_data::PointData>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeriesData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.label_values.is_empty() {
            state.serialize_entry("labelValues", &self.label_values)?;
        }
        if !self.point_data.is_empty() {
            state.serialize_entry("pointData", &self.point_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TimeSeriesData].
pub mod time_series_data {
    #[allow(unused_imports)]
    use super::*;

    /// A point's value columns and time interval. Each point has one or more
    /// point values corresponding to the entries in `point_descriptors` field in
    /// the TimeSeriesDescriptor associated with this object.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PointData {
        /// The values that make up the point.
        pub values: std::vec::Vec<crate::model::TypedValue>,

        /// The time interval associated with the point.
        pub time_interval: std::option::Option<crate::model::TimeInterval>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PointData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::time_series_data::PointData::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::TypedValue>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [time_interval][crate::model::time_series_data::PointData::time_interval].
        pub fn set_time_interval<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TimeInterval>,
        {
            self.time_interval = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time_interval][crate::model::time_series_data::PointData::time_interval].
        pub fn set_or_clear_time_interval<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TimeInterval>,
        {
            self.time_interval = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PointData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.TimeSeriesData.PointData"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PointData {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                __time_interval,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PointData")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                "timeInterval" => Ok(__FieldTag::__time_interval),
                                "time_interval" => Ok(__FieldTag::__time_interval),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PointData;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PointData")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::TypedValue>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__time_interval => {
                                if !fields.insert(__FieldTag::__time_interval) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_interval",
                                    ));
                                }
                                result.time_interval = map
                                    .next_value::<std::option::Option<crate::model::TimeInterval>>(
                                    )?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PointData {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if self.time_interval.is_some() {
                state.serialize_entry("timeInterval", &self.time_interval)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// A label value.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LabelValue {
    /// The label value can be a bool, int64, or string.
    pub value: std::option::Option<crate::model::label_value::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LabelValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::LabelValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::label_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::LabelValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::label_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::LabelValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::label_value::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::LabelValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::label_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::LabelValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::label_value::Value::Int64Value(v.into()));
        self
    }

    /// The value of [value][crate::model::LabelValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::label_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::LabelValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::label_value::Value::StringValue(v.into()));
        self
    }
}

impl wkt::message::Message for LabelValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.LabelValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LabelValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bool_value,
            __int64_value,
            __string_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LabelValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "int64Value" => Ok(__FieldTag::__int64_value),
                            "int64_value" => Ok(__FieldTag::__int64_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LabelValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LabelValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.LabelValue.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::label_value::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int64_value => {
                            if !fields.insert(__FieldTag::__int64_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int64_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.LabelValue.int64_value, latest field was int64Value",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::label_value::Value::Int64Value(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.monitoring.v3.LabelValue.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::label_value::Value::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LabelValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.int64_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("int64Value", &__With(value))?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LabelValue].
pub mod label_value {
    #[allow(unused_imports)]
    use super::*;

    /// The label value can be a bool, int64, or string.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// A bool label value.
        BoolValue(bool),
        /// An int64 label value.
        Int64Value(i64),
        /// A string label value.
        StringValue(std::string::String),
    }
}

/// An error associated with a query in the time series query language format.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryError {
    /// The location of the time series query language text that this error applies
    /// to.
    pub locator: std::option::Option<crate::model::TextLocator>,

    /// The error message.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locator][crate::model::QueryError::locator].
    pub fn set_locator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextLocator>,
    {
        self.locator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [locator][crate::model::QueryError::locator].
    pub fn set_or_clear_locator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextLocator>,
    {
        self.locator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::QueryError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for QueryError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __locator,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locator" => Ok(__FieldTag::__locator),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__locator => {
                            if !fields.insert(__FieldTag::__locator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locator",
                                ));
                            }
                            result.locator =
                                map.next_value::<std::option::Option<crate::model::TextLocator>>()?;
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.locator.is_some() {
            state.serialize_entry("locator", &self.locator)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A locator for text. Indicates a particular part of the text of a request or
/// of an object referenced in the request.
///
/// For example, suppose the request field `text` contains:
///
/// text: "The quick brown fox jumps over the lazy dog."
///
/// Then the locator:
///
/// source: "text"
/// start_position {
/// line: 1
/// column: 17
/// }
/// end_position {
/// line: 1
/// column: 19
/// }
///
/// refers to the part of the text: "fox".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TextLocator {
    /// The source of the text. The source may be a field in the request, in which
    /// case its format is the format of the
    /// google.rpc.BadRequest.FieldViolation.field field in
    /// <https://cloud.google.com/apis/design/errors#error_details>. It may also be
    /// be a source other than the request field (e.g. a macro definition
    /// referenced in the text of the query), in which case this is the name of
    /// the source (e.g. the macro name).
    pub source: std::string::String,

    /// The position of the first byte within the text.
    pub start_position: std::option::Option<crate::model::text_locator::Position>,

    /// The position of the last byte within the text.
    pub end_position: std::option::Option<crate::model::text_locator::Position>,

    /// If `source`, `start_position`, and `end_position` describe a call on
    /// some object (e.g. a macro in the time series query language text) and a
    /// location is to be designated in that object's text, `nested_locator`
    /// identifies the location within that object.
    pub nested_locator: std::option::Option<std::boxed::Box<crate::model::TextLocator>>,

    /// When `nested_locator` is set, this field gives the reason for the nesting.
    /// Usually, the reason is a macro invocation. In that case, the macro name
    /// (including the leading '@') signals the location of the macro call
    /// in the text and a macro argument name (including the leading '$') signals
    /// the location of the macro argument inside the macro body that got
    /// substituted away.
    pub nesting_reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextLocator {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::TextLocator::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [start_position][crate::model::TextLocator::start_position].
    pub fn set_start_position<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text_locator::Position>,
    {
        self.start_position = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_position][crate::model::TextLocator::start_position].
    pub fn set_or_clear_start_position<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text_locator::Position>,
    {
        self.start_position = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_position][crate::model::TextLocator::end_position].
    pub fn set_end_position<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text_locator::Position>,
    {
        self.end_position = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_position][crate::model::TextLocator::end_position].
    pub fn set_or_clear_end_position<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text_locator::Position>,
    {
        self.end_position = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nested_locator][crate::model::TextLocator::nested_locator].
    pub fn set_nested_locator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextLocator>,
    {
        self.nested_locator = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [nested_locator][crate::model::TextLocator::nested_locator].
    pub fn set_or_clear_nested_locator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextLocator>,
    {
        self.nested_locator = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }

    /// Sets the value of [nesting_reason][crate::model::TextLocator::nesting_reason].
    pub fn set_nesting_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nesting_reason = v.into();
        self
    }
}

impl wkt::message::Message for TextLocator {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TextLocator"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextLocator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __start_position,
            __end_position,
            __nested_locator,
            __nesting_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextLocator")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "startPosition" => Ok(__FieldTag::__start_position),
                            "start_position" => Ok(__FieldTag::__start_position),
                            "endPosition" => Ok(__FieldTag::__end_position),
                            "end_position" => Ok(__FieldTag::__end_position),
                            "nestedLocator" => Ok(__FieldTag::__nested_locator),
                            "nested_locator" => Ok(__FieldTag::__nested_locator),
                            "nestingReason" => Ok(__FieldTag::__nesting_reason),
                            "nesting_reason" => Ok(__FieldTag::__nesting_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextLocator;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextLocator")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_position => {
                            if !fields.insert(__FieldTag::__start_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_position",
                                ));
                            }
                            result.start_position = map.next_value::<std::option::Option<crate::model::text_locator::Position>>()?
                                ;
                        }
                        __FieldTag::__end_position => {
                            if !fields.insert(__FieldTag::__end_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_position",
                                ));
                            }
                            result.end_position = map.next_value::<std::option::Option<crate::model::text_locator::Position>>()?
                                ;
                        }
                        __FieldTag::__nested_locator => {
                            if !fields.insert(__FieldTag::__nested_locator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nested_locator",
                                ));
                            }
                            result.nested_locator = map.next_value::<std::option::Option<std::boxed::Box<crate::model::TextLocator>>>()?
                                ;
                        }
                        __FieldTag::__nesting_reason => {
                            if !fields.insert(__FieldTag::__nesting_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nesting_reason",
                                ));
                            }
                            result.nesting_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TextLocator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.start_position.is_some() {
            state.serialize_entry("startPosition", &self.start_position)?;
        }
        if self.end_position.is_some() {
            state.serialize_entry("endPosition", &self.end_position)?;
        }
        if self.nested_locator.is_some() {
            state.serialize_entry("nestedLocator", &self.nested_locator)?;
        }
        if !self.nesting_reason.is_empty() {
            state.serialize_entry("nestingReason", &self.nesting_reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TextLocator].
pub mod text_locator {
    #[allow(unused_imports)]
    use super::*;

    /// The position of a byte within the text.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Position {
        /// The line, starting with 1, where the byte is positioned.
        pub line: i32,

        /// The column within the line, starting with 1, where the byte is
        /// positioned. This is a byte index even though the text is UTF-8.
        pub column: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Position {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line][crate::model::text_locator::Position::line].
        pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.line = v.into();
            self
        }

        /// Sets the value of [column][crate::model::text_locator::Position::column].
        pub fn set_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }
    }

    impl wkt::message::Message for Position {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.TextLocator.Position"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Position {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __line,
                __column,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Position")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "line" => Ok(__FieldTag::__line),
                                "column" => Ok(__FieldTag::__column),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Position;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Position")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__line => {
                                if !fields.insert(__FieldTag::__line) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for line",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.line = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__column => {
                                if !fields.insert(__FieldTag::__column) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for column",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.column = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Position {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.line) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("line", &__With(&self.line))?;
            }
            if !wkt::internal::is_default(&self.column) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("column", &__With(&self.column))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The `ListMonitoredResourceDescriptors` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub name: std::string::String,

    /// An optional [filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// describing the descriptors to be returned.  The filter can reference the
    /// descriptor's type and labels. For example, the following filter returns
    /// only Google Compute Engine descriptors that have an `id` label:
    ///
    /// ```norust
    /// resource.type = starts_with("gce_") AND resource.label:id
    /// ```
    pub filter: std::string::String,

    /// A positive number that is the maximum number of results to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMonitoredResourceDescriptorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListMonitoredResourceDescriptorsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMonitoredResourceDescriptorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMonitoredResourceDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMonitoredResourceDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMonitoredResourceDescriptorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMonitoredResourceDescriptorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListMonitoredResourceDescriptorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMonitoredResourceDescriptorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMonitoredResourceDescriptorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMonitoredResourceDescriptorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListMonitoredResourceDescriptors` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsResponse {
    /// The monitored resource descriptors that are available to this project
    /// and that match `filter`, if present.
    pub resource_descriptors: std::vec::Vec<api::model::MonitoredResourceDescriptor>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMonitoredResourceDescriptorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_descriptors][crate::model::ListMonitoredResourceDescriptorsResponse::resource_descriptors].
    pub fn set_resource_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResourceDescriptor>,
    {
        use std::iter::Iterator;
        self.resource_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMonitoredResourceDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMonitoredResourceDescriptorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMonitoredResourceDescriptorsResponse {
    type PageItem = api::model::MonitoredResourceDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resource_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMonitoredResourceDescriptorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_descriptors,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListMonitoredResourceDescriptorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceDescriptors" => Ok(__FieldTag::__resource_descriptors),
                            "resource_descriptors" => Ok(__FieldTag::__resource_descriptors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMonitoredResourceDescriptorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMonitoredResourceDescriptorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_descriptors => {
                            if !fields.insert(__FieldTag::__resource_descriptors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_descriptors",
                                ));
                            }
                            result.resource_descriptors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<api::model::MonitoredResourceDescriptor>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMonitoredResourceDescriptorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_descriptors.is_empty() {
            state.serialize_entry("resourceDescriptors", &self.resource_descriptors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetMonitoredResourceDescriptor` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMonitoredResourceDescriptorRequest {
    /// Required. The monitored resource descriptor to get.  The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE]
    /// ```
    ///
    /// The `[RESOURCE_TYPE]` is a predefined type, such as
    /// `cloudsql_database`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMonitoredResourceDescriptorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMonitoredResourceDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMonitoredResourceDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetMonitoredResourceDescriptorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMonitoredResourceDescriptorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GetMonitoredResourceDescriptorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMonitoredResourceDescriptorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMonitoredResourceDescriptorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMonitoredResourceDescriptorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListMetricDescriptors` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMetricDescriptorsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub name: std::string::String,

    /// Optional. If this field is empty, all custom and
    /// system-defined metric descriptors are returned.
    /// Otherwise, the [filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifies which metric descriptors are to be
    /// returned. For example, the following filter matches all
    /// [custom metrics](https://cloud.google.com/monitoring/custom-metrics):
    ///
    /// ```norust
    /// metric.type = starts_with("custom.googleapis.com/")
    /// ```
    pub filter: std::string::String,

    /// Optional. A positive number that is the maximum number of results to
    /// return. The default and maximum value is 10,000. If a page_size <= 0 or >
    /// 10,000 is submitted, will instead return a maximum of 10,000 results.
    pub page_size: i32,

    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return additional results from the previous
    /// method call.
    pub page_token: std::string::String,

    /// Optional. If true, only metrics and monitored resource types that have
    /// recent data (within roughly 25 hours) will be included in the response.
    ///
    /// - If a metric descriptor enumerates monitored resource types, only the
    ///   monitored resource types for which the metric type has recent data will
    ///   be included in the returned metric descriptor, and if none of them have
    ///   recent data, the metric descriptor will not be returned.
    /// - If a metric descriptor does not enumerate the compatible monitored
    ///   resource types, it will be returned only if the metric type has recent
    ///   data for some monitored resource type. The returned descriptor will not
    ///   enumerate any monitored resource types.
    pub active_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMetricDescriptorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListMetricDescriptorsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMetricDescriptorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetricDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetricDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [active_only][crate::model::ListMetricDescriptorsRequest::active_only].
    pub fn set_active_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.active_only = v.into();
        self
    }
}

impl wkt::message::Message for ListMetricDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMetricDescriptorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMetricDescriptorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __page_size,
            __page_token,
            __active_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMetricDescriptorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "activeOnly" => Ok(__FieldTag::__active_only),
                            "active_only" => Ok(__FieldTag::__active_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMetricDescriptorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMetricDescriptorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active_only => {
                            if !fields.insert(__FieldTag::__active_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_only",
                                ));
                            }
                            result.active_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMetricDescriptorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.active_only) {
            state.serialize_entry("activeOnly", &self.active_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListMetricDescriptors` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMetricDescriptorsResponse {
    /// The metric descriptors that are available to the project
    /// and that match the value of `filter`, if present.
    pub metric_descriptors: std::vec::Vec<api::model::MetricDescriptor>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMetricDescriptorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_descriptors][crate::model::ListMetricDescriptorsResponse::metric_descriptors].
    pub fn set_metric_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MetricDescriptor>,
    {
        use std::iter::Iterator;
        self.metric_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMetricDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMetricDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListMetricDescriptorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMetricDescriptorsResponse {
    type PageItem = api::model::MetricDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metric_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMetricDescriptorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric_descriptors,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMetricDescriptorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metricDescriptors" => Ok(__FieldTag::__metric_descriptors),
                            "metric_descriptors" => Ok(__FieldTag::__metric_descriptors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMetricDescriptorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMetricDescriptorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric_descriptors => {
                            if !fields.insert(__FieldTag::__metric_descriptors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_descriptors",
                                ));
                            }
                            result.metric_descriptors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<api::model::MetricDescriptor>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMetricDescriptorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metric_descriptors.is_empty() {
            state.serialize_entry("metricDescriptors", &self.metric_descriptors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetMetricDescriptor` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMetricDescriptorRequest {
    /// Required. The metric descriptor on which to execute the request. The format
    /// is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
    /// ```
    ///
    /// An example value of `[METRIC_ID]` is
    /// `"compute.googleapis.com/instance/disk/read_bytes_count"`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMetricDescriptorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetricDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetricDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetMetricDescriptorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMetricDescriptorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMetricDescriptorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMetricDescriptorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMetricDescriptorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMetricDescriptorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `CreateMetricDescriptor` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMetricDescriptorRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    /// 4
    /// projects/[PROJECT_ID_OR_NUMBER]
    pub name: std::string::String,

    /// Required. The new [custom
    /// metric](https://cloud.google.com/monitoring/custom-metrics) descriptor.
    pub metric_descriptor: std::option::Option<api::model::MetricDescriptor>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMetricDescriptorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateMetricDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [metric_descriptor][crate::model::CreateMetricDescriptorRequest::metric_descriptor].
    pub fn set_metric_descriptor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MetricDescriptor>,
    {
        self.metric_descriptor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric_descriptor][crate::model::CreateMetricDescriptorRequest::metric_descriptor].
    pub fn set_or_clear_metric_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MetricDescriptor>,
    {
        self.metric_descriptor = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateMetricDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateMetricDescriptorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMetricDescriptorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __metric_descriptor,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMetricDescriptorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "metricDescriptor" => Ok(__FieldTag::__metric_descriptor),
                            "metric_descriptor" => Ok(__FieldTag::__metric_descriptor),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMetricDescriptorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMetricDescriptorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric_descriptor => {
                            if !fields.insert(__FieldTag::__metric_descriptor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_descriptor",
                                ));
                            }
                            result.metric_descriptor = map
                                .next_value::<std::option::Option<api::model::MetricDescriptor>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMetricDescriptorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.metric_descriptor.is_some() {
            state.serialize_entry("metricDescriptor", &self.metric_descriptor)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `DeleteMetricDescriptor` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMetricDescriptorRequest {
    /// Required. The metric descriptor on which to execute the request. The format
    /// is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
    /// ```
    ///
    /// An example of `[METRIC_ID]` is:
    /// `"custom.googleapis.com/my_test_metric"`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMetricDescriptorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMetricDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMetricDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteMetricDescriptorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMetricDescriptorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMetricDescriptorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMetricDescriptorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMetricDescriptorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMetricDescriptorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListTimeSeries` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTimeSeriesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name),
    /// organization or folder on which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// organizations/[ORGANIZATION_ID]
    /// folders/[FOLDER_ID]
    /// ```
    pub name: std::string::String,

    /// Required. A [monitoring
    /// filter](https://cloud.google.com/monitoring/api/v3/filters) that specifies
    /// which time series should be returned.  The filter must specify a single
    /// metric type, and can additionally specify metric labels and other
    /// information. For example:
    ///
    /// ```norust
    /// metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
    ///     metric.labels.instance_name = "my-instance-name"
    /// ```
    pub filter: std::string::String,

    /// Required. The time interval for which results should be returned. Only time
    /// series that contain data points in the specified interval are included in
    /// the response.
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// Specifies the alignment of data points in individual time series as
    /// well as how to combine the retrieved time series across specified labels.
    ///
    /// By default (if no `aggregation` is explicitly specified), the raw time
    /// series data is returned.
    pub aggregation: std::option::Option<crate::model::Aggregation>,

    /// Apply a second aggregation after `aggregation` is applied. May only be
    /// specified if `aggregation` is specified.
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Unsupported: must be left blank. The points in each time series are
    /// currently returned in reverse time order (most recent to oldest).
    pub order_by: std::string::String,

    /// Required. Specifies which information is returned about the time series.
    pub view: crate::model::list_time_series_request::TimeSeriesView,

    /// A positive number that is the maximum number of results to return. If
    /// `page_size` is empty or more than 100,000 results, the effective
    /// `page_size` is 100,000 results. If `view` is set to `FULL`, this is the
    /// maximum number of `Points` returned. If `view` is set to `HEADERS`, this is
    /// the maximum number of `TimeSeries` returned.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTimeSeriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListTimeSeriesRequest::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::ListTimeSeriesRequest::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aggregation][crate::model::ListTimeSeriesRequest::aggregation].
    pub fn set_aggregation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.aggregation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregation][crate::model::ListTimeSeriesRequest::aggregation].
    pub fn set_or_clear_aggregation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.aggregation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::ListTimeSeriesRequest::secondary_aggregation].
    pub fn set_secondary_aggregation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.secondary_aggregation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_aggregation][crate::model::ListTimeSeriesRequest::secondary_aggregation].
    pub fn set_or_clear_secondary_aggregation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Aggregation>,
    {
        self.secondary_aggregation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [order_by][crate::model::ListTimeSeriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListTimeSeriesRequest::view].
    pub fn set_view<
        T: std::convert::Into<crate::model::list_time_series_request::TimeSeriesView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTimeSeriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTimeSeriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListTimeSeriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTimeSeriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __interval,
            __aggregation,
            __secondary_aggregation,
            __order_by,
            __view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTimeSeriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "interval" => Ok(__FieldTag::__interval),
                            "aggregation" => Ok(__FieldTag::__aggregation),
                            "secondaryAggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "secondary_aggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTimeSeriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTimeSeriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval = map
                                .next_value::<std::option::Option<crate::model::TimeInterval>>()?;
                        }
                        __FieldTag::__aggregation => {
                            if !fields.insert(__FieldTag::__aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation",
                                ));
                            }
                            result.aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__secondary_aggregation => {
                            if !fields.insert(__FieldTag::__secondary_aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_aggregation",
                                ));
                            }
                            result.secondary_aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::list_time_series_request::TimeSeriesView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTimeSeriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if self.aggregation.is_some() {
            state.serialize_entry("aggregation", &self.aggregation)?;
        }
        if self.secondary_aggregation.is_some() {
            state.serialize_entry("secondaryAggregation", &self.secondary_aggregation)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ListTimeSeriesRequest].
pub mod list_time_series_request {
    #[allow(unused_imports)]
    use super::*;

    /// Controls which fields are returned by `ListTimeSeries*`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeSeriesView {
        /// Returns the identity of the metric(s), the time series,
        /// and the time series data.
        Full,
        /// Returns the identity of the metric and the time series resource,
        /// but not the time series data.
        Headers,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeSeriesView::value] or
        /// [TimeSeriesView::name].
        UnknownValue(time_series_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_series_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeSeriesView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Full => std::option::Option::Some(0),
                Self::Headers => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Full => std::option::Option::Some("FULL"),
                Self::Headers => std::option::Option::Some("HEADERS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeSeriesView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeSeriesView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeSeriesView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Full,
                1 => Self::Headers,
                _ => Self::UnknownValue(time_series_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeSeriesView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FULL" => Self::Full,
                "HEADERS" => Self::Headers,
                _ => Self::UnknownValue(time_series_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeSeriesView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Full => serializer.serialize_i32(0),
                Self::Headers => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeSeriesView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeSeriesView>::new(
                ".google.monitoring.v3.ListTimeSeriesRequest.TimeSeriesView",
            ))
        }
    }
}

/// The `ListTimeSeries` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTimeSeriesResponse {
    /// One or more time series that match the filter included in the request.
    pub time_series: std::vec::Vec<crate::model::TimeSeries>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    /// Query execution errors that may have caused the time series data returned
    /// to be incomplete.
    pub execution_errors: std::vec::Vec<rpc::model::Status>,

    /// The unit in which all `time_series` point values are reported. `unit`
    /// follows the UCUM format for units as seen in
    /// <https://unitsofmeasure.org/ucum.html>.
    /// If different `time_series` have different units (for example, because they
    /// come from different metric types, or a unit is absent), then `unit` will be
    /// "{not_a_unit}".
    pub unit: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTimeSeriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series][crate::model::ListTimeSeriesResponse::time_series].
    pub fn set_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTimeSeriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [execution_errors][crate::model::ListTimeSeriesResponse::execution_errors].
    pub fn set_execution_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.execution_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unit][crate::model::ListTimeSeriesResponse::unit].
    pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.unit = v.into();
        self
    }
}

impl wkt::message::Message for ListTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListTimeSeriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTimeSeriesResponse {
    type PageItem = crate::model::TimeSeries;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.time_series
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTimeSeriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series,
            __next_page_token,
            __execution_errors,
            __unit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTimeSeriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeries" => Ok(__FieldTag::__time_series),
                            "time_series" => Ok(__FieldTag::__time_series),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "executionErrors" => Ok(__FieldTag::__execution_errors),
                            "execution_errors" => Ok(__FieldTag::__execution_errors),
                            "unit" => Ok(__FieldTag::__unit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTimeSeriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTimeSeriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series => {
                            if !fields.insert(__FieldTag::__time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series",
                                ));
                            }
                            result.time_series = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TimeSeries>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_errors => {
                            if !fields.insert(__FieldTag::__execution_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_errors",
                                ));
                            }
                            result.execution_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unit => {
                            if !fields.insert(__FieldTag::__unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unit",
                                ));
                            }
                            result.unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTimeSeriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.time_series.is_empty() {
            state.serialize_entry("timeSeries", &self.time_series)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.execution_errors.is_empty() {
            state.serialize_entry("executionErrors", &self.execution_errors)?;
        }
        if !self.unit.is_empty() {
            state.serialize_entry("unit", &self.unit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `CreateTimeSeries` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTimeSeriesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub name: std::string::String,

    /// Required. The new data to be added to a list of time series.
    /// Adds at most one data point to each of several time series.  The new data
    /// point must be more recent than any other point in its time series.  Each
    /// `TimeSeries` value must fully specify a unique time series by supplying
    /// all label values for the metric and the monitored resource.
    ///
    /// The maximum number of `TimeSeries` objects per `Create` request is 200.
    pub time_series: std::vec::Vec<crate::model::TimeSeries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [time_series][crate::model::CreateTimeSeriesRequest::time_series].
    pub fn set_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTimeSeriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __time_series,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTimeSeriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "timeSeries" => Ok(__FieldTag::__time_series),
                            "time_series" => Ok(__FieldTag::__time_series),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTimeSeriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTimeSeriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_series => {
                            if !fields.insert(__FieldTag::__time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series",
                                ));
                            }
                            result.time_series = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TimeSeries>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTimeSeriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.time_series.is_empty() {
            state.serialize_entry("timeSeries", &self.time_series)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DEPRECATED. Used to hold per-time-series error status.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTimeSeriesError {
    /// DEPRECATED. Time series ID that resulted in the `status` error.
    #[deprecated]
    pub time_series: std::option::Option<crate::model::TimeSeries>,

    /// DEPRECATED. The status of the requested write operation for `time_series`.
    #[deprecated]
    pub status: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTimeSeriesError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series][crate::model::CreateTimeSeriesError::time_series].
    #[deprecated]
    pub fn set_time_series<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSeries>,
    {
        self.time_series = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_series][crate::model::CreateTimeSeriesError::time_series].
    #[deprecated]
    pub fn set_or_clear_time_series<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSeries>,
    {
        self.time_series = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::CreateTimeSeriesError::status].
    #[deprecated]
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::CreateTimeSeriesError::status].
    #[deprecated]
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTimeSeriesError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTimeSeriesError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTimeSeriesError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeries" => Ok(__FieldTag::__time_series),
                            "time_series" => Ok(__FieldTag::__time_series),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTimeSeriesError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTimeSeriesError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series => {
                            if !fields.insert(__FieldTag::__time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series",
                                ));
                            }
                            result.time_series =
                                map.next_value::<std::option::Option<crate::model::TimeSeries>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTimeSeriesError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.time_series.is_some() {
            state.serialize_entry("timeSeries", &self.time_series)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Summary of the result of a failed request to write data to a time series.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTimeSeriesSummary {
    /// The number of points in the request.
    pub total_point_count: i32,

    /// The number of points that were successfully written.
    pub success_point_count: i32,

    /// The number of points that failed to be written. Order is not guaranteed.
    pub errors: std::vec::Vec<crate::model::create_time_series_summary::Error>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTimeSeriesSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_point_count][crate::model::CreateTimeSeriesSummary::total_point_count].
    pub fn set_total_point_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_point_count = v.into();
        self
    }

    /// Sets the value of [success_point_count][crate::model::CreateTimeSeriesSummary::success_point_count].
    pub fn set_success_point_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.success_point_count = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::CreateTimeSeriesSummary::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::create_time_series_summary::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateTimeSeriesSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTimeSeriesSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_point_count,
            __success_point_count,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTimeSeriesSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalPointCount" => Ok(__FieldTag::__total_point_count),
                            "total_point_count" => Ok(__FieldTag::__total_point_count),
                            "successPointCount" => Ok(__FieldTag::__success_point_count),
                            "success_point_count" => Ok(__FieldTag::__success_point_count),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTimeSeriesSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTimeSeriesSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_point_count => {
                            if !fields.insert(__FieldTag::__total_point_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_point_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_point_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__success_point_count => {
                            if !fields.insert(__FieldTag::__success_point_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success_point_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.success_point_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::create_time_series_summary::Error>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTimeSeriesSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_point_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalPointCount", &__With(&self.total_point_count))?;
        }
        if !wkt::internal::is_default(&self.success_point_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successPointCount", &__With(&self.success_point_count))?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CreateTimeSeriesSummary].
pub mod create_time_series_summary {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed information about an error category.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Error {
        /// The status of the requested write operation.
        pub status: std::option::Option<rpc::model::Status>,

        /// The number of points that couldn't be written because of `status`.
        pub point_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Error {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::create_time_series_summary::Error::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::create_time_series_summary::Error::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [point_count][crate::model::create_time_series_summary::Error::point_count].
        pub fn set_point_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.point_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Error {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.CreateTimeSeriesSummary.Error"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Error {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __status,
                __point_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Error")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "status" => Ok(__FieldTag::__status),
                                "pointCount" => Ok(__FieldTag::__point_count),
                                "point_count" => Ok(__FieldTag::__point_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Error;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Error")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::__point_count => {
                                if !fields.insert(__FieldTag::__point_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for point_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.point_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Error {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !wkt::internal::is_default(&self.point_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("pointCount", &__With(&self.point_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The `QueryTimeSeries` request. For information about the status of
/// Monitoring Query Language (MQL), see the [MQL deprecation
/// notice](https://cloud.google.com/stackdriver/docs/deprecations/mql).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct QueryTimeSeriesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub name: std::string::String,

    /// Required. The query in the [Monitoring Query
    /// Language](https://cloud.google.com/monitoring/mql/reference) format.
    /// The default time zone is in UTC.
    pub query: std::string::String,

    /// A positive number that is the maximum number of time_series_data to return.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::QueryTimeSeriesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryTimeSeriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryTimeSeriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryTimeSeriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryTimeSeriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __query,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryTimeSeriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "query" => Ok(__FieldTag::__query),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryTimeSeriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryTimeSeriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryTimeSeriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `QueryTimeSeries` response. For information about the status of
/// Monitoring Query Language (MQL), see the [MQL deprecation
/// notice](https://cloud.google.com/stackdriver/docs/deprecations/mql).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct QueryTimeSeriesResponse {
    /// The descriptor for the time series data.
    pub time_series_descriptor: std::option::Option<crate::model::TimeSeriesDescriptor>,

    /// The time series data.
    pub time_series_data: std::vec::Vec<crate::model::TimeSeriesData>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results, use that value as
    /// `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    /// Query execution errors that may have caused the time series data returned
    /// to be incomplete. The available data will be available in the
    /// response.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryTimeSeriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_descriptor][crate::model::QueryTimeSeriesResponse::time_series_descriptor].
    pub fn set_time_series_descriptor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSeriesDescriptor>,
    {
        self.time_series_descriptor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_series_descriptor][crate::model::QueryTimeSeriesResponse::time_series_descriptor].
    pub fn set_or_clear_time_series_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSeriesDescriptor>,
    {
        self.time_series_descriptor = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_series_data][crate::model::QueryTimeSeriesResponse::time_series_data].
    pub fn set_time_series_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesData>,
    {
        use std::iter::Iterator;
        self.time_series_data = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::QueryTimeSeriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::QueryTimeSeriesResponse::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryTimeSeriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for QueryTimeSeriesResponse {
    type PageItem = crate::model::TimeSeriesData;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.time_series_data
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryTimeSeriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_descriptor,
            __time_series_data,
            __next_page_token,
            __partial_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryTimeSeriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesDescriptor" => Ok(__FieldTag::__time_series_descriptor),
                            "time_series_descriptor" => Ok(__FieldTag::__time_series_descriptor),
                            "timeSeriesData" => Ok(__FieldTag::__time_series_data),
                            "time_series_data" => Ok(__FieldTag::__time_series_data),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryTimeSeriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryTimeSeriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_descriptor => {
                            if !fields.insert(__FieldTag::__time_series_descriptor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_descriptor",
                                ));
                            }
                            result.time_series_descriptor = map.next_value::<std::option::Option<crate::model::TimeSeriesDescriptor>>()?
                                ;
                        }
                        __FieldTag::__time_series_data => {
                            if !fields.insert(__FieldTag::__time_series_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_data",
                                ));
                            }
                            result.time_series_data =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TimeSeriesData>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryTimeSeriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.time_series_descriptor.is_some() {
            state.serialize_entry("timeSeriesDescriptor", &self.time_series_descriptor)?;
        }
        if !self.time_series_data.is_empty() {
            state.serialize_entry("timeSeriesData", &self.time_series_data)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This is an error detail intended to be used with INVALID_ARGUMENT errors.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryErrorList {
    /// Errors in parsing the time series query language text. The number of errors
    /// in the response may be limited.
    pub errors: std::vec::Vec<crate::model::QueryError>,

    /// A summary of all the errors.
    pub error_summary: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryErrorList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [errors][crate::model::QueryErrorList::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_summary][crate::model::QueryErrorList::error_summary].
    pub fn set_error_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_summary = v.into();
        self
    }
}

impl wkt::message::Message for QueryErrorList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.QueryErrorList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryErrorList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __errors,
            __error_summary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryErrorList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errors" => Ok(__FieldTag::__errors),
                            "errorSummary" => Ok(__FieldTag::__error_summary),
                            "error_summary" => Ok(__FieldTag::__error_summary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryErrorList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryErrorList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QueryError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_summary => {
                            if !fields.insert(__FieldTag::__error_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_summary",
                                ));
                            }
                            result.error_summary = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryErrorList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self.error_summary.is_empty() {
            state.serialize_entry("errorSummary", &self.error_summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a change made to a configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MutationRecord {
    /// When the change occurred.
    pub mutate_time: std::option::Option<wkt::Timestamp>,

    /// The email address of the user making the change.
    pub mutated_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MutationRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mutate_time][crate::model::MutationRecord::mutate_time].
    pub fn set_mutate_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.mutate_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mutate_time][crate::model::MutationRecord::mutate_time].
    pub fn set_or_clear_mutate_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.mutate_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mutated_by][crate::model::MutationRecord::mutated_by].
    pub fn set_mutated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mutated_by = v.into();
        self
    }
}

impl wkt::message::Message for MutationRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.MutationRecord"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MutationRecord {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mutate_time,
            __mutated_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MutationRecord")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mutateTime" => Ok(__FieldTag::__mutate_time),
                            "mutate_time" => Ok(__FieldTag::__mutate_time),
                            "mutatedBy" => Ok(__FieldTag::__mutated_by),
                            "mutated_by" => Ok(__FieldTag::__mutated_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MutationRecord;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MutationRecord")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mutate_time => {
                            if !fields.insert(__FieldTag::__mutate_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mutate_time",
                                ));
                            }
                            result.mutate_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__mutated_by => {
                            if !fields.insert(__FieldTag::__mutated_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mutated_by",
                                ));
                            }
                            result.mutated_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MutationRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mutate_time.is_some() {
            state.serialize_entry("mutateTime", &self.mutate_time)?;
        }
        if !self.mutated_by.is_empty() {
            state.serialize_entry("mutatedBy", &self.mutated_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A description of a notification channel. The descriptor includes
/// the properties of the channel and the set of labels or fields that
/// must be specified to configure channels of a given type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NotificationChannelDescriptor {
    /// The full REST resource name for this descriptor. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[TYPE]
    /// ```
    ///
    /// In the above, `[TYPE]` is the value of the `type` field.
    pub name: std::string::String,

    /// The type of notification channel, such as "email" and "sms". To view the
    /// full list of channels, see
    /// [Channel
    /// descriptors](https://cloud.google.com/monitoring/alerts/using-channels-api#ncd).
    /// Notification channel types are globally unique.
    pub r#type: std::string::String,

    /// A human-readable name for the notification channel type.  This
    /// form of the name is suitable for a user interface.
    pub display_name: std::string::String,

    /// A human-readable description of the notification channel
    /// type. The description may include a description of the properties
    /// of the channel and pointers to external documentation.
    pub description: std::string::String,

    /// The set of labels that must be defined to identify a particular
    /// channel of the corresponding type. Each label includes a
    /// description for how that field should be populated.
    pub labels: std::vec::Vec<api::model::LabelDescriptor>,

    /// The tiers that support this notification channel; the project service tier
    /// must be one of the supported_tiers.
    #[deprecated]
    pub supported_tiers: std::vec::Vec<crate::model::ServiceTier>,

    /// The product launch stage for channels of this type.
    pub launch_stage: api::model::LaunchStage,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationChannelDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotificationChannelDescriptor::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::NotificationChannelDescriptor::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotificationChannelDescriptor::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotificationChannelDescriptor::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NotificationChannelDescriptor::labels].
    pub fn set_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::LabelDescriptor>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_tiers][crate::model::NotificationChannelDescriptor::supported_tiers].
    #[deprecated]
    pub fn set_supported_tiers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceTier>,
    {
        use std::iter::Iterator;
        self.supported_tiers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [launch_stage][crate::model::NotificationChannelDescriptor::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }
}

impl wkt::message::Message for NotificationChannelDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.NotificationChannelDescriptor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotificationChannelDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __display_name,
            __description,
            __labels,
            __supported_tiers,
            __launch_stage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationChannelDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "supportedTiers" => Ok(__FieldTag::__supported_tiers),
                            "supported_tiers" => Ok(__FieldTag::__supported_tiers),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotificationChannelDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationChannelDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map.next_value::<std::option::Option<std::vec::Vec<api::model::LabelDescriptor>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__supported_tiers => {
                            if !fields.insert(__FieldTag::__supported_tiers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_tiers",
                                ));
                            }
                            result.supported_tiers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ServiceTier>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<api::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NotificationChannelDescriptor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.supported_tiers.is_empty() {
            state.serialize_entry("supportedTiers", &self.supported_tiers)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A `NotificationChannel` is a medium through which an alert is
/// delivered when a policy violation is detected. Examples of channels
/// include email, SMS, and third-party messaging applications. Fields
/// containing sensitive information like authentication tokens or
/// contact info are only partially populated on retrieval.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NotificationChannel {
    /// The type of the notification channel. This field matches the
    /// value of the
    /// [NotificationChannelDescriptor.type][google.monitoring.v3.NotificationChannelDescriptor.type]
    /// field.
    ///
    /// [google.monitoring.v3.NotificationChannelDescriptor.type]: crate::model::NotificationChannelDescriptor::type
    pub r#type: std::string::String,

    /// Identifier. The full REST resource name for this channel. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    ///
    /// The `[CHANNEL_ID]` is automatically assigned by the server on creation.
    pub name: std::string::String,

    /// An optional human-readable name for this notification channel. It is
    /// recommended that you specify a non-empty and unique name in order to
    /// make it easier to identify the channels in your project, though this is
    /// not enforced. The display name is limited to 512 Unicode characters.
    pub display_name: std::string::String,

    /// An optional human-readable description of this notification channel. This
    /// description may provide additional details, beyond the display
    /// name, for the channel. This may not exceed 1024 Unicode characters.
    pub description: std::string::String,

    /// Configuration fields that define the channel and its behavior. The
    /// permissible and required labels are specified in the
    /// [NotificationChannelDescriptor.labels][google.monitoring.v3.NotificationChannelDescriptor.labels]
    /// of the `NotificationChannelDescriptor` corresponding to the `type` field.
    ///
    /// [google.monitoring.v3.NotificationChannelDescriptor.labels]: crate::model::NotificationChannelDescriptor::labels
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User-supplied key/value data that does not need to conform to
    /// the corresponding `NotificationChannelDescriptor`'s schema, unlike
    /// the `labels` field. This field is intended to be used for organizing
    /// and identifying the `NotificationChannel` objects.
    ///
    /// The field can contain up to 64 entries. Each key and value is limited to
    /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
    /// values can contain only lowercase letters, numerals, underscores, and
    /// dashes. Keys must begin with a letter.
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Indicates whether this channel has been verified or not. On a
    /// [`ListNotificationChannels`][google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
    /// or
    /// [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
    /// operation, this field is expected to be populated.
    ///
    /// If the value is `UNVERIFIED`, then it indicates that the channel is
    /// non-functioning (it both requires verification and lacks verification);
    /// otherwise, it is assumed that the channel works.
    ///
    /// If the channel is neither `VERIFIED` nor `UNVERIFIED`, it implies that
    /// the channel is of a type that does not require verification or that
    /// this specific channel has been exempted from verification because it was
    /// created prior to verification being required for channels of this type.
    ///
    /// This field cannot be modified using a standard
    /// [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
    /// operation. To change the value of this field, you must call
    /// [`VerifyNotificationChannel`][google.monitoring.v3.NotificationChannelService.VerifyNotificationChannel].
    ///
    /// [google.monitoring.v3.NotificationChannelService.GetNotificationChannel]: crate::client::NotificationChannelService::get_notification_channel
    /// [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]: crate::client::NotificationChannelService::list_notification_channels
    /// [google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]: crate::client::NotificationChannelService::update_notification_channel
    /// [google.monitoring.v3.NotificationChannelService.VerifyNotificationChannel]: crate::client::NotificationChannelService::verify_notification_channel
    pub verification_status: crate::model::notification_channel::VerificationStatus,

    /// Whether notifications are forwarded to the described channel. This makes
    /// it possible to disable delivery of notifications to a particular channel
    /// without removing the channel from all alerting policies that reference
    /// the channel. This is a more convenient approach when the change is
    /// temporary and you want to receive notifications from the same set
    /// of alerting policies on the channel at some point in the future.
    pub enabled: std::option::Option<wkt::BoolValue>,

    /// Record of the creation of this channel.
    pub creation_record: std::option::Option<crate::model::MutationRecord>,

    /// Records of the modification of this channel.
    pub mutation_records: std::vec::Vec<crate::model::MutationRecord>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationChannel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::NotificationChannel::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::NotificationChannel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotificationChannel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotificationChannel::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NotificationChannel::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::NotificationChannel::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [verification_status][crate::model::NotificationChannel::verification_status].
    pub fn set_verification_status<
        T: std::convert::Into<crate::model::notification_channel::VerificationStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.verification_status = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::NotificationChannel::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::NotificationChannel::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_record][crate::model::NotificationChannel::creation_record].
    pub fn set_creation_record<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MutationRecord>,
    {
        self.creation_record = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_record][crate::model::NotificationChannel::creation_record].
    pub fn set_or_clear_creation_record<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MutationRecord>,
    {
        self.creation_record = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mutation_records][crate::model::NotificationChannel::mutation_records].
    pub fn set_mutation_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MutationRecord>,
    {
        use std::iter::Iterator;
        self.mutation_records = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NotificationChannel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.NotificationChannel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotificationChannel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __name,
            __display_name,
            __description,
            __labels,
            __user_labels,
            __verification_status,
            __enabled,
            __creation_record,
            __mutation_records,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationChannel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "userLabels" => Ok(__FieldTag::__user_labels),
                            "user_labels" => Ok(__FieldTag::__user_labels),
                            "verificationStatus" => Ok(__FieldTag::__verification_status),
                            "verification_status" => Ok(__FieldTag::__verification_status),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "creationRecord" => Ok(__FieldTag::__creation_record),
                            "creation_record" => Ok(__FieldTag::__creation_record),
                            "mutationRecords" => Ok(__FieldTag::__mutation_records),
                            "mutation_records" => Ok(__FieldTag::__mutation_records),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotificationChannel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationChannel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_labels => {
                            if !fields.insert(__FieldTag::__user_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_labels",
                                ));
                            }
                            result.user_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verification_status => {
                            if !fields.insert(__FieldTag::__verification_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verification_status",
                                ));
                            }
                            result.verification_status = map
                                .next_value::<std::option::Option<
                                    crate::model::notification_channel::VerificationStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__creation_record => {
                            if !fields.insert(__FieldTag::__creation_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_record",
                                ));
                            }
                            result.creation_record = map
                                .next_value::<std::option::Option<crate::model::MutationRecord>>(
                                )?;
                        }
                        __FieldTag::__mutation_records => {
                            if !fields.insert(__FieldTag::__mutation_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mutation_records",
                                ));
                            }
                            result.mutation_records =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MutationRecord>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NotificationChannel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !wkt::internal::is_default(&self.verification_status) {
            state.serialize_entry("verificationStatus", &self.verification_status)?;
        }
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.creation_record.is_some() {
            state.serialize_entry("creationRecord", &self.creation_record)?;
        }
        if !self.mutation_records.is_empty() {
            state.serialize_entry("mutationRecords", &self.mutation_records)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NotificationChannel].
pub mod notification_channel {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether the channel has been verified or not. It is illegal
    /// to specify this field in a
    /// [`CreateNotificationChannel`][google.monitoring.v3.NotificationChannelService.CreateNotificationChannel]
    /// or an
    /// [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
    /// operation.
    ///
    /// [google.monitoring.v3.NotificationChannelService.CreateNotificationChannel]: crate::client::NotificationChannelService::create_notification_channel
    /// [google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]: crate::client::NotificationChannelService::update_notification_channel
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VerificationStatus {
        /// Sentinel value used to indicate that the state is unknown, omitted, or
        /// is not applicable (as in the case of channels that neither support
        /// nor require verification in order to function).
        Unspecified,
        /// The channel has yet to be verified and requires verification to function.
        /// Note that this state also applies to the case where the verification
        /// process has been initiated by sending a verification code but where
        /// the verification code has not been submitted to complete the process.
        Unverified,
        /// It has been proven that notifications can be received on this
        /// notification channel and that someone on the project has access
        /// to messages that are delivered to that channel.
        Verified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VerificationStatus::value] or
        /// [VerificationStatus::name].
        UnknownValue(verification_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod verification_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VerificationStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unverified => std::option::Option::Some(1),
                Self::Verified => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERIFICATION_STATUS_UNSPECIFIED"),
                Self::Unverified => std::option::Option::Some("UNVERIFIED"),
                Self::Verified => std::option::Option::Some("VERIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VerificationStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VerificationStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VerificationStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unverified,
                2 => Self::Verified,
                _ => Self::UnknownValue(verification_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VerificationStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERIFICATION_STATUS_UNSPECIFIED" => Self::Unspecified,
                "UNVERIFIED" => Self::Unverified,
                "VERIFIED" => Self::Verified,
                _ => Self::UnknownValue(verification_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VerificationStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unverified => serializer.serialize_i32(1),
                Self::Verified => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VerificationStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VerificationStatus>::new(
                ".google.monitoring.v3.NotificationChannel.VerificationStatus",
            ))
        }
    }
}

/// The `ListNotificationChannelDescriptors` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotificationChannelDescriptorsRequest {
    /// Required. The REST resource name of the parent from which to retrieve
    /// the notification channel descriptors. The expected syntax is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// Note that this
    /// [names](https://cloud.google.com/monitoring/api/v3#project_name) the parent
    /// container in which to look for the descriptors; to retrieve a single
    /// descriptor by name, use the
    /// [GetNotificationChannelDescriptor][google.monitoring.v3.NotificationChannelService.GetNotificationChannelDescriptor]
    /// operation, instead.
    ///
    /// [google.monitoring.v3.NotificationChannelService.GetNotificationChannelDescriptor]: crate::client::NotificationChannelService::get_notification_channel_descriptor
    pub name: std::string::String,

    /// The maximum number of results to return in a single response. If
    /// not set to a positive number, a reasonable value will be chosen by the
    /// service.
    pub page_size: i32,

    /// If non-empty, `page_token` must contain a value returned as the
    /// `next_page_token` in a previous response to request the next set
    /// of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotificationChannelDescriptorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListNotificationChannelDescriptorsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotificationChannelDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotificationChannelDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelDescriptorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotificationChannelDescriptorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListNotificationChannelDescriptorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotificationChannelDescriptorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotificationChannelDescriptorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotificationChannelDescriptorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListNotificationChannelDescriptors` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotificationChannelDescriptorsResponse {
    /// The monitored resource descriptors supported for the specified
    /// project, optionally filtered.
    pub channel_descriptors: std::vec::Vec<crate::model::NotificationChannelDescriptor>,

    /// If not empty, indicates that there may be more results that match
    /// the request. Use the value in the `page_token` field in a
    /// subsequent request to fetch the next set of results. If empty,
    /// all results have been returned.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotificationChannelDescriptorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel_descriptors][crate::model::ListNotificationChannelDescriptorsResponse::channel_descriptors].
    pub fn set_channel_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotificationChannelDescriptor>,
    {
        use std::iter::Iterator;
        self.channel_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNotificationChannelDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelDescriptorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotificationChannelDescriptorsResponse {
    type PageItem = crate::model::NotificationChannelDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.channel_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotificationChannelDescriptorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel_descriptors,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ListNotificationChannelDescriptorsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channelDescriptors" => Ok(__FieldTag::__channel_descriptors),
                            "channel_descriptors" => Ok(__FieldTag::__channel_descriptors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotificationChannelDescriptorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotificationChannelDescriptorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel_descriptors => {
                            if !fields.insert(__FieldTag::__channel_descriptors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_descriptors",
                                ));
                            }
                            result.channel_descriptors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NotificationChannelDescriptor>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotificationChannelDescriptorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.channel_descriptors.is_empty() {
            state.serialize_entry("channelDescriptors", &self.channel_descriptors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetNotificationChannelDescriptor` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNotificationChannelDescriptorRequest {
    /// Required. The channel type for which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNotificationChannelDescriptorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotificationChannelDescriptorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNotificationChannelDescriptorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelDescriptorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNotificationChannelDescriptorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GetNotificationChannelDescriptorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNotificationChannelDescriptorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNotificationChannelDescriptorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNotificationChannelDescriptorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `CreateNotificationChannel` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNotificationChannelRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// This names the container into which the channel will be
    /// written, this does not name the newly created channel. The resulting
    /// channel's name will have a normalized version of this field as a prefix,
    /// but will add `/notificationChannels/[CHANNEL_ID]` to identify the channel.
    pub name: std::string::String,

    /// Required. The definition of the `NotificationChannel` to create.
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNotificationChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [notification_channel][crate::model::CreateNotificationChannelRequest::notification_channel].
    pub fn set_notification_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationChannel>,
    {
        self.notification_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_channel][crate::model::CreateNotificationChannelRequest::notification_channel].
    pub fn set_or_clear_notification_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationChannel>,
    {
        self.notification_channel = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateNotificationChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateNotificationChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __notification_channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNotificationChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "notificationChannel" => Ok(__FieldTag::__notification_channel),
                            "notification_channel" => Ok(__FieldTag::__notification_channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateNotificationChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNotificationChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notification_channel => {
                            if !fields.insert(__FieldTag::__notification_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_channel",
                                ));
                            }
                            result.notification_channel = map.next_value::<std::option::Option<crate::model::NotificationChannel>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateNotificationChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.notification_channel.is_some() {
            state.serialize_entry("notificationChannel", &self.notification_channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListNotificationChannels` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotificationChannelsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
    /// to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// This names the container
    /// in which to look for the notification channels; it does not name a
    /// specific channel. To query a specific channel by REST resource name, use
    /// the
    /// [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
    /// operation.
    ///
    /// [google.monitoring.v3.NotificationChannelService.GetNotificationChannel]: crate::client::NotificationChannelService::get_notification_channel
    pub name: std::string::String,

    /// Optional. If provided, this field specifies the criteria that must be met
    /// by notification channels to be included in the response.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    pub filter: std::string::String,

    /// Optional. A comma-separated list of fields by which to sort the result.
    /// Supports the same set of fields as in `filter`. Entries can be prefixed
    /// with a minus sign to sort in descending rather than ascending order.
    ///
    /// For more details, see [sorting and
    /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
    pub order_by: std::string::String,

    /// Optional. The maximum number of results to return in a single response. If
    /// not set to a positive number, a reasonable value will be chosen by the
    /// service.
    pub page_size: i32,

    /// Optional. If non-empty, `page_token` must contain a value returned as the
    /// `next_page_token` in a previous response to request the next set
    /// of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotificationChannelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListNotificationChannelsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotificationChannelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotificationChannelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotificationChannelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotificationChannelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotificationChannelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __order_by,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotificationChannelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotificationChannelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotificationChannelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotificationChannelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListNotificationChannels` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotificationChannelsResponse {
    /// The notification channels defined for the specified project.
    pub notification_channels: std::vec::Vec<crate::model::NotificationChannel>,

    /// If not empty, indicates that there may be more results that match
    /// the request. Use the value in the `page_token` field in a
    /// subsequent request to fetch the next set of results. If empty,
    /// all results have been returned.
    pub next_page_token: std::string::String,

    /// The total number of notification channels in all pages. This number is only
    /// an estimate, and may change in subsequent pages. <https://aip.dev/158>
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotificationChannelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notification_channels][crate::model::ListNotificationChannelsResponse::notification_channels].
    pub fn set_notification_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotificationChannel>,
    {
        use std::iter::Iterator;
        self.notification_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNotificationChannelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListNotificationChannelsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationChannelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListNotificationChannelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotificationChannelsResponse {
    type PageItem = crate::model::NotificationChannel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notification_channels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotificationChannelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notification_channels,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotificationChannelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notificationChannels" => Ok(__FieldTag::__notification_channels),
                            "notification_channels" => Ok(__FieldTag::__notification_channels),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotificationChannelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotificationChannelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notification_channels => {
                            if !fields.insert(__FieldTag::__notification_channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_channels",
                                ));
                            }
                            result.notification_channels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NotificationChannel>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotificationChannelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.notification_channels.is_empty() {
            state.serialize_entry("notificationChannels", &self.notification_channels)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetNotificationChannel` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNotificationChannelRequest {
    /// Required. The channel for which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNotificationChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNotificationChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNotificationChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNotificationChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNotificationChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNotificationChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `UpdateNotificationChannel` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNotificationChannelRequest {
    /// Optional. The fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A description of the changes to be applied to the specified
    /// notification channel. The description must provide a definition for
    /// fields to be updated; the names of these fields should also be
    /// included in the `update_mask`.
    pub notification_channel: std::option::Option<crate::model::NotificationChannel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNotificationChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateNotificationChannelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNotificationChannelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_channel][crate::model::UpdateNotificationChannelRequest::notification_channel].
    pub fn set_notification_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationChannel>,
    {
        self.notification_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_channel][crate::model::UpdateNotificationChannelRequest::notification_channel].
    pub fn set_or_clear_notification_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationChannel>,
    {
        self.notification_channel = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateNotificationChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateNotificationChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __notification_channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNotificationChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "notificationChannel" => Ok(__FieldTag::__notification_channel),
                            "notification_channel" => Ok(__FieldTag::__notification_channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateNotificationChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNotificationChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__notification_channel => {
                            if !fields.insert(__FieldTag::__notification_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_channel",
                                ));
                            }
                            result.notification_channel = map.next_value::<std::option::Option<crate::model::NotificationChannel>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateNotificationChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.notification_channel.is_some() {
            state.serialize_entry("notificationChannel", &self.notification_channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `DeleteNotificationChannel` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNotificationChannelRequest {
    /// Required. The channel for which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
    /// ```
    pub name: std::string::String,

    /// If true, the notification channel will be deleted regardless of its
    /// use in alert policies (the policies will be updated to remove the
    /// channel). If false, this operation will fail if the notification channel
    /// is referenced by existing alerting policies.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNotificationChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteNotificationChannelRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteNotificationChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteNotificationChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNotificationChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteNotificationChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNotificationChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteNotificationChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `SendNotificationChannelVerificationCode` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SendNotificationChannelVerificationCodeRequest {
    /// Required. The notification channel to which to send a verification code.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SendNotificationChannelVerificationCodeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SendNotificationChannelVerificationCodeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SendNotificationChannelVerificationCodeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.SendNotificationChannelVerificationCodeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SendNotificationChannelVerificationCodeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for SendNotificationChannelVerificationCodeRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SendNotificationChannelVerificationCodeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SendNotificationChannelVerificationCodeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SendNotificationChannelVerificationCodeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetNotificationChannelVerificationCode` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNotificationChannelVerificationCodeRequest {
    /// Required. The notification channel for which a verification code is to be
    /// generated and retrieved. This must name a channel that is already verified;
    /// if the specified channel is not verified, the request will fail.
    pub name: std::string::String,

    /// The desired expiration time. If specified, the API will guarantee that
    /// the returned code will not be valid after the specified timestamp;
    /// however, the API cannot guarantee that the returned code will be
    /// valid for at least as long as the requested time (the API puts an upper
    /// bound on the amount of time for which a code may be valid). If omitted,
    /// a default expiration will be used, which may be less than the max
    /// permissible expiration (so specifying an expiration may extend the
    /// code's lifetime over omitting an expiration, even though the API does
    /// impose an upper limit on the maximum expiration that is permitted).
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNotificationChannelVerificationCodeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotificationChannelVerificationCodeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GetNotificationChannelVerificationCodeRequest::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::GetNotificationChannelVerificationCodeRequest::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetNotificationChannelVerificationCodeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelVerificationCodeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNotificationChannelVerificationCodeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for GetNotificationChannelVerificationCodeRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNotificationChannelVerificationCodeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNotificationChannelVerificationCodeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNotificationChannelVerificationCodeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetNotificationChannelVerificationCode` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNotificationChannelVerificationCodeResponse {
    /// The verification code, which may be used to verify other channels
    /// that have an equivalent identity (i.e. other channels of the same
    /// type with the same fingerprint such as other email channels with
    /// the same email address or other sms channels with the same number).
    pub code: std::string::String,

    /// The expiration time associated with the code that was returned. If
    /// an expiration was provided in the request, this is the minimum of the
    /// requested expiration in the request and the max permitted expiration.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNotificationChannelVerificationCodeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::GetNotificationChannelVerificationCodeResponse::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GetNotificationChannelVerificationCodeResponse::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::GetNotificationChannelVerificationCodeResponse::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetNotificationChannelVerificationCodeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetNotificationChannelVerificationCodeResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNotificationChannelVerificationCodeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for GetNotificationChannelVerificationCodeResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNotificationChannelVerificationCodeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNotificationChannelVerificationCodeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNotificationChannelVerificationCodeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `VerifyNotificationChannel` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyNotificationChannelRequest {
    /// Required. The notification channel to verify.
    pub name: std::string::String,

    /// Required. The verification code that was delivered to the channel as
    /// a result of invoking the `SendNotificationChannelVerificationCode` API
    /// method or that was retrieved from a verified channel via
    /// `GetNotificationChannelVerificationCode`. For example, one might have
    /// "G-123456" or "TKNZGhhd2EyN3I1MnRnMjRv" (in general, one is only
    /// guaranteed that the code is valid UTF-8; one should not
    /// make any assumptions regarding the structure or format of the code).
    pub code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyNotificationChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyNotificationChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [code][crate::model::VerifyNotificationChannelRequest::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for VerifyNotificationChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.VerifyNotificationChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyNotificationChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyNotificationChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "code" => Ok(__FieldTag::__code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyNotificationChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyNotificationChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyNotificationChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A `Service` is a discrete, autonomous, and network-accessible unit, designed
/// to solve an individual concern
/// ([Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)). In
/// Cloud Monitoring, a `Service` acts as the root resource under which
/// operational aspects of the service are accessible.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Service {
    /// Identifier. Resource name for this Service. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    pub name: std::string::String,

    /// Name used for UI elements listing this Service.
    pub display_name: std::string::String,

    /// Message that contains the service type and service labels of this service
    /// if it is a basic service.
    /// Documentation and examples
    /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
    pub basic_service: std::option::Option<crate::model::service::BasicService>,

    /// Configuration for how to query telemetry on a Service.
    pub telemetry: std::option::Option<crate::model::service::Telemetry>,

    /// Labels which have been used to annotate the service. Label keys must start
    /// with a letter. Label keys and values may contain lowercase letters,
    /// numbers, underscores, and dashes. Label keys and values have a maximum
    /// length of 63 characters, and must be less than 128 bytes in size. Up to 64
    /// label entries may be stored. For labels which do not have a semantic value,
    /// the empty string may be supplied for the label value.
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// REQUIRED. Service-identifying atoms specifying the underlying service.
    pub identifier: std::option::Option<crate::model::service::Identifier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Service::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [basic_service][crate::model::Service::basic_service].
    pub fn set_basic_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::service::BasicService>,
    {
        self.basic_service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [basic_service][crate::model::Service::basic_service].
    pub fn set_or_clear_basic_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::service::BasicService>,
    {
        self.basic_service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [telemetry][crate::model::Service::telemetry].
    pub fn set_telemetry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::service::Telemetry>,
    {
        self.telemetry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [telemetry][crate::model::Service::telemetry].
    pub fn set_or_clear_telemetry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::service::Telemetry>,
    {
        self.telemetry = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_labels][crate::model::Service::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [identifier][crate::model::Service::identifier].
    ///
    /// Note that all the setters affecting `identifier` are mutually
    /// exclusive.
    pub fn set_identifier<
        T: std::convert::Into<std::option::Option<crate::model::service::Identifier>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier = v.into();
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `Custom`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom(&self) -> std::option::Option<&std::boxed::Box<crate::model::service::Custom>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::Custom(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `Custom`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_custom<T: std::convert::Into<std::boxed::Box<crate::model::service::Custom>>>(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::Custom(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `AppEngine`, `None` if the field is not set or
    /// holds a different branch.
    pub fn app_engine(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::AppEngine>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::AppEngine(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `AppEngine`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_app_engine<
        T: std::convert::Into<std::boxed::Box<crate::model::service::AppEngine>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::AppEngine(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `CloudEndpoints`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_endpoints(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::CloudEndpoints>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::CloudEndpoints(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `CloudEndpoints`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_cloud_endpoints<
        T: std::convert::Into<std::boxed::Box<crate::model::service::CloudEndpoints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::CloudEndpoints(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `ClusterIstio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster_istio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::ClusterIstio>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::ClusterIstio(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `ClusterIstio`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_cluster_istio<
        T: std::convert::Into<std::boxed::Box<crate::model::service::ClusterIstio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::ClusterIstio(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `MeshIstio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mesh_istio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::MeshIstio>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::MeshIstio(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `MeshIstio`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_mesh_istio<
        T: std::convert::Into<std::boxed::Box<crate::model::service::MeshIstio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::MeshIstio(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `IstioCanonicalService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn istio_canonical_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::IstioCanonicalService>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::IstioCanonicalService(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `IstioCanonicalService`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_istio_canonical_service<
        T: std::convert::Into<std::boxed::Box<crate::model::service::IstioCanonicalService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier = std::option::Option::Some(
            crate::model::service::Identifier::IstioCanonicalService(v.into()),
        );
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `CloudRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::CloudRun>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::CloudRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `CloudRun`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_cloud_run<
        T: std::convert::Into<std::boxed::Box<crate::model::service::CloudRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::CloudRun(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `GkeNamespace`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke_namespace(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::GkeNamespace>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::GkeNamespace(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `GkeNamespace`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_gke_namespace<
        T: std::convert::Into<std::boxed::Box<crate::model::service::GkeNamespace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::GkeNamespace(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `GkeWorkload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke_workload(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::GkeWorkload>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::GkeWorkload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `GkeWorkload`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_gke_workload<
        T: std::convert::Into<std::boxed::Box<crate::model::service::GkeWorkload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::GkeWorkload(v.into()));
        self
    }

    /// The value of [identifier][crate::model::Service::identifier]
    /// if it holds a `GkeService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::service::GkeService>> {
        #[allow(unreachable_patterns)]
        self.identifier.as_ref().and_then(|v| match v {
            crate::model::service::Identifier::GkeService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [identifier][crate::model::Service::identifier]
    /// to hold a `GkeService`.
    ///
    /// Note that all the setters affecting `identifier` are
    /// mutually exclusive.
    pub fn set_gke_service<
        T: std::convert::Into<std::boxed::Box<crate::model::service::GkeService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identifier =
            std::option::Option::Some(crate::model::service::Identifier::GkeService(v.into()));
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Service"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Service {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __custom,
            __app_engine,
            __cloud_endpoints,
            __cluster_istio,
            __mesh_istio,
            __istio_canonical_service,
            __cloud_run,
            __gke_namespace,
            __gke_workload,
            __gke_service,
            __basic_service,
            __telemetry,
            __user_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Service")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "custom" => Ok(__FieldTag::__custom),
                            "appEngine" => Ok(__FieldTag::__app_engine),
                            "app_engine" => Ok(__FieldTag::__app_engine),
                            "cloudEndpoints" => Ok(__FieldTag::__cloud_endpoints),
                            "cloud_endpoints" => Ok(__FieldTag::__cloud_endpoints),
                            "clusterIstio" => Ok(__FieldTag::__cluster_istio),
                            "cluster_istio" => Ok(__FieldTag::__cluster_istio),
                            "meshIstio" => Ok(__FieldTag::__mesh_istio),
                            "mesh_istio" => Ok(__FieldTag::__mesh_istio),
                            "istioCanonicalService" => Ok(__FieldTag::__istio_canonical_service),
                            "istio_canonical_service" => Ok(__FieldTag::__istio_canonical_service),
                            "cloudRun" => Ok(__FieldTag::__cloud_run),
                            "cloud_run" => Ok(__FieldTag::__cloud_run),
                            "gkeNamespace" => Ok(__FieldTag::__gke_namespace),
                            "gke_namespace" => Ok(__FieldTag::__gke_namespace),
                            "gkeWorkload" => Ok(__FieldTag::__gke_workload),
                            "gke_workload" => Ok(__FieldTag::__gke_workload),
                            "gkeService" => Ok(__FieldTag::__gke_service),
                            "gke_service" => Ok(__FieldTag::__gke_service),
                            "basicService" => Ok(__FieldTag::__basic_service),
                            "basic_service" => Ok(__FieldTag::__basic_service),
                            "telemetry" => Ok(__FieldTag::__telemetry),
                            "userLabels" => Ok(__FieldTag::__user_labels),
                            "user_labels" => Ok(__FieldTag::__user_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Service;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Service")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom => {
                            if !fields.insert(__FieldTag::__custom) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.custom, latest field was custom",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::Custom(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::Custom>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__app_engine => {
                            if !fields.insert(__FieldTag::__app_engine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.app_engine, latest field was appEngine",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::AppEngine(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::AppEngine>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_endpoints => {
                            if !fields.insert(__FieldTag::__cloud_endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_endpoints",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.cloud_endpoints, latest field was cloudEndpoints",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::CloudEndpoints(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::CloudEndpoints>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cluster_istio => {
                            if !fields.insert(__FieldTag::__cluster_istio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_istio",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.cluster_istio, latest field was clusterIstio",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::ClusterIstio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::ClusterIstio>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mesh_istio => {
                            if !fields.insert(__FieldTag::__mesh_istio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mesh_istio",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.mesh_istio, latest field was meshIstio",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::MeshIstio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::MeshIstio>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__istio_canonical_service => {
                            if !fields.insert(__FieldTag::__istio_canonical_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for istio_canonical_service",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.istio_canonical_service, latest field was istioCanonicalService",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::IstioCanonicalService(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::service::IstioCanonicalService,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_run => {
                            if !fields.insert(__FieldTag::__cloud_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.cloud_run, latest field was cloudRun",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::CloudRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::CloudRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gke_namespace => {
                            if !fields.insert(__FieldTag::__gke_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_namespace",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.gke_namespace, latest field was gkeNamespace",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::GkeNamespace(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::GkeNamespace>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gke_workload => {
                            if !fields.insert(__FieldTag::__gke_workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_workload",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.gke_workload, latest field was gkeWorkload",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::GkeWorkload(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::GkeWorkload>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gke_service => {
                            if !fields.insert(__FieldTag::__gke_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_service",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .google.monitoring.v3.Service.gke_service, latest field was gkeService",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::service::Identifier::GkeService(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::service::GkeService>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__basic_service => {
                            if !fields.insert(__FieldTag::__basic_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for basic_service",
                                ));
                            }
                            result.basic_service = map.next_value::<std::option::Option<crate::model::service::BasicService>>()?
                                ;
                        }
                        __FieldTag::__telemetry => {
                            if !fields.insert(__FieldTag::__telemetry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for telemetry",
                                ));
                            }
                            result.telemetry = map.next_value::<std::option::Option<crate::model::service::Telemetry>>()?
                                ;
                        }
                        __FieldTag::__user_labels => {
                            if !fields.insert(__FieldTag::__user_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_labels",
                                ));
                            }
                            result.user_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Service {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.custom() {
            state.serialize_entry("custom", value)?;
        }
        if let Some(value) = self.app_engine() {
            state.serialize_entry("appEngine", value)?;
        }
        if let Some(value) = self.cloud_endpoints() {
            state.serialize_entry("cloudEndpoints", value)?;
        }
        if let Some(value) = self.cluster_istio() {
            state.serialize_entry("clusterIstio", value)?;
        }
        if let Some(value) = self.mesh_istio() {
            state.serialize_entry("meshIstio", value)?;
        }
        if let Some(value) = self.istio_canonical_service() {
            state.serialize_entry("istioCanonicalService", value)?;
        }
        if let Some(value) = self.cloud_run() {
            state.serialize_entry("cloudRun", value)?;
        }
        if let Some(value) = self.gke_namespace() {
            state.serialize_entry("gkeNamespace", value)?;
        }
        if let Some(value) = self.gke_workload() {
            state.serialize_entry("gkeWorkload", value)?;
        }
        if let Some(value) = self.gke_service() {
            state.serialize_entry("gkeService", value)?;
        }
        if self.basic_service.is_some() {
            state.serialize_entry("basicService", &self.basic_service)?;
        }
        if self.telemetry.is_some() {
            state.serialize_entry("telemetry", &self.telemetry)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Service].
pub mod service {
    #[allow(unused_imports)]
    use super::*;

    /// Use a custom service to designate a service that you want to monitor
    /// when none of the other service types (like App Engine, Cloud Run, or
    /// a GKE type) matches your intended service.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Custom {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Custom {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Custom {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.Custom"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Custom {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Custom")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Custom;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Custom")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Custom {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// App Engine service. Learn more at <https://cloud.google.com/appengine>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AppEngine {
        /// The ID of the App Engine module underlying this service. Corresponds to
        /// the `module_id` resource label in the [`gae_app` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_gae_app).
        pub module_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AppEngine {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [module_id][crate::model::service::AppEngine::module_id].
        pub fn set_module_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.module_id = v.into();
            self
        }
    }

    impl wkt::message::Message for AppEngine {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.AppEngine"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AppEngine {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __module_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AppEngine")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "moduleId" => Ok(__FieldTag::__module_id),
                                "module_id" => Ok(__FieldTag::__module_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AppEngine;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AppEngine")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__module_id => {
                                if !fields.insert(__FieldTag::__module_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for module_id",
                                    ));
                                }
                                result.module_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AppEngine {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.module_id.is_empty() {
                state.serialize_entry("moduleId", &self.module_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Cloud Endpoints service. Learn more at <https://cloud.google.com/endpoints>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudEndpoints {
        /// The name of the Cloud Endpoints service underlying this service.
        /// Corresponds to the `service` resource label in the [`api` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_api).
        pub service: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudEndpoints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::service::CloudEndpoints::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudEndpoints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.CloudEndpoints"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudEndpoints {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudEndpoints")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "service" => Ok(__FieldTag::__service),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudEndpoints;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudEndpoints")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service => {
                                if !fields.insert(__FieldTag::__service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service",
                                    ));
                                }
                                result.service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudEndpoints {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service.is_empty() {
                state.serialize_entry("service", &self.service)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Istio service scoped to a single Kubernetes cluster. Learn more at
    /// <https://istio.io>. Clusters running OSS Istio will have their services
    /// ingested as this type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterIstio {
        /// The location of the Kubernetes cluster in which this Istio service is
        /// defined. Corresponds to the `location` resource label in `k8s_cluster`
        /// resources.
        pub location: std::string::String,

        /// The name of the Kubernetes cluster in which this Istio service is
        /// defined. Corresponds to the `cluster_name` resource label in
        /// `k8s_cluster` resources.
        pub cluster_name: std::string::String,

        /// The namespace of the Istio service underlying this service. Corresponds
        /// to the `destination_service_namespace` metric label in Istio metrics.
        pub service_namespace: std::string::String,

        /// The name of the Istio service underlying this service. Corresponds to the
        /// `destination_service_name` metric label in Istio metrics.
        pub service_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterIstio {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location][crate::model::service::ClusterIstio::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::ClusterIstio::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [service_namespace][crate::model::service::ClusterIstio::service_namespace].
        pub fn set_service_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_namespace = v.into();
            self
        }

        /// Sets the value of [service_name][crate::model::service::ClusterIstio::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }
    }

    impl wkt::message::Message for ClusterIstio {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.ClusterIstio"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterIstio {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __location,
                __cluster_name,
                __service_namespace,
                __service_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterIstio")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "location" => Ok(__FieldTag::__location),
                                "clusterName" => Ok(__FieldTag::__cluster_name),
                                "cluster_name" => Ok(__FieldTag::__cluster_name),
                                "serviceNamespace" => Ok(__FieldTag::__service_namespace),
                                "service_namespace" => Ok(__FieldTag::__service_namespace),
                                "serviceName" => Ok(__FieldTag::__service_name),
                                "service_name" => Ok(__FieldTag::__service_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterIstio;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterIstio")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_name => {
                                if !fields.insert(__FieldTag::__cluster_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_name",
                                    ));
                                }
                                result.cluster_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_namespace => {
                                if !fields.insert(__FieldTag::__service_namespace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_namespace",
                                    ));
                                }
                                result.service_namespace = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_name => {
                                if !fields.insert(__FieldTag::__service_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_name",
                                    ));
                                }
                                result.service_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterIstio {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self.cluster_name.is_empty() {
                state.serialize_entry("clusterName", &self.cluster_name)?;
            }
            if !self.service_namespace.is_empty() {
                state.serialize_entry("serviceNamespace", &self.service_namespace)?;
            }
            if !self.service_name.is_empty() {
                state.serialize_entry("serviceName", &self.service_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8
    /// will have their services ingested as this type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MeshIstio {
        /// Identifier for the mesh in which this Istio service is defined.
        /// Corresponds to the `mesh_uid` metric label in Istio metrics.
        pub mesh_uid: std::string::String,

        /// The namespace of the Istio service underlying this service. Corresponds
        /// to the `destination_service_namespace` metric label in Istio metrics.
        pub service_namespace: std::string::String,

        /// The name of the Istio service underlying this service. Corresponds to the
        /// `destination_service_name` metric label in Istio metrics.
        pub service_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MeshIstio {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mesh_uid][crate::model::service::MeshIstio::mesh_uid].
        pub fn set_mesh_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mesh_uid = v.into();
            self
        }

        /// Sets the value of [service_namespace][crate::model::service::MeshIstio::service_namespace].
        pub fn set_service_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_namespace = v.into();
            self
        }

        /// Sets the value of [service_name][crate::model::service::MeshIstio::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }
    }

    impl wkt::message::Message for MeshIstio {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.MeshIstio"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MeshIstio {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mesh_uid,
                __service_namespace,
                __service_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MeshIstio")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "meshUid" => Ok(__FieldTag::__mesh_uid),
                                "mesh_uid" => Ok(__FieldTag::__mesh_uid),
                                "serviceNamespace" => Ok(__FieldTag::__service_namespace),
                                "service_namespace" => Ok(__FieldTag::__service_namespace),
                                "serviceName" => Ok(__FieldTag::__service_name),
                                "service_name" => Ok(__FieldTag::__service_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MeshIstio;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MeshIstio")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mesh_uid => {
                                if !fields.insert(__FieldTag::__mesh_uid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mesh_uid",
                                    ));
                                }
                                result.mesh_uid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_namespace => {
                                if !fields.insert(__FieldTag::__service_namespace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_namespace",
                                    ));
                                }
                                result.service_namespace = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_name => {
                                if !fields.insert(__FieldTag::__service_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_name",
                                    ));
                                }
                                result.service_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MeshIstio {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.mesh_uid.is_empty() {
                state.serialize_entry("meshUid", &self.mesh_uid)?;
            }
            if !self.service_namespace.is_empty() {
                state.serialize_entry("serviceNamespace", &self.service_namespace)?;
            }
            if !self.service_name.is_empty() {
                state.serialize_entry("serviceName", &self.service_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >=
    /// 1.6.8 will have their services ingested as this type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IstioCanonicalService {
        /// Identifier for the Istio mesh in which this canonical service is defined.
        /// Corresponds to the `mesh_uid` metric label in
        /// [Istio metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        pub mesh_uid: std::string::String,

        /// The namespace of the canonical service underlying this service.
        /// Corresponds to the `destination_canonical_service_namespace` metric
        /// label in [Istio
        /// metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        pub canonical_service_namespace: std::string::String,

        /// The name of the canonical service underlying this service.
        /// Corresponds to the `destination_canonical_service_name` metric label in
        /// label in [Istio
        /// metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        pub canonical_service: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IstioCanonicalService {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mesh_uid][crate::model::service::IstioCanonicalService::mesh_uid].
        pub fn set_mesh_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mesh_uid = v.into();
            self
        }

        /// Sets the value of [canonical_service_namespace][crate::model::service::IstioCanonicalService::canonical_service_namespace].
        pub fn set_canonical_service_namespace<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.canonical_service_namespace = v.into();
            self
        }

        /// Sets the value of [canonical_service][crate::model::service::IstioCanonicalService::canonical_service].
        pub fn set_canonical_service<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.canonical_service = v.into();
            self
        }
    }

    impl wkt::message::Message for IstioCanonicalService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.IstioCanonicalService"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IstioCanonicalService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mesh_uid,
                __canonical_service_namespace,
                __canonical_service,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IstioCanonicalService")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "meshUid" => Ok(__FieldTag::__mesh_uid),
                                "mesh_uid" => Ok(__FieldTag::__mesh_uid),
                                "canonicalServiceNamespace" => {
                                    Ok(__FieldTag::__canonical_service_namespace)
                                }
                                "canonical_service_namespace" => {
                                    Ok(__FieldTag::__canonical_service_namespace)
                                }
                                "canonicalService" => Ok(__FieldTag::__canonical_service),
                                "canonical_service" => Ok(__FieldTag::__canonical_service),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IstioCanonicalService;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IstioCanonicalService")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mesh_uid => {
                                if !fields.insert(__FieldTag::__mesh_uid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mesh_uid",
                                    ));
                                }
                                result.mesh_uid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__canonical_service_namespace => {
                                if !fields.insert(__FieldTag::__canonical_service_namespace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for canonical_service_namespace",
                                    ));
                                }
                                result.canonical_service_namespace = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__canonical_service => {
                                if !fields.insert(__FieldTag::__canonical_service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for canonical_service",
                                    ));
                                }
                                result.canonical_service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IstioCanonicalService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.mesh_uid.is_empty() {
                state.serialize_entry("meshUid", &self.mesh_uid)?;
            }
            if !self.canonical_service_namespace.is_empty() {
                state.serialize_entry(
                    "canonicalServiceNamespace",
                    &self.canonical_service_namespace,
                )?;
            }
            if !self.canonical_service.is_empty() {
                state.serialize_entry("canonicalService", &self.canonical_service)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Cloud Run service. Learn more at <https://cloud.google.com/run>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudRun {
        /// The name of the Cloud Run service. Corresponds to the `service_name`
        /// resource label in the [`cloud_run_revision` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
        pub service_name: std::string::String,

        /// The location the service is run. Corresponds to the `location`
        /// resource label in the [`cloud_run_revision` monitored
        /// resource](https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
        pub location: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudRun {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_name][crate::model::service::CloudRun::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::CloudRun::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudRun {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.CloudRun"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudRun {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service_name,
                __location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudRun")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serviceName" => Ok(__FieldTag::__service_name),
                                "service_name" => Ok(__FieldTag::__service_name),
                                "location" => Ok(__FieldTag::__location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudRun;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudRun")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service_name => {
                                if !fields.insert(__FieldTag::__service_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_name",
                                    ));
                                }
                                result.service_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudRun {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service_name.is_empty() {
                state.serialize_entry("serviceName", &self.service_name)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// GKE Namespace. The field names correspond to the resource metadata labels
    /// on monitored resources that fall under a namespace (for example,
    /// `k8s_container` or `k8s_pod`).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GkeNamespace {
        /// Output only. The project this resource lives in. For legacy services
        /// migrated from the `Custom` type, this may be a distinct project from the
        /// one parenting the service itself.
        pub project_id: std::string::String,

        /// The location of the parent cluster. This may be a zone or region.
        pub location: std::string::String,

        /// The name of the parent cluster.
        pub cluster_name: std::string::String,

        /// The name of this namespace.
        pub namespace_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeNamespace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::service::GkeNamespace::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::GkeNamespace::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::GkeNamespace::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [namespace_name][crate::model::service::GkeNamespace::namespace_name].
        pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespace_name = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNamespace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.GkeNamespace"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GkeNamespace {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __project_id,
                __location,
                __cluster_name,
                __namespace_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GkeNamespace")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "projectId" => Ok(__FieldTag::__project_id),
                                "project_id" => Ok(__FieldTag::__project_id),
                                "location" => Ok(__FieldTag::__location),
                                "clusterName" => Ok(__FieldTag::__cluster_name),
                                "cluster_name" => Ok(__FieldTag::__cluster_name),
                                "namespaceName" => Ok(__FieldTag::__namespace_name),
                                "namespace_name" => Ok(__FieldTag::__namespace_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GkeNamespace;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GkeNamespace")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__project_id => {
                                if !fields.insert(__FieldTag::__project_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_id",
                                    ));
                                }
                                result.project_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_name => {
                                if !fields.insert(__FieldTag::__cluster_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_name",
                                    ));
                                }
                                result.cluster_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__namespace_name => {
                                if !fields.insert(__FieldTag::__namespace_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for namespace_name",
                                    ));
                                }
                                result.namespace_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GkeNamespace {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.project_id.is_empty() {
                state.serialize_entry("projectId", &self.project_id)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self.cluster_name.is_empty() {
                state.serialize_entry("clusterName", &self.cluster_name)?;
            }
            if !self.namespace_name.is_empty() {
                state.serialize_entry("namespaceName", &self.namespace_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A GKE Workload (Deployment, StatefulSet, etc). The field names correspond
    /// to the metadata labels on monitored resources that fall under a workload
    /// (for example, `k8s_container` or `k8s_pod`).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GkeWorkload {
        /// Output only. The project this resource lives in. For legacy services
        /// migrated from the `Custom` type, this may be a distinct project from the
        /// one parenting the service itself.
        pub project_id: std::string::String,

        /// The location of the parent cluster. This may be a zone or region.
        pub location: std::string::String,

        /// The name of the parent cluster.
        pub cluster_name: std::string::String,

        /// The name of the parent namespace.
        pub namespace_name: std::string::String,

        /// The type of this workload (for example, "Deployment" or "DaemonSet")
        pub top_level_controller_type: std::string::String,

        /// The name of this workload.
        pub top_level_controller_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeWorkload {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::service::GkeWorkload::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::GkeWorkload::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::GkeWorkload::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [namespace_name][crate::model::service::GkeWorkload::namespace_name].
        pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespace_name = v.into();
            self
        }

        /// Sets the value of [top_level_controller_type][crate::model::service::GkeWorkload::top_level_controller_type].
        pub fn set_top_level_controller_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.top_level_controller_type = v.into();
            self
        }

        /// Sets the value of [top_level_controller_name][crate::model::service::GkeWorkload::top_level_controller_name].
        pub fn set_top_level_controller_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.top_level_controller_name = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeWorkload {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.GkeWorkload"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GkeWorkload {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __project_id,
                __location,
                __cluster_name,
                __namespace_name,
                __top_level_controller_type,
                __top_level_controller_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GkeWorkload")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "projectId" => Ok(__FieldTag::__project_id),
                                "project_id" => Ok(__FieldTag::__project_id),
                                "location" => Ok(__FieldTag::__location),
                                "clusterName" => Ok(__FieldTag::__cluster_name),
                                "cluster_name" => Ok(__FieldTag::__cluster_name),
                                "namespaceName" => Ok(__FieldTag::__namespace_name),
                                "namespace_name" => Ok(__FieldTag::__namespace_name),
                                "topLevelControllerType" => {
                                    Ok(__FieldTag::__top_level_controller_type)
                                }
                                "top_level_controller_type" => {
                                    Ok(__FieldTag::__top_level_controller_type)
                                }
                                "topLevelControllerName" => {
                                    Ok(__FieldTag::__top_level_controller_name)
                                }
                                "top_level_controller_name" => {
                                    Ok(__FieldTag::__top_level_controller_name)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GkeWorkload;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GkeWorkload")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__project_id => {
                                if !fields.insert(__FieldTag::__project_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_id",
                                    ));
                                }
                                result.project_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_name => {
                                if !fields.insert(__FieldTag::__cluster_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_name",
                                    ));
                                }
                                result.cluster_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__namespace_name => {
                                if !fields.insert(__FieldTag::__namespace_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for namespace_name",
                                    ));
                                }
                                result.namespace_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__top_level_controller_type => {
                                if !fields.insert(__FieldTag::__top_level_controller_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for top_level_controller_type",
                                    ));
                                }
                                result.top_level_controller_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__top_level_controller_name => {
                                if !fields.insert(__FieldTag::__top_level_controller_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for top_level_controller_name",
                                    ));
                                }
                                result.top_level_controller_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GkeWorkload {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.project_id.is_empty() {
                state.serialize_entry("projectId", &self.project_id)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self.cluster_name.is_empty() {
                state.serialize_entry("clusterName", &self.cluster_name)?;
            }
            if !self.namespace_name.is_empty() {
                state.serialize_entry("namespaceName", &self.namespace_name)?;
            }
            if !self.top_level_controller_type.is_empty() {
                state.serialize_entry("topLevelControllerType", &self.top_level_controller_type)?;
            }
            if !self.top_level_controller_name.is_empty() {
                state.serialize_entry("topLevelControllerName", &self.top_level_controller_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// GKE Service. The "service" here represents a
    /// [Kubernetes service
    /// object](https://kubernetes.io/docs/concepts/services-networking/service).
    /// The field names correspond to the resource labels on [`k8s_service`
    /// monitored
    /// resources](https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GkeService {
        /// Output only. The project this resource lives in. For legacy services
        /// migrated from the `Custom` type, this may be a distinct project from the
        /// one parenting the service itself.
        pub project_id: std::string::String,

        /// The location of the parent cluster. This may be a zone or region.
        pub location: std::string::String,

        /// The name of the parent cluster.
        pub cluster_name: std::string::String,

        /// The name of the parent namespace.
        pub namespace_name: std::string::String,

        /// The name of this service.
        pub service_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeService {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::service::GkeService::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [location][crate::model::service::GkeService::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [cluster_name][crate::model::service::GkeService::cluster_name].
        pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_name = v.into();
            self
        }

        /// Sets the value of [namespace_name][crate::model::service::GkeService::namespace_name].
        pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespace_name = v.into();
            self
        }

        /// Sets the value of [service_name][crate::model::service::GkeService::service_name].
        pub fn set_service_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_name = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.GkeService"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GkeService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __project_id,
                __location,
                __cluster_name,
                __namespace_name,
                __service_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GkeService")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "projectId" => Ok(__FieldTag::__project_id),
                                "project_id" => Ok(__FieldTag::__project_id),
                                "location" => Ok(__FieldTag::__location),
                                "clusterName" => Ok(__FieldTag::__cluster_name),
                                "cluster_name" => Ok(__FieldTag::__cluster_name),
                                "namespaceName" => Ok(__FieldTag::__namespace_name),
                                "namespace_name" => Ok(__FieldTag::__namespace_name),
                                "serviceName" => Ok(__FieldTag::__service_name),
                                "service_name" => Ok(__FieldTag::__service_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GkeService;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GkeService")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__project_id => {
                                if !fields.insert(__FieldTag::__project_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_id",
                                    ));
                                }
                                result.project_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_name => {
                                if !fields.insert(__FieldTag::__cluster_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_name",
                                    ));
                                }
                                result.cluster_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__namespace_name => {
                                if !fields.insert(__FieldTag::__namespace_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for namespace_name",
                                    ));
                                }
                                result.namespace_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_name => {
                                if !fields.insert(__FieldTag::__service_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_name",
                                    ));
                                }
                                result.service_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GkeService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.project_id.is_empty() {
                state.serialize_entry("projectId", &self.project_id)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self.cluster_name.is_empty() {
                state.serialize_entry("clusterName", &self.cluster_name)?;
            }
            if !self.namespace_name.is_empty() {
                state.serialize_entry("namespaceName", &self.namespace_name)?;
            }
            if !self.service_name.is_empty() {
                state.serialize_entry("serviceName", &self.service_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A well-known service type, defined by its service type and service labels.
    /// Documentation and examples
    /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BasicService {
        /// The type of service that this basic service defines, e.g.
        /// APP_ENGINE service type.
        /// Documentation and valid values
        /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
        pub service_type: std::string::String,

        /// Labels that specify the resource that emits the monitoring data which
        /// is used for SLO reporting of this `Service`.
        /// Documentation and valid values for given service types
        /// [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
        pub service_labels: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BasicService {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_type][crate::model::service::BasicService::service_type].
        pub fn set_service_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_type = v.into();
            self
        }

        /// Sets the value of [service_labels][crate::model::service::BasicService::service_labels].
        pub fn set_service_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.service_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for BasicService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.BasicService"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BasicService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service_type,
                __service_labels,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BasicService")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serviceType" => Ok(__FieldTag::__service_type),
                                "service_type" => Ok(__FieldTag::__service_type),
                                "serviceLabels" => Ok(__FieldTag::__service_labels),
                                "service_labels" => Ok(__FieldTag::__service_labels),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BasicService;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BasicService")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service_type => {
                                if !fields.insert(__FieldTag::__service_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_type",
                                    ));
                                }
                                result.service_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_labels => {
                                if !fields.insert(__FieldTag::__service_labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_labels",
                                    ));
                                }
                                result.service_labels = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BasicService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service_type.is_empty() {
                state.serialize_entry("serviceType", &self.service_type)?;
            }
            if !self.service_labels.is_empty() {
                state.serialize_entry("serviceLabels", &self.service_labels)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for how to query telemetry on a Service.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Telemetry {
        /// The full name of the resource that defines this service. Formatted as
        /// described in <https://cloud.google.com/apis/design/resource_names>.
        pub resource_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Telemetry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_name][crate::model::service::Telemetry::resource_name].
        pub fn set_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_name = v.into();
            self
        }
    }

    impl wkt::message::Message for Telemetry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Service.Telemetry"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Telemetry {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __resource_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Telemetry")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "resourceName" => Ok(__FieldTag::__resource_name),
                                "resource_name" => Ok(__FieldTag::__resource_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Telemetry;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Telemetry")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__resource_name => {
                                if !fields.insert(__FieldTag::__resource_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_name",
                                    ));
                                }
                                result.resource_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Telemetry {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.resource_name.is_empty() {
                state.serialize_entry("resourceName", &self.resource_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// REQUIRED. Service-identifying atoms specifying the underlying service.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Identifier {
        /// Custom service type.
        Custom(std::boxed::Box<crate::model::service::Custom>),
        /// Type used for App Engine services.
        AppEngine(std::boxed::Box<crate::model::service::AppEngine>),
        /// Type used for Cloud Endpoints services.
        CloudEndpoints(std::boxed::Box<crate::model::service::CloudEndpoints>),
        /// Type used for Istio services that live in a Kubernetes cluster.
        ClusterIstio(std::boxed::Box<crate::model::service::ClusterIstio>),
        /// Type used for Istio services scoped to an Istio mesh.
        MeshIstio(std::boxed::Box<crate::model::service::MeshIstio>),
        /// Type used for canonical services scoped to an Istio mesh.
        /// Metrics for Istio are
        /// [documented here](https://istio.io/latest/docs/reference/config/metrics/)
        IstioCanonicalService(std::boxed::Box<crate::model::service::IstioCanonicalService>),
        /// Type used for Cloud Run services.
        CloudRun(std::boxed::Box<crate::model::service::CloudRun>),
        /// Type used for GKE Namespaces.
        GkeNamespace(std::boxed::Box<crate::model::service::GkeNamespace>),
        /// Type used for GKE Workloads.
        GkeWorkload(std::boxed::Box<crate::model::service::GkeWorkload>),
        /// Type used for GKE Services (the Kubernetes concept of a service).
        GkeService(std::boxed::Box<crate::model::service::GkeService>),
    }
}

/// A Service-Level Objective (SLO) describes a level of desired good service. It
/// consists of a service-level indicator (SLI), a performance goal, and a period
/// over which the objective is to be evaluated against that goal. The SLO can
/// use SLIs defined in a number of different manners. Typical SLOs might include
/// "99% of requests in each rolling week have latency below 200 milliseconds" or
/// "99.5% of requests in each calendar month return successfully."
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceLevelObjective {
    /// Identifier. Resource name for this `ServiceLevelObjective`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
    /// ```
    pub name: std::string::String,

    /// Name used for UI elements listing this SLO.
    pub display_name: std::string::String,

    /// The definition of good service, used to measure and calculate the quality
    /// of the `Service`'s performance with respect to a single aspect of service
    /// quality.
    pub service_level_indicator: std::option::Option<crate::model::ServiceLevelIndicator>,

    /// The fraction of service that must be good in order for this objective to be
    /// met. `0 < goal <= 0.9999`.
    pub goal: f64,

    /// Labels which have been used to annotate the service-level objective. Label
    /// keys must start with a letter. Label keys and values may contain lowercase
    /// letters, numbers, underscores, and dashes. Label keys and values have a
    /// maximum length of 63 characters, and must be less than 128 bytes in size.
    /// Up to 64 label entries may be stored. For labels which do not have a
    /// semantic value, the empty string may be supplied for the label value.
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The time period over which the objective will be evaluated.
    pub period: std::option::Option<crate::model::service_level_objective::Period>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceLevelObjective {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ServiceLevelObjective::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ServiceLevelObjective::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [service_level_indicator][crate::model::ServiceLevelObjective::service_level_indicator].
    pub fn set_service_level_indicator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceLevelIndicator>,
    {
        self.service_level_indicator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_level_indicator][crate::model::ServiceLevelObjective::service_level_indicator].
    pub fn set_or_clear_service_level_indicator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceLevelIndicator>,
    {
        self.service_level_indicator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [goal][crate::model::ServiceLevelObjective::goal].
    pub fn set_goal<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.goal = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::ServiceLevelObjective::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [period][crate::model::ServiceLevelObjective::period].
    ///
    /// Note that all the setters affecting `period` are mutually
    /// exclusive.
    pub fn set_period<
        T: std::convert::Into<std::option::Option<crate::model::service_level_objective::Period>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.period = v.into();
        self
    }

    /// The value of [period][crate::model::ServiceLevelObjective::period]
    /// if it holds a `RollingPeriod`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rolling_period(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.period.as_ref().and_then(|v| match v {
            crate::model::service_level_objective::Period::RollingPeriod(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [period][crate::model::ServiceLevelObjective::period]
    /// to hold a `RollingPeriod`.
    ///
    /// Note that all the setters affecting `period` are
    /// mutually exclusive.
    pub fn set_rolling_period<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.period = std::option::Option::Some(
            crate::model::service_level_objective::Period::RollingPeriod(v.into()),
        );
        self
    }

    /// The value of [period][crate::model::ServiceLevelObjective::period]
    /// if it holds a `CalendarPeriod`, `None` if the field is not set or
    /// holds a different branch.
    pub fn calendar_period(&self) -> std::option::Option<&gtype::model::CalendarPeriod> {
        #[allow(unreachable_patterns)]
        self.period.as_ref().and_then(|v| match v {
            crate::model::service_level_objective::Period::CalendarPeriod(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [period][crate::model::ServiceLevelObjective::period]
    /// to hold a `CalendarPeriod`.
    ///
    /// Note that all the setters affecting `period` are
    /// mutually exclusive.
    pub fn set_calendar_period<T: std::convert::Into<gtype::model::CalendarPeriod>>(
        mut self,
        v: T,
    ) -> Self {
        self.period = std::option::Option::Some(
            crate::model::service_level_objective::Period::CalendarPeriod(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ServiceLevelObjective {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ServiceLevelObjective"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceLevelObjective {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __service_level_indicator,
            __goal,
            __rolling_period,
            __calendar_period,
            __user_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceLevelObjective")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "serviceLevelIndicator" => Ok(__FieldTag::__service_level_indicator),
                            "service_level_indicator" => Ok(__FieldTag::__service_level_indicator),
                            "goal" => Ok(__FieldTag::__goal),
                            "rollingPeriod" => Ok(__FieldTag::__rolling_period),
                            "rolling_period" => Ok(__FieldTag::__rolling_period),
                            "calendarPeriod" => Ok(__FieldTag::__calendar_period),
                            "calendar_period" => Ok(__FieldTag::__calendar_period),
                            "userLabels" => Ok(__FieldTag::__user_labels),
                            "user_labels" => Ok(__FieldTag::__user_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceLevelObjective;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceLevelObjective")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_level_indicator => {
                            if !fields.insert(__FieldTag::__service_level_indicator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_level_indicator",
                                ));
                            }
                            result.service_level_indicator = map.next_value::<std::option::Option<crate::model::ServiceLevelIndicator>>()?
                                ;
                        }
                        __FieldTag::__goal => {
                            if !fields.insert(__FieldTag::__goal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for goal",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.goal = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rolling_period => {
                            if !fields.insert(__FieldTag::__rolling_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rolling_period",
                                ));
                            }
                            if result.period.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `period`, a oneof with full ID .google.monitoring.v3.ServiceLevelObjective.rolling_period, latest field was rollingPeriod",
                                ));
                            }
                            result.period = std::option::Option::Some(
                                crate::model::service_level_objective::Period::RollingPeriod(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__calendar_period => {
                            if !fields.insert(__FieldTag::__calendar_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for calendar_period",
                                ));
                            }
                            if result.period.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `period`, a oneof with full ID .google.monitoring.v3.ServiceLevelObjective.calendar_period, latest field was calendarPeriod",
                                ));
                            }
                            result.period = std::option::Option::Some(
                                crate::model::service_level_objective::Period::CalendarPeriod(
                                    map.next_value::<std::option::Option<gtype::model::CalendarPeriod>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__user_labels => {
                            if !fields.insert(__FieldTag::__user_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_labels",
                                ));
                            }
                            result.user_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceLevelObjective {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.service_level_indicator.is_some() {
            state.serialize_entry("serviceLevelIndicator", &self.service_level_indicator)?;
        }
        if !wkt::internal::is_default(&self.goal) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("goal", &__With(&self.goal))?;
        }
        if let Some(value) = self.rolling_period() {
            state.serialize_entry("rollingPeriod", value)?;
        }
        if let Some(value) = self.calendar_period() {
            state.serialize_entry("calendarPeriod", value)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ServiceLevelObjective].
pub mod service_level_objective {
    #[allow(unused_imports)]
    use super::*;

    /// `ServiceLevelObjective.View` determines what form of
    /// `ServiceLevelObjective` is returned from `GetServiceLevelObjective`,
    /// `ListServiceLevelObjectives`, and `ListServiceLevelObjectiveVersions` RPCs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum View {
        /// Same as FULL.
        Unspecified,
        /// Return the embedded `ServiceLevelIndicator` in the form in which it was
        /// defined. If it was defined using a `BasicSli`, return that `BasicSli`.
        Full,
        /// For `ServiceLevelIndicator`s using `BasicSli` articulation, instead
        /// return the `ServiceLevelIndicator` with its mode of computation fully
        /// spelled out as a `RequestBasedSli`. For `ServiceLevelIndicator`s using
        /// `RequestBasedSli` or `WindowsBasedSli`, return the
        /// `ServiceLevelIndicator` as it was provided.
        Explicit,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [View::value] or
        /// [View::name].
        UnknownValue(view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl View {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Full => std::option::Option::Some(2),
                Self::Explicit => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VIEW_UNSPECIFIED"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::Explicit => std::option::Option::Some("EXPLICIT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for View {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for View {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for View {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Explicit,
                2 => Self::Full,
                _ => Self::UnknownValue(view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for View {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VIEW_UNSPECIFIED" => Self::Unspecified,
                "FULL" => Self::Full,
                "EXPLICIT" => Self::Explicit,
                _ => Self::UnknownValue(view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for View {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Full => serializer.serialize_i32(2),
                Self::Explicit => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for View {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<View>::new(
                ".google.monitoring.v3.ServiceLevelObjective.View",
            ))
        }
    }

    /// The time period over which the objective will be evaluated.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Period {
        /// A rolling time period, semantically "in the past `<rolling_period>`".
        /// Must be an integer multiple of 1 day no larger than 30 days.
        RollingPeriod(std::boxed::Box<wkt::Duration>),
        /// A calendar period, semantically "since the start of the current
        /// `<calendar_period>`". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and
        /// `MONTH` are supported.
        CalendarPeriod(gtype::model::CalendarPeriod),
    }
}

/// A Service-Level Indicator (SLI) describes the "performance" of a service. For
/// some services, the SLI is well-defined. In such cases, the SLI can be
/// described easily by referencing the well-known SLI and providing the needed
/// parameters. Alternatively, a "custom" SLI can be defined with a query to the
/// underlying metric store. An SLI is defined to be `good_service /
/// total_service` over any queried time interval. The value of performance
/// always falls into the range `0 <= performance <= 1`. A custom SLI describes
/// how to compute this ratio, whether this is by dividing values from a pair of
/// time series, cutting a `Distribution` into good and bad counts, or counting
/// time windows in which the service complies with a criterion. For separation
/// of concerns, a single Service-Level Indicator measures performance for only
/// one aspect of service quality, such as fraction of successful queries or
/// fast-enough queries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceLevelIndicator {
    /// Service level indicators can be grouped by whether the "unit" of service
    /// being measured is based on counts of good requests or on counts of good
    /// time windows
    pub r#type: std::option::Option<crate::model::service_level_indicator::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceLevelIndicator {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ServiceLevelIndicator::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::service_level_indicator::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// if it holds a `BasicSli`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_sli(&self) -> std::option::Option<&std::boxed::Box<crate::model::BasicSli>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::service_level_indicator::Type::BasicSli(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// to hold a `BasicSli`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_basic_sli<T: std::convert::Into<std::boxed::Box<crate::model::BasicSli>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::service_level_indicator::Type::BasicSli(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// if it holds a `RequestBased`, `None` if the field is not set or
    /// holds a different branch.
    pub fn request_based(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RequestBasedSli>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::service_level_indicator::Type::RequestBased(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// to hold a `RequestBased`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_request_based<
        T: std::convert::Into<std::boxed::Box<crate::model::RequestBasedSli>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::service_level_indicator::Type::RequestBased(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// if it holds a `WindowsBased`, `None` if the field is not set or
    /// holds a different branch.
    pub fn windows_based(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WindowsBasedSli>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::service_level_indicator::Type::WindowsBased(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ServiceLevelIndicator::r#type]
    /// to hold a `WindowsBased`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_windows_based<
        T: std::convert::Into<std::boxed::Box<crate::model::WindowsBasedSli>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::service_level_indicator::Type::WindowsBased(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ServiceLevelIndicator {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ServiceLevelIndicator"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceLevelIndicator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __basic_sli,
            __request_based,
            __windows_based,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceLevelIndicator")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "basicSli" => Ok(__FieldTag::__basic_sli),
                            "basic_sli" => Ok(__FieldTag::__basic_sli),
                            "requestBased" => Ok(__FieldTag::__request_based),
                            "request_based" => Ok(__FieldTag::__request_based),
                            "windowsBased" => Ok(__FieldTag::__windows_based),
                            "windows_based" => Ok(__FieldTag::__windows_based),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceLevelIndicator;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceLevelIndicator")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__basic_sli => {
                            if !fields.insert(__FieldTag::__basic_sli) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for basic_sli",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.monitoring.v3.ServiceLevelIndicator.basic_sli, latest field was basicSli",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::service_level_indicator::Type::BasicSli(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BasicSli>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__request_based => {
                            if !fields.insert(__FieldTag::__request_based) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_based",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.monitoring.v3.ServiceLevelIndicator.request_based, latest field was requestBased",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::service_level_indicator::Type::RequestBased(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RequestBasedSli>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__windows_based => {
                            if !fields.insert(__FieldTag::__windows_based) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_based",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.monitoring.v3.ServiceLevelIndicator.windows_based, latest field was windowsBased",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::service_level_indicator::Type::WindowsBased(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WindowsBasedSli>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceLevelIndicator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.basic_sli() {
            state.serialize_entry("basicSli", value)?;
        }
        if let Some(value) = self.request_based() {
            state.serialize_entry("requestBased", value)?;
        }
        if let Some(value) = self.windows_based() {
            state.serialize_entry("windowsBased", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ServiceLevelIndicator].
pub mod service_level_indicator {
    #[allow(unused_imports)]
    use super::*;

    /// Service level indicators can be grouped by whether the "unit" of service
    /// being measured is based on counts of good requests or on counts of good
    /// time windows
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Basic SLI on a well-known service type.
        BasicSli(std::boxed::Box<crate::model::BasicSli>),
        /// Request-based SLIs
        RequestBased(std::boxed::Box<crate::model::RequestBasedSli>),
        /// Windows-based SLIs
        WindowsBased(std::boxed::Box<crate::model::WindowsBasedSli>),
    }
}

/// An SLI measuring performance on a well-known service type. Performance will
/// be computed on the basis of pre-defined metrics. The type of the
/// `service_resource` determines the metrics to use and the
/// `service_resource.labels` and `metric_labels` are used to construct a
/// monitoring filter to filter that metric down to just the data relevant to
/// this service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BasicSli {
    /// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from
    /// other methods will not be used to calculate performance for this SLI. If
    /// omitted, this SLI applies to all the Service's methods. For service types
    /// that don't support breaking down by method, setting this field will result
    /// in an error.
    pub method: std::vec::Vec<std::string::String>,

    /// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry
    /// from other locations will not be used to calculate performance for this
    /// SLI. If omitted, this SLI applies to all locations in which the Service has
    /// activity. For service types that don't support breaking down by location,
    /// setting this field will result in an error.
    pub location: std::vec::Vec<std::string::String>,

    /// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry
    /// from other API versions will not be used to calculate performance for this
    /// SLI. If omitted, this SLI applies to all API versions. For service types
    /// that don't support breaking down by version, setting this field will result
    /// in an error.
    pub version: std::vec::Vec<std::string::String>,

    /// This SLI can be evaluated on the basis of availability or latency.
    pub sli_criteria: std::option::Option<crate::model::basic_sli::SliCriteria>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicSli {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::BasicSli::method].
    pub fn set_method<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.method = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location][crate::model::BasicSli::location].
    pub fn set_location<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.location = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version][crate::model::BasicSli::version].
    pub fn set_version<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sli_criteria][crate::model::BasicSli::sli_criteria].
    ///
    /// Note that all the setters affecting `sli_criteria` are mutually
    /// exclusive.
    pub fn set_sli_criteria<
        T: std::convert::Into<std::option::Option<crate::model::basic_sli::SliCriteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sli_criteria = v.into();
        self
    }

    /// The value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// if it holds a `Availability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn availability(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::basic_sli::AvailabilityCriteria>> {
        #[allow(unreachable_patterns)]
        self.sli_criteria.as_ref().and_then(|v| match v {
            crate::model::basic_sli::SliCriteria::Availability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// to hold a `Availability`.
    ///
    /// Note that all the setters affecting `sli_criteria` are
    /// mutually exclusive.
    pub fn set_availability<
        T: std::convert::Into<std::boxed::Box<crate::model::basic_sli::AvailabilityCriteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sli_criteria =
            std::option::Option::Some(crate::model::basic_sli::SliCriteria::Availability(v.into()));
        self
    }

    /// The value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// if it holds a `Latency`, `None` if the field is not set or
    /// holds a different branch.
    pub fn latency(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::basic_sli::LatencyCriteria>> {
        #[allow(unreachable_patterns)]
        self.sli_criteria.as_ref().and_then(|v| match v {
            crate::model::basic_sli::SliCriteria::Latency(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sli_criteria][crate::model::BasicSli::sli_criteria]
    /// to hold a `Latency`.
    ///
    /// Note that all the setters affecting `sli_criteria` are
    /// mutually exclusive.
    pub fn set_latency<
        T: std::convert::Into<std::boxed::Box<crate::model::basic_sli::LatencyCriteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sli_criteria =
            std::option::Option::Some(crate::model::basic_sli::SliCriteria::Latency(v.into()));
        self
    }
}

impl wkt::message::Message for BasicSli {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.BasicSli"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BasicSli {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __method,
            __location,
            __version,
            __availability,
            __latency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BasicSli")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "method" => Ok(__FieldTag::__method),
                            "location" => Ok(__FieldTag::__location),
                            "version" => Ok(__FieldTag::__version),
                            "availability" => Ok(__FieldTag::__availability),
                            "latency" => Ok(__FieldTag::__latency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BasicSli;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BasicSli")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__method => {
                            if !fields.insert(__FieldTag::__method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method",
                                ));
                            }
                            result.method = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__availability => {
                            if !fields.insert(__FieldTag::__availability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability",
                                ));
                            }
                            if result.sli_criteria.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sli_criteria`, a oneof with full ID .google.monitoring.v3.BasicSli.availability, latest field was availability",
                                ));
                            }
                            result.sli_criteria = std::option::Option::Some(
                                crate::model::basic_sli::SliCriteria::Availability(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::basic_sli::AvailabilityCriteria,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__latency => {
                            if !fields.insert(__FieldTag::__latency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latency",
                                ));
                            }
                            if result.sli_criteria.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sli_criteria`, a oneof with full ID .google.monitoring.v3.BasicSli.latency, latest field was latency",
                                ));
                            }
                            result.sli_criteria = std::option::Option::Some(
                                crate::model::basic_sli::SliCriteria::Latency(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::basic_sli::LatencyCriteria>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BasicSli {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.method.is_empty() {
            state.serialize_entry("method", &self.method)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if let Some(value) = self.availability() {
            state.serialize_entry("availability", value)?;
        }
        if let Some(value) = self.latency() {
            state.serialize_entry("latency", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BasicSli].
pub mod basic_sli {
    #[allow(unused_imports)]
    use super::*;

    /// Future parameters for the availability SLI.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AvailabilityCriteria {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AvailabilityCriteria {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AvailabilityCriteria {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.BasicSli.AvailabilityCriteria"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AvailabilityCriteria {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AvailabilityCriteria")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AvailabilityCriteria;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AvailabilityCriteria")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AvailabilityCriteria {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Parameters for a latency threshold SLI.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LatencyCriteria {
        /// Good service is defined to be the count of requests made to this service
        /// that return in no more than `threshold`.
        pub threshold: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LatencyCriteria {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threshold][crate::model::basic_sli::LatencyCriteria::threshold].
        pub fn set_threshold<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.threshold = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [threshold][crate::model::basic_sli::LatencyCriteria::threshold].
        pub fn set_or_clear_threshold<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.threshold = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for LatencyCriteria {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.BasicSli.LatencyCriteria"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LatencyCriteria {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __threshold,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LatencyCriteria")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "threshold" => Ok(__FieldTag::__threshold),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LatencyCriteria;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LatencyCriteria")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__threshold => {
                                if !fields.insert(__FieldTag::__threshold) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for threshold",
                                    ));
                                }
                                result.threshold =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LatencyCriteria {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.threshold.is_some() {
                state.serialize_entry("threshold", &self.threshold)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// This SLI can be evaluated on the basis of availability or latency.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SliCriteria {
        /// Good service is defined to be the count of requests made to this service
        /// that return successfully.
        Availability(std::boxed::Box<crate::model::basic_sli::AvailabilityCriteria>),
        /// Good service is defined to be the count of requests made to this service
        /// that are fast enough with respect to `latency.threshold`.
        Latency(std::boxed::Box<crate::model::basic_sli::LatencyCriteria>),
    }
}

/// Range of numerical values within `min` and `max`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Range {
    /// Range minimum.
    pub min: f64,

    /// Range maximum.
    pub max: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Range {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min][crate::model::Range::min].
    pub fn set_min<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min = v.into();
        self
    }

    /// Sets the value of [max][crate::model::Range::max].
    pub fn set_max<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max = v.into();
        self
    }
}

impl wkt::message::Message for Range {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Range"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Range {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min,
            __max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Range")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "min" => Ok(__FieldTag::__min),
                            "max" => Ok(__FieldTag::__max),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Range;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Range")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min => {
                            if !fields.insert(__FieldTag::__min) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max => {
                            if !fields.insert(__FieldTag::__max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Range {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("min", &__With(&self.min))?;
        }
        if !wkt::internal::is_default(&self.max) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("max", &__With(&self.max))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Service Level Indicators for which atomic units of service are counted
/// directly.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RequestBasedSli {
    /// The means to compute a ratio of `good_service` to `total_service`.
    pub method: std::option::Option<crate::model::request_based_sli::Method>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RequestBasedSli {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::RequestBasedSli::method].
    ///
    /// Note that all the setters affecting `method` are mutually
    /// exclusive.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::request_based_sli::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::RequestBasedSli::method]
    /// if it holds a `GoodTotalRatio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn good_total_ratio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesRatio>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::request_based_sli::Method::GoodTotalRatio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::RequestBasedSli::method]
    /// to hold a `GoodTotalRatio`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_good_total_ratio<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesRatio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::request_based_sli::Method::GoodTotalRatio(v.into()),
        );
        self
    }

    /// The value of [method][crate::model::RequestBasedSli::method]
    /// if it holds a `DistributionCut`, `None` if the field is not set or
    /// holds a different branch.
    pub fn distribution_cut(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DistributionCut>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::request_based_sli::Method::DistributionCut(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::RequestBasedSli::method]
    /// to hold a `DistributionCut`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_distribution_cut<
        T: std::convert::Into<std::boxed::Box<crate::model::DistributionCut>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::request_based_sli::Method::DistributionCut(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RequestBasedSli {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.RequestBasedSli"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RequestBasedSli {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __good_total_ratio,
            __distribution_cut,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RequestBasedSli")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "goodTotalRatio" => Ok(__FieldTag::__good_total_ratio),
                            "good_total_ratio" => Ok(__FieldTag::__good_total_ratio),
                            "distributionCut" => Ok(__FieldTag::__distribution_cut),
                            "distribution_cut" => Ok(__FieldTag::__distribution_cut),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RequestBasedSli;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RequestBasedSli")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__good_total_ratio => {
                            if !fields.insert(__FieldTag::__good_total_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for good_total_ratio",
                                ));
                            }
                            if result.method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `method`, a oneof with full ID .google.monitoring.v3.RequestBasedSli.good_total_ratio, latest field was goodTotalRatio",
                                ));
                            }
                            result.method = std::option::Option::Some(
                                crate::model::request_based_sli::Method::GoodTotalRatio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeSeriesRatio>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__distribution_cut => {
                            if !fields.insert(__FieldTag::__distribution_cut) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution_cut",
                                ));
                            }
                            if result.method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `method`, a oneof with full ID .google.monitoring.v3.RequestBasedSli.distribution_cut, latest field was distributionCut",
                                ));
                            }
                            result.method = std::option::Option::Some(
                                crate::model::request_based_sli::Method::DistributionCut(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DistributionCut>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RequestBasedSli {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.good_total_ratio() {
            state.serialize_entry("goodTotalRatio", value)?;
        }
        if let Some(value) = self.distribution_cut() {
            state.serialize_entry("distributionCut", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RequestBasedSli].
pub mod request_based_sli {
    #[allow(unused_imports)]
    use super::*;

    /// The means to compute a ratio of `good_service` to `total_service`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// `good_total_ratio` is used when the ratio of `good_service` to
        /// `total_service` is computed from two `TimeSeries`.
        GoodTotalRatio(std::boxed::Box<crate::model::TimeSeriesRatio>),
        /// `distribution_cut` is used when `good_service` is a count of values
        /// aggregated in a `Distribution` that fall into a good range. The
        /// `total_service` is the total count of all values aggregated in the
        /// `Distribution`.
        DistributionCut(std::boxed::Box<crate::model::DistributionCut>),
    }
}

/// A `TimeSeriesRatio` specifies two `TimeSeries` to use for computing the
/// `good_service / total_service` ratio. The specified `TimeSeries` must have
/// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
/// DELTA` or `MetricKind = CUMULATIVE`. The `TimeSeriesRatio` must specify
/// exactly two of good, bad, and total, and the relationship `good_service +
/// bad_service = total_service` will be assumed.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeriesRatio {
    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` quantifying good service provided. Must have
    /// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
    /// DELTA` or `MetricKind = CUMULATIVE`.
    pub good_service_filter: std::string::String,

    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` quantifying bad service, either demanded service
    /// that was not provided or demanded service that was of inadequate quality.
    /// Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have
    /// `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
    pub bad_service_filter: std::string::String,

    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` quantifying total demanded service. Must have
    /// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
    /// DELTA` or `MetricKind = CUMULATIVE`.
    pub total_service_filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesRatio {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [good_service_filter][crate::model::TimeSeriesRatio::good_service_filter].
    pub fn set_good_service_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.good_service_filter = v.into();
        self
    }

    /// Sets the value of [bad_service_filter][crate::model::TimeSeriesRatio::bad_service_filter].
    pub fn set_bad_service_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bad_service_filter = v.into();
        self
    }

    /// Sets the value of [total_service_filter][crate::model::TimeSeriesRatio::total_service_filter].
    pub fn set_total_service_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_service_filter = v.into();
        self
    }
}

impl wkt::message::Message for TimeSeriesRatio {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.TimeSeriesRatio"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeriesRatio {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __good_service_filter,
            __bad_service_filter,
            __total_service_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesRatio")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "goodServiceFilter" => Ok(__FieldTag::__good_service_filter),
                            "good_service_filter" => Ok(__FieldTag::__good_service_filter),
                            "badServiceFilter" => Ok(__FieldTag::__bad_service_filter),
                            "bad_service_filter" => Ok(__FieldTag::__bad_service_filter),
                            "totalServiceFilter" => Ok(__FieldTag::__total_service_filter),
                            "total_service_filter" => Ok(__FieldTag::__total_service_filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeriesRatio;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesRatio")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__good_service_filter => {
                            if !fields.insert(__FieldTag::__good_service_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for good_service_filter",
                                ));
                            }
                            result.good_service_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bad_service_filter => {
                            if !fields.insert(__FieldTag::__bad_service_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bad_service_filter",
                                ));
                            }
                            result.bad_service_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_service_filter => {
                            if !fields.insert(__FieldTag::__total_service_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_service_filter",
                                ));
                            }
                            result.total_service_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeriesRatio {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.good_service_filter.is_empty() {
            state.serialize_entry("goodServiceFilter", &self.good_service_filter)?;
        }
        if !self.bad_service_filter.is_empty() {
            state.serialize_entry("badServiceFilter", &self.bad_service_filter)?;
        }
        if !self.total_service_filter.is_empty() {
            state.serialize_entry("totalServiceFilter", &self.total_service_filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A `DistributionCut` defines a `TimeSeries` and thresholds used for measuring
/// good service and total service. The `TimeSeries` must have `ValueType =
/// DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`. The
/// computed `good_service` will be the estimated count of values in the
/// `Distribution` that fall within the specified `min` and `max`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DistributionCut {
    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` aggregating values. Must have `ValueType =
    /// DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
    pub distribution_filter: std::string::String,

    /// Range of values considered "good." For a one-sided range, set one bound to
    /// an infinite value.
    pub range: std::option::Option<crate::model::Range>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DistributionCut {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [distribution_filter][crate::model::DistributionCut::distribution_filter].
    pub fn set_distribution_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.distribution_filter = v.into();
        self
    }

    /// Sets the value of [range][crate::model::DistributionCut::range].
    pub fn set_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range][crate::model::DistributionCut::range].
    pub fn set_or_clear_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.range = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DistributionCut {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DistributionCut"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DistributionCut {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __distribution_filter,
            __range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DistributionCut")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "distributionFilter" => Ok(__FieldTag::__distribution_filter),
                            "distribution_filter" => Ok(__FieldTag::__distribution_filter),
                            "range" => Ok(__FieldTag::__range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DistributionCut;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DistributionCut")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__distribution_filter => {
                            if !fields.insert(__FieldTag::__distribution_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution_filter",
                                ));
                            }
                            result.distribution_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            result.range =
                                map.next_value::<std::option::Option<crate::model::Range>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DistributionCut {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.distribution_filter.is_empty() {
            state.serialize_entry("distributionFilter", &self.distribution_filter)?;
        }
        if self.range.is_some() {
            state.serialize_entry("range", &self.range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A `WindowsBasedSli` defines `good_service` as the count of time windows for
/// which the provided service was of good quality. Criteria for determining
/// if service was good are embedded in the `window_criterion`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WindowsBasedSli {
    /// Duration over which window quality is evaluated. Must be an integer
    /// fraction of a day and at least `60s`.
    pub window_period: std::option::Option<wkt::Duration>,

    /// The criterion to use for evaluating window goodness.
    pub window_criterion: std::option::Option<crate::model::windows_based_sli::WindowCriterion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsBasedSli {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window_period][crate::model::WindowsBasedSli::window_period].
    pub fn set_window_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.window_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window_period][crate::model::WindowsBasedSli::window_period].
    pub fn set_or_clear_window_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.window_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion].
    ///
    /// Note that all the setters affecting `window_criterion` are mutually
    /// exclusive.
    pub fn set_window_criterion<
        T: std::convert::Into<std::option::Option<crate::model::windows_based_sli::WindowCriterion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = v.into();
        self
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `GoodBadMetricFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn good_bad_metric_filter(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::GoodBadMetricFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `GoodBadMetricFilter`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_good_bad_metric_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::GoodBadMetricFilter(v.into()),
        );
        self
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `GoodTotalRatioThreshold`, `None` if the field is not set or
    /// holds a different branch.
    pub fn good_total_ratio_threshold(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::windows_based_sli::PerformanceThreshold>>
    {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::GoodTotalRatioThreshold(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `GoodTotalRatioThreshold`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_good_total_ratio_threshold<
        T: std::convert::Into<std::boxed::Box<crate::model::windows_based_sli::PerformanceThreshold>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::GoodTotalRatioThreshold(v.into()),
        );
        self
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `MetricMeanInRange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn metric_mean_in_range(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::windows_based_sli::MetricRange>> {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::MetricMeanInRange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `MetricMeanInRange`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_metric_mean_in_range<
        T: std::convert::Into<std::boxed::Box<crate::model::windows_based_sli::MetricRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::MetricMeanInRange(v.into()),
        );
        self
    }

    /// The value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// if it holds a `MetricSumInRange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn metric_sum_in_range(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::windows_based_sli::MetricRange>> {
        #[allow(unreachable_patterns)]
        self.window_criterion.as_ref().and_then(|v| match v {
            crate::model::windows_based_sli::WindowCriterion::MetricSumInRange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [window_criterion][crate::model::WindowsBasedSli::window_criterion]
    /// to hold a `MetricSumInRange`.
    ///
    /// Note that all the setters affecting `window_criterion` are
    /// mutually exclusive.
    pub fn set_metric_sum_in_range<
        T: std::convert::Into<std::boxed::Box<crate::model::windows_based_sli::MetricRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window_criterion = std::option::Option::Some(
            crate::model::windows_based_sli::WindowCriterion::MetricSumInRange(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WindowsBasedSli {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.WindowsBasedSli"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WindowsBasedSli {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __good_bad_metric_filter,
            __good_total_ratio_threshold,
            __metric_mean_in_range,
            __metric_sum_in_range,
            __window_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsBasedSli")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "goodBadMetricFilter" => Ok(__FieldTag::__good_bad_metric_filter),
                            "good_bad_metric_filter" => Ok(__FieldTag::__good_bad_metric_filter),
                            "goodTotalRatioThreshold" => {
                                Ok(__FieldTag::__good_total_ratio_threshold)
                            }
                            "good_total_ratio_threshold" => {
                                Ok(__FieldTag::__good_total_ratio_threshold)
                            }
                            "metricMeanInRange" => Ok(__FieldTag::__metric_mean_in_range),
                            "metric_mean_in_range" => Ok(__FieldTag::__metric_mean_in_range),
                            "metricSumInRange" => Ok(__FieldTag::__metric_sum_in_range),
                            "metric_sum_in_range" => Ok(__FieldTag::__metric_sum_in_range),
                            "windowPeriod" => Ok(__FieldTag::__window_period),
                            "window_period" => Ok(__FieldTag::__window_period),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WindowsBasedSli;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsBasedSli")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__good_bad_metric_filter => {
                            if !fields.insert(__FieldTag::__good_bad_metric_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for good_bad_metric_filter",
                                ));
                            }
                            if result.window_criterion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `window_criterion`, a oneof with full ID .google.monitoring.v3.WindowsBasedSli.good_bad_metric_filter, latest field was goodBadMetricFilter",
                                ));
                            }
                            result.window_criterion = std::option::Option::Some(
                                crate::model::windows_based_sli::WindowCriterion::GoodBadMetricFilter(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__good_total_ratio_threshold => {
                            if !fields.insert(__FieldTag::__good_total_ratio_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for good_total_ratio_threshold",
                                ));
                            }
                            if result.window_criterion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `window_criterion`, a oneof with full ID .google.monitoring.v3.WindowsBasedSli.good_total_ratio_threshold, latest field was goodTotalRatioThreshold",
                                ));
                            }
                            result.window_criterion = std::option::Option::Some(
                                crate::model::windows_based_sli::WindowCriterion::GoodTotalRatioThreshold(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::windows_based_sli::PerformanceThreshold>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__metric_mean_in_range => {
                            if !fields.insert(__FieldTag::__metric_mean_in_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_mean_in_range",
                                ));
                            }
                            if result.window_criterion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `window_criterion`, a oneof with full ID .google.monitoring.v3.WindowsBasedSli.metric_mean_in_range, latest field was metricMeanInRange",
                                ));
                            }
                            result.window_criterion = std::option::Option::Some(
                                crate::model::windows_based_sli::WindowCriterion::MetricMeanInRange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::windows_based_sli::MetricRange,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__metric_sum_in_range => {
                            if !fields.insert(__FieldTag::__metric_sum_in_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_sum_in_range",
                                ));
                            }
                            if result.window_criterion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `window_criterion`, a oneof with full ID .google.monitoring.v3.WindowsBasedSli.metric_sum_in_range, latest field was metricSumInRange",
                                ));
                            }
                            result.window_criterion = std::option::Option::Some(
                                crate::model::windows_based_sli::WindowCriterion::MetricSumInRange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::windows_based_sli::MetricRange,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__window_period => {
                            if !fields.insert(__FieldTag::__window_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window_period",
                                ));
                            }
                            result.window_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WindowsBasedSli {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.good_bad_metric_filter() {
            state.serialize_entry("goodBadMetricFilter", value)?;
        }
        if let Some(value) = self.good_total_ratio_threshold() {
            state.serialize_entry("goodTotalRatioThreshold", value)?;
        }
        if let Some(value) = self.metric_mean_in_range() {
            state.serialize_entry("metricMeanInRange", value)?;
        }
        if let Some(value) = self.metric_sum_in_range() {
            state.serialize_entry("metricSumInRange", value)?;
        }
        if self.window_period.is_some() {
            state.serialize_entry("windowPeriod", &self.window_period)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WindowsBasedSli].
pub mod windows_based_sli {
    #[allow(unused_imports)]
    use super::*;

    /// A `PerformanceThreshold` is used when each window is good when that window
    /// has a sufficiently high `performance`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PerformanceThreshold {
        /// If window `performance >= threshold`, the window is counted as good.
        pub threshold: f64,

        /// The means, either a request-based SLI or a basic SLI, by which to compute
        /// performance over a window.
        pub r#type:
            std::option::Option<crate::model::windows_based_sli::performance_threshold::Type>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PerformanceThreshold {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threshold][crate::model::windows_based_sli::PerformanceThreshold::threshold].
        pub fn set_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.threshold = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::type].
        ///
        /// Note that all the setters affecting `r#type` are mutually
        /// exclusive.
        pub fn set_type<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::windows_based_sli::performance_threshold::Type,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// if it holds a `Performance`, `None` if the field is not set or
        /// holds a different branch.
        pub fn performance(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::RequestBasedSli>> {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::windows_based_sli::performance_threshold::Type::Performance(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// to hold a `Performance`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_performance<
            T: std::convert::Into<std::boxed::Box<crate::model::RequestBasedSli>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::windows_based_sli::performance_threshold::Type::Performance(v.into()),
            );
            self
        }

        /// The value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// if it holds a `BasicSliPerformance`, `None` if the field is not set or
        /// holds a different branch.
        pub fn basic_sli_performance(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BasicSli>> {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::windows_based_sli::performance_threshold::Type::BasicSliPerformance(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::windows_based_sli::PerformanceThreshold::r#type]
        /// to hold a `BasicSliPerformance`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_basic_sli_performance<
            T: std::convert::Into<std::boxed::Box<crate::model::BasicSli>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::windows_based_sli::performance_threshold::Type::BasicSliPerformance(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for PerformanceThreshold {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.WindowsBasedSli.PerformanceThreshold"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PerformanceThreshold {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __performance,
                __basic_sli_performance,
                __threshold,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PerformanceThreshold")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "performance" => Ok(__FieldTag::__performance),
                                "basicSliPerformance" => Ok(__FieldTag::__basic_sli_performance),
                                "basic_sli_performance" => Ok(__FieldTag::__basic_sli_performance),
                                "threshold" => Ok(__FieldTag::__threshold),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PerformanceThreshold;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PerformanceThreshold")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__performance => {
                                if !fields.insert(__FieldTag::__performance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for performance",
                                    ));
                                }
                                if result.r#type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `r#type`, a oneof with full ID .google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.performance, latest field was performance",
                                    ));
                                }
                                result.r#type = std::option::Option::Some(
                                    crate::model::windows_based_sli::performance_threshold::Type::Performance(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::RequestBasedSli>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__basic_sli_performance => {
                                if !fields.insert(__FieldTag::__basic_sli_performance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for basic_sli_performance",
                                    ));
                                }
                                if result.r#type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `r#type`, a oneof with full ID .google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.basic_sli_performance, latest field was basicSliPerformance",
                                    ));
                                }
                                result.r#type = std::option::Option::Some(
                                    crate::model::windows_based_sli::performance_threshold::Type::BasicSliPerformance(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::BasicSli>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__threshold => {
                                if !fields.insert(__FieldTag::__threshold) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for threshold",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.threshold =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PerformanceThreshold {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.performance() {
                state.serialize_entry("performance", value)?;
            }
            if let Some(value) = self.basic_sli_performance() {
                state.serialize_entry("basicSliPerformance", value)?;
            }
            if !wkt::internal::is_default(&self.threshold) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("threshold", &__With(&self.threshold))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PerformanceThreshold].
    pub mod performance_threshold {
        #[allow(unused_imports)]
        use super::*;

        /// The means, either a request-based SLI or a basic SLI, by which to compute
        /// performance over a window.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// `RequestBasedSli` to evaluate to judge window quality.
            Performance(std::boxed::Box<crate::model::RequestBasedSli>),
            /// `BasicSli` to evaluate to judge window quality.
            BasicSliPerformance(std::boxed::Box<crate::model::BasicSli>),
        }
    }

    /// A `MetricRange` is used when each window is good when the value x of a
    /// single `TimeSeries` satisfies `range.min <= x <= range.max`. The provided
    /// `TimeSeries` must have `ValueType = INT64` or `ValueType = DOUBLE` and
    /// `MetricKind = GAUGE`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MetricRange {
        /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        /// specifying the `TimeSeries` to use for evaluating window quality.
        pub time_series: std::string::String,

        /// Range of values considered "good." For a one-sided range, set one bound
        /// to an infinite value.
        pub range: std::option::Option<crate::model::Range>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MetricRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series][crate::model::windows_based_sli::MetricRange::time_series].
        pub fn set_time_series<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.time_series = v.into();
            self
        }

        /// Sets the value of [range][crate::model::windows_based_sli::MetricRange::range].
        pub fn set_range<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Range>,
        {
            self.range = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [range][crate::model::windows_based_sli::MetricRange::range].
        pub fn set_or_clear_range<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Range>,
        {
            self.range = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MetricRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.WindowsBasedSli.MetricRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MetricRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time_series,
                __range,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MetricRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "timeSeries" => Ok(__FieldTag::__time_series),
                                "time_series" => Ok(__FieldTag::__time_series),
                                "range" => Ok(__FieldTag::__range),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MetricRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MetricRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time_series => {
                                if !fields.insert(__FieldTag::__time_series) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_series",
                                    ));
                                }
                                result.time_series = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__range => {
                                if !fields.insert(__FieldTag::__range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for range",
                                    ));
                                }
                                result.range =
                                    map.next_value::<std::option::Option<crate::model::Range>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MetricRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.time_series.is_empty() {
                state.serialize_entry("timeSeries", &self.time_series)?;
            }
            if self.range.is_some() {
                state.serialize_entry("range", &self.range)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The criterion to use for evaluating window goodness.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WindowCriterion {
        /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        /// specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if
        /// any `true` values appear in the window.
        GoodBadMetricFilter(std::string::String),
        /// A window is good if its `performance` is high enough.
        GoodTotalRatioThreshold(
            std::boxed::Box<crate::model::windows_based_sli::PerformanceThreshold>,
        ),
        /// A window is good if the metric's value is in a good range, averaged
        /// across returned streams.
        MetricMeanInRange(std::boxed::Box<crate::model::windows_based_sli::MetricRange>),
        /// A window is good if the metric's value is in a good range, summed across
        /// returned streams.
        MetricSumInRange(std::boxed::Box<crate::model::windows_based_sli::MetricRange>),
    }
}

/// The `CreateService` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateServiceRequest {
    /// Required. Resource
    /// [name](https://cloud.google.com/monitoring/api/v3#project_name) of the
    /// parent Metrics Scope. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub parent: std::string::String,

    /// Optional. The Service id to use for this Service. If omitted, an id will be
    /// generated instead. Must match the pattern `[a-z0-9\-]+`
    pub service_id: std::string::String,

    /// Required. The `Service` to create.
    pub service: std::option::Option<crate::model::Service>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateServiceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service_id][crate::model::CreateServiceRequest::service_id].
    pub fn set_service_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_id = v.into();
        self
    }

    /// Sets the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __service_id,
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "serviceId" => Ok(__FieldTag::__service_id),
                            "service_id" => Ok(__FieldTag::__service_id),
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_id => {
                            if !fields.insert(__FieldTag::__service_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_id",
                                ));
                            }
                            result.service_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<crate::model::Service>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.service_id.is_empty() {
            state.serialize_entry("serviceId", &self.service_id)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetService` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Required. Resource name of the `Service`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListServices` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Required. Resource name of the parent containing the listed services,
    /// either a [project](https://cloud.google.com/monitoring/api/v3#project_name)
    /// or a Monitoring Metrics Scope. The formats are:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// workspaces/[HOST_PROJECT_ID_OR_NUMBER]
    /// ```
    pub parent: std::string::String,

    /// A filter specifying what `Service`s to return. The filter supports
    /// filtering on a particular service-identifier type or one of its attributes.
    ///
    /// To filter on a particular service-identifier type, the `identifier_case`
    /// refers to which option in the `identifier` field is populated. For example,
    /// the filter `identifier_case = "CUSTOM"` would match all services with a
    /// value for the `custom` field. Valid options include "CUSTOM", "APP_ENGINE",
    /// "MESH_ISTIO", and the other options listed at
    /// <https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#Service>
    ///
    /// To filter on an attribute of a service-identifier type, apply the filter
    /// name by using the snake case of the service-identifier type and the
    /// attribute of that service-identifier type, and join the two with a period.
    /// For example, to filter by the `meshUid` field of the `MeshIstio`
    /// service-identifier type, you must filter on `mesh_istio.mesh_uid =
    /// "123"` to match all services with mesh UID "123". Service-identifier types
    /// and their attributes are described at
    /// <https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services#Service>
    pub filter: std::string::String,

    /// A non-negative number that is the maximum number of results to return.
    /// When 0, use default page size.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServicesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListServices` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The `Service`s matching the specified filter.
    pub services: std::vec::Vec<crate::model::Service>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `UpdateService` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Required. The `Service` to draw updates from.
    /// The given `name` specifies the resource to update.
    pub service: std::option::Option<crate::model::Service>,

    /// A set of field paths defining which fields to use for the update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<crate::model::Service>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `DeleteService` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Required. Resource name of the `Service` to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `CreateServiceLevelObjective` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateServiceLevelObjectiveRequest {
    /// Required. Resource name of the parent `Service`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// ```
    pub parent: std::string::String,

    /// Optional. The ServiceLevelObjective id to use for this
    /// ServiceLevelObjective. If omitted, an id will be generated instead. Must
    /// match the pattern `^[a-zA-Z0-9-_:.]+$`
    pub service_level_objective_id: std::string::String,

    /// Required. The `ServiceLevelObjective` to create.
    /// The provided `name` will be respected if no `ServiceLevelObjective` exists
    /// with this name.
    pub service_level_objective: std::option::Option<crate::model::ServiceLevelObjective>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceLevelObjectiveRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateServiceLevelObjectiveRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service_level_objective_id][crate::model::CreateServiceLevelObjectiveRequest::service_level_objective_id].
    pub fn set_service_level_objective_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_level_objective_id = v.into();
        self
    }

    /// Sets the value of [service_level_objective][crate::model::CreateServiceLevelObjectiveRequest::service_level_objective].
    pub fn set_service_level_objective<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceLevelObjective>,
    {
        self.service_level_objective = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_level_objective][crate::model::CreateServiceLevelObjectiveRequest::service_level_objective].
    pub fn set_or_clear_service_level_objective<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceLevelObjective>,
    {
        self.service_level_objective = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateServiceLevelObjectiveRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateServiceLevelObjectiveRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __service_level_objective_id,
            __service_level_objective,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateServiceLevelObjectiveRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "serviceLevelObjectiveId" => {
                                Ok(__FieldTag::__service_level_objective_id)
                            }
                            "service_level_objective_id" => {
                                Ok(__FieldTag::__service_level_objective_id)
                            }
                            "serviceLevelObjective" => Ok(__FieldTag::__service_level_objective),
                            "service_level_objective" => Ok(__FieldTag::__service_level_objective),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateServiceLevelObjectiveRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateServiceLevelObjectiveRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_level_objective_id => {
                            if !fields.insert(__FieldTag::__service_level_objective_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_level_objective_id",
                                ));
                            }
                            result.service_level_objective_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_level_objective => {
                            if !fields.insert(__FieldTag::__service_level_objective) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_level_objective",
                                ));
                            }
                            result.service_level_objective = map.next_value::<std::option::Option<crate::model::ServiceLevelObjective>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateServiceLevelObjectiveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.service_level_objective_id.is_empty() {
            state.serialize_entry("serviceLevelObjectiveId", &self.service_level_objective_id)?;
        }
        if self.service_level_objective.is_some() {
            state.serialize_entry("serviceLevelObjective", &self.service_level_objective)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `GetServiceLevelObjective` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceLevelObjectiveRequest {
    /// Required. Resource name of the `ServiceLevelObjective` to get. The format
    /// is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
    /// ```
    pub name: std::string::String,

    /// View of the `ServiceLevelObjective` to return. If `DEFAULT`, return the
    /// `ServiceLevelObjective` as originally defined. If `EXPLICIT` and the
    /// `ServiceLevelObjective` is defined in terms of a `BasicSli`, replace the
    /// `BasicSli` with a `RequestBasedSli` spelling out how the SLI is computed.
    pub view: crate::model::service_level_objective::View,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceLevelObjectiveRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceLevelObjectiveRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetServiceLevelObjectiveRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::service_level_objective::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetServiceLevelObjectiveRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceLevelObjectiveRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceLevelObjectiveRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceLevelObjectiveRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceLevelObjectiveRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<
                                    crate::model::service_level_objective::View,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceLevelObjectiveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListServiceLevelObjectives` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServiceLevelObjectivesRequest {
    /// Required. Resource name of the parent containing the listed SLOs, either a
    /// project or a Monitoring Metrics Scope. The formats are:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    /// workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
    /// ```
    pub parent: std::string::String,

    /// A filter specifying what `ServiceLevelObjective`s to return.
    pub filter: std::string::String,

    /// A non-negative number that is the maximum number of results to return.
    /// When 0, use default page size.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return additional results from the previous method call.
    pub page_token: std::string::String,

    /// View of the `ServiceLevelObjective`s to return. If `DEFAULT`, return each
    /// `ServiceLevelObjective` as originally defined. If `EXPLICIT` and the
    /// `ServiceLevelObjective` is defined in terms of a `BasicSli`, replace the
    /// `BasicSli` with a `RequestBasedSli` spelling out how the SLI is computed.
    pub view: crate::model::service_level_objective::View,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceLevelObjectivesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServiceLevelObjectivesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServiceLevelObjectivesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServiceLevelObjectivesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServiceLevelObjectivesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListServiceLevelObjectivesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::service_level_objective::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceLevelObjectivesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServiceLevelObjectivesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServiceLevelObjectivesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServiceLevelObjectivesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServiceLevelObjectivesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServiceLevelObjectivesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<
                                    crate::model::service_level_objective::View,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServiceLevelObjectivesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `ListServiceLevelObjectives` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServiceLevelObjectivesResponse {
    /// The `ServiceLevelObjective`s matching the specified filter.
    pub service_level_objectives: std::vec::Vec<crate::model::ServiceLevelObjective>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceLevelObjectivesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_level_objectives][crate::model::ListServiceLevelObjectivesResponse::service_level_objectives].
    pub fn set_service_level_objectives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceLevelObjective>,
    {
        use std::iter::Iterator;
        self.service_level_objectives = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServiceLevelObjectivesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceLevelObjectivesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListServiceLevelObjectivesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServiceLevelObjectivesResponse {
    type PageItem = crate::model::ServiceLevelObjective;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.service_level_objectives
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServiceLevelObjectivesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_level_objectives,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServiceLevelObjectivesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceLevelObjectives" => Ok(__FieldTag::__service_level_objectives),
                            "service_level_objectives" => {
                                Ok(__FieldTag::__service_level_objectives)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServiceLevelObjectivesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServiceLevelObjectivesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_level_objectives => {
                            if !fields.insert(__FieldTag::__service_level_objectives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_level_objectives",
                                ));
                            }
                            result.service_level_objectives = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ServiceLevelObjective>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServiceLevelObjectivesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_level_objectives.is_empty() {
            state.serialize_entry("serviceLevelObjectives", &self.service_level_objectives)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `UpdateServiceLevelObjective` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateServiceLevelObjectiveRequest {
    /// Required. The `ServiceLevelObjective` to draw updates from.
    /// The given `name` specifies the resource to update.
    pub service_level_objective: std::option::Option<crate::model::ServiceLevelObjective>,

    /// A set of field paths defining which fields to use for the update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceLevelObjectiveRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_level_objective][crate::model::UpdateServiceLevelObjectiveRequest::service_level_objective].
    pub fn set_service_level_objective<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceLevelObjective>,
    {
        self.service_level_objective = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_level_objective][crate::model::UpdateServiceLevelObjectiveRequest::service_level_objective].
    pub fn set_or_clear_service_level_objective<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceLevelObjective>,
    {
        self.service_level_objective = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceLevelObjectiveRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServiceLevelObjectiveRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateServiceLevelObjectiveRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateServiceLevelObjectiveRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_level_objective,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateServiceLevelObjectiveRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceLevelObjective" => Ok(__FieldTag::__service_level_objective),
                            "service_level_objective" => Ok(__FieldTag::__service_level_objective),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateServiceLevelObjectiveRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateServiceLevelObjectiveRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_level_objective => {
                            if !fields.insert(__FieldTag::__service_level_objective) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_level_objective",
                                ));
                            }
                            result.service_level_objective = map.next_value::<std::option::Option<crate::model::ServiceLevelObjective>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateServiceLevelObjectiveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service_level_objective.is_some() {
            state.serialize_entry("serviceLevelObjective", &self.service_level_objective)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The `DeleteServiceLevelObjective` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteServiceLevelObjectiveRequest {
    /// Required. Resource name of the `ServiceLevelObjective` to delete. The
    /// format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceLevelObjectiveRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceLevelObjectiveRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceLevelObjectiveRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteServiceLevelObjectiveRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteServiceLevelObjectiveRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteServiceLevelObjectiveRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteServiceLevelObjectiveRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteServiceLevelObjectiveRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteServiceLevelObjectiveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A `Snooze` will prevent any alerts from being opened, and close any that
/// are already open. The `Snooze` will work on alerts that match the
/// criteria defined in the `Snooze`. The `Snooze` will be active from
/// `interval.start_time` through `interval.end_time`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Snooze {
    /// Required. Identifier. The name of the `Snooze`. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
    /// ```
    ///
    /// The ID of the `Snooze` will be generated by the system.
    pub name: std::string::String,

    /// Required. This defines the criteria for applying the `Snooze`. See
    /// `Criteria` for more information.
    pub criteria: std::option::Option<crate::model::snooze::Criteria>,

    /// Required. The `Snooze` will be active from `interval.start_time` through
    /// `interval.end_time`.
    /// `interval.start_time` cannot be in the past. There is a 15 second clock
    /// skew to account for the time it takes for a request to reach the API from
    /// the UI.
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// Required. A display name for the `Snooze`. This can be, at most, 512
    /// unicode characters.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Snooze {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snooze::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [criteria][crate::model::Snooze::criteria].
    pub fn set_criteria<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::snooze::Criteria>,
    {
        self.criteria = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [criteria][crate::model::Snooze::criteria].
    pub fn set_or_clear_criteria<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::snooze::Criteria>,
    {
        self.criteria = v.map(|x| x.into());
        self
    }

    /// Sets the value of [interval][crate::model::Snooze::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::Snooze::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::Snooze::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Snooze {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.Snooze"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Snooze {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __criteria,
            __interval,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Snooze")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "criteria" => Ok(__FieldTag::__criteria),
                            "interval" => Ok(__FieldTag::__interval),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Snooze;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Snooze")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__criteria => {
                            if !fields.insert(__FieldTag::__criteria) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for criteria",
                                ));
                            }
                            result.criteria = map
                                .next_value::<std::option::Option<crate::model::snooze::Criteria>>(
                                )?;
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval = map
                                .next_value::<std::option::Option<crate::model::TimeInterval>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Snooze {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.criteria.is_some() {
            state.serialize_entry("criteria", &self.criteria)?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Snooze].
pub mod snooze {
    #[allow(unused_imports)]
    use super::*;

    /// Criteria specific to the `AlertPolicy`s that this `Snooze` applies to. The
    /// `Snooze` will suppress alerts that come from one of the `AlertPolicy`s
    /// whose names are supplied.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Criteria {
        /// The specific `AlertPolicy` names for the alert that should be snoozed.
        /// The format is:
        ///
        /// ```norust
        /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]
        /// ```
        ///
        /// There is a limit of 16 policies per snooze. This limit is checked during
        /// snooze creation.
        /// Exactly 1 alert policy is required if `filter` is specified at the same
        /// time.
        pub policies: std::vec::Vec<std::string::String>,

        /// Optional. The filter string to match on Alert fields when silencing the
        /// alerts. It follows the standard <https://google.aip.dev/160> syntax.
        /// A filter string used to apply the snooze to specific incidents
        /// that have matching filter values.
        /// Filters can be defined for snoozes that apply to one alerting
        /// policy.
        /// Filters must be a string formatted as one or more resource labels with
        /// specific label values. If multiple resource labels are used, then they
        /// must be connected with an AND operator. For example, the following filter
        /// applies the snooze to incidents that have an instance ID of
        /// `1234567890` and a zone of `us-central1-a`:
        ///
        /// ```norust
        /// resource.labels.instance_id="1234567890" AND
        /// resource.labels.zone="us-central1-a"
        /// ```
        pub filter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Criteria {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [policies][crate::model::snooze::Criteria::policies].
        pub fn set_policies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.policies = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [filter][crate::model::snooze::Criteria::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for Criteria {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.Snooze.Criteria"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Criteria {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __policies,
                __filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Criteria")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "policies" => Ok(__FieldTag::__policies),
                                "filter" => Ok(__FieldTag::__filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Criteria;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Criteria")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__policies => {
                                if !fields.insert(__FieldTag::__policies) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policies",
                                    ));
                                }
                                result.policies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Criteria {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.policies.is_empty() {
                state.serialize_entry("policies", &self.policies)?;
            }
            if !self.filter.is_empty() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The message definition for creating a `Snooze`. Users must provide the body
/// of the `Snooze` to be created but must omit the `Snooze` field, `name`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSnoozeRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// a `Snooze` should be created. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub parent: std::string::String,

    /// Required. The `Snooze` to create. Omit the `name` field, as it will be
    /// filled in by the API.
    pub snooze: std::option::Option<crate::model::Snooze>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSnoozeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSnoozeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [snooze][crate::model::CreateSnoozeRequest::snooze].
    pub fn set_snooze<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Snooze>,
    {
        self.snooze = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snooze][crate::model::CreateSnoozeRequest::snooze].
    pub fn set_or_clear_snooze<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Snooze>,
    {
        self.snooze = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSnoozeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateSnoozeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSnoozeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __snooze,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSnoozeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "snooze" => Ok(__FieldTag::__snooze),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSnoozeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSnoozeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snooze => {
                            if !fields.insert(__FieldTag::__snooze) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snooze",
                                ));
                            }
                            result.snooze =
                                map.next_value::<std::option::Option<crate::model::Snooze>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSnoozeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.snooze.is_some() {
            state.serialize_entry("snooze", &self.snooze)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message definition for listing `Snooze`s associated with the given
/// `parent`, satisfying the optional `filter`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnoozesRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// `Snooze`s should be listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub parent: std::string::String,

    /// Optional. Optional filter to restrict results to the given criteria. The
    /// following fields are supported.
    ///
    /// * `interval.start_time`
    /// * `interval.end_time`
    ///
    /// For example:
    ///
    /// ```norust
    /// interval.start_time > "2022-03-11T00:00:00-08:00" AND
    ///     interval.end_time < "2022-03-12T00:00:00-08:00"
    /// ```
    pub filter: std::string::String,

    /// Optional. The maximum number of results to return for a single query. The
    /// server may further constrain the maximum number of results returned in a
    /// single page. The value should be in the range [1, 1000]. If the value given
    /// is outside this range, the server will decide the number of results to be
    /// returned.
    pub page_size: i32,

    /// Optional. The `next_page_token` from a previous call to
    /// `ListSnoozesRequest` to get the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnoozesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSnoozesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSnoozesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnoozesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnoozesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnoozesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListSnoozesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnoozesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnoozesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnoozesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnoozesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnoozesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The results of a successful `ListSnoozes` call, containing the matching
/// `Snooze`s.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnoozesResponse {
    /// `Snooze`s matching this list call.
    pub snoozes: std::vec::Vec<crate::model::Snooze>,

    /// Page token for repeated calls to `ListSnoozes`, to fetch additional pages
    /// of results. If this is empty or missing, there are no more pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnoozesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snoozes][crate::model::ListSnoozesResponse::snoozes].
    pub fn set_snoozes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snooze>,
    {
        use std::iter::Iterator;
        self.snoozes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSnoozesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnoozesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListSnoozesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSnoozesResponse {
    type PageItem = crate::model::Snooze;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snoozes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnoozesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snoozes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnoozesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snoozes" => Ok(__FieldTag::__snoozes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnoozesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnoozesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snoozes => {
                            if !fields.insert(__FieldTag::__snoozes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snoozes",
                                ));
                            }
                            result.snoozes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Snooze>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnoozesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snoozes.is_empty() {
            state.serialize_entry("snoozes", &self.snoozes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message definition for retrieving a `Snooze`. Users must specify the
/// field, `name`, which identifies the `Snooze`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSnoozeRequest {
    /// Required. The ID of the `Snooze` to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/snoozes/[SNOOZE_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSnoozeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSnoozeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnoozeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetSnoozeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSnoozeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSnoozeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSnoozeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSnoozeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSnoozeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message definition for updating a `Snooze`. The field, `snooze.name`
/// identifies the `Snooze` to be updated. The remainder of `snooze` gives the
/// content the `Snooze` in question will be assigned.
///
/// What fields can be updated depends on the start time and end time of the
/// `Snooze`.
///
/// * end time is in the past: These `Snooze`s are considered
///   read-only and cannot be updated.
/// * start time is in the past and end time is in the future: `display_name`
///   and `interval.end_time` can be updated.
/// * start time is in the future: `display_name`, `interval.start_time` and
///   `interval.end_time` can be updated.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSnoozeRequest {
    /// Required. The `Snooze` to update. Must have the name field present.
    pub snooze: std::option::Option<crate::model::Snooze>,

    /// Required. The fields to update.
    ///
    /// For each field listed in `update_mask`:
    ///
    /// * If the `Snooze` object supplied in the `UpdateSnoozeRequest` has a
    ///   value for that field, the value of the field in the existing `Snooze`
    ///   will be set to the value of the field in the supplied `Snooze`.
    /// * If the field does not have a value in the supplied `Snooze`, the field
    ///   in the existing `Snooze` is set to its default value.
    ///
    /// Fields not listed retain their existing value.
    ///
    /// The following are the field names that are accepted in `update_mask`:
    ///
    /// * `display_name`
    /// * `interval.start_time`
    /// * `interval.end_time`
    ///
    /// That said, the start time and end time of the `Snooze` determines which
    /// fields can legally be updated. Before attempting an update, users should
    /// consult the documentation for `UpdateSnoozeRequest`, which talks about
    /// which fields can be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSnoozeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snooze][crate::model::UpdateSnoozeRequest::snooze].
    pub fn set_snooze<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Snooze>,
    {
        self.snooze = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snooze][crate::model::UpdateSnoozeRequest::snooze].
    pub fn set_or_clear_snooze<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Snooze>,
    {
        self.snooze = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnoozeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSnoozeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSnoozeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateSnoozeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSnoozeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snooze,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSnoozeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snooze" => Ok(__FieldTag::__snooze),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSnoozeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSnoozeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snooze => {
                            if !fields.insert(__FieldTag::__snooze) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snooze",
                                ));
                            }
                            result.snooze =
                                map.next_value::<std::option::Option<crate::model::Snooze>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSnoozeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.snooze.is_some() {
            state.serialize_entry("snooze", &self.snooze)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The context of a span. This is attached to an
/// [Exemplar][google.api.Distribution.Exemplar]
/// in [Distribution][google.api.Distribution] values during aggregation.
///
/// It contains the name of a span with format:
///
/// ```norust
/// projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID]
/// ```
///
/// [google.api.Distribution]: api::model::Distribution
/// [google.api.Distribution.Exemplar]: api::model::distribution::Exemplar
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpanContext {
    /// The resource name of the span. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID]
    /// ```
    ///
    /// `[TRACE_ID]` is a unique identifier for a trace within a project;
    /// it is a 32-character hexadecimal encoding of a 16-byte array.
    ///
    /// `[SPAN_ID]` is a unique identifier for a span within a trace; it
    /// is a 16-character hexadecimal encoding of an 8-byte array.
    pub span_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpanContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [span_name][crate::model::SpanContext::span_name].
    pub fn set_span_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.span_name = v.into();
        self
    }
}

impl wkt::message::Message for SpanContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.SpanContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpanContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __span_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpanContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "spanName" => Ok(__FieldTag::__span_name),
                            "span_name" => Ok(__FieldTag::__span_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpanContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpanContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__span_name => {
                            if !fields.insert(__FieldTag::__span_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for span_name",
                                ));
                            }
                            result.span_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpanContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.span_name.is_empty() {
            state.serialize_entry("spanName", &self.span_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An internal checker allows Uptime checks to run on private/internal GCP
/// resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub struct InternalChecker {
    /// A unique resource name for this InternalChecker. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]
    /// ```
    ///
    /// `[PROJECT_ID_OR_NUMBER]` is the Cloud Monitoring Metrics Scope project for
    /// the Uptime check config associated with the internal checker.
    pub name: std::string::String,

    /// The checker's human-readable name. The display name
    /// should be unique within a Cloud Monitoring Metrics Scope in order to make
    /// it easier to identify; however, uniqueness is not enforced.
    pub display_name: std::string::String,

    /// The [GCP VPC network](https://cloud.google.com/vpc/docs/vpc) where the
    /// internal resource lives (ex: "default").
    pub network: std::string::String,

    /// The GCP zone the Uptime check should egress from. Only respected for
    /// internal Uptime checks, where internal_network is specified.
    pub gcp_zone: std::string::String,

    /// The GCP project ID where the internal checker lives. Not necessary
    /// the same as the Metrics Scope project.
    pub peer_project_id: std::string::String,

    /// The current operational state of the internal checker.
    pub state: crate::model::internal_checker::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InternalChecker {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InternalChecker::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InternalChecker::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [network][crate::model::InternalChecker::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [gcp_zone][crate::model::InternalChecker::gcp_zone].
    pub fn set_gcp_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_zone = v.into();
        self
    }

    /// Sets the value of [peer_project_id][crate::model::InternalChecker::peer_project_id].
    pub fn set_peer_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_project_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::InternalChecker::state].
    pub fn set_state<T: std::convert::Into<crate::model::internal_checker::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for InternalChecker {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.InternalChecker"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InternalChecker {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __network,
            __gcp_zone,
            __peer_project_id,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InternalChecker")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "network" => Ok(__FieldTag::__network),
                            "gcpZone" => Ok(__FieldTag::__gcp_zone),
                            "gcp_zone" => Ok(__FieldTag::__gcp_zone),
                            "peerProjectId" => Ok(__FieldTag::__peer_project_id),
                            "peer_project_id" => Ok(__FieldTag::__peer_project_id),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InternalChecker;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InternalChecker")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_zone => {
                            if !fields.insert(__FieldTag::__gcp_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_zone",
                                ));
                            }
                            result.gcp_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_project_id => {
                            if !fields.insert(__FieldTag::__peer_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_project_id",
                                ));
                            }
                            result.peer_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::internal_checker::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InternalChecker {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.gcp_zone.is_empty() {
            state.serialize_entry("gcpZone", &self.gcp_zone)?;
        }
        if !self.peer_project_id.is_empty() {
            state.serialize_entry("peerProjectId", &self.peer_project_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InternalChecker].
pub mod internal_checker {
    #[allow(unused_imports)]
    use super::*;

    /// Operational states for an internal checker.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// An internal checker should never be in the unspecified state.
        Unspecified,
        /// The checker is being created, provisioned, and configured. A checker in
        /// this state can be returned by `ListInternalCheckers` or
        /// `GetInternalChecker`, as well as by examining the [long running
        /// Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
        /// that created it.
        Creating,
        /// The checker is running and available for use. A checker in this state
        /// can be returned by `ListInternalCheckers` or `GetInternalChecker` as
        /// well as by examining the [long running
        /// Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
        /// that created it.
        /// If a checker is being torn down, it is neither visible nor usable, so
        /// there is no "deleting" or "down" state.
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Running,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.monitoring.v3.InternalChecker.State",
            ))
        }
    }
}

/// Describes a Synthetic Monitor to be invoked by Uptime.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SyntheticMonitorTarget {
    /// Specifies a Synthetic Monitor's execution stack.
    pub target: std::option::Option<crate::model::synthetic_monitor_target::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SyntheticMonitorTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::SyntheticMonitorTarget::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::synthetic_monitor_target::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::SyntheticMonitorTarget::target]
    /// if it holds a `CloudFunctionV2`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_function_v2(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::synthetic_monitor_target::CloudFunctionV2Target>,
    > {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::synthetic_monitor_target::Target::CloudFunctionV2(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::SyntheticMonitorTarget::target]
    /// to hold a `CloudFunctionV2`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_function_v2<
        T: std::convert::Into<
                std::boxed::Box<crate::model::synthetic_monitor_target::CloudFunctionV2Target>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::synthetic_monitor_target::Target::CloudFunctionV2(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SyntheticMonitorTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.SyntheticMonitorTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SyntheticMonitorTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_function_v2,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SyntheticMonitorTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudFunctionV2" => Ok(__FieldTag::__cloud_function_v2),
                            "cloud_function_v2" => Ok(__FieldTag::__cloud_function_v2),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SyntheticMonitorTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SyntheticMonitorTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_function_v2 => {
                            if !fields.insert(__FieldTag::__cloud_function_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_function_v2",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.monitoring.v3.SyntheticMonitorTarget.cloud_function_v2, latest field was cloudFunctionV2",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::synthetic_monitor_target::Target::CloudFunctionV2(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::synthetic_monitor_target::CloudFunctionV2Target>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SyntheticMonitorTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_function_v2() {
            state.serialize_entry("cloudFunctionV2", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SyntheticMonitorTarget].
pub mod synthetic_monitor_target {
    #[allow(unused_imports)]
    use super::*;

    /// A Synthetic Monitor deployed to a Cloud Functions V2 instance.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudFunctionV2Target {
        /// Required. Fully qualified GCFv2 resource name
        /// i.e. `projects/{project}/locations/{location}/functions/{function}`
        /// Required.
        pub name: std::string::String,

        /// Output only. The `cloud_run_revision` Monitored Resource associated with
        /// the GCFv2. The Synthetic Monitor execution results (metrics, logs, and
        /// spans) are reported against this Monitored Resource. This field is output
        /// only.
        pub cloud_run_revision: std::option::Option<api::model::MonitoredResource>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudFunctionV2Target {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::synthetic_monitor_target::CloudFunctionV2Target::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [cloud_run_revision][crate::model::synthetic_monitor_target::CloudFunctionV2Target::cloud_run_revision].
        pub fn set_cloud_run_revision<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<api::model::MonitoredResource>,
        {
            self.cloud_run_revision = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cloud_run_revision][crate::model::synthetic_monitor_target::CloudFunctionV2Target::cloud_run_revision].
        pub fn set_or_clear_cloud_run_revision<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<api::model::MonitoredResource>,
        {
            self.cloud_run_revision = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for CloudFunctionV2Target {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.SyntheticMonitorTarget.CloudFunctionV2Target"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudFunctionV2Target {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __cloud_run_revision,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudFunctionV2Target")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "cloudRunRevision" => Ok(__FieldTag::__cloud_run_revision),
                                "cloud_run_revision" => Ok(__FieldTag::__cloud_run_revision),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudFunctionV2Target;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudFunctionV2Target")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cloud_run_revision => {
                                if !fields.insert(__FieldTag::__cloud_run_revision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_run_revision",
                                    ));
                                }
                                result.cloud_run_revision = map.next_value::<std::option::Option<api::model::MonitoredResource>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudFunctionV2Target {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if self.cloud_run_revision.is_some() {
                state.serialize_entry("cloudRunRevision", &self.cloud_run_revision)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Specifies a Synthetic Monitor's execution stack.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Target a Synthetic Monitor GCFv2 instance.
        CloudFunctionV2(
            std::boxed::Box<crate::model::synthetic_monitor_target::CloudFunctionV2Target>,
        ),
    }
}

/// This message configures which resources and services to monitor for
/// availability.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UptimeCheckConfig {
    /// Identifier. A unique resource name for this Uptime check configuration. The
    /// format is:
    ///
    /// ```norust
    ///  projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
    /// ```
    ///
    /// `[PROJECT_ID_OR_NUMBER]` is the Workspace host project associated with the
    /// Uptime check.
    ///
    /// This field should be omitted when creating the Uptime check configuration;
    /// on create, the resource name is assigned by the server and included in the
    /// response.
    pub name: std::string::String,

    /// A human-friendly name for the Uptime check configuration. The display name
    /// should be unique within a Cloud Monitoring Workspace in order to make it
    /// easier to identify; however, uniqueness is not enforced. Required.
    pub display_name: std::string::String,

    /// How often, in seconds, the Uptime check is performed.
    /// Currently, the only supported values are `60s` (1 minute), `300s`
    /// (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
    /// defaults to `60s`.
    pub period: std::option::Option<wkt::Duration>,

    /// The maximum amount of time to wait for the request to complete (must be
    /// between 1 and 60 seconds). Required.
    pub timeout: std::option::Option<wkt::Duration>,

    /// The content that is expected to appear in the data returned by the target
    /// server against which the check is run.  Currently, only the first entry
    /// in the `content_matchers` list is supported, and additional entries will
    /// be ignored. This field is optional and should only be specified if a
    /// content match is required as part of the/ Uptime check.
    pub content_matchers: std::vec::Vec<crate::model::uptime_check_config::ContentMatcher>,

    /// The type of checkers to use to execute the Uptime check.
    pub checker_type: crate::model::uptime_check_config::CheckerType,

    /// The list of regions from which the check will be run.
    /// Some regions contain one location, and others contain more than one.
    /// If this field is specified, enough regions must be provided to include a
    /// minimum of 3 locations.  Not specifying this field will result in Uptime
    /// checks running from all available regions.
    pub selected_regions: std::vec::Vec<crate::model::UptimeCheckRegion>,

    /// If this is `true`, then checks are made only from the 'internal_checkers'.
    /// If it is `false`, then checks are made only from the 'selected_regions'.
    /// It is an error to provide 'selected_regions' when is_internal is `true`,
    /// or to provide 'internal_checkers' when is_internal is `false`.
    #[deprecated]
    pub is_internal: bool,

    /// The internal checkers that this check will egress from. If `is_internal` is
    /// `true` and this list is empty, the check will egress from all the
    /// InternalCheckers configured for the project that owns this
    /// `UptimeCheckConfig`.
    #[deprecated]
    pub internal_checkers: std::vec::Vec<crate::model::InternalChecker>,

    /// User-supplied key/value data to be used for organizing and
    /// identifying the `UptimeCheckConfig` objects.
    ///
    /// The field can contain up to 64 entries. Each key and value is limited to
    /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
    /// values can contain only lowercase letters, numerals, underscores, and
    /// dashes. Keys must begin with a letter.
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The resource the check is checking. Required.
    pub resource: std::option::Option<crate::model::uptime_check_config::Resource>,

    /// The type of Uptime check request.
    pub check_request_type:
        std::option::Option<crate::model::uptime_check_config::CheckRequestType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UptimeCheckConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UptimeCheckConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::UptimeCheckConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [period][crate::model::UptimeCheckConfig::period].
    pub fn set_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [period][crate::model::UptimeCheckConfig::period].
    pub fn set_or_clear_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::UptimeCheckConfig::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::UptimeCheckConfig::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [content_matchers][crate::model::UptimeCheckConfig::content_matchers].
    pub fn set_content_matchers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::uptime_check_config::ContentMatcher>,
    {
        use std::iter::Iterator;
        self.content_matchers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [checker_type][crate::model::UptimeCheckConfig::checker_type].
    pub fn set_checker_type<
        T: std::convert::Into<crate::model::uptime_check_config::CheckerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.checker_type = v.into();
        self
    }

    /// Sets the value of [selected_regions][crate::model::UptimeCheckConfig::selected_regions].
    pub fn set_selected_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UptimeCheckRegion>,
    {
        use std::iter::Iterator;
        self.selected_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [is_internal][crate::model::UptimeCheckConfig::is_internal].
    #[deprecated]
    pub fn set_is_internal<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_internal = v.into();
        self
    }

    /// Sets the value of [internal_checkers][crate::model::UptimeCheckConfig::internal_checkers].
    #[deprecated]
    pub fn set_internal_checkers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InternalChecker>,
    {
        use std::iter::Iterator;
        self.internal_checkers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::UptimeCheckConfig::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource][crate::model::UptimeCheckConfig::resource].
    ///
    /// Note that all the setters affecting `resource` are mutually
    /// exclusive.
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::uptime_check_config::Resource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::UptimeCheckConfig::resource]
    /// if it holds a `MonitoredResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn monitored_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<api::model::MonitoredResource>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::Resource::MonitoredResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::UptimeCheckConfig::resource]
    /// to hold a `MonitoredResource`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_monitored_resource<
        T: std::convert::Into<std::boxed::Box<api::model::MonitoredResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::uptime_check_config::Resource::MonitoredResource(v.into()),
        );
        self
    }

    /// The value of [resource][crate::model::UptimeCheckConfig::resource]
    /// if it holds a `ResourceGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::uptime_check_config::ResourceGroup>>
    {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::Resource::ResourceGroup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::UptimeCheckConfig::resource]
    /// to hold a `ResourceGroup`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_resource_group<
        T: std::convert::Into<std::boxed::Box<crate::model::uptime_check_config::ResourceGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::uptime_check_config::Resource::ResourceGroup(v.into()),
        );
        self
    }

    /// The value of [resource][crate::model::UptimeCheckConfig::resource]
    /// if it holds a `SyntheticMonitor`, `None` if the field is not set or
    /// holds a different branch.
    pub fn synthetic_monitor(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SyntheticMonitorTarget>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::Resource::SyntheticMonitor(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::UptimeCheckConfig::resource]
    /// to hold a `SyntheticMonitor`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_synthetic_monitor<
        T: std::convert::Into<std::boxed::Box<crate::model::SyntheticMonitorTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::uptime_check_config::Resource::SyntheticMonitor(v.into()),
        );
        self
    }

    /// Sets the value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type].
    ///
    /// Note that all the setters affecting `check_request_type` are mutually
    /// exclusive.
    pub fn set_check_request_type<
        T: std::convert::Into<
                std::option::Option<crate::model::uptime_check_config::CheckRequestType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_request_type = v.into();
        self
    }

    /// The value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// if it holds a `HttpCheck`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_check(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::uptime_check_config::HttpCheck>> {
        #[allow(unreachable_patterns)]
        self.check_request_type.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::CheckRequestType::HttpCheck(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// to hold a `HttpCheck`.
    ///
    /// Note that all the setters affecting `check_request_type` are
    /// mutually exclusive.
    pub fn set_http_check<
        T: std::convert::Into<std::boxed::Box<crate::model::uptime_check_config::HttpCheck>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_request_type = std::option::Option::Some(
            crate::model::uptime_check_config::CheckRequestType::HttpCheck(v.into()),
        );
        self
    }

    /// The value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// if it holds a `TcpCheck`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tcp_check(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::uptime_check_config::TcpCheck>> {
        #[allow(unreachable_patterns)]
        self.check_request_type.as_ref().and_then(|v| match v {
            crate::model::uptime_check_config::CheckRequestType::TcpCheck(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [check_request_type][crate::model::UptimeCheckConfig::check_request_type]
    /// to hold a `TcpCheck`.
    ///
    /// Note that all the setters affecting `check_request_type` are
    /// mutually exclusive.
    pub fn set_tcp_check<
        T: std::convert::Into<std::boxed::Box<crate::model::uptime_check_config::TcpCheck>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_request_type = std::option::Option::Some(
            crate::model::uptime_check_config::CheckRequestType::TcpCheck(v.into()),
        );
        self
    }
}

impl wkt::message::Message for UptimeCheckConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UptimeCheckConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __monitored_resource,
            __resource_group,
            __synthetic_monitor,
            __http_check,
            __tcp_check,
            __period,
            __timeout,
            __content_matchers,
            __checker_type,
            __selected_regions,
            __is_internal,
            __internal_checkers,
            __user_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UptimeCheckConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "monitoredResource" => Ok(__FieldTag::__monitored_resource),
                            "monitored_resource" => Ok(__FieldTag::__monitored_resource),
                            "resourceGroup" => Ok(__FieldTag::__resource_group),
                            "resource_group" => Ok(__FieldTag::__resource_group),
                            "syntheticMonitor" => Ok(__FieldTag::__synthetic_monitor),
                            "synthetic_monitor" => Ok(__FieldTag::__synthetic_monitor),
                            "httpCheck" => Ok(__FieldTag::__http_check),
                            "http_check" => Ok(__FieldTag::__http_check),
                            "tcpCheck" => Ok(__FieldTag::__tcp_check),
                            "tcp_check" => Ok(__FieldTag::__tcp_check),
                            "period" => Ok(__FieldTag::__period),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "contentMatchers" => Ok(__FieldTag::__content_matchers),
                            "content_matchers" => Ok(__FieldTag::__content_matchers),
                            "checkerType" => Ok(__FieldTag::__checker_type),
                            "checker_type" => Ok(__FieldTag::__checker_type),
                            "selectedRegions" => Ok(__FieldTag::__selected_regions),
                            "selected_regions" => Ok(__FieldTag::__selected_regions),
                            "isInternal" => Ok(__FieldTag::__is_internal),
                            "is_internal" => Ok(__FieldTag::__is_internal),
                            "internalCheckers" => Ok(__FieldTag::__internal_checkers),
                            "internal_checkers" => Ok(__FieldTag::__internal_checkers),
                            "userLabels" => Ok(__FieldTag::__user_labels),
                            "user_labels" => Ok(__FieldTag::__user_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UptimeCheckConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UptimeCheckConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitored_resource => {
                            if !fields.insert(__FieldTag::__monitored_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitored_resource",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.monitored_resource, latest field was monitoredResource",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::uptime_check_config::Resource::MonitoredResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<api::model::MonitoredResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__resource_group => {
                            if !fields.insert(__FieldTag::__resource_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_group",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.resource_group, latest field was resourceGroup",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::uptime_check_config::Resource::ResourceGroup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::uptime_check_config::ResourceGroup,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__synthetic_monitor => {
                            if !fields.insert(__FieldTag::__synthetic_monitor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for synthetic_monitor",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.synthetic_monitor, latest field was syntheticMonitor",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::uptime_check_config::Resource::SyntheticMonitor(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SyntheticMonitorTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__http_check => {
                            if !fields.insert(__FieldTag::__http_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_check",
                                ));
                            }
                            if result.check_request_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `check_request_type`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.http_check, latest field was httpCheck",
                                ));
                            }
                            result.check_request_type = std::option::Option::Some(
                                crate::model::uptime_check_config::CheckRequestType::HttpCheck(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::uptime_check_config::HttpCheck,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__tcp_check => {
                            if !fields.insert(__FieldTag::__tcp_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tcp_check",
                                ));
                            }
                            if result.check_request_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `check_request_type`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.tcp_check, latest field was tcpCheck",
                                ));
                            }
                            result.check_request_type = std::option::Option::Some(
                                crate::model::uptime_check_config::CheckRequestType::TcpCheck(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::uptime_check_config::TcpCheck,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__period => {
                            if !fields.insert(__FieldTag::__period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for period",
                                ));
                            }
                            result.period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__content_matchers => {
                            if !fields.insert(__FieldTag::__content_matchers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_matchers",
                                ));
                            }
                            result.content_matchers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::uptime_check_config::ContentMatcher,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__checker_type => {
                            if !fields.insert(__FieldTag::__checker_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for checker_type",
                                ));
                            }
                            result.checker_type =
                                map.next_value::<std::option::Option<
                                    crate::model::uptime_check_config::CheckerType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_regions => {
                            if !fields.insert(__FieldTag::__selected_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_regions",
                                ));
                            }
                            result.selected_regions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UptimeCheckRegion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_internal => {
                            if !fields.insert(__FieldTag::__is_internal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_internal",
                                ));
                            }
                            result.is_internal = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_checkers => {
                            if !fields.insert(__FieldTag::__internal_checkers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_checkers",
                                ));
                            }
                            result.internal_checkers =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InternalChecker>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_labels => {
                            if !fields.insert(__FieldTag::__user_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_labels",
                                ));
                            }
                            result.user_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UptimeCheckConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.monitored_resource() {
            state.serialize_entry("monitoredResource", value)?;
        }
        if let Some(value) = self.resource_group() {
            state.serialize_entry("resourceGroup", value)?;
        }
        if let Some(value) = self.synthetic_monitor() {
            state.serialize_entry("syntheticMonitor", value)?;
        }
        if let Some(value) = self.http_check() {
            state.serialize_entry("httpCheck", value)?;
        }
        if let Some(value) = self.tcp_check() {
            state.serialize_entry("tcpCheck", value)?;
        }
        if self.period.is_some() {
            state.serialize_entry("period", &self.period)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self.content_matchers.is_empty() {
            state.serialize_entry("contentMatchers", &self.content_matchers)?;
        }
        if !wkt::internal::is_default(&self.checker_type) {
            state.serialize_entry("checkerType", &self.checker_type)?;
        }
        if !self.selected_regions.is_empty() {
            state.serialize_entry("selectedRegions", &self.selected_regions)?;
        }
        if !wkt::internal::is_default(&self.is_internal) {
            state.serialize_entry("isInternal", &self.is_internal)?;
        }
        if !self.internal_checkers.is_empty() {
            state.serialize_entry("internalCheckers", &self.internal_checkers)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UptimeCheckConfig].
pub mod uptime_check_config {
    #[allow(unused_imports)]
    use super::*;

    /// The resource submessage for group checks. It can be used instead of a
    /// monitored resource, when multiple resources are being monitored.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceGroup {
        /// The group of resources being monitored. Should be only the `[GROUP_ID]`,
        /// and not the full-path
        /// `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
        pub group_id: std::string::String,

        /// The resource type of the group members.
        pub resource_type: crate::model::GroupResourceType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceGroup {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [group_id][crate::model::uptime_check_config::ResourceGroup::group_id].
        pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group_id = v.into();
            self
        }

        /// Sets the value of [resource_type][crate::model::uptime_check_config::ResourceGroup::resource_type].
        pub fn set_resource_type<T: std::convert::Into<crate::model::GroupResourceType>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceGroup {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.ResourceGroup"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __group_id,
                __resource_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceGroup")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "groupId" => Ok(__FieldTag::__group_id),
                                "group_id" => Ok(__FieldTag::__group_id),
                                "resourceType" => Ok(__FieldTag::__resource_type),
                                "resource_type" => Ok(__FieldTag::__resource_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceGroup;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceGroup")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__group_id => {
                                if !fields.insert(__FieldTag::__group_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group_id",
                                    ));
                                }
                                result.group_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource_type => {
                                if !fields.insert(__FieldTag::__resource_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_type",
                                    ));
                                }
                                result.resource_type = map.next_value::<std::option::Option<crate::model::GroupResourceType>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.group_id.is_empty() {
                state.serialize_entry("groupId", &self.group_id)?;
            }
            if !wkt::internal::is_default(&self.resource_type) {
                state.serialize_entry("resourceType", &self.resource_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Information involved in sending ICMP pings alongside public HTTP/TCP
    /// checks. For HTTP, the pings are performed for each part of the redirect
    /// chain.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PingConfig {
        /// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        pub pings_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pings_count][crate::model::uptime_check_config::PingConfig::pings_count].
        pub fn set_pings_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.pings_count = v.into();
            self
        }
    }

    impl wkt::message::Message for PingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.PingConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PingConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __pings_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PingConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pingsCount" => Ok(__FieldTag::__pings_count),
                                "pings_count" => Ok(__FieldTag::__pings_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PingConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PingConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__pings_count => {
                                if !fields.insert(__FieldTag::__pings_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pings_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.pings_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PingConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.pings_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("pingsCount", &__With(&self.pings_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Information involved in an HTTP/HTTPS Uptime check request.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HttpCheck {
        /// The HTTP request method to use for the check. If set to
        /// `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
        pub request_method: crate::model::uptime_check_config::http_check::RequestMethod,

        /// If `true`, use HTTPS instead of HTTP to run the check.
        pub use_ssl: bool,

        /// Optional (defaults to "/"). The path to the page against which to run
        /// the check. Will be combined with the `host` (specified within the
        /// `monitored_resource`) and `port` to construct the full URL. If the
        /// provided path does not begin with "/", a "/" will be prepended
        /// automatically.
        pub path: std::string::String,

        /// Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
        /// `use_ssl` is `true`). The TCP port on the HTTP server against which to
        /// run the check. Will be combined with host (specified within the
        /// `monitored_resource`) and `path` to construct the full URL.
        pub port: i32,

        /// The authentication information. Optional when creating an HTTP check;
        /// defaults to empty.
        /// Do not set both `auth_method` and `auth_info`.
        pub auth_info:
            std::option::Option<crate::model::uptime_check_config::http_check::BasicAuthentication>,

        /// Boolean specifying whether to encrypt the header information.
        /// Encryption should be specified for any headers related to authentication
        /// that you do not wish to be seen when retrieving the configuration. The
        /// server will be responsible for encrypting the headers.
        /// On Get/List calls, if `mask_headers` is set to `true` then the headers
        /// will be obscured with `******.`
        pub mask_headers: bool,

        /// The list of headers to send as part of the Uptime check request.
        /// If two headers have the same key and different values, they should
        /// be entered as a single header, with the value being a comma-separated
        /// list of all the desired values as described at
        /// <https://www.w3.org/Protocols/rfc2616/rfc2616.txt> (page 31).
        /// Entering two separate headers with the same key in a Create call will
        /// cause the first to be overwritten by the second.
        /// The maximum number of headers allowed is 100.
        pub headers: std::collections::HashMap<std::string::String, std::string::String>,

        /// The content type header to use for the check. The following
        /// configurations result in errors:
        ///
        /// 1. Content type is specified in both the `headers` field and the
        ///    `content_type` field.
        /// 1. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
        /// 1. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
        /// 1. Request method is `POST` and a "Content-Type" header is provided via
        ///    `headers` field. The `content_type` field should be used instead.
        pub content_type: crate::model::uptime_check_config::http_check::ContentType,

        /// A user provided content type header to use for the check. The invalid
        /// configurations outlined in the `content_type` field apply to
        /// `custom_content_type`, as well as the following:
        ///
        /// 1. `content_type` is `URL_ENCODED` and `custom_content_type` is set.
        /// 1. `content_type` is `USER_PROVIDED` and `custom_content_type` is not
        ///    set.
        pub custom_content_type: std::string::String,

        /// Boolean specifying whether to include SSL certificate validation as a
        /// part of the Uptime check. Only applies to checks where
        /// `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
        /// setting `validate_ssl` to `true` has no effect.
        pub validate_ssl: bool,

        /// The request body associated with the HTTP POST request. If `content_type`
        /// is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
        /// provide a `Content-Length` header via the `headers` field or the API will
        /// do so. If the `request_method` is `GET` and `body` is not empty, the API
        /// will return an error. The maximum byte size is 1 megabyte.
        ///
        /// Note: If client libraries aren't used (which performs the conversion
        /// automatically) base64 encode your `body` data since the field is of
        /// `bytes` type.
        pub body: ::bytes::Bytes,

        /// If present, the check will only pass if the HTTP response status code is
        /// in this set of status codes. If empty, the HTTP status code will only
        /// pass if the HTTP status code is 200-299.
        pub accepted_response_status_codes:
            std::vec::Vec<crate::model::uptime_check_config::http_check::ResponseStatusCode>,

        /// Contains information needed to add pings to an HTTP check.
        pub ping_config: std::option::Option<crate::model::uptime_check_config::PingConfig>,

        /// This field is optional and should be set only by users interested in
        /// an authenticated uptime check.
        /// Do not set both `auth_method` and `auth_info`.
        pub auth_method:
            std::option::Option<crate::model::uptime_check_config::http_check::AuthMethod>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HttpCheck {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [request_method][crate::model::uptime_check_config::HttpCheck::request_method].
        pub fn set_request_method<
            T: std::convert::Into<crate::model::uptime_check_config::http_check::RequestMethod>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.request_method = v.into();
            self
        }

        /// Sets the value of [use_ssl][crate::model::uptime_check_config::HttpCheck::use_ssl].
        pub fn set_use_ssl<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_ssl = v.into();
            self
        }

        /// Sets the value of [path][crate::model::uptime_check_config::HttpCheck::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [port][crate::model::uptime_check_config::HttpCheck::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [auth_info][crate::model::uptime_check_config::HttpCheck::auth_info].
        pub fn set_auth_info<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::uptime_check_config::http_check::BasicAuthentication,
                >,
        {
            self.auth_info = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [auth_info][crate::model::uptime_check_config::HttpCheck::auth_info].
        pub fn set_or_clear_auth_info<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::uptime_check_config::http_check::BasicAuthentication,
                >,
        {
            self.auth_info = v.map(|x| x.into());
            self
        }

        /// Sets the value of [mask_headers][crate::model::uptime_check_config::HttpCheck::mask_headers].
        pub fn set_mask_headers<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.mask_headers = v.into();
            self
        }

        /// Sets the value of [headers][crate::model::uptime_check_config::HttpCheck::headers].
        pub fn set_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [content_type][crate::model::uptime_check_config::HttpCheck::content_type].
        pub fn set_content_type<
            T: std::convert::Into<crate::model::uptime_check_config::http_check::ContentType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.content_type = v.into();
            self
        }

        /// Sets the value of [custom_content_type][crate::model::uptime_check_config::HttpCheck::custom_content_type].
        pub fn set_custom_content_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.custom_content_type = v.into();
            self
        }

        /// Sets the value of [validate_ssl][crate::model::uptime_check_config::HttpCheck::validate_ssl].
        pub fn set_validate_ssl<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.validate_ssl = v.into();
            self
        }

        /// Sets the value of [body][crate::model::uptime_check_config::HttpCheck::body].
        pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.body = v.into();
            self
        }

        /// Sets the value of [accepted_response_status_codes][crate::model::uptime_check_config::HttpCheck::accepted_response_status_codes].
        pub fn set_accepted_response_status_codes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::uptime_check_config::http_check::ResponseStatusCode,
                >,
        {
            use std::iter::Iterator;
            self.accepted_response_status_codes = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [ping_config][crate::model::uptime_check_config::HttpCheck::ping_config].
        pub fn set_ping_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::uptime_check_config::PingConfig>,
        {
            self.ping_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ping_config][crate::model::uptime_check_config::HttpCheck::ping_config].
        pub fn set_or_clear_ping_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::uptime_check_config::PingConfig>,
        {
            self.ping_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [auth_method][crate::model::uptime_check_config::HttpCheck::auth_method].
        ///
        /// Note that all the setters affecting `auth_method` are mutually
        /// exclusive.
        pub fn set_auth_method<
            T: std::convert::Into<
                    std::option::Option<crate::model::uptime_check_config::http_check::AuthMethod>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auth_method = v.into();
            self
        }

        /// The value of [auth_method][crate::model::uptime_check_config::HttpCheck::auth_method]
        /// if it holds a `ServiceAgentAuthentication`, `None` if the field is not set or
        /// holds a different branch.
        pub fn service_agent_authentication(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::uptime_check_config::http_check::ServiceAgentAuthentication,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.auth_method.as_ref().and_then(|v| match v {
                crate::model::uptime_check_config::http_check::AuthMethod::ServiceAgentAuthentication(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [auth_method][crate::model::uptime_check_config::HttpCheck::auth_method]
        /// to hold a `ServiceAgentAuthentication`.
        ///
        /// Note that all the setters affecting `auth_method` are
        /// mutually exclusive.
        pub fn set_service_agent_authentication<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::uptime_check_config::http_check::ServiceAgentAuthentication,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auth_method = std::option::Option::Some(
                crate::model::uptime_check_config::http_check::AuthMethod::ServiceAgentAuthentication(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for HttpCheck {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HttpCheck {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __request_method,
                __use_ssl,
                __path,
                __port,
                __auth_info,
                __mask_headers,
                __headers,
                __content_type,
                __custom_content_type,
                __validate_ssl,
                __body,
                __accepted_response_status_codes,
                __ping_config,
                __service_agent_authentication,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HttpCheck")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "requestMethod" => Ok(__FieldTag::__request_method),
                                "request_method" => Ok(__FieldTag::__request_method),
                                "useSsl" => Ok(__FieldTag::__use_ssl),
                                "use_ssl" => Ok(__FieldTag::__use_ssl),
                                "path" => Ok(__FieldTag::__path),
                                "port" => Ok(__FieldTag::__port),
                                "authInfo" => Ok(__FieldTag::__auth_info),
                                "auth_info" => Ok(__FieldTag::__auth_info),
                                "maskHeaders" => Ok(__FieldTag::__mask_headers),
                                "mask_headers" => Ok(__FieldTag::__mask_headers),
                                "headers" => Ok(__FieldTag::__headers),
                                "contentType" => Ok(__FieldTag::__content_type),
                                "content_type" => Ok(__FieldTag::__content_type),
                                "customContentType" => Ok(__FieldTag::__custom_content_type),
                                "custom_content_type" => Ok(__FieldTag::__custom_content_type),
                                "validateSsl" => Ok(__FieldTag::__validate_ssl),
                                "validate_ssl" => Ok(__FieldTag::__validate_ssl),
                                "body" => Ok(__FieldTag::__body),
                                "acceptedResponseStatusCodes" => {
                                    Ok(__FieldTag::__accepted_response_status_codes)
                                }
                                "accepted_response_status_codes" => {
                                    Ok(__FieldTag::__accepted_response_status_codes)
                                }
                                "pingConfig" => Ok(__FieldTag::__ping_config),
                                "ping_config" => Ok(__FieldTag::__ping_config),
                                "serviceAgentAuthentication" => {
                                    Ok(__FieldTag::__service_agent_authentication)
                                }
                                "service_agent_authentication" => {
                                    Ok(__FieldTag::__service_agent_authentication)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HttpCheck;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HttpCheck")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__request_method => {
                                if !fields.insert(__FieldTag::__request_method) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for request_method",
                                    ));
                                }
                                result.request_method = map.next_value::<std::option::Option<crate::model::uptime_check_config::http_check::RequestMethod>>()?.unwrap_or_default();
                            }
                            __FieldTag::__use_ssl => {
                                if !fields.insert(__FieldTag::__use_ssl) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for use_ssl",
                                    ));
                                }
                                result.use_ssl = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__port => {
                                if !fields.insert(__FieldTag::__port) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for port",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__auth_info => {
                                if !fields.insert(__FieldTag::__auth_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auth_info",
                                    ));
                                }
                                result.auth_info = map.next_value::<std::option::Option<crate::model::uptime_check_config::http_check::BasicAuthentication>>()?
                                    ;
                            }
                            __FieldTag::__mask_headers => {
                                if !fields.insert(__FieldTag::__mask_headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mask_headers",
                                    ));
                                }
                                result.mask_headers = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__headers => {
                                if !fields.insert(__FieldTag::__headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for headers",
                                    ));
                                }
                                result.headers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__content_type => {
                                if !fields.insert(__FieldTag::__content_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for content_type",
                                    ));
                                }
                                result.content_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::uptime_check_config::http_check::ContentType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__custom_content_type => {
                                if !fields.insert(__FieldTag::__custom_content_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_content_type",
                                    ));
                                }
                                result.custom_content_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__validate_ssl => {
                                if !fields.insert(__FieldTag::__validate_ssl) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for validate_ssl",
                                    ));
                                }
                                result.validate_ssl = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__body => {
                                if !fields.insert(__FieldTag::__body) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for body",
                                    ));
                                }
                                struct __With(std::option::Option<::bytes::Bytes>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<serde_with::base64::Base64>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.body = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__accepted_response_status_codes => {
                                if !fields.insert(__FieldTag::__accepted_response_status_codes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for accepted_response_status_codes",
                                    ));
                                }
                                result.accepted_response_status_codes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::uptime_check_config::http_check::ResponseStatusCode>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__ping_config => {
                                if !fields.insert(__FieldTag::__ping_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ping_config",
                                    ));
                                }
                                result.ping_config = map.next_value::<std::option::Option<
                                    crate::model::uptime_check_config::PingConfig,
                                >>()?;
                            }
                            __FieldTag::__service_agent_authentication => {
                                if !fields.insert(__FieldTag::__service_agent_authentication) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_agent_authentication",
                                    ));
                                }
                                if result.auth_method.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `auth_method`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.HttpCheck.service_agent_authentication, latest field was serviceAgentAuthentication",
                                    ));
                                }
                                result.auth_method = std::option::Option::Some(
                                    crate::model::uptime_check_config::http_check::AuthMethod::ServiceAgentAuthentication(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::uptime_check_config::http_check::ServiceAgentAuthentication>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HttpCheck {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.request_method) {
                state.serialize_entry("requestMethod", &self.request_method)?;
            }
            if !wkt::internal::is_default(&self.use_ssl) {
                state.serialize_entry("useSsl", &self.use_ssl)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !wkt::internal::is_default(&self.port) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("port", &__With(&self.port))?;
            }
            if self.auth_info.is_some() {
                state.serialize_entry("authInfo", &self.auth_info)?;
            }
            if !wkt::internal::is_default(&self.mask_headers) {
                state.serialize_entry("maskHeaders", &self.mask_headers)?;
            }
            if !self.headers.is_empty() {
                state.serialize_entry("headers", &self.headers)?;
            }
            if !wkt::internal::is_default(&self.content_type) {
                state.serialize_entry("contentType", &self.content_type)?;
            }
            if !self.custom_content_type.is_empty() {
                state.serialize_entry("customContentType", &self.custom_content_type)?;
            }
            if !wkt::internal::is_default(&self.validate_ssl) {
                state.serialize_entry("validateSsl", &self.validate_ssl)?;
            }
            if !self.body.is_empty() {
                struct __With<'a>(&'a ::bytes::Bytes);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("body", &__With(&self.body))?;
            }
            if !self.accepted_response_status_codes.is_empty() {
                state.serialize_entry(
                    "acceptedResponseStatusCodes",
                    &self.accepted_response_status_codes,
                )?;
            }
            if self.ping_config.is_some() {
                state.serialize_entry("pingConfig", &self.ping_config)?;
            }
            if let Some(value) = self.service_agent_authentication() {
                state.serialize_entry("serviceAgentAuthentication", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [HttpCheck].
    pub mod http_check {
        #[allow(unused_imports)]
        use super::*;

        /// The authentication parameters to provide to the specified resource or
        /// URL that requires a username and password. Currently, only
        /// [Basic HTTP authentication](https://tools.ietf.org/html/rfc7617) is
        /// supported in Uptime checks.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BasicAuthentication {
            /// The username to use when authenticating with the HTTP server.
            pub username: std::string::String,

            /// The password to use when authenticating with the HTTP server.
            pub password: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BasicAuthentication {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::uptime_check_config::http_check::BasicAuthentication::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password][crate::model::uptime_check_config::http_check::BasicAuthentication::password].
            pub fn set_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password = v.into();
                self
            }
        }

        impl wkt::message::Message for BasicAuthentication {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BasicAuthentication {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __username,
                    __password,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BasicAuthentication")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "username" => Ok(__FieldTag::__username),
                                    "password" => Ok(__FieldTag::__password),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BasicAuthentication;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BasicAuthentication")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__username => {
                                    if !fields.insert(__FieldTag::__username) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for username",
                                            ),
                                        );
                                    }
                                    result.username = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__password => {
                                    if !fields.insert(__FieldTag::__password) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for password",
                                            ),
                                        );
                                    }
                                    result.password = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BasicAuthentication {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.username.is_empty() {
                    state.serialize_entry("username", &self.username)?;
                }
                if !self.password.is_empty() {
                    state.serialize_entry("password", &self.password)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// A status to accept. Either a status code class like "2xx", or an integer
        /// status code like "200".
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ResponseStatusCode {
            /// Either a specific value or a class of status codes.
            pub status_code: std::option::Option<
                crate::model::uptime_check_config::http_check::response_status_code::StatusCode,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ResponseStatusCode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code].
            ///
            /// Note that all the setters affecting `status_code` are mutually
            /// exclusive.
            pub fn set_status_code<T: std::convert::Into<std::option::Option<crate::model::uptime_check_config::http_check::response_status_code::StatusCode>>>(mut self, v: T) -> Self
            {
                self.status_code = v.into();
                self
            }

            /// The value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// if it holds a `StatusValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn status_value(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.status_code.as_ref().and_then(|v| match v {
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// to hold a `StatusValue`.
            ///
            /// Note that all the setters affecting `status_code` are
            /// mutually exclusive.
            pub fn set_status_value<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.status_code = std::option::Option::Some(
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusValue(
                        v.into()
                    )
                );
                self
            }

            /// The value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// if it holds a `StatusClass`, `None` if the field is not set or
            /// holds a different branch.
            pub fn status_class(
                &self,
            ) -> std::option::Option<
                &crate::model::uptime_check_config::http_check::response_status_code::StatusClass,
            > {
                #[allow(unreachable_patterns)]
                self.status_code.as_ref().and_then(|v| match v {
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusClass(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [status_code][crate::model::uptime_check_config::http_check::ResponseStatusCode::status_code]
            /// to hold a `StatusClass`.
            ///
            /// Note that all the setters affecting `status_code` are
            /// mutually exclusive.
            pub fn set_status_class<T: std::convert::Into<crate::model::uptime_check_config::http_check::response_status_code::StatusClass>>(mut self, v: T) -> Self{
                self.status_code = std::option::Option::Some(
                    crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusClass(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for ResponseStatusCode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ResponseStatusCode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __status_value,
                    __status_class,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ResponseStatusCode")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "statusValue" => Ok(__FieldTag::__status_value),
                                    "status_value" => Ok(__FieldTag::__status_value),
                                    "statusClass" => Ok(__FieldTag::__status_class),
                                    "status_class" => Ok(__FieldTag::__status_class),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ResponseStatusCode;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ResponseStatusCode")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__status_value => {
                                    if !fields.insert(__FieldTag::__status_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for status_value",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.status_code.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `status_code`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.status_value, latest field was statusValue",
                                            ),
                                        );
                                    }
                                    result.status_code = std::option::Option::Some(
                                        crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusValue(
                                            map.next_value::<__With>()?.0.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__status_class => {
                                    if !fields.insert(__FieldTag::__status_class) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for status_class",
                                            ),
                                        );
                                    }
                                    if result.status_code.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `status_code`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.status_class, latest field was statusClass",
                                            ),
                                        );
                                    }
                                    result.status_code = std::option::Option::Some(
                                        crate::model::uptime_check_config::http_check::response_status_code::StatusCode::StatusClass(
                                            map.next_value::<std::option::Option<crate::model::uptime_check_config::http_check::response_status_code::StatusClass>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ResponseStatusCode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.status_value() {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("statusValue", &__With(value))?;
                }
                if let Some(value) = self.status_class() {
                    state.serialize_entry("statusClass", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ResponseStatusCode].
        pub mod response_status_code {
            #[allow(unused_imports)]
            use super::*;

            /// An HTTP status code class.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum StatusClass {
                /// Default value that matches no status codes.
                Unspecified,
                /// The class of status codes between 100 and 199.
                StatusClass1Xx,
                /// The class of status codes between 200 and 299.
                StatusClass2Xx,
                /// The class of status codes between 300 and 399.
                StatusClass3Xx,
                /// The class of status codes between 400 and 499.
                StatusClass4Xx,
                /// The class of status codes between 500 and 599.
                StatusClass5Xx,
                /// The class of all status codes.
                Any,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [StatusClass::value] or
                /// [StatusClass::name].
                UnknownValue(status_class::UnknownValue),
            }

            #[doc(hidden)]
            pub mod status_class {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl StatusClass {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::StatusClass1Xx => std::option::Option::Some(100),
                        Self::StatusClass2Xx => std::option::Option::Some(200),
                        Self::StatusClass3Xx => std::option::Option::Some(300),
                        Self::StatusClass4Xx => std::option::Option::Some(400),
                        Self::StatusClass5Xx => std::option::Option::Some(500),
                        Self::Any => std::option::Option::Some(1000),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATUS_CLASS_UNSPECIFIED"),
                        Self::StatusClass1Xx => std::option::Option::Some("STATUS_CLASS_1XX"),
                        Self::StatusClass2Xx => std::option::Option::Some("STATUS_CLASS_2XX"),
                        Self::StatusClass3Xx => std::option::Option::Some("STATUS_CLASS_3XX"),
                        Self::StatusClass4Xx => std::option::Option::Some("STATUS_CLASS_4XX"),
                        Self::StatusClass5Xx => std::option::Option::Some("STATUS_CLASS_5XX"),
                        Self::Any => std::option::Option::Some("STATUS_CLASS_ANY"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for StatusClass {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for StatusClass {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for StatusClass {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        100 => Self::StatusClass1Xx,
                        200 => Self::StatusClass2Xx,
                        300 => Self::StatusClass3Xx,
                        400 => Self::StatusClass4Xx,
                        500 => Self::StatusClass5Xx,
                        1000 => Self::Any,
                        _ => Self::UnknownValue(status_class::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for StatusClass {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATUS_CLASS_UNSPECIFIED" => Self::Unspecified,
                        "STATUS_CLASS_1XX" => Self::StatusClass1Xx,
                        "STATUS_CLASS_2XX" => Self::StatusClass2Xx,
                        "STATUS_CLASS_3XX" => Self::StatusClass3Xx,
                        "STATUS_CLASS_4XX" => Self::StatusClass4Xx,
                        "STATUS_CLASS_5XX" => Self::StatusClass5Xx,
                        "STATUS_CLASS_ANY" => Self::Any,
                        _ => Self::UnknownValue(status_class::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for StatusClass {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::StatusClass1Xx => serializer.serialize_i32(100),
                        Self::StatusClass2Xx => serializer.serialize_i32(200),
                        Self::StatusClass3Xx => serializer.serialize_i32(300),
                        Self::StatusClass4Xx => serializer.serialize_i32(400),
                        Self::StatusClass5Xx => serializer.serialize_i32(500),
                        Self::Any => serializer.serialize_i32(1000),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for StatusClass {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<StatusClass>::new(
                        ".google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.StatusClass"))
                }
            }

            /// Either a specific value or a class of status codes.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum StatusCode {
                /// A status code to accept.
                StatusValue(i32),
                /// A class of status codes to accept.
                StatusClass(crate::model::uptime_check_config::http_check::response_status_code::StatusClass),
            }
        }

        /// Contains information needed for generating either an
        /// [OpenID Connect
        /// token](https://developers.google.com/identity/protocols/OpenIDConnect) or
        /// [OAuth token](https://developers.google.com/identity/protocols/oauth2).
        /// The token will be generated for the Monitoring service agent service
        /// account.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ServiceAgentAuthentication {

            /// Type of authentication.
            pub r#type: crate::model::uptime_check_config::http_check::service_agent_authentication::ServiceAgentAuthenticationType,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ServiceAgentAuthentication {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::uptime_check_config::http_check::ServiceAgentAuthentication::type].
            pub fn set_type<T: std::convert::Into<crate::model::uptime_check_config::http_check::service_agent_authentication::ServiceAgentAuthenticationType>>(mut self, v: T) -> Self{
                self.r#type = v.into();
                self
            }
        }

        impl wkt::message::Message for ServiceAgentAuthentication {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ServiceAgentAuthentication {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __type,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ServiceAgentAuthentication")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "type" => Ok(__FieldTag::__type),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ServiceAgentAuthentication;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ServiceAgentAuthentication")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map.next_value::<std::option::Option<crate::model::uptime_check_config::http_check::service_agent_authentication::ServiceAgentAuthenticationType>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ServiceAgentAuthentication {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.r#type) {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ServiceAgentAuthentication].
        pub mod service_agent_authentication {
            #[allow(unused_imports)]
            use super::*;

            /// Type of authentication.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ServiceAgentAuthenticationType {
                /// Default value, will result in OIDC Authentication.
                Unspecified,
                /// OIDC Authentication
                OidcToken,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ServiceAgentAuthenticationType::value] or
                /// [ServiceAgentAuthenticationType::name].
                UnknownValue(service_agent_authentication_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod service_agent_authentication_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl ServiceAgentAuthenticationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::OidcToken => std::option::Option::Some(1),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(
                            "SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED",
                        ),
                        Self::OidcToken => std::option::Option::Some("OIDC_TOKEN"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for ServiceAgentAuthenticationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for ServiceAgentAuthenticationType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for ServiceAgentAuthenticationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::OidcToken,
                        _ => Self::UnknownValue(service_agent_authentication_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for ServiceAgentAuthenticationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "OIDC_TOKEN" => Self::OidcToken,
                        _ => Self::UnknownValue(service_agent_authentication_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for ServiceAgentAuthenticationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::OidcToken => serializer.serialize_i32(1),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for ServiceAgentAuthenticationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceAgentAuthenticationType>::new(
                        ".google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication.ServiceAgentAuthenticationType"))
                }
            }
        }

        /// The HTTP request method options.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum RequestMethod {
            /// No request method specified.
            MethodUnspecified,
            /// GET request.
            Get,
            /// POST request.
            Post,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [RequestMethod::value] or
            /// [RequestMethod::name].
            UnknownValue(request_method::UnknownValue),
        }

        #[doc(hidden)]
        pub mod request_method {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl RequestMethod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::MethodUnspecified => std::option::Option::Some(0),
                    Self::Get => std::option::Option::Some(1),
                    Self::Post => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::MethodUnspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                    Self::Get => std::option::Option::Some("GET"),
                    Self::Post => std::option::Option::Some("POST"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for RequestMethod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for RequestMethod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for RequestMethod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::MethodUnspecified,
                    1 => Self::Get,
                    2 => Self::Post,
                    _ => Self::UnknownValue(request_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for RequestMethod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "METHOD_UNSPECIFIED" => Self::MethodUnspecified,
                    "GET" => Self::Get,
                    "POST" => Self::Post,
                    _ => Self::UnknownValue(request_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for RequestMethod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::MethodUnspecified => serializer.serialize_i32(0),
                    Self::Get => serializer.serialize_i32(1),
                    Self::Post => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for RequestMethod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<RequestMethod>::new(
                    ".google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod",
                ))
            }
        }

        /// Header options corresponding to the content type of a HTTP request body.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ContentType {
            /// No content type specified.
            TypeUnspecified,
            /// `body` is in URL-encoded form. Equivalent to setting the `Content-Type`
            /// to `application/x-www-form-urlencoded` in the HTTP request.
            UrlEncoded,
            /// `body` is in `custom_content_type` form. Equivalent to setting the
            /// `Content-Type` to the contents of `custom_content_type` in the HTTP
            /// request.
            UserProvided,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ContentType::value] or
            /// [ContentType::name].
            UnknownValue(content_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod content_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ContentType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::TypeUnspecified => std::option::Option::Some(0),
                    Self::UrlEncoded => std::option::Option::Some(1),
                    Self::UserProvided => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::TypeUnspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::UrlEncoded => std::option::Option::Some("URL_ENCODED"),
                    Self::UserProvided => std::option::Option::Some("USER_PROVIDED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ContentType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ContentType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ContentType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::TypeUnspecified,
                    1 => Self::UrlEncoded,
                    2 => Self::UserProvided,
                    _ => Self::UnknownValue(content_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ContentType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::TypeUnspecified,
                    "URL_ENCODED" => Self::UrlEncoded,
                    "USER_PROVIDED" => Self::UserProvided,
                    _ => Self::UnknownValue(content_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ContentType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::TypeUnspecified => serializer.serialize_i32(0),
                    Self::UrlEncoded => serializer.serialize_i32(1),
                    Self::UserProvided => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ContentType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentType>::new(
                    ".google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType",
                ))
            }
        }

        /// This field is optional and should be set only by users interested in
        /// an authenticated uptime check.
        /// Do not set both `auth_method` and `auth_info`.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AuthMethod {
            /// If specified, Uptime will generate and attach an OIDC JWT token for the
            /// Monitoring service agent service account as an `Authorization` header
            /// in the HTTP request when probing.
            ServiceAgentAuthentication(
                std::boxed::Box<
                    crate::model::uptime_check_config::http_check::ServiceAgentAuthentication,
                >,
            ),
        }
    }

    /// Information required for a TCP Uptime check request.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TcpCheck {
        /// The TCP port on the server against which to run the check. Will be
        /// combined with host (specified within the `monitored_resource`) to
        /// construct the full URL. Required.
        pub port: i32,

        /// Contains information needed to add pings to a TCP check.
        pub ping_config: std::option::Option<crate::model::uptime_check_config::PingConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TcpCheck {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [port][crate::model::uptime_check_config::TcpCheck::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [ping_config][crate::model::uptime_check_config::TcpCheck::ping_config].
        pub fn set_ping_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::uptime_check_config::PingConfig>,
        {
            self.ping_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ping_config][crate::model::uptime_check_config::TcpCheck::ping_config].
        pub fn set_or_clear_ping_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::uptime_check_config::PingConfig>,
        {
            self.ping_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TcpCheck {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.TcpCheck"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TcpCheck {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __port,
                __ping_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TcpCheck")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "port" => Ok(__FieldTag::__port),
                                "pingConfig" => Ok(__FieldTag::__ping_config),
                                "ping_config" => Ok(__FieldTag::__ping_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TcpCheck;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TcpCheck")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__port => {
                                if !fields.insert(__FieldTag::__port) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for port",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__ping_config => {
                                if !fields.insert(__FieldTag::__ping_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ping_config",
                                    ));
                                }
                                result.ping_config = map.next_value::<std::option::Option<
                                    crate::model::uptime_check_config::PingConfig,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TcpCheck {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.port) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("port", &__With(&self.port))?;
            }
            if self.ping_config.is_some() {
                state.serialize_entry("pingConfig", &self.ping_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Optional. Used to perform content matching. This allows matching based on
    /// substrings and regular expressions, together with their negations. Only the
    /// first 4&nbsp;MB of an HTTP or HTTPS check's response (and the first
    /// 1&nbsp;MB of a TCP check's response) are examined for purposes of content
    /// matching.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ContentMatcher {
        /// String, regex or JSON content to match. Maximum 1024 bytes. An empty
        /// `content` string indicates no content matching is to be performed.
        pub content: std::string::String,

        /// The type of content matcher that will be applied to the server output,
        /// compared to the `content` string when the check is run.
        pub matcher: crate::model::uptime_check_config::content_matcher::ContentMatcherOption,

        /// Certain `ContentMatcherOption` types require additional information.
        /// `MATCHES_JSON_PATH` or `NOT_MATCHES_JSON_PATH` require a
        /// `JsonPathMatcher`; not used for other options.
        pub additional_matcher_info: std::option::Option<
            crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ContentMatcher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [content][crate::model::uptime_check_config::ContentMatcher::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }

        /// Sets the value of [matcher][crate::model::uptime_check_config::ContentMatcher::matcher].
        pub fn set_matcher<
            T: std::convert::Into<
                    crate::model::uptime_check_config::content_matcher::ContentMatcherOption,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.matcher = v.into();
            self
        }

        /// Sets the value of [additional_matcher_info][crate::model::uptime_check_config::ContentMatcher::additional_matcher_info].
        ///
        /// Note that all the setters affecting `additional_matcher_info` are mutually
        /// exclusive.
        pub fn set_additional_matcher_info<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.additional_matcher_info = v.into();
            self
        }

        /// The value of [additional_matcher_info][crate::model::uptime_check_config::ContentMatcher::additional_matcher_info]
        /// if it holds a `JsonPathMatcher`, `None` if the field is not set or
        /// holds a different branch.
        pub fn json_path_matcher(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::uptime_check_config::content_matcher::JsonPathMatcher>,
        > {
            #[allow(unreachable_patterns)]
            self.additional_matcher_info.as_ref().and_then(|v| match v {
                crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo::JsonPathMatcher(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [additional_matcher_info][crate::model::uptime_check_config::ContentMatcher::additional_matcher_info]
        /// to hold a `JsonPathMatcher`.
        ///
        /// Note that all the setters affecting `additional_matcher_info` are
        /// mutually exclusive.
        pub fn set_json_path_matcher<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::uptime_check_config::content_matcher::JsonPathMatcher,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.additional_matcher_info = std::option::Option::Some(
                crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo::JsonPathMatcher(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ContentMatcher {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.ContentMatcher"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ContentMatcher {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __content,
                __matcher,
                __json_path_matcher,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ContentMatcher")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "content" => Ok(__FieldTag::__content),
                                "matcher" => Ok(__FieldTag::__matcher),
                                "jsonPathMatcher" => Ok(__FieldTag::__json_path_matcher),
                                "json_path_matcher" => Ok(__FieldTag::__json_path_matcher),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ContentMatcher;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ContentMatcher")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__content => {
                                if !fields.insert(__FieldTag::__content) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for content",
                                    ));
                                }
                                result.content = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__matcher => {
                                if !fields.insert(__FieldTag::__matcher) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for matcher",
                                    ));
                                }
                                result.matcher = map.next_value::<std::option::Option<crate::model::uptime_check_config::content_matcher::ContentMatcherOption>>()?.unwrap_or_default();
                            }
                            __FieldTag::__json_path_matcher => {
                                if !fields.insert(__FieldTag::__json_path_matcher) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for json_path_matcher",
                                    ));
                                }
                                if result.additional_matcher_info.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `additional_matcher_info`, a oneof with full ID .google.monitoring.v3.UptimeCheckConfig.ContentMatcher.json_path_matcher, latest field was jsonPathMatcher",
                                    ));
                                }
                                result.additional_matcher_info = std::option::Option::Some(
                                    crate::model::uptime_check_config::content_matcher::AdditionalMatcherInfo::JsonPathMatcher(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::uptime_check_config::content_matcher::JsonPathMatcher>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ContentMatcher {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.content.is_empty() {
                state.serialize_entry("content", &self.content)?;
            }
            if !wkt::internal::is_default(&self.matcher) {
                state.serialize_entry("matcher", &self.matcher)?;
            }
            if let Some(value) = self.json_path_matcher() {
                state.serialize_entry("jsonPathMatcher", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ContentMatcher].
    pub mod content_matcher {
        #[allow(unused_imports)]
        use super::*;

        /// Information needed to perform a JSONPath content match.
        /// Used for `ContentMatcherOption::MATCHES_JSON_PATH` and
        /// `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct JsonPathMatcher {

            /// JSONPath within the response output pointing to the expected
            /// `ContentMatcher::content` to match against.
            pub json_path: std::string::String,

            /// The type of JSONPath match that will be applied to the JSON output
            /// (`ContentMatcher.content`)
            pub json_matcher: crate::model::uptime_check_config::content_matcher::json_path_matcher::JsonPathMatcherOption,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonPathMatcher {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [json_path][crate::model::uptime_check_config::content_matcher::JsonPathMatcher::json_path].
            pub fn set_json_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.json_path = v.into();
                self
            }

            /// Sets the value of [json_matcher][crate::model::uptime_check_config::content_matcher::JsonPathMatcher::json_matcher].
            pub fn set_json_matcher<T: std::convert::Into<crate::model::uptime_check_config::content_matcher::json_path_matcher::JsonPathMatcherOption>>(mut self, v: T) -> Self{
                self.json_matcher = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonPathMatcher {
            fn typename() -> &'static str {
                "type.googleapis.com/google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for JsonPathMatcher {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __json_path,
                    __json_matcher,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for JsonPathMatcher")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "jsonPath" => Ok(__FieldTag::__json_path),
                                    "json_path" => Ok(__FieldTag::__json_path),
                                    "jsonMatcher" => Ok(__FieldTag::__json_matcher),
                                    "json_matcher" => Ok(__FieldTag::__json_matcher),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = JsonPathMatcher;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct JsonPathMatcher")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__json_path => {
                                    if !fields.insert(__FieldTag::__json_path) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for json_path",
                                            ),
                                        );
                                    }
                                    result.json_path = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__json_matcher => {
                                    if !fields.insert(__FieldTag::__json_matcher) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for json_matcher",
                                            ),
                                        );
                                    }
                                    result.json_matcher = map.next_value::<std::option::Option<crate::model::uptime_check_config::content_matcher::json_path_matcher::JsonPathMatcherOption>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for JsonPathMatcher {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.json_path.is_empty() {
                    state.serialize_entry("jsonPath", &self.json_path)?;
                }
                if !wkt::internal::is_default(&self.json_matcher) {
                    state.serialize_entry("jsonMatcher", &self.json_matcher)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [JsonPathMatcher].
        pub mod json_path_matcher {
            #[allow(unused_imports)]
            use super::*;

            /// Options to perform JSONPath content matching.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum JsonPathMatcherOption {
                /// No JSONPath matcher type specified (not valid).
                Unspecified,
                /// Selects 'exact string' matching. The match succeeds if the content at
                /// the `json_path` within the output is exactly the same as the
                /// `content` string.
                ExactMatch,
                /// Selects regular-expression matching. The match succeeds if the
                /// content at the `json_path` within the output matches the regular
                /// expression specified in the `content` string.
                RegexMatch,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [JsonPathMatcherOption::value] or
                /// [JsonPathMatcherOption::name].
                UnknownValue(json_path_matcher_option::UnknownValue),
            }

            #[doc(hidden)]
            pub mod json_path_matcher_option {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl JsonPathMatcherOption {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::ExactMatch => std::option::Option::Some(1),
                        Self::RegexMatch => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("JSON_PATH_MATCHER_OPTION_UNSPECIFIED")
                        }
                        Self::ExactMatch => std::option::Option::Some("EXACT_MATCH"),
                        Self::RegexMatch => std::option::Option::Some("REGEX_MATCH"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for JsonPathMatcherOption {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for JsonPathMatcherOption {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for JsonPathMatcherOption {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::ExactMatch,
                        2 => Self::RegexMatch,
                        _ => Self::UnknownValue(json_path_matcher_option::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for JsonPathMatcherOption {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "JSON_PATH_MATCHER_OPTION_UNSPECIFIED" => Self::Unspecified,
                        "EXACT_MATCH" => Self::ExactMatch,
                        "REGEX_MATCH" => Self::RegexMatch,
                        _ => Self::UnknownValue(json_path_matcher_option::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for JsonPathMatcherOption {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::ExactMatch => serializer.serialize_i32(1),
                        Self::RegexMatch => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for JsonPathMatcherOption {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<JsonPathMatcherOption>::new(
                        ".google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher.JsonPathMatcherOption"))
                }
            }
        }

        /// Options to perform content matching.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ContentMatcherOption {
            /// No content matcher type specified (maintained for backward
            /// compatibility, but deprecated for future use).
            /// Treated as `CONTAINS_STRING`.
            Unspecified,
            /// Selects substring matching. The match succeeds if the output contains
            /// the `content` string.  This is the default value for checks without
            /// a `matcher` option, or where the value of `matcher` is
            /// `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
            ContainsString,
            /// Selects negation of substring matching. The match succeeds if the
            /// output does _NOT_ contain the `content` string.
            NotContainsString,
            /// Selects regular-expression matching. The match succeeds if the output
            /// matches the regular expression specified in the `content` string.
            /// Regex matching is only supported for HTTP/HTTPS checks.
            MatchesRegex,
            /// Selects negation of regular-expression matching. The match succeeds if
            /// the output does _NOT_ match the regular expression specified in the
            /// `content` string. Regex matching is only supported for HTTP/HTTPS
            /// checks.
            NotMatchesRegex,
            /// Selects JSONPath matching. See `JsonPathMatcher` for details on when
            /// the match succeeds. JSONPath matching is only supported for HTTP/HTTPS
            /// checks.
            MatchesJsonPath,
            /// Selects JSONPath matching. See `JsonPathMatcher` for details on when
            /// the match succeeds. Succeeds when output does _NOT_ match as specified.
            /// JSONPath is only supported for HTTP/HTTPS checks.
            NotMatchesJsonPath,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ContentMatcherOption::value] or
            /// [ContentMatcherOption::name].
            UnknownValue(content_matcher_option::UnknownValue),
        }

        #[doc(hidden)]
        pub mod content_matcher_option {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ContentMatcherOption {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ContainsString => std::option::Option::Some(1),
                    Self::NotContainsString => std::option::Option::Some(2),
                    Self::MatchesRegex => std::option::Option::Some(3),
                    Self::NotMatchesRegex => std::option::Option::Some(4),
                    Self::MatchesJsonPath => std::option::Option::Some(5),
                    Self::NotMatchesJsonPath => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("CONTENT_MATCHER_OPTION_UNSPECIFIED")
                    }
                    Self::ContainsString => std::option::Option::Some("CONTAINS_STRING"),
                    Self::NotContainsString => std::option::Option::Some("NOT_CONTAINS_STRING"),
                    Self::MatchesRegex => std::option::Option::Some("MATCHES_REGEX"),
                    Self::NotMatchesRegex => std::option::Option::Some("NOT_MATCHES_REGEX"),
                    Self::MatchesJsonPath => std::option::Option::Some("MATCHES_JSON_PATH"),
                    Self::NotMatchesJsonPath => std::option::Option::Some("NOT_MATCHES_JSON_PATH"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ContentMatcherOption {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ContentMatcherOption {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ContentMatcherOption {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ContainsString,
                    2 => Self::NotContainsString,
                    3 => Self::MatchesRegex,
                    4 => Self::NotMatchesRegex,
                    5 => Self::MatchesJsonPath,
                    6 => Self::NotMatchesJsonPath,
                    _ => Self::UnknownValue(content_matcher_option::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ContentMatcherOption {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONTENT_MATCHER_OPTION_UNSPECIFIED" => Self::Unspecified,
                    "CONTAINS_STRING" => Self::ContainsString,
                    "NOT_CONTAINS_STRING" => Self::NotContainsString,
                    "MATCHES_REGEX" => Self::MatchesRegex,
                    "NOT_MATCHES_REGEX" => Self::NotMatchesRegex,
                    "MATCHES_JSON_PATH" => Self::MatchesJsonPath,
                    "NOT_MATCHES_JSON_PATH" => Self::NotMatchesJsonPath,
                    _ => Self::UnknownValue(content_matcher_option::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ContentMatcherOption {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ContainsString => serializer.serialize_i32(1),
                    Self::NotContainsString => serializer.serialize_i32(2),
                    Self::MatchesRegex => serializer.serialize_i32(3),
                    Self::NotMatchesRegex => serializer.serialize_i32(4),
                    Self::MatchesJsonPath => serializer.serialize_i32(5),
                    Self::NotMatchesJsonPath => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ContentMatcherOption {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentMatcherOption>::new(
                    ".google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption"))
            }
        }

        /// Certain `ContentMatcherOption` types require additional information.
        /// `MATCHES_JSON_PATH` or `NOT_MATCHES_JSON_PATH` require a
        /// `JsonPathMatcher`; not used for other options.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AdditionalMatcherInfo {
            /// Matcher information for `MATCHES_JSON_PATH` and `NOT_MATCHES_JSON_PATH`
            JsonPathMatcher(
                std::boxed::Box<
                    crate::model::uptime_check_config::content_matcher::JsonPathMatcher,
                >,
            ),
        }
    }

    /// What kind of checkers are available to be used by the check.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CheckerType {
        /// The default checker type. Currently converted to `STATIC_IP_CHECKERS`
        /// on creation, the default conversion behavior may change in the future.
        Unspecified,
        /// `STATIC_IP_CHECKERS` are used for uptime checks that perform egress
        /// across the public internet. `STATIC_IP_CHECKERS` use the static IP
        /// addresses returned by `ListUptimeCheckIps`.
        StaticIpCheckers,
        /// `VPC_CHECKERS` are used for uptime checks that perform egress using
        /// Service Directory and private network access. When using `VPC_CHECKERS`,
        /// the monitored resource type must be `servicedirectory_service`.
        VpcCheckers,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CheckerType::value] or
        /// [CheckerType::name].
        UnknownValue(checker_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod checker_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CheckerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StaticIpCheckers => std::option::Option::Some(1),
                Self::VpcCheckers => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHECKER_TYPE_UNSPECIFIED"),
                Self::StaticIpCheckers => std::option::Option::Some("STATIC_IP_CHECKERS"),
                Self::VpcCheckers => std::option::Option::Some("VPC_CHECKERS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CheckerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CheckerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CheckerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StaticIpCheckers,
                3 => Self::VpcCheckers,
                _ => Self::UnknownValue(checker_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CheckerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHECKER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STATIC_IP_CHECKERS" => Self::StaticIpCheckers,
                "VPC_CHECKERS" => Self::VpcCheckers,
                _ => Self::UnknownValue(checker_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CheckerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StaticIpCheckers => serializer.serialize_i32(1),
                Self::VpcCheckers => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CheckerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CheckerType>::new(
                ".google.monitoring.v3.UptimeCheckConfig.CheckerType",
            ))
        }
    }

    /// The resource the check is checking. Required.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Resource {
        /// The [monitored
        /// resource](https://cloud.google.com/monitoring/api/resources) associated
        /// with the configuration.
        /// The following monitored resource types are valid for this field:
        /// `uptime_url`,
        /// `gce_instance`,
        /// `gae_app`,
        /// `aws_ec2_instance`,
        /// `aws_elb_load_balancer`
        /// `k8s_service`
        /// `servicedirectory_service`
        /// `cloud_run_revision`
        MonitoredResource(std::boxed::Box<api::model::MonitoredResource>),
        /// The group resource associated with the configuration.
        ResourceGroup(std::boxed::Box<crate::model::uptime_check_config::ResourceGroup>),
        /// Specifies a Synthetic Monitor to invoke.
        SyntheticMonitor(std::boxed::Box<crate::model::SyntheticMonitorTarget>),
    }

    /// The type of Uptime check request.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CheckRequestType {
        /// Contains information needed to make an HTTP or HTTPS check.
        HttpCheck(std::boxed::Box<crate::model::uptime_check_config::HttpCheck>),
        /// Contains information needed to make a TCP check.
        TcpCheck(std::boxed::Box<crate::model::uptime_check_config::TcpCheck>),
    }
}

/// Contains the region, location, and list of IP
/// addresses where checkers in the location run from.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UptimeCheckIp {
    /// A broad region category in which the IP address is located.
    pub region: crate::model::UptimeCheckRegion,

    /// A more specific location within the region that typically encodes
    /// a particular city/town/metro (and its containing state/province or country)
    /// within the broader umbrella region category.
    pub location: std::string::String,

    /// The IP address from which the Uptime check originates. This is a fully
    /// specified IP address (not an IP address range). Most IP addresses, as of
    /// this publication, are in IPv4 format; however, one should not rely on the
    /// IP addresses being in IPv4 format indefinitely, and should support
    /// interpreting this field in either IPv4 or IPv6 format.
    pub ip_address: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UptimeCheckIp {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [region][crate::model::UptimeCheckIp::region].
    pub fn set_region<T: std::convert::Into<crate::model::UptimeCheckRegion>>(
        mut self,
        v: T,
    ) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [location][crate::model::UptimeCheckIp::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::UptimeCheckIp::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for UptimeCheckIp {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UptimeCheckIp"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UptimeCheckIp {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __region,
            __location,
            __ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UptimeCheckIp")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "region" => Ok(__FieldTag::__region),
                            "location" => Ok(__FieldTag::__location),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UptimeCheckIp;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UptimeCheckIp")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<crate::model::UptimeCheckRegion>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UptimeCheckIp {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.region) {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `ListUptimeCheckConfigs` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUptimeCheckConfigsRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
    /// Uptime check configurations are listed. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub parent: std::string::String,

    /// If provided, this field specifies the criteria that must be met by
    /// uptime checks to be included in the response.
    ///
    /// For more details, see [Filtering
    /// syntax](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering#filter_syntax).
    pub filter: std::string::String,

    /// The maximum number of results to return in a single response. The server
    /// may further constrain the maximum number of results returned in a single
    /// page. If the page_size is <=0, the server will decide the number of results
    /// to be returned.
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return more results from the previous method call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUptimeCheckConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUptimeCheckConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUptimeCheckConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUptimeCheckConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUptimeCheckConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUptimeCheckConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUptimeCheckConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUptimeCheckConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUptimeCheckConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUptimeCheckConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `ListUptimeCheckConfigs` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUptimeCheckConfigsResponse {
    /// The returned Uptime check configurations.
    pub uptime_check_configs: std::vec::Vec<crate::model::UptimeCheckConfig>,

    /// This field represents the pagination token to retrieve the next page of
    /// results. If the value is empty, it means no further results for the
    /// request. To retrieve the next page of results, the value of the
    /// next_page_token is passed to the subsequent List method call (in the
    /// request message's page_token field).
    pub next_page_token: std::string::String,

    /// The total number of Uptime check configurations for the project,
    /// irrespective of any pagination.
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUptimeCheckConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uptime_check_configs][crate::model::ListUptimeCheckConfigsResponse::uptime_check_configs].
    pub fn set_uptime_check_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UptimeCheckConfig>,
    {
        use std::iter::Iterator;
        self.uptime_check_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUptimeCheckConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListUptimeCheckConfigsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUptimeCheckConfigsResponse {
    type PageItem = crate::model::UptimeCheckConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.uptime_check_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUptimeCheckConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uptime_check_configs,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUptimeCheckConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uptimeCheckConfigs" => Ok(__FieldTag::__uptime_check_configs),
                            "uptime_check_configs" => Ok(__FieldTag::__uptime_check_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUptimeCheckConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUptimeCheckConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uptime_check_configs => {
                            if !fields.insert(__FieldTag::__uptime_check_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uptime_check_configs",
                                ));
                            }
                            result.uptime_check_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UptimeCheckConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUptimeCheckConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uptime_check_configs.is_empty() {
            state.serialize_entry("uptimeCheckConfigs", &self.uptime_check_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `GetUptimeCheckConfig` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUptimeCheckConfigRequest {
    /// Required. The Uptime check configuration to retrieve. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUptimeCheckConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUptimeCheckConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.GetUptimeCheckConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUptimeCheckConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUptimeCheckConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUptimeCheckConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUptimeCheckConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUptimeCheckConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `CreateUptimeCheckConfig` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUptimeCheckConfigRequest {
    /// Required. The
    /// [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
    /// to create the Uptime check. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    pub parent: std::string::String,

    /// Required. The new Uptime check configuration.
    pub uptime_check_config: std::option::Option<crate::model::UptimeCheckConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUptimeCheckConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUptimeCheckConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [uptime_check_config][crate::model::CreateUptimeCheckConfigRequest::uptime_check_config].
    pub fn set_uptime_check_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UptimeCheckConfig>,
    {
        self.uptime_check_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [uptime_check_config][crate::model::CreateUptimeCheckConfigRequest::uptime_check_config].
    pub fn set_or_clear_uptime_check_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UptimeCheckConfig>,
    {
        self.uptime_check_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.CreateUptimeCheckConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUptimeCheckConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __uptime_check_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUptimeCheckConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "uptimeCheckConfig" => Ok(__FieldTag::__uptime_check_config),
                            "uptime_check_config" => Ok(__FieldTag::__uptime_check_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUptimeCheckConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUptimeCheckConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uptime_check_config => {
                            if !fields.insert(__FieldTag::__uptime_check_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uptime_check_config",
                                ));
                            }
                            result.uptime_check_config = map
                                .next_value::<std::option::Option<crate::model::UptimeCheckConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUptimeCheckConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.uptime_check_config.is_some() {
            state.serialize_entry("uptimeCheckConfig", &self.uptime_check_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `UpdateUptimeCheckConfig` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateUptimeCheckConfigRequest {
    /// Optional. If present, only the listed fields in the current Uptime check
    /// configuration are updated with values from the new configuration. If this
    /// field is empty, then the current configuration is completely replaced with
    /// the new configuration.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. If an `updateMask` has been specified, this field gives
    /// the values for the set of fields mentioned in the `updateMask`. If an
    /// `updateMask` has not been given, this Uptime check configuration replaces
    /// the current configuration. If a field is mentioned in `updateMask` but
    /// the corresponding field is omitted in this partial Uptime check
    /// configuration, it has the effect of deleting/clearing the field from the
    /// configuration on the server.
    ///
    /// The following fields can be updated: `display_name`,
    /// `http_check`, `tcp_check`, `timeout`, `content_matchers`, and
    /// `selected_regions`.
    pub uptime_check_config: std::option::Option<crate::model::UptimeCheckConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateUptimeCheckConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateUptimeCheckConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateUptimeCheckConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uptime_check_config][crate::model::UpdateUptimeCheckConfigRequest::uptime_check_config].
    pub fn set_uptime_check_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UptimeCheckConfig>,
    {
        self.uptime_check_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [uptime_check_config][crate::model::UpdateUptimeCheckConfigRequest::uptime_check_config].
    pub fn set_or_clear_uptime_check_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UptimeCheckConfig>,
    {
        self.uptime_check_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.UpdateUptimeCheckConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateUptimeCheckConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __uptime_check_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateUptimeCheckConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "uptimeCheckConfig" => Ok(__FieldTag::__uptime_check_config),
                            "uptime_check_config" => Ok(__FieldTag::__uptime_check_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateUptimeCheckConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateUptimeCheckConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__uptime_check_config => {
                            if !fields.insert(__FieldTag::__uptime_check_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uptime_check_config",
                                ));
                            }
                            result.uptime_check_config = map
                                .next_value::<std::option::Option<crate::model::UptimeCheckConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateUptimeCheckConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.uptime_check_config.is_some() {
            state.serialize_entry("uptimeCheckConfig", &self.uptime_check_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `DeleteUptimeCheckConfig` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUptimeCheckConfigRequest {
    /// Required. The Uptime check configuration to delete. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
    /// ```
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUptimeCheckConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUptimeCheckConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUptimeCheckConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.DeleteUptimeCheckConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUptimeCheckConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUptimeCheckConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUptimeCheckConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUptimeCheckConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUptimeCheckConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `ListUptimeCheckIps` request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUptimeCheckIpsRequest {
    /// The maximum number of results to return in a single response. The server
    /// may further constrain the maximum number of results returned in a single
    /// page. If the page_size is <=0, the server will decide the number of results
    /// to be returned.
    /// NOTE: this field is not yet implemented
    pub page_size: i32,

    /// If this field is not empty then it must contain the `nextPageToken` value
    /// returned by a previous call to this method.  Using this field causes the
    /// method to return more results from the previous method call.
    /// NOTE: this field is not yet implemented
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUptimeCheckIpsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListUptimeCheckIpsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUptimeCheckIpsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckIpsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckIpsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUptimeCheckIpsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUptimeCheckIpsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUptimeCheckIpsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUptimeCheckIpsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUptimeCheckIpsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The protocol for the `ListUptimeCheckIps` response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUptimeCheckIpsResponse {
    /// The returned list of IP addresses (including region and location) that the
    /// checkers run from.
    pub uptime_check_ips: std::vec::Vec<crate::model::UptimeCheckIp>,

    /// This field represents the pagination token to retrieve the next page of
    /// results. If the value is empty, it means no further results for the
    /// request. To retrieve the next page of results, the value of the
    /// next_page_token is passed to the subsequent List method call (in the
    /// request message's page_token field).
    /// NOTE: this field is not yet implemented
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUptimeCheckIpsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uptime_check_ips][crate::model::ListUptimeCheckIpsResponse::uptime_check_ips].
    pub fn set_uptime_check_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UptimeCheckIp>,
    {
        use std::iter::Iterator;
        self.uptime_check_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUptimeCheckIpsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUptimeCheckIpsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.v3.ListUptimeCheckIpsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUptimeCheckIpsResponse {
    type PageItem = crate::model::UptimeCheckIp;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.uptime_check_ips
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUptimeCheckIpsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uptime_check_ips,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUptimeCheckIpsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uptimeCheckIps" => Ok(__FieldTag::__uptime_check_ips),
                            "uptime_check_ips" => Ok(__FieldTag::__uptime_check_ips),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUptimeCheckIpsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUptimeCheckIpsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uptime_check_ips => {
                            if !fields.insert(__FieldTag::__uptime_check_ips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uptime_check_ips",
                                ));
                            }
                            result.uptime_check_ips = map.next_value::<std::option::Option<std::vec::Vec<crate::model::UptimeCheckIp>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUptimeCheckIpsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uptime_check_ips.is_empty() {
            state.serialize_entry("uptimeCheckIps", &self.uptime_check_ips)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies an ordering relationship on two arguments, called `left` and
/// `right`.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComparisonType {
    /// No ordering relationship is specified.
    ComparisonUnspecified,
    /// True if the left argument is greater than the right argument.
    ComparisonGt,
    /// True if the left argument is greater than or equal to the right argument.
    ComparisonGe,
    /// True if the left argument is less than the right argument.
    ComparisonLt,
    /// True if the left argument is less than or equal to the right argument.
    ComparisonLe,
    /// True if the left argument is equal to the right argument.
    ComparisonEq,
    /// True if the left argument is not equal to the right argument.
    ComparisonNe,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComparisonType::value] or
    /// [ComparisonType::name].
    UnknownValue(comparison_type::UnknownValue),
}

#[doc(hidden)]
pub mod comparison_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComparisonType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::ComparisonUnspecified => std::option::Option::Some(0),
            Self::ComparisonGt => std::option::Option::Some(1),
            Self::ComparisonGe => std::option::Option::Some(2),
            Self::ComparisonLt => std::option::Option::Some(3),
            Self::ComparisonLe => std::option::Option::Some(4),
            Self::ComparisonEq => std::option::Option::Some(5),
            Self::ComparisonNe => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::ComparisonUnspecified => std::option::Option::Some("COMPARISON_UNSPECIFIED"),
            Self::ComparisonGt => std::option::Option::Some("COMPARISON_GT"),
            Self::ComparisonGe => std::option::Option::Some("COMPARISON_GE"),
            Self::ComparisonLt => std::option::Option::Some("COMPARISON_LT"),
            Self::ComparisonLe => std::option::Option::Some("COMPARISON_LE"),
            Self::ComparisonEq => std::option::Option::Some("COMPARISON_EQ"),
            Self::ComparisonNe => std::option::Option::Some("COMPARISON_NE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComparisonType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComparisonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComparisonType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::ComparisonUnspecified,
            1 => Self::ComparisonGt,
            2 => Self::ComparisonGe,
            3 => Self::ComparisonLt,
            4 => Self::ComparisonLe,
            5 => Self::ComparisonEq,
            6 => Self::ComparisonNe,
            _ => Self::UnknownValue(comparison_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComparisonType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPARISON_UNSPECIFIED" => Self::ComparisonUnspecified,
            "COMPARISON_GT" => Self::ComparisonGt,
            "COMPARISON_GE" => Self::ComparisonGe,
            "COMPARISON_LT" => Self::ComparisonLt,
            "COMPARISON_LE" => Self::ComparisonLe,
            "COMPARISON_EQ" => Self::ComparisonEq,
            "COMPARISON_NE" => Self::ComparisonNe,
            _ => Self::UnknownValue(comparison_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComparisonType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ComparisonUnspecified => serializer.serialize_i32(0),
            Self::ComparisonGt => serializer.serialize_i32(1),
            Self::ComparisonGe => serializer.serialize_i32(2),
            Self::ComparisonLt => serializer.serialize_i32(3),
            Self::ComparisonLe => serializer.serialize_i32(4),
            Self::ComparisonEq => serializer.serialize_i32(5),
            Self::ComparisonNe => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComparisonType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComparisonType>::new(
            ".google.monitoring.v3.ComparisonType",
        ))
    }
}

/// The tier of service for a Metrics Scope. Please see the
/// [service tiers
/// documentation](https://cloud.google.com/monitoring/workspaces/tiers) for more
/// details.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub enum ServiceTier {
    /// An invalid sentinel value, used to indicate that a tier has not
    /// been provided explicitly.
    Unspecified,
    /// The Cloud Monitoring Basic tier, a free tier of service that provides basic
    /// features, a moderate allotment of logs, and access to built-in metrics.
    /// A number of features are not available in this tier. For more details,
    /// see [the service tiers
    /// documentation](https://cloud.google.com/monitoring/workspaces/tiers).
    Basic,
    /// The Cloud Monitoring Premium tier, a higher, more expensive tier of service
    /// that provides access to all Cloud Monitoring features, lets you use Cloud
    /// Monitoring with AWS accounts, and has a larger allotments for logs and
    /// metrics. For more details, see [the service tiers
    /// documentation](https://cloud.google.com/monitoring/workspaces/tiers).
    Premium,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ServiceTier::value] or
    /// [ServiceTier::name].
    UnknownValue(service_tier::UnknownValue),
}

#[doc(hidden)]
pub mod service_tier {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ServiceTier {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Premium => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SERVICE_TIER_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("SERVICE_TIER_BASIC"),
            Self::Premium => std::option::Option::Some("SERVICE_TIER_PREMIUM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ServiceTier {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ServiceTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ServiceTier {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Premium,
            _ => Self::UnknownValue(service_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ServiceTier {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SERVICE_TIER_UNSPECIFIED" => Self::Unspecified,
            "SERVICE_TIER_BASIC" => Self::Basic,
            "SERVICE_TIER_PREMIUM" => Self::Premium,
            _ => Self::UnknownValue(service_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ServiceTier {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Premium => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ServiceTier {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceTier>::new(
            ".google.monitoring.v3.ServiceTier",
        ))
    }
}

/// The regions from which an Uptime check can be run.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UptimeCheckRegion {
    /// Default value if no region is specified. Will result in Uptime checks
    /// running from all regions.
    RegionUnspecified,
    /// Allows checks to run from locations within the United States of America.
    Usa,
    /// Allows checks to run from locations within the continent of Europe.
    Europe,
    /// Allows checks to run from locations within the continent of South
    /// America.
    SouthAmerica,
    /// Allows checks to run from locations within the Asia Pacific area (ex:
    /// Singapore).
    AsiaPacific,
    /// Allows checks to run from locations within the western United States of
    /// America
    UsaOregon,
    /// Allows checks to run from locations within the central United States of
    /// America
    UsaIowa,
    /// Allows checks to run from locations within the eastern United States of
    /// America
    UsaVirginia,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UptimeCheckRegion::value] or
    /// [UptimeCheckRegion::name].
    UnknownValue(uptime_check_region::UnknownValue),
}

#[doc(hidden)]
pub mod uptime_check_region {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UptimeCheckRegion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::RegionUnspecified => std::option::Option::Some(0),
            Self::Usa => std::option::Option::Some(1),
            Self::Europe => std::option::Option::Some(2),
            Self::SouthAmerica => std::option::Option::Some(3),
            Self::AsiaPacific => std::option::Option::Some(4),
            Self::UsaOregon => std::option::Option::Some(5),
            Self::UsaIowa => std::option::Option::Some(6),
            Self::UsaVirginia => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::RegionUnspecified => std::option::Option::Some("REGION_UNSPECIFIED"),
            Self::Usa => std::option::Option::Some("USA"),
            Self::Europe => std::option::Option::Some("EUROPE"),
            Self::SouthAmerica => std::option::Option::Some("SOUTH_AMERICA"),
            Self::AsiaPacific => std::option::Option::Some("ASIA_PACIFIC"),
            Self::UsaOregon => std::option::Option::Some("USA_OREGON"),
            Self::UsaIowa => std::option::Option::Some("USA_IOWA"),
            Self::UsaVirginia => std::option::Option::Some("USA_VIRGINIA"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UptimeCheckRegion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UptimeCheckRegion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UptimeCheckRegion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::RegionUnspecified,
            1 => Self::Usa,
            2 => Self::Europe,
            3 => Self::SouthAmerica,
            4 => Self::AsiaPacific,
            5 => Self::UsaOregon,
            6 => Self::UsaIowa,
            7 => Self::UsaVirginia,
            _ => Self::UnknownValue(uptime_check_region::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UptimeCheckRegion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "REGION_UNSPECIFIED" => Self::RegionUnspecified,
            "USA" => Self::Usa,
            "EUROPE" => Self::Europe,
            "SOUTH_AMERICA" => Self::SouthAmerica,
            "ASIA_PACIFIC" => Self::AsiaPacific,
            "USA_OREGON" => Self::UsaOregon,
            "USA_IOWA" => Self::UsaIowa,
            "USA_VIRGINIA" => Self::UsaVirginia,
            _ => Self::UnknownValue(uptime_check_region::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UptimeCheckRegion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::RegionUnspecified => serializer.serialize_i32(0),
            Self::Usa => serializer.serialize_i32(1),
            Self::Europe => serializer.serialize_i32(2),
            Self::SouthAmerica => serializer.serialize_i32(3),
            Self::AsiaPacific => serializer.serialize_i32(4),
            Self::UsaOregon => serializer.serialize_i32(5),
            Self::UsaIowa => serializer.serialize_i32(6),
            Self::UsaVirginia => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UptimeCheckRegion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UptimeCheckRegion>::new(
            ".google.monitoring.v3.UptimeCheckRegion",
        ))
    }
}

/// The supported resource types that can be used as values of
/// `group_resource.resource_type`.
/// `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
/// The resource types `gae_app` and `uptime_url` are not valid here because
/// group checks on App Engine modules and URLs are not allowed.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum GroupResourceType {
    /// Default value (not valid).
    ResourceTypeUnspecified,
    /// A group of instances from Google Cloud Platform (GCP) or
    /// Amazon Web Services (AWS).
    Instance,
    /// A group of Amazon ELB load balancers.
    AwsElbLoadBalancer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [GroupResourceType::value] or
    /// [GroupResourceType::name].
    UnknownValue(group_resource_type::UnknownValue),
}

#[doc(hidden)]
pub mod group_resource_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl GroupResourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::ResourceTypeUnspecified => std::option::Option::Some(0),
            Self::Instance => std::option::Option::Some(1),
            Self::AwsElbLoadBalancer => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::ResourceTypeUnspecified => std::option::Option::Some("RESOURCE_TYPE_UNSPECIFIED"),
            Self::Instance => std::option::Option::Some("INSTANCE"),
            Self::AwsElbLoadBalancer => std::option::Option::Some("AWS_ELB_LOAD_BALANCER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for GroupResourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for GroupResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for GroupResourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::ResourceTypeUnspecified,
            1 => Self::Instance,
            2 => Self::AwsElbLoadBalancer,
            _ => Self::UnknownValue(group_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for GroupResourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESOURCE_TYPE_UNSPECIFIED" => Self::ResourceTypeUnspecified,
            "INSTANCE" => Self::Instance,
            "AWS_ELB_LOAD_BALANCER" => Self::AwsElbLoadBalancer,
            _ => Self::UnknownValue(group_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for GroupResourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ResourceTypeUnspecified => serializer.serialize_i32(0),
            Self::Instance => serializer.serialize_i32(1),
            Self::AwsElbLoadBalancer => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for GroupResourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<GroupResourceType>::new(
            ".google.monitoring.v3.GroupResourceType",
        ))
    }
}
