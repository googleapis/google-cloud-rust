// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AlertChart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AlertChart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AlertChart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AlertChart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CollapsibleGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collapsed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CollapsibleGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collapsed" => Ok(__FieldTag::__collapsed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CollapsibleGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CollapsibleGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collapsed => {
                            if !fields.insert(__FieldTag::__collapsed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collapsed",
                                ));
                            }
                            result.collapsed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Aggregation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alignment_period,
            __per_series_aligner,
            __cross_series_reducer,
            __group_by_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Aggregation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alignmentPeriod" => Ok(__FieldTag::__alignment_period),
                            "alignment_period" => Ok(__FieldTag::__alignment_period),
                            "perSeriesAligner" => Ok(__FieldTag::__per_series_aligner),
                            "per_series_aligner" => Ok(__FieldTag::__per_series_aligner),
                            "crossSeriesReducer" => Ok(__FieldTag::__cross_series_reducer),
                            "cross_series_reducer" => Ok(__FieldTag::__cross_series_reducer),
                            "groupByFields" => Ok(__FieldTag::__group_by_fields),
                            "group_by_fields" => Ok(__FieldTag::__group_by_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Aggregation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Aggregation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alignment_period => {
                            if !fields.insert(__FieldTag::__alignment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alignment_period",
                                ));
                            }
                            result.alignment_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__per_series_aligner => {
                            if !fields.insert(__FieldTag::__per_series_aligner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for per_series_aligner",
                                ));
                            }
                            result.per_series_aligner = map.next_value::<std::option::Option<crate::model::aggregation::Aligner>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cross_series_reducer => {
                            if !fields.insert(__FieldTag::__cross_series_reducer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_series_reducer",
                                ));
                            }
                            result.cross_series_reducer = map.next_value::<std::option::Option<crate::model::aggregation::Reducer>>()?.unwrap_or_default();
                        }
                        __FieldTag::__group_by_fields => {
                            if !fields.insert(__FieldTag::__group_by_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_by_fields",
                                ));
                            }
                            result.group_by_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PickTimeSeriesFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ranking_method,
            __num_time_series,
            __direction,
            __interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PickTimeSeriesFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rankingMethod" => Ok(__FieldTag::__ranking_method),
                            "ranking_method" => Ok(__FieldTag::__ranking_method),
                            "numTimeSeries" => Ok(__FieldTag::__num_time_series),
                            "num_time_series" => Ok(__FieldTag::__num_time_series),
                            "direction" => Ok(__FieldTag::__direction),
                            "interval" => Ok(__FieldTag::__interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PickTimeSeriesFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PickTimeSeriesFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ranking_method => {
                            if !fields.insert(__FieldTag::__ranking_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ranking_method",
                                ));
                            }
                            result.ranking_method =
                                map.next_value::<std::option::Option<
                                    crate::model::pick_time_series_filter::Method,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_time_series => {
                            if !fields.insert(__FieldTag::__num_time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_time_series",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_time_series =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map
                                .next_value::<std::option::Option<
                                    crate::model::pick_time_series_filter::Direction,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval =
                                map.next_value::<std::option::Option<gtype::model::Interval>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StatisticalTimeSeriesFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ranking_method,
            __num_time_series,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatisticalTimeSeriesFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rankingMethod" => Ok(__FieldTag::__ranking_method),
                            "ranking_method" => Ok(__FieldTag::__ranking_method),
                            "numTimeSeries" => Ok(__FieldTag::__num_time_series),
                            "num_time_series" => Ok(__FieldTag::__num_time_series),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StatisticalTimeSeriesFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatisticalTimeSeriesFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ranking_method => {
                            if !fields.insert(__FieldTag::__ranking_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ranking_method",
                                ));
                            }
                            result.ranking_method = map
                                .next_value::<std::option::Option<
                                    crate::model::statistical_time_series_filter::Method,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_time_series => {
                            if !fields.insert(__FieldTag::__num_time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_time_series",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_time_series =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Dashboard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __etag,
            __grid_layout,
            __mosaic_layout,
            __row_layout,
            __column_layout,
            __dashboard_filters,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dashboard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "etag" => Ok(__FieldTag::__etag),
                            "gridLayout" => Ok(__FieldTag::__grid_layout),
                            "grid_layout" => Ok(__FieldTag::__grid_layout),
                            "mosaicLayout" => Ok(__FieldTag::__mosaic_layout),
                            "mosaic_layout" => Ok(__FieldTag::__mosaic_layout),
                            "rowLayout" => Ok(__FieldTag::__row_layout),
                            "row_layout" => Ok(__FieldTag::__row_layout),
                            "columnLayout" => Ok(__FieldTag::__column_layout),
                            "column_layout" => Ok(__FieldTag::__column_layout),
                            "dashboardFilters" => Ok(__FieldTag::__dashboard_filters),
                            "dashboard_filters" => Ok(__FieldTag::__dashboard_filters),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Dashboard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dashboard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grid_layout => {
                            if !fields.insert(__FieldTag::__grid_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grid_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.grid_layout, latest field was gridLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::GridLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GridLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mosaic_layout => {
                            if !fields.insert(__FieldTag::__mosaic_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mosaic_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.mosaic_layout, latest field was mosaicLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::MosaicLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MosaicLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__row_layout => {
                            if !fields.insert(__FieldTag::__row_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.row_layout, latest field was rowLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::RowLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RowLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__column_layout => {
                            if !fields.insert(__FieldTag::__column_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_layout",
                                ));
                            }
                            if result.layout.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `layout`, a oneof with full ID .google.monitoring.dashboard.v1.Dashboard.column_layout, latest field was columnLayout",
                                ));
                            }
                            result.layout = std::option::Option::Some(
                                crate::model::dashboard::Layout::ColumnLayout(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ColumnLayout>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dashboard_filters => {
                            if !fields.insert(__FieldTag::__dashboard_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboard_filters",
                                ));
                            }
                            result.dashboard_filters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DashboardFilter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DashboardFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label_key,
            __template_variable,
            __string_value,
            __filter_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DashboardFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labelKey" => Ok(__FieldTag::__label_key),
                            "label_key" => Ok(__FieldTag::__label_key),
                            "templateVariable" => Ok(__FieldTag::__template_variable),
                            "template_variable" => Ok(__FieldTag::__template_variable),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "filterType" => Ok(__FieldTag::__filter_type),
                            "filter_type" => Ok(__FieldTag::__filter_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DashboardFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DashboardFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label_key => {
                            if !fields.insert(__FieldTag::__label_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_key",
                                ));
                            }
                            result.label_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template_variable => {
                            if !fields.insert(__FieldTag::__template_variable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_variable",
                                ));
                            }
                            result.template_variable = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.default_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `default_value`, a oneof with full ID .google.monitoring.dashboard.v1.DashboardFilter.string_value, latest field was stringValue",
                                ));
                            }
                            result.default_value = std::option::Option::Some(
                                crate::model::dashboard_filter::DefaultValue::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__filter_type => {
                            if !fields.insert(__FieldTag::__filter_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_type",
                                ));
                            }
                            result.filter_type = map.next_value::<std::option::Option<crate::model::dashboard_filter::FilterType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dashboard,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dashboard" => Ok(__FieldTag::__dashboard),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dashboard => {
                            if !fields.insert(__FieldTag::__dashboard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboard",
                                ));
                            }
                            result.dashboard =
                                map.next_value::<std::option::Option<crate::model::Dashboard>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDashboardsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDashboardsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDashboardsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDashboardsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDashboardsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dashboards,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDashboardsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dashboards" => Ok(__FieldTag::__dashboards),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDashboardsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDashboardsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dashboards => {
                            if !fields.insert(__FieldTag::__dashboards) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboards",
                                ));
                            }
                            result.dashboards = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dashboard>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateDashboardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dashboard,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDashboardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dashboard" => Ok(__FieldTag::__dashboard),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateDashboardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDashboardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dashboard => {
                            if !fields.insert(__FieldTag::__dashboard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dashboard",
                                ));
                            }
                            result.dashboard =
                                map.next_value::<std::option::Option<crate::model::Dashboard>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ErrorReportingPanel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_names,
            __services,
            __versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorReportingPanel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectNames" => Ok(__FieldTag::__project_names),
                            "project_names" => Ok(__FieldTag::__project_names),
                            "services" => Ok(__FieldTag::__services),
                            "versions" => Ok(__FieldTag::__versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ErrorReportingPanel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorReportingPanel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_names => {
                            if !fields.insert(__FieldTag::__project_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_names",
                                ));
                            }
                            result.project_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IncidentList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __monitored_resources,
            __policy_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IncidentList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "monitoredResources" => Ok(__FieldTag::__monitored_resources),
                            "monitored_resources" => Ok(__FieldTag::__monitored_resources),
                            "policyNames" => Ok(__FieldTag::__policy_names),
                            "policy_names" => Ok(__FieldTag::__policy_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IncidentList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IncidentList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__monitored_resources => {
                            if !fields.insert(__FieldTag::__monitored_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitored_resources",
                                ));
                            }
                            result.monitored_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<api::model::MonitoredResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_names => {
                            if !fields.insert(__FieldTag::__policy_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_names",
                                ));
                            }
                            result.policy_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GridLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            __widgets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GridLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            "widgets" => Ok(__FieldTag::__widgets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GridLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GridLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.columns = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__widgets => {
                            if !fields.insert(__FieldTag::__widgets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for widgets",
                                ));
                            }
                            result.widgets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Widget>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MosaicLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            __tiles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MosaicLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            "tiles" => Ok(__FieldTag::__tiles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MosaicLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MosaicLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.columns = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tiles => {
                            if !fields.insert(__FieldTag::__tiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tiles",
                                ));
                            }
                            result.tiles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::mosaic_layout::Tile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::mosaic_layout::Tile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x_pos,
            __y_pos,
            __width,
            __height,
            __widget,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "xPos" => Ok(__FieldTag::__x_pos),
                            "x_pos" => Ok(__FieldTag::__x_pos),
                            "yPos" => Ok(__FieldTag::__y_pos),
                            "y_pos" => Ok(__FieldTag::__y_pos),
                            "width" => Ok(__FieldTag::__width),
                            "height" => Ok(__FieldTag::__height),
                            "widget" => Ok(__FieldTag::__widget),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::mosaic_layout::Tile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x_pos => {
                            if !fields.insert(__FieldTag::__x_pos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x_pos",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x_pos = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y_pos => {
                            if !fields.insert(__FieldTag::__y_pos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y_pos",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y_pos = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__width => {
                            if !fields.insert(__FieldTag::__width) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for width",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.width = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__height => {
                            if !fields.insert(__FieldTag::__height) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for height",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.height = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__widget => {
                            if !fields.insert(__FieldTag::__widget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for widget",
                                ));
                            }
                            result.widget =
                                map.next_value::<std::option::Option<crate::model::Widget>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RowLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RowLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rows" => Ok(__FieldTag::__rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RowLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RowLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::row_layout::Row>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::row_layout::Row {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __weight,
            __widgets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Row")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weight" => Ok(__FieldTag::__weight),
                            "widgets" => Ok(__FieldTag::__widgets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::row_layout::Row;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Row")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__weight => {
                            if !fields.insert(__FieldTag::__weight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weight",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.weight = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__widgets => {
                            if !fields.insert(__FieldTag::__widgets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for widgets",
                                ));
                            }
                            result.widgets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Widget>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ColumnLayout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnLayout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ColumnLayout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnLayout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::column_layout::Column>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::column_layout::Column {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __weight,
            __widgets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Column")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weight" => Ok(__FieldTag::__weight),
                            "widgets" => Ok(__FieldTag::__widgets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::column_layout::Column;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Column")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__weight => {
                            if !fields.insert(__FieldTag::__weight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weight",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.weight = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__widgets => {
                            if !fields.insert(__FieldTag::__widgets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for widgets",
                                ));
                            }
                            result.widgets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Widget>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LogsPanel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __resource_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogsPanel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LogsPanel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogsPanel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TimeSeriesQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_filter,
            __time_series_filter_ratio,
            __time_series_query_language,
            __prometheus_query,
            __unit_override,
            __output_full_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesFilter" => Ok(__FieldTag::__time_series_filter),
                            "time_series_filter" => Ok(__FieldTag::__time_series_filter),
                            "timeSeriesFilterRatio" => Ok(__FieldTag::__time_series_filter_ratio),
                            "time_series_filter_ratio" => {
                                Ok(__FieldTag::__time_series_filter_ratio)
                            }
                            "timeSeriesQueryLanguage" => {
                                Ok(__FieldTag::__time_series_query_language)
                            }
                            "time_series_query_language" => {
                                Ok(__FieldTag::__time_series_query_language)
                            }
                            "prometheusQuery" => Ok(__FieldTag::__prometheus_query),
                            "prometheus_query" => Ok(__FieldTag::__prometheus_query),
                            "unitOverride" => Ok(__FieldTag::__unit_override),
                            "unit_override" => Ok(__FieldTag::__unit_override),
                            "outputFullDuration" => Ok(__FieldTag::__output_full_duration),
                            "output_full_duration" => Ok(__FieldTag::__output_full_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TimeSeriesQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_filter => {
                            if !fields.insert(__FieldTag::__time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_filter",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.time_series_filter, latest field was timeSeriesFilter",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::TimeSeriesFilter(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeSeriesFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__time_series_filter_ratio => {
                            if !fields.insert(__FieldTag::__time_series_filter_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_filter_ratio",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.time_series_filter_ratio, latest field was timeSeriesFilterRatio",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::TimeSeriesFilterRatio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeSeriesFilterRatio>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__time_series_query_language => {
                            if !fields.insert(__FieldTag::__time_series_query_language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_query_language",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.time_series_query_language, latest field was timeSeriesQueryLanguage",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::TimeSeriesQueryLanguage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__prometheus_query => {
                            if !fields.insert(__FieldTag::__prometheus_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prometheus_query",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesQuery.prometheus_query, latest field was prometheusQuery",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::time_series_query::Source::PrometheusQuery(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__unit_override => {
                            if !fields.insert(__FieldTag::__unit_override) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unit_override",
                                ));
                            }
                            result.unit_override = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_full_duration => {
                            if !fields.insert(__FieldTag::__output_full_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_full_duration",
                                ));
                            }
                            result.output_full_duration = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TimeSeriesFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __aggregation,
            __secondary_aggregation,
            __pick_time_series_filter,
            __statistical_time_series_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "aggregation" => Ok(__FieldTag::__aggregation),
                            "secondaryAggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "secondary_aggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "pickTimeSeriesFilter" => Ok(__FieldTag::__pick_time_series_filter),
                            "pick_time_series_filter" => Ok(__FieldTag::__pick_time_series_filter),
                            "statisticalTimeSeriesFilter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            "statistical_time_series_filter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TimeSeriesFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aggregation => {
                            if !fields.insert(__FieldTag::__aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation",
                                ));
                            }
                            result.aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__secondary_aggregation => {
                            if !fields.insert(__FieldTag::__secondary_aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_aggregation",
                                ));
                            }
                            result.secondary_aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__pick_time_series_filter => {
                            if !fields.insert(__FieldTag::__pick_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pick_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilter.pick_time_series_filter, latest field was pickTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PickTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__statistical_time_series_filter => {
                            if !fields.insert(__FieldTag::__statistical_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statistical_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilter.statistical_time_series_filter, latest field was statisticalTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TimeSeriesFilterRatio {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __numerator,
            __denominator,
            __secondary_aggregation,
            __pick_time_series_filter,
            __statistical_time_series_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesFilterRatio")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "numerator" => Ok(__FieldTag::__numerator),
                            "denominator" => Ok(__FieldTag::__denominator),
                            "secondaryAggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "secondary_aggregation" => Ok(__FieldTag::__secondary_aggregation),
                            "pickTimeSeriesFilter" => Ok(__FieldTag::__pick_time_series_filter),
                            "pick_time_series_filter" => Ok(__FieldTag::__pick_time_series_filter),
                            "statisticalTimeSeriesFilter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            "statistical_time_series_filter" => {
                                Ok(__FieldTag::__statistical_time_series_filter)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TimeSeriesFilterRatio;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesFilterRatio")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__numerator => {
                            if !fields.insert(__FieldTag::__numerator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numerator",
                                ));
                            }
                            result.numerator = map.next_value::<std::option::Option<
                                crate::model::time_series_filter_ratio::RatioPart,
                            >>()?;
                        }
                        __FieldTag::__denominator => {
                            if !fields.insert(__FieldTag::__denominator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denominator",
                                ));
                            }
                            result.denominator = map.next_value::<std::option::Option<
                                crate::model::time_series_filter_ratio::RatioPart,
                            >>()?;
                        }
                        __FieldTag::__secondary_aggregation => {
                            if !fields.insert(__FieldTag::__secondary_aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_aggregation",
                                ));
                            }
                            result.secondary_aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::__pick_time_series_filter => {
                            if !fields.insert(__FieldTag::__pick_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pick_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilterRatio.pick_time_series_filter, latest field was pickTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PickTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__statistical_time_series_filter => {
                            if !fields.insert(__FieldTag::__statistical_time_series_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statistical_time_series_filter",
                                ));
                            }
                            if result.output_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_filter`, a oneof with full ID .google.monitoring.dashboard.v1.TimeSeriesFilterRatio.statistical_time_series_filter, latest field was statisticalTimeSeriesFilter",
                                ));
                            }
                            result.output_filter = std::option::Option::Some(
                                crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::time_series_filter_ratio::RatioPart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __aggregation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RatioPart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "aggregation" => Ok(__FieldTag::__aggregation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::time_series_filter_ratio::RatioPart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RatioPart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aggregation => {
                            if !fields.insert(__FieldTag::__aggregation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation",
                                ));
                            }
                            result.aggregation =
                                map.next_value::<std::option::Option<crate::model::Aggregation>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Threshold {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label,
            __value,
            __color,
            __direction,
            __target_axis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Threshold")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "label" => Ok(__FieldTag::__label),
                            "value" => Ok(__FieldTag::__value),
                            "color" => Ok(__FieldTag::__color),
                            "direction" => Ok(__FieldTag::__direction),
                            "targetAxis" => Ok(__FieldTag::__target_axis),
                            "target_axis" => Ok(__FieldTag::__target_axis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Threshold;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Threshold")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__color => {
                            if !fields.insert(__FieldTag::__color) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for color",
                                ));
                            }
                            result.color = map
                                .next_value::<std::option::Option<crate::model::threshold::Color>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map.next_value::<std::option::Option<crate::model::threshold::Direction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__target_axis => {
                            if !fields.insert(__FieldTag::__target_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_axis",
                                ));
                            }
                            result.target_axis = map.next_value::<std::option::Option<crate::model::threshold::TargetAxis>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PieChart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sets,
            __chart_type,
            __show_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PieChart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSets" => Ok(__FieldTag::__data_sets),
                            "data_sets" => Ok(__FieldTag::__data_sets),
                            "chartType" => Ok(__FieldTag::__chart_type),
                            "chart_type" => Ok(__FieldTag::__chart_type),
                            "showLabels" => Ok(__FieldTag::__show_labels),
                            "show_labels" => Ok(__FieldTag::__show_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PieChart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PieChart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sets => {
                            if !fields.insert(__FieldTag::__data_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sets",
                                ));
                            }
                            result.data_sets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::pie_chart::PieChartDataSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__chart_type => {
                            if !fields.insert(__FieldTag::__chart_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chart_type",
                                ));
                            }
                            result.chart_type = map.next_value::<std::option::Option<crate::model::pie_chart::PieChartType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__show_labels => {
                            if !fields.insert(__FieldTag::__show_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_labels",
                                ));
                            }
                            result.show_labels = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::pie_chart::PieChartDataSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_query,
            __slice_name_template,
            __min_alignment_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PieChartDataSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                            "time_series_query" => Ok(__FieldTag::__time_series_query),
                            "sliceNameTemplate" => Ok(__FieldTag::__slice_name_template),
                            "slice_name_template" => Ok(__FieldTag::__slice_name_template),
                            "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                            "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::pie_chart::PieChartDataSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PieChartDataSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_query => {
                            if !fields.insert(__FieldTag::__time_series_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_query",
                                ));
                            }
                            result.time_series_query = map
                                .next_value::<std::option::Option<crate::model::TimeSeriesQuery>>(
                                )?;
                        }
                        __FieldTag::__slice_name_template => {
                            if !fields.insert(__FieldTag::__slice_name_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slice_name_template",
                                ));
                            }
                            result.slice_name_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_alignment_period => {
                            if !fields.insert(__FieldTag::__min_alignment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_alignment_period",
                                ));
                            }
                            result.min_alignment_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Scorecard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_query,
            __gauge_view,
            __spark_chart_view,
            __blank_view,
            __thresholds,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Scorecard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                            "time_series_query" => Ok(__FieldTag::__time_series_query),
                            "gaugeView" => Ok(__FieldTag::__gauge_view),
                            "gauge_view" => Ok(__FieldTag::__gauge_view),
                            "sparkChartView" => Ok(__FieldTag::__spark_chart_view),
                            "spark_chart_view" => Ok(__FieldTag::__spark_chart_view),
                            "blankView" => Ok(__FieldTag::__blank_view),
                            "blank_view" => Ok(__FieldTag::__blank_view),
                            "thresholds" => Ok(__FieldTag::__thresholds),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Scorecard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Scorecard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_query => {
                            if !fields.insert(__FieldTag::__time_series_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_query",
                                ));
                            }
                            result.time_series_query = map
                                .next_value::<std::option::Option<crate::model::TimeSeriesQuery>>(
                                )?;
                        }
                        __FieldTag::__gauge_view => {
                            if !fields.insert(__FieldTag::__gauge_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gauge_view",
                                ));
                            }
                            if result.data_view.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_view`, a oneof with full ID .google.monitoring.dashboard.v1.Scorecard.gauge_view, latest field was gaugeView",
                                ));
                            }
                            result.data_view = std::option::Option::Some(
                                crate::model::scorecard::DataView::GaugeView(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::scorecard::GaugeView>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_chart_view => {
                            if !fields.insert(__FieldTag::__spark_chart_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_chart_view",
                                ));
                            }
                            if result.data_view.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_view`, a oneof with full ID .google.monitoring.dashboard.v1.Scorecard.spark_chart_view, latest field was sparkChartView",
                                ));
                            }
                            result.data_view = std::option::Option::Some(
                                crate::model::scorecard::DataView::SparkChartView(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::scorecard::SparkChartView>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__blank_view => {
                            if !fields.insert(__FieldTag::__blank_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blank_view",
                                ));
                            }
                            if result.data_view.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_view`, a oneof with full ID .google.monitoring.dashboard.v1.Scorecard.blank_view, latest field was blankView",
                                ));
                            }
                            result.data_view = std::option::Option::Some(
                                crate::model::scorecard::DataView::BlankView(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__thresholds => {
                            if !fields.insert(__FieldTag::__thresholds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for thresholds",
                                ));
                            }
                            result.thresholds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Threshold>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::scorecard::GaugeView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lower_bound,
            __upper_bound,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GaugeView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lowerBound" => Ok(__FieldTag::__lower_bound),
                            "lower_bound" => Ok(__FieldTag::__lower_bound),
                            "upperBound" => Ok(__FieldTag::__upper_bound),
                            "upper_bound" => Ok(__FieldTag::__upper_bound),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::scorecard::GaugeView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GaugeView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lower_bound => {
                            if !fields.insert(__FieldTag::__lower_bound) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lower_bound",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.lower_bound = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__upper_bound => {
                            if !fields.insert(__FieldTag::__upper_bound) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upper_bound",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.upper_bound = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::scorecard::SparkChartView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __spark_chart_type,
            __min_alignment_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkChartView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sparkChartType" => Ok(__FieldTag::__spark_chart_type),
                            "spark_chart_type" => Ok(__FieldTag::__spark_chart_type),
                            "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                            "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::scorecard::SparkChartView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkChartView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__spark_chart_type => {
                            if !fields.insert(__FieldTag::__spark_chart_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_chart_type",
                                ));
                            }
                            result.spark_chart_type = map
                                .next_value::<std::option::Option<crate::model::SparkChartType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_alignment_period => {
                            if !fields.insert(__FieldTag::__min_alignment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_alignment_period",
                                ));
                            }
                            result.min_alignment_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SectionHeader {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subtitle,
            __divider_below,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SectionHeader")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subtitle" => Ok(__FieldTag::__subtitle),
                            "dividerBelow" => Ok(__FieldTag::__divider_below),
                            "divider_below" => Ok(__FieldTag::__divider_below),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SectionHeader;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SectionHeader")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subtitle => {
                            if !fields.insert(__FieldTag::__subtitle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subtitle",
                                ));
                            }
                            result.subtitle = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__divider_below => {
                            if !fields.insert(__FieldTag::__divider_below) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for divider_below",
                                ));
                            }
                            result.divider_below = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SingleViewGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SingleViewGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SingleViewGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SingleViewGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TimeSeriesTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sets,
            __metric_visualization,
            __column_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeriesTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSets" => Ok(__FieldTag::__data_sets),
                            "data_sets" => Ok(__FieldTag::__data_sets),
                            "metricVisualization" => Ok(__FieldTag::__metric_visualization),
                            "metric_visualization" => Ok(__FieldTag::__metric_visualization),
                            "columnSettings" => Ok(__FieldTag::__column_settings),
                            "column_settings" => Ok(__FieldTag::__column_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TimeSeriesTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeriesTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sets => {
                            if !fields.insert(__FieldTag::__data_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sets",
                                ));
                            }
                            result.data_sets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::time_series_table::TableDataSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric_visualization => {
                            if !fields.insert(__FieldTag::__metric_visualization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_visualization",
                                ));
                            }
                            result.metric_visualization = map
                                .next_value::<std::option::Option<
                                    crate::model::time_series_table::MetricVisualization,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__column_settings => {
                            if !fields.insert(__FieldTag::__column_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_settings",
                                ));
                            }
                            result.column_settings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::time_series_table::ColumnSettings>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::time_series_table::TableDataSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_query,
            __table_template,
            __min_alignment_period,
            __table_display_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableDataSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                            "time_series_query" => Ok(__FieldTag::__time_series_query),
                            "tableTemplate" => Ok(__FieldTag::__table_template),
                            "table_template" => Ok(__FieldTag::__table_template),
                            "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                            "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                            "tableDisplayOptions" => Ok(__FieldTag::__table_display_options),
                            "table_display_options" => Ok(__FieldTag::__table_display_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::time_series_table::TableDataSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableDataSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_query => {
                            if !fields.insert(__FieldTag::__time_series_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_query",
                                ));
                            }
                            result.time_series_query = map
                                .next_value::<std::option::Option<crate::model::TimeSeriesQuery>>(
                                )?;
                        }
                        __FieldTag::__table_template => {
                            if !fields.insert(__FieldTag::__table_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_template",
                                ));
                            }
                            result.table_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_alignment_period => {
                            if !fields.insert(__FieldTag::__min_alignment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_alignment_period",
                                ));
                            }
                            result.min_alignment_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__table_display_options => {
                            if !fields.insert(__FieldTag::__table_display_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_display_options",
                                ));
                            }
                            result.table_display_options = map.next_value::<std::option::Option<crate::model::TableDisplayOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::time_series_table::ColumnSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column,
            __visible,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "column" => Ok(__FieldTag::__column),
                            "visible" => Ok(__FieldTag::__visible),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::time_series_table::ColumnSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visible => {
                            if !fields.insert(__FieldTag::__visible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visible",
                                ));
                            }
                            result.visible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableDisplayOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __shown_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableDisplayOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shownColumns" => Ok(__FieldTag::__shown_columns),
                            "shown_columns" => Ok(__FieldTag::__shown_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableDisplayOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableDisplayOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__shown_columns => {
                            if !fields.insert(__FieldTag::__shown_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shown_columns",
                                ));
                            }
                            result.shown_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Text {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __format,
            __style,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Text")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "format" => Ok(__FieldTag::__format),
                            "style" => Ok(__FieldTag::__style),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Text;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Text")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<crate::model::text::Format>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__style => {
                            if !fields.insert(__FieldTag::__style) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for style",
                                ));
                            }
                            result.style = map
                                .next_value::<std::option::Option<crate::model::text::TextStyle>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::text::TextStyle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __background_color,
            __text_color,
            __horizontal_alignment,
            __vertical_alignment,
            __padding,
            __font_size,
            __pointer_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextStyle")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backgroundColor" => Ok(__FieldTag::__background_color),
                            "background_color" => Ok(__FieldTag::__background_color),
                            "textColor" => Ok(__FieldTag::__text_color),
                            "text_color" => Ok(__FieldTag::__text_color),
                            "horizontalAlignment" => Ok(__FieldTag::__horizontal_alignment),
                            "horizontal_alignment" => Ok(__FieldTag::__horizontal_alignment),
                            "verticalAlignment" => Ok(__FieldTag::__vertical_alignment),
                            "vertical_alignment" => Ok(__FieldTag::__vertical_alignment),
                            "padding" => Ok(__FieldTag::__padding),
                            "fontSize" => Ok(__FieldTag::__font_size),
                            "font_size" => Ok(__FieldTag::__font_size),
                            "pointerLocation" => Ok(__FieldTag::__pointer_location),
                            "pointer_location" => Ok(__FieldTag::__pointer_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::text::TextStyle;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextStyle")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__background_color => {
                            if !fields.insert(__FieldTag::__background_color) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for background_color",
                                ));
                            }
                            result.background_color = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_color => {
                            if !fields.insert(__FieldTag::__text_color) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_color",
                                ));
                            }
                            result.text_color = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__horizontal_alignment => {
                            if !fields.insert(__FieldTag::__horizontal_alignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for horizontal_alignment",
                                ));
                            }
                            result.horizontal_alignment = map
                                .next_value::<std::option::Option<
                                    crate::model::text::text_style::HorizontalAlignment,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vertical_alignment => {
                            if !fields.insert(__FieldTag::__vertical_alignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertical_alignment",
                                ));
                            }
                            result.vertical_alignment = map
                                .next_value::<std::option::Option<
                                    crate::model::text::text_style::VerticalAlignment,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__padding => {
                            if !fields.insert(__FieldTag::__padding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for padding",
                                ));
                            }
                            result.padding =
                                map.next_value::<std::option::Option<
                                    crate::model::text::text_style::PaddingSize,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__font_size => {
                            if !fields.insert(__FieldTag::__font_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for font_size",
                                ));
                            }
                            result.font_size = map.next_value::<std::option::Option<crate::model::text::text_style::FontSize>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pointer_location => {
                            if !fields.insert(__FieldTag::__pointer_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pointer_location",
                                ));
                            }
                            result.pointer_location = map
                                .next_value::<std::option::Option<
                                    crate::model::text::text_style::PointerLocation,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Widget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __xy_chart,
            __scorecard,
            __text,
            __blank,
            __alert_chart,
            __time_series_table,
            __collapsible_group,
            __logs_panel,
            __incident_list,
            __pie_chart,
            __error_reporting_panel,
            __section_header,
            __single_view_group,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Widget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "xyChart" => Ok(__FieldTag::__xy_chart),
                            "xy_chart" => Ok(__FieldTag::__xy_chart),
                            "scorecard" => Ok(__FieldTag::__scorecard),
                            "text" => Ok(__FieldTag::__text),
                            "blank" => Ok(__FieldTag::__blank),
                            "alertChart" => Ok(__FieldTag::__alert_chart),
                            "alert_chart" => Ok(__FieldTag::__alert_chart),
                            "timeSeriesTable" => Ok(__FieldTag::__time_series_table),
                            "time_series_table" => Ok(__FieldTag::__time_series_table),
                            "collapsibleGroup" => Ok(__FieldTag::__collapsible_group),
                            "collapsible_group" => Ok(__FieldTag::__collapsible_group),
                            "logsPanel" => Ok(__FieldTag::__logs_panel),
                            "logs_panel" => Ok(__FieldTag::__logs_panel),
                            "incidentList" => Ok(__FieldTag::__incident_list),
                            "incident_list" => Ok(__FieldTag::__incident_list),
                            "pieChart" => Ok(__FieldTag::__pie_chart),
                            "pie_chart" => Ok(__FieldTag::__pie_chart),
                            "errorReportingPanel" => Ok(__FieldTag::__error_reporting_panel),
                            "error_reporting_panel" => Ok(__FieldTag::__error_reporting_panel),
                            "sectionHeader" => Ok(__FieldTag::__section_header),
                            "section_header" => Ok(__FieldTag::__section_header),
                            "singleViewGroup" => Ok(__FieldTag::__single_view_group),
                            "single_view_group" => Ok(__FieldTag::__single_view_group),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Widget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Widget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__xy_chart => {
                            if !fields.insert(__FieldTag::__xy_chart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for xy_chart",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.xy_chart, latest field was xyChart",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(
                                    crate::model::widget::Content::XyChart(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::XyChart>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__scorecard => {
                            if !fields.insert(__FieldTag::__scorecard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scorecard",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.scorecard, latest field was scorecard",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::Scorecard(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Scorecard>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.text, latest field was text",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(
                                    crate::model::widget::Content::Text(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Text>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__blank => {
                            if !fields.insert(__FieldTag::__blank) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blank",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.blank, latest field was blank",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::Blank(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__alert_chart => {
                            if !fields.insert(__FieldTag::__alert_chart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alert_chart",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.alert_chart, latest field was alertChart",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::AlertChart(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AlertChart>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__time_series_table => {
                            if !fields.insert(__FieldTag::__time_series_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_table",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.time_series_table, latest field was timeSeriesTable",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::TimeSeriesTable(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeSeriesTable>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__collapsible_group => {
                            if !fields.insert(__FieldTag::__collapsible_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collapsible_group",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.collapsible_group, latest field was collapsibleGroup",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::CollapsibleGroup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CollapsibleGroup>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__logs_panel => {
                            if !fields.insert(__FieldTag::__logs_panel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logs_panel",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.logs_panel, latest field was logsPanel",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::LogsPanel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LogsPanel>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__incident_list => {
                            if !fields.insert(__FieldTag::__incident_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incident_list",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.incident_list, latest field was incidentList",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::IncidentList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IncidentList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pie_chart => {
                            if !fields.insert(__FieldTag::__pie_chart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pie_chart",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.pie_chart, latest field was pieChart",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(crate::model::widget::Content::PieChart(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PieChart>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__error_reporting_panel => {
                            if !fields.insert(__FieldTag::__error_reporting_panel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_reporting_panel",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.error_reporting_panel, latest field was errorReportingPanel",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::ErrorReportingPanel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ErrorReportingPanel>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__section_header => {
                            if !fields.insert(__FieldTag::__section_header) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for section_header",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.section_header, latest field was sectionHeader",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::SectionHeader(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SectionHeader>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__single_view_group => {
                            if !fields.insert(__FieldTag::__single_view_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_view_group",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.monitoring.dashboard.v1.Widget.single_view_group, latest field was singleViewGroup",
                                ));
                            }
                            result.content = std::option::Option::Some(
                                crate::model::widget::Content::SingleViewGroup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SingleViewGroup>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::XyChart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sets,
            __timeshift_duration,
            __thresholds,
            __x_axis,
            __y_axis,
            __y2_axis,
            __chart_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for XyChart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSets" => Ok(__FieldTag::__data_sets),
                            "data_sets" => Ok(__FieldTag::__data_sets),
                            "timeshiftDuration" => Ok(__FieldTag::__timeshift_duration),
                            "timeshift_duration" => Ok(__FieldTag::__timeshift_duration),
                            "thresholds" => Ok(__FieldTag::__thresholds),
                            "xAxis" => Ok(__FieldTag::__x_axis),
                            "x_axis" => Ok(__FieldTag::__x_axis),
                            "yAxis" => Ok(__FieldTag::__y_axis),
                            "y_axis" => Ok(__FieldTag::__y_axis),
                            "y2Axis" => Ok(__FieldTag::__y2_axis),
                            "y2_axis" => Ok(__FieldTag::__y2_axis),
                            "chartOptions" => Ok(__FieldTag::__chart_options),
                            "chart_options" => Ok(__FieldTag::__chart_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::XyChart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct XyChart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sets => {
                            if !fields.insert(__FieldTag::__data_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sets",
                                ));
                            }
                            result.data_sets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::xy_chart::DataSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeshift_duration => {
                            if !fields.insert(__FieldTag::__timeshift_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeshift_duration",
                                ));
                            }
                            result.timeshift_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__thresholds => {
                            if !fields.insert(__FieldTag::__thresholds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for thresholds",
                                ));
                            }
                            result.thresholds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Threshold>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__x_axis => {
                            if !fields.insert(__FieldTag::__x_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x_axis",
                                ));
                            }
                            result.x_axis = map
                                .next_value::<std::option::Option<crate::model::xy_chart::Axis>>(
                                )?;
                        }
                        __FieldTag::__y_axis => {
                            if !fields.insert(__FieldTag::__y_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y_axis",
                                ));
                            }
                            result.y_axis = map
                                .next_value::<std::option::Option<crate::model::xy_chart::Axis>>(
                                )?;
                        }
                        __FieldTag::__y2_axis => {
                            if !fields.insert(__FieldTag::__y2_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y2_axis",
                                ));
                            }
                            result.y2_axis = map
                                .next_value::<std::option::Option<crate::model::xy_chart::Axis>>(
                                )?;
                        }
                        __FieldTag::__chart_options => {
                            if !fields.insert(__FieldTag::__chart_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chart_options",
                                ));
                            }
                            result.chart_options = map
                                .next_value::<std::option::Option<crate::model::ChartOptions>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::xy_chart::DataSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_series_query,
            __plot_type,
            __legend_template,
            __min_alignment_period,
            __target_axis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeSeriesQuery" => Ok(__FieldTag::__time_series_query),
                            "time_series_query" => Ok(__FieldTag::__time_series_query),
                            "plotType" => Ok(__FieldTag::__plot_type),
                            "plot_type" => Ok(__FieldTag::__plot_type),
                            "legendTemplate" => Ok(__FieldTag::__legend_template),
                            "legend_template" => Ok(__FieldTag::__legend_template),
                            "minAlignmentPeriod" => Ok(__FieldTag::__min_alignment_period),
                            "min_alignment_period" => Ok(__FieldTag::__min_alignment_period),
                            "targetAxis" => Ok(__FieldTag::__target_axis),
                            "target_axis" => Ok(__FieldTag::__target_axis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::xy_chart::DataSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_series_query => {
                            if !fields.insert(__FieldTag::__time_series_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_query",
                                ));
                            }
                            result.time_series_query = map
                                .next_value::<std::option::Option<crate::model::TimeSeriesQuery>>(
                                )?;
                        }
                        __FieldTag::__plot_type => {
                            if !fields.insert(__FieldTag::__plot_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plot_type",
                                ));
                            }
                            result.plot_type = map.next_value::<std::option::Option<crate::model::xy_chart::data_set::PlotType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__legend_template => {
                            if !fields.insert(__FieldTag::__legend_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legend_template",
                                ));
                            }
                            result.legend_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_alignment_period => {
                            if !fields.insert(__FieldTag::__min_alignment_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_alignment_period",
                                ));
                            }
                            result.min_alignment_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__target_axis => {
                            if !fields.insert(__FieldTag::__target_axis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_axis",
                                ));
                            }
                            result.target_axis =
                                map.next_value::<std::option::Option<
                                    crate::model::xy_chart::data_set::TargetAxis,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::xy_chart::Axis {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label,
            __scale,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Axis")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "label" => Ok(__FieldTag::__label),
                            "scale" => Ok(__FieldTag::__scale),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::xy_chart::Axis;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Axis")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            result.scale = map.next_value::<std::option::Option<crate::model::xy_chart::axis::Scale>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ChartOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChartOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ChartOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChartOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::chart_options::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
