// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gclient;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A chart that displays alert policy data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlertChart {
    /// Required. The resource name of the alert policy. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl AlertChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AlertChart::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AlertChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.AlertChart"
    }
}

/// A widget that groups the other widgets. All widgets that are within
/// the area spanned by the grouping widget are considered member widgets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CollapsibleGroup {
    /// The collapsed state of the widget on first page load.
    pub collapsed: bool,
}

impl CollapsibleGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [collapsed][crate::model::CollapsibleGroup::collapsed].
    pub fn set_collapsed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.collapsed = v.into();
        self
    }
}

impl wkt::message::Message for CollapsibleGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.CollapsibleGroup"
    }
}

/// Describes how to combine multiple time series to provide a different view of
/// the data.  Aggregation of time series is done in two steps. First, each time
/// series in the set is _aligned_ to the same time interval boundaries, then the
/// set of time series is optionally _reduced_ in number.
///
/// Alignment consists of applying the `per_series_aligner` operation
/// to each time series after its data has been divided into regular
/// `alignment_period` time intervals. This process takes _all_ of the data
/// points in an alignment period, applies a mathematical transformation such as
/// averaging, minimum, maximum, delta, etc., and converts them into a single
/// data point per period.
///
/// Reduction is when the aligned and transformed time series can optionally be
/// combined, reducing the number of time series through similar mathematical
/// transformations. Reduction involves applying a `cross_series_reducer` to
/// all the time series, optionally sorting the time series into subsets with
/// `group_by_fields`, and applying the reducer to each subset.
///
/// The raw time series data can contain a huge amount of information from
/// multiple sources. Alignment and reduction transforms this mass of data into
/// a more manageable and representative collection of data, for example "the
/// 95% latency across the average of all tasks in a cluster". This
/// representative data can be more easily graphed and comprehended, and the
/// individual time series data is still available for later drilldown. For more
/// details, see [Filtering and
/// aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Aggregation {
    /// The `alignment_period` specifies a time interval, in seconds, that is used
    /// to divide the data in all the
    /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
    /// time. This will be done before the per-series aligner can be applied to
    /// the data.
    ///
    /// The value must be at least 60 seconds. If a per-series aligner other than
    /// `ALIGN_NONE` is specified, this field is required or an error is returned.
    /// If no per-series aligner is specified, or the aligner `ALIGN_NONE` is
    /// specified, then this field is ignored.
    ///
    /// The maximum value of the `alignment_period` is 2 years, or 104 weeks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub alignment_period: std::option::Option<wkt::Duration>,

    /// An `Aligner` describes how to bring the data points in a single
    /// time series into temporal alignment. Except for `ALIGN_NONE`, all
    /// alignments cause all the data points in an `alignment_period` to be
    /// mathematically grouped together, resulting in a single data point for
    /// each `alignment_period` with end timestamp at the end of the period.
    ///
    /// Not all alignment operations may be applied to all time series. The valid
    /// choices depend on the `metric_kind` and `value_type` of the original time
    /// series. Alignment can change the `metric_kind` or the `value_type` of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `cross_series_reducer` is specified, then
    /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
    /// and `alignment_period` must be specified; otherwise, an error is
    /// returned.
    pub per_series_aligner: crate::model::aggregation::Aligner,

    /// The reduction operation to be used to combine time series into a single
    /// time series, where the value of each data point in the resulting series is
    /// a function of all the already aligned values in the input time series.
    ///
    /// Not all reducer operations can be applied to all time series. The valid
    /// choices depend on the `metric_kind` and the `value_type` of the original
    /// time series. Reduction can yield a time series with a different
    /// `metric_kind` or `value_type` than the input time series.
    ///
    /// Time series data must first be aligned (see `per_series_aligner`) in order
    /// to perform cross-time series reduction. If `cross_series_reducer` is
    /// specified, then `per_series_aligner` must be specified, and must not be
    /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
    /// error is returned.
    pub cross_series_reducer: crate::model::aggregation::Reducer,

    /// The set of fields to preserve when `cross_series_reducer` is
    /// specified. The `group_by_fields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// operation. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `cross_series_reducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `group_by_fields` are aggregated away.  If
    /// `group_by_fields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `cross_series_reducer` is not
    /// defined, this field is ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group_by_fields: std::vec::Vec<std::string::String>,
}

impl Aggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alignment_period][crate::model::Aggregation::alignment_period].
    pub fn set_alignment_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.alignment_period = v.into();
        self
    }

    /// Sets the value of [per_series_aligner][crate::model::Aggregation::per_series_aligner].
    pub fn set_per_series_aligner<T: std::convert::Into<crate::model::aggregation::Aligner>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_series_aligner = v.into();
        self
    }

    /// Sets the value of [cross_series_reducer][crate::model::Aggregation::cross_series_reducer].
    pub fn set_cross_series_reducer<T: std::convert::Into<crate::model::aggregation::Reducer>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_series_reducer = v.into();
        self
    }

    /// Sets the value of [group_by_fields][crate::model::Aggregation::group_by_fields].
    pub fn set_group_by_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.group_by_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Aggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Aggregation"
    }
}

/// Defines additional types related to Aggregation
pub mod aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// The `Aligner` specifies the operation that will be applied to the data
    /// points in each alignment period in a time series. Except for
    /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
    /// operation replaces the set of data values in each alignment period with
    /// a single value: the result of applying the operation to the data values.
    /// An aligned time series has a single data value at the end of each
    /// `alignment_period`.
    ///
    /// An alignment operation can change the data type of the values, too. For
    /// example, if you apply a counting operation to boolean values, the data
    /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
    /// in the aligned result is `INT64`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Aligner(i32);

    impl Aligner {
        /// No alignment. Raw data is returned. Not valid if cross-series reduction
        /// is requested. The `value_type` of the result is the same as the
        /// `value_type` of the input.
        pub const ALIGN_NONE: Aligner = Aligner::new(0);

        /// Align and convert to
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
        /// The output is `delta = y1 - y0`.
        ///
        /// This alignment is valid for
        /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
        /// `DELTA` metrics. If the selected alignment period results in periods
        /// with no data, then the aligned value for such a period is created by
        /// interpolation. The `value_type`  of the aligned result is the same as
        /// the `value_type` of the input.
        pub const ALIGN_DELTA: Aligner = Aligner::new(1);

        /// Align and convert to a rate. The result is computed as
        /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
        /// Think of this aligner as providing the slope of the line that passes
        /// through the value at the start and at the end of the `alignment_period`.
        ///
        /// This aligner is valid for `CUMULATIVE`
        /// and `DELTA` metrics with numeric values. If the selected alignment
        /// period results in periods with no data, then the aligned value for
        /// such a period is created by interpolation. The output is a `GAUGE`
        /// metric with `value_type` `DOUBLE`.
        ///
        /// If, by "rate", you mean "percentage change", see the
        /// `ALIGN_PERCENT_CHANGE` aligner instead.
        pub const ALIGN_RATE: Aligner = Aligner::new(2);

        /// Align by interpolating between adjacent points around the alignment
        /// period boundary. This aligner is valid for `GAUGE` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as the
        /// `value_type` of the input.
        pub const ALIGN_INTERPOLATE: Aligner = Aligner::new(3);

        /// Align by moving the most recent data point before the end of the
        /// alignment period to the boundary at the end of the alignment
        /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
        /// the aligned result is the same as the `value_type` of the input.
        pub const ALIGN_NEXT_OLDER: Aligner = Aligner::new(4);

        /// Align the time series by returning the minimum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        pub const ALIGN_MIN: Aligner = Aligner::new(10);

        /// Align the time series by returning the maximum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        pub const ALIGN_MAX: Aligner = Aligner::new(11);

        /// Align the time series by returning the mean value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
        pub const ALIGN_MEAN: Aligner = Aligner::new(12);

        /// Align the time series by returning the number of values in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric or Boolean values. The `value_type` of the aligned result is
        /// `INT64`.
        pub const ALIGN_COUNT: Aligner = Aligner::new(13);

        /// Align the time series by returning the sum of the values in each
        /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with numeric and distribution values. The `value_type` of the
        /// aligned result is the same as the `value_type` of the input.
        pub const ALIGN_SUM: Aligner = Aligner::new(14);

        /// Align the time series by returning the standard deviation of the values
        /// in each alignment period. This aligner is valid for `GAUGE` and
        /// `DELTA` metrics with numeric values. The `value_type` of the output is
        /// `DOUBLE`.
        pub const ALIGN_STDDEV: Aligner = Aligner::new(15);

        /// Align the time series by returning the number of `True` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        pub const ALIGN_COUNT_TRUE: Aligner = Aligner::new(16);

        /// Align the time series by returning the number of `False` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        pub const ALIGN_COUNT_FALSE: Aligner = Aligner::new(24);

        /// Align the time series by returning the ratio of the number of `True`
        /// values to the total number of values in each alignment period. This
        /// aligner is valid for `GAUGE` metrics with Boolean values. The output
        /// value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
        pub const ALIGN_FRACTION_TRUE: Aligner = Aligner::new(17);

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 99th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_99: Aligner = Aligner::new(18);

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 95th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_95: Aligner = Aligner::new(19);

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 50th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_50: Aligner = Aligner::new(20);

        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 5th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        pub const ALIGN_PERCENTILE_05: Aligner = Aligner::new(21);

        /// Align and convert to a percentage change. This aligner is valid for
        /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
        /// `((current - previous)/previous) * 100`, where the value of `previous` is
        /// determined based on the `alignment_period`.
        ///
        /// If the values of `current` and `previous` are both 0, then the returned
        /// value is 0. If only `previous` is 0, the returned value is infinity.
        ///
        /// A 10-minute moving mean is computed at each point of the alignment period
        /// prior to the above calculation to smooth the metric and prevent false
        /// positives from very short-lived spikes. The moving mean is only
        /// applicable for data whose values are `>= 0`. Any values `< 0` are
        /// treated as a missing datapoint, and are ignored. While `DELTA`
        /// metrics are accepted by this alignment, special care should be taken that
        /// the values for the metric will always be positive. The output is a
        /// `GAUGE` metric with `value_type` `DOUBLE`.
        pub const ALIGN_PERCENT_CHANGE: Aligner = Aligner::new(23);

        /// Creates a new Aligner instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ALIGN_NONE"),
                1 => std::borrow::Cow::Borrowed("ALIGN_DELTA"),
                2 => std::borrow::Cow::Borrowed("ALIGN_RATE"),
                3 => std::borrow::Cow::Borrowed("ALIGN_INTERPOLATE"),
                4 => std::borrow::Cow::Borrowed("ALIGN_NEXT_OLDER"),
                10 => std::borrow::Cow::Borrowed("ALIGN_MIN"),
                11 => std::borrow::Cow::Borrowed("ALIGN_MAX"),
                12 => std::borrow::Cow::Borrowed("ALIGN_MEAN"),
                13 => std::borrow::Cow::Borrowed("ALIGN_COUNT"),
                14 => std::borrow::Cow::Borrowed("ALIGN_SUM"),
                15 => std::borrow::Cow::Borrowed("ALIGN_STDDEV"),
                16 => std::borrow::Cow::Borrowed("ALIGN_COUNT_TRUE"),
                17 => std::borrow::Cow::Borrowed("ALIGN_FRACTION_TRUE"),
                18 => std::borrow::Cow::Borrowed("ALIGN_PERCENTILE_99"),
                19 => std::borrow::Cow::Borrowed("ALIGN_PERCENTILE_95"),
                20 => std::borrow::Cow::Borrowed("ALIGN_PERCENTILE_50"),
                21 => std::borrow::Cow::Borrowed("ALIGN_PERCENTILE_05"),
                23 => std::borrow::Cow::Borrowed("ALIGN_PERCENT_CHANGE"),
                24 => std::borrow::Cow::Borrowed("ALIGN_COUNT_FALSE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ALIGN_NONE" => std::option::Option::Some(Self::ALIGN_NONE),
                "ALIGN_DELTA" => std::option::Option::Some(Self::ALIGN_DELTA),
                "ALIGN_RATE" => std::option::Option::Some(Self::ALIGN_RATE),
                "ALIGN_INTERPOLATE" => std::option::Option::Some(Self::ALIGN_INTERPOLATE),
                "ALIGN_NEXT_OLDER" => std::option::Option::Some(Self::ALIGN_NEXT_OLDER),
                "ALIGN_MIN" => std::option::Option::Some(Self::ALIGN_MIN),
                "ALIGN_MAX" => std::option::Option::Some(Self::ALIGN_MAX),
                "ALIGN_MEAN" => std::option::Option::Some(Self::ALIGN_MEAN),
                "ALIGN_COUNT" => std::option::Option::Some(Self::ALIGN_COUNT),
                "ALIGN_SUM" => std::option::Option::Some(Self::ALIGN_SUM),
                "ALIGN_STDDEV" => std::option::Option::Some(Self::ALIGN_STDDEV),
                "ALIGN_COUNT_TRUE" => std::option::Option::Some(Self::ALIGN_COUNT_TRUE),
                "ALIGN_COUNT_FALSE" => std::option::Option::Some(Self::ALIGN_COUNT_FALSE),
                "ALIGN_FRACTION_TRUE" => std::option::Option::Some(Self::ALIGN_FRACTION_TRUE),
                "ALIGN_PERCENTILE_99" => std::option::Option::Some(Self::ALIGN_PERCENTILE_99),
                "ALIGN_PERCENTILE_95" => std::option::Option::Some(Self::ALIGN_PERCENTILE_95),
                "ALIGN_PERCENTILE_50" => std::option::Option::Some(Self::ALIGN_PERCENTILE_50),
                "ALIGN_PERCENTILE_05" => std::option::Option::Some(Self::ALIGN_PERCENTILE_05),
                "ALIGN_PERCENT_CHANGE" => std::option::Option::Some(Self::ALIGN_PERCENT_CHANGE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Aligner {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Aligner {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// A Reducer operation describes how to aggregate data points from multiple
    /// time series into a single time series, where the value of each data point
    /// in the resulting series is a function of all the already aligned values in
    /// the input time series.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Reducer(i32);

    impl Reducer {
        /// No cross-time series reduction. The output of the `Aligner` is
        /// returned.
        pub const REDUCE_NONE: Reducer = Reducer::new(0);

        /// Reduce by computing the mean value across time series for each
        /// alignment period. This reducer is valid for
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
        /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
        /// numeric or distribution values. The `value_type` of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        pub const REDUCE_MEAN: Reducer = Reducer::new(1);

        /// Reduce by computing the minimum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        pub const REDUCE_MIN: Reducer = Reducer::new(2);

        /// Reduce by computing the maximum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        pub const REDUCE_MAX: Reducer = Reducer::new(3);

        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric and distribution values. The `value_type` of the output is
        /// the same as the `value_type` of the input.
        pub const REDUCE_SUM: Reducer = Reducer::new(4);

        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics with numeric or distribution values. The `value_type`
        /// of the output is `DOUBLE`.
        pub const REDUCE_STDDEV: Reducer = Reducer::new(5);

        /// Reduce by computing the number of data points across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of numeric, Boolean, distribution, and string
        /// `value_type`. The `value_type` of the output is `INT64`.
        pub const REDUCE_COUNT: Reducer = Reducer::new(6);

        /// Reduce by computing the number of `True`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        pub const REDUCE_COUNT_TRUE: Reducer = Reducer::new(7);

        /// Reduce by computing the number of `False`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        pub const REDUCE_COUNT_FALSE: Reducer = Reducer::new(15);

        /// Reduce by computing the ratio of the number of `True`-valued data points
        /// to the total number of data points for each alignment period. This
        /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
        /// The output value is in the range [0.0, 1.0] and has `value_type`
        /// `DOUBLE`.
        pub const REDUCE_FRACTION_TRUE: Reducer = Reducer::new(8);

        /// Reduce by computing the [99th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_99: Reducer = Reducer::new(9);

        /// Reduce by computing the [95th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_95: Reducer = Reducer::new(10);

        /// Reduce by computing the [50th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_50: Reducer = Reducer::new(11);

        /// Reduce by computing the [5th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        pub const REDUCE_PERCENTILE_05: Reducer = Reducer::new(12);

        /// Creates a new Reducer instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("REDUCE_NONE"),
                1 => std::borrow::Cow::Borrowed("REDUCE_MEAN"),
                2 => std::borrow::Cow::Borrowed("REDUCE_MIN"),
                3 => std::borrow::Cow::Borrowed("REDUCE_MAX"),
                4 => std::borrow::Cow::Borrowed("REDUCE_SUM"),
                5 => std::borrow::Cow::Borrowed("REDUCE_STDDEV"),
                6 => std::borrow::Cow::Borrowed("REDUCE_COUNT"),
                7 => std::borrow::Cow::Borrowed("REDUCE_COUNT_TRUE"),
                8 => std::borrow::Cow::Borrowed("REDUCE_FRACTION_TRUE"),
                9 => std::borrow::Cow::Borrowed("REDUCE_PERCENTILE_99"),
                10 => std::borrow::Cow::Borrowed("REDUCE_PERCENTILE_95"),
                11 => std::borrow::Cow::Borrowed("REDUCE_PERCENTILE_50"),
                12 => std::borrow::Cow::Borrowed("REDUCE_PERCENTILE_05"),
                15 => std::borrow::Cow::Borrowed("REDUCE_COUNT_FALSE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "REDUCE_NONE" => std::option::Option::Some(Self::REDUCE_NONE),
                "REDUCE_MEAN" => std::option::Option::Some(Self::REDUCE_MEAN),
                "REDUCE_MIN" => std::option::Option::Some(Self::REDUCE_MIN),
                "REDUCE_MAX" => std::option::Option::Some(Self::REDUCE_MAX),
                "REDUCE_SUM" => std::option::Option::Some(Self::REDUCE_SUM),
                "REDUCE_STDDEV" => std::option::Option::Some(Self::REDUCE_STDDEV),
                "REDUCE_COUNT" => std::option::Option::Some(Self::REDUCE_COUNT),
                "REDUCE_COUNT_TRUE" => std::option::Option::Some(Self::REDUCE_COUNT_TRUE),
                "REDUCE_COUNT_FALSE" => std::option::Option::Some(Self::REDUCE_COUNT_FALSE),
                "REDUCE_FRACTION_TRUE" => std::option::Option::Some(Self::REDUCE_FRACTION_TRUE),
                "REDUCE_PERCENTILE_99" => std::option::Option::Some(Self::REDUCE_PERCENTILE_99),
                "REDUCE_PERCENTILE_95" => std::option::Option::Some(Self::REDUCE_PERCENTILE_95),
                "REDUCE_PERCENTILE_50" => std::option::Option::Some(Self::REDUCE_PERCENTILE_50),
                "REDUCE_PERCENTILE_05" => std::option::Option::Some(Self::REDUCE_PERCENTILE_05),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Reducer {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Reducer {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Describes a ranking-based time series filter. Each input time series is
/// ranked with an aligner. The filter will allow up to `num_time_series` time
/// series to pass through it, selecting them based on the relative ranking.
///
/// For example, if `ranking_method` is `METHOD_MEAN`,`direction` is `BOTTOM`,
/// and `num_time_series` is 3, then the 3 times series with the lowest mean
/// values will pass through the filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PickTimeSeriesFilter {
    /// `ranking_method` is applied to each time series independently to produce
    /// the value which will be used to compare the time series to other time
    /// series.
    pub ranking_method: crate::model::pick_time_series_filter::Method,

    /// How many time series to allow to pass through the filter.
    pub num_time_series: i32,

    /// How to use the ranking to select time series that pass through the filter.
    pub direction: crate::model::pick_time_series_filter::Direction,

    /// Select the top N streams/time series within this time interval
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<gtype::model::Interval>,
}

impl PickTimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ranking_method][crate::model::PickTimeSeriesFilter::ranking_method].
    pub fn set_ranking_method<
        T: std::convert::Into<crate::model::pick_time_series_filter::Method>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_method = v.into();
        self
    }

    /// Sets the value of [num_time_series][crate::model::PickTimeSeriesFilter::num_time_series].
    pub fn set_num_time_series<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_time_series = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::PickTimeSeriesFilter::direction].
    pub fn set_direction<
        T: std::convert::Into<crate::model::pick_time_series_filter::Direction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::PickTimeSeriesFilter::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<gtype::model::Interval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }
}

impl wkt::message::Message for PickTimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.PickTimeSeriesFilter"
    }
}

/// Defines additional types related to PickTimeSeriesFilter
pub mod pick_time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The value reducers that can be applied to a `PickTimeSeriesFilter`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Method(i32);

    impl Method {
        /// Not allowed. You must specify a different `Method` if you specify a
        /// `PickTimeSeriesFilter`.
        pub const METHOD_UNSPECIFIED: Method = Method::new(0);

        /// Select the mean of all values.
        pub const METHOD_MEAN: Method = Method::new(1);

        /// Select the maximum value.
        pub const METHOD_MAX: Method = Method::new(2);

        /// Select the minimum value.
        pub const METHOD_MIN: Method = Method::new(3);

        /// Compute the sum of all values.
        pub const METHOD_SUM: Method = Method::new(4);

        /// Select the most recent value.
        pub const METHOD_LATEST: Method = Method::new(5);

        /// Creates a new Method instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("METHOD_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("METHOD_MEAN"),
                2 => std::borrow::Cow::Borrowed("METHOD_MAX"),
                3 => std::borrow::Cow::Borrowed("METHOD_MIN"),
                4 => std::borrow::Cow::Borrowed("METHOD_SUM"),
                5 => std::borrow::Cow::Borrowed("METHOD_LATEST"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "METHOD_UNSPECIFIED" => std::option::Option::Some(Self::METHOD_UNSPECIFIED),
                "METHOD_MEAN" => std::option::Option::Some(Self::METHOD_MEAN),
                "METHOD_MAX" => std::option::Option::Some(Self::METHOD_MAX),
                "METHOD_MIN" => std::option::Option::Some(Self::METHOD_MIN),
                "METHOD_SUM" => std::option::Option::Some(Self::METHOD_SUM),
                "METHOD_LATEST" => std::option::Option::Some(Self::METHOD_LATEST),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Describes the ranking directions.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Direction(i32);

    impl Direction {
        /// Not allowed. You must specify a different `Direction` if you specify a
        /// `PickTimeSeriesFilter`.
        pub const DIRECTION_UNSPECIFIED: Direction = Direction::new(0);

        /// Pass the highest `num_time_series` ranking inputs.
        pub const TOP: Direction = Direction::new(1);

        /// Pass the lowest `num_time_series` ranking inputs.
        pub const BOTTOM: Direction = Direction::new(2);

        /// Creates a new Direction instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DIRECTION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TOP"),
                2 => std::borrow::Cow::Borrowed("BOTTOM"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DIRECTION_UNSPECIFIED" => std::option::Option::Some(Self::DIRECTION_UNSPECIFIED),
                "TOP" => std::option::Option::Some(Self::TOP),
                "BOTTOM" => std::option::Option::Some(Self::BOTTOM),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A filter that ranks streams based on their statistical relation to other
/// streams in a request.
/// Note: This field is deprecated and completely ignored by the API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StatisticalTimeSeriesFilter {
    /// `rankingMethod` is applied to a set of time series, and then the produced
    /// value for each individual time series is used to compare a given time
    /// series to others.
    /// These are methods that cannot be applied stream-by-stream, but rather
    /// require the full context of a request to evaluate time series.
    pub ranking_method: crate::model::statistical_time_series_filter::Method,

    /// How many time series to output.
    pub num_time_series: i32,
}

impl StatisticalTimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ranking_method][crate::model::StatisticalTimeSeriesFilter::ranking_method].
    pub fn set_ranking_method<
        T: std::convert::Into<crate::model::statistical_time_series_filter::Method>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_method = v.into();
        self
    }

    /// Sets the value of [num_time_series][crate::model::StatisticalTimeSeriesFilter::num_time_series].
    pub fn set_num_time_series<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_time_series = v.into();
        self
    }
}

impl wkt::message::Message for StatisticalTimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter"
    }
}

/// Defines additional types related to StatisticalTimeSeriesFilter
pub mod statistical_time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The filter methods that can be applied to a stream.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Method(i32);

    impl Method {
        /// Not allowed in well-formed requests.
        pub const METHOD_UNSPECIFIED: Method = Method::new(0);

        /// Compute the outlier score of each stream.
        pub const METHOD_CLUSTER_OUTLIER: Method = Method::new(1);

        /// Creates a new Method instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("METHOD_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("METHOD_CLUSTER_OUTLIER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "METHOD_UNSPECIFIED" => std::option::Option::Some(Self::METHOD_UNSPECIFIED),
                "METHOD_CLUSTER_OUTLIER" => std::option::Option::Some(Self::METHOD_CLUSTER_OUTLIER),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A Google Stackdriver dashboard. Dashboards define the content and layout
/// of pages in the Stackdriver web application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dashboard {
    /// Identifier. The resource name of the dashboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The mutable, human-readable name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// `etag` is used for optimistic concurrency control as a way to help
    /// prevent simultaneous updates of a policy from overwriting each other.
    /// An `etag` is returned in the response to `GetDashboard`, and
    /// users are expected to put that etag in the request to `UpdateDashboard` to
    /// ensure that their change will be applied to the same version of the
    /// Dashboard configuration. The field should not be passed during
    /// dashboard creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Filters to reduce the amount of data charted based on the filter criteria.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dashboard_filters: std::vec::Vec<crate::model::DashboardFilter>,

    /// Labels applied to the dashboard
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A dashboard's root container element that defines the layout style.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub layout: std::option::Option<crate::model::dashboard::Layout>,
}

impl Dashboard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dashboard::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Dashboard::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Dashboard::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [dashboard_filters][crate::model::Dashboard::dashboard_filters].
    pub fn set_dashboard_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DashboardFilter>,
    {
        use std::iter::Iterator;
        self.dashboard_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Dashboard::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `layout`.
    pub fn set_layout<
        T: std::convert::Into<std::option::Option<crate::model::dashboard::Layout>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.layout = v.into();
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `GridLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_grid_layout(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GridLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::GridLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `MosaicLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_mosaic_layout(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MosaicLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::MosaicLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `RowLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_row_layout(&self) -> std::option::Option<&std::boxed::Box<crate::model::RowLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::RowLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `ColumnLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_column_layout(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ColumnLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::ColumnLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `GridLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_grid_layout<T: std::convert::Into<std::boxed::Box<crate::model::GridLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::GridLayout(v.into()));
        self
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `MosaicLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_mosaic_layout<T: std::convert::Into<std::boxed::Box<crate::model::MosaicLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::MosaicLayout(v.into()));
        self
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `RowLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_row_layout<T: std::convert::Into<std::boxed::Box<crate::model::RowLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::RowLayout(v.into()));
        self
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `ColumnLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_column_layout<T: std::convert::Into<std::boxed::Box<crate::model::ColumnLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::ColumnLayout(v.into()));
        self
    }
}

impl wkt::message::Message for Dashboard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Dashboard"
    }
}

/// Defines additional types related to Dashboard
pub mod dashboard {
    #[allow(unused_imports)]
    use super::*;

    /// A dashboard's root container element that defines the layout style.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Layout {
        /// Content is arranged with a basic layout that re-flows a simple list of
        /// informational elements like widgets or tiles.
        GridLayout(std::boxed::Box<crate::model::GridLayout>),
        /// The content is arranged as a grid of tiles, with each content widget
        /// occupying one or more grid blocks.
        MosaicLayout(std::boxed::Box<crate::model::MosaicLayout>),
        /// The content is divided into equally spaced rows and the widgets are
        /// arranged horizontally.
        RowLayout(std::boxed::Box<crate::model::RowLayout>),
        /// The content is divided into equally spaced columns and the widgets are
        /// arranged vertically.
        ColumnLayout(std::boxed::Box<crate::model::ColumnLayout>),
    }
}

/// A filter to reduce the amount of data charted in relevant widgets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DashboardFilter {
    /// Required. The key for the label
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label_key: std::string::String,

    /// The placeholder text that can be referenced in a filter string or MQL
    /// query. If omitted, the dashboard filter will be applied to all relevant
    /// widgets in the dashboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_variable: std::string::String,

    /// The specified filter type
    pub filter_type: crate::model::dashboard_filter::FilterType,

    /// The default value used in the filter comparison
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub default_value: std::option::Option<crate::model::dashboard_filter::DefaultValue>,
}

impl DashboardFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_key][crate::model::DashboardFilter::label_key].
    pub fn set_label_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label_key = v.into();
        self
    }

    /// Sets the value of [template_variable][crate::model::DashboardFilter::template_variable].
    pub fn set_template_variable<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.template_variable = v.into();
        self
    }

    /// Sets the value of [filter_type][crate::model::DashboardFilter::filter_type].
    pub fn set_filter_type<T: std::convert::Into<crate::model::dashboard_filter::FilterType>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_type = v.into();
        self
    }

    /// Sets the value of `default_value`.
    pub fn set_default_value<
        T: std::convert::Into<std::option::Option<crate::model::dashboard_filter::DefaultValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_value = v.into();
        self
    }

    /// The value of [default_value][crate::model::DashboardFilter::default_value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.default_value.as_ref().and_then(|v| match v {
            crate::model::dashboard_filter::DefaultValue::StringValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [default_value][crate::model::DashboardFilter::default_value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `default_value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = std::option::Option::Some(
            crate::model::dashboard_filter::DefaultValue::StringValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DashboardFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.DashboardFilter"
    }
}

/// Defines additional types related to DashboardFilter
pub mod dashboard_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The type for the dashboard filter
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FilterType(i32);

    impl FilterType {
        /// Filter type is unspecified. This is not valid in a well-formed request.
        pub const FILTER_TYPE_UNSPECIFIED: FilterType = FilterType::new(0);

        /// Filter on a resource label value
        pub const RESOURCE_LABEL: FilterType = FilterType::new(1);

        /// Filter on a metrics label value
        pub const METRIC_LABEL: FilterType = FilterType::new(2);

        /// Filter on a user metadata label value
        pub const USER_METADATA_LABEL: FilterType = FilterType::new(3);

        /// Filter on a system metadata label value
        pub const SYSTEM_METADATA_LABEL: FilterType = FilterType::new(4);

        /// Filter on a group id
        pub const GROUP: FilterType = FilterType::new(5);

        /// Creates a new FilterType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FILTER_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RESOURCE_LABEL"),
                2 => std::borrow::Cow::Borrowed("METRIC_LABEL"),
                3 => std::borrow::Cow::Borrowed("USER_METADATA_LABEL"),
                4 => std::borrow::Cow::Borrowed("SYSTEM_METADATA_LABEL"),
                5 => std::borrow::Cow::Borrowed("GROUP"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FILTER_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FILTER_TYPE_UNSPECIFIED)
                }
                "RESOURCE_LABEL" => std::option::Option::Some(Self::RESOURCE_LABEL),
                "METRIC_LABEL" => std::option::Option::Some(Self::METRIC_LABEL),
                "USER_METADATA_LABEL" => std::option::Option::Some(Self::USER_METADATA_LABEL),
                "SYSTEM_METADATA_LABEL" => std::option::Option::Some(Self::SYSTEM_METADATA_LABEL),
                "GROUP" => std::option::Option::Some(Self::GROUP),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FilterType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FilterType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The default value used in the filter comparison
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DefaultValue {
        /// A variable-length string value.
        StringValue(std::string::String),
    }
}

/// The `CreateDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDashboardRequest {
    /// Required. The project on which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// The `[PROJECT_ID_OR_NUMBER]` must match the dashboard resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The initial dashboard specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dashboard: std::option::Option<crate::model::Dashboard>,

    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    pub validate_only: bool,
}

impl CreateDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDashboardRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dashboard][crate::model::CreateDashboardRequest::dashboard].
    pub fn set_dashboard<T: std::convert::Into<std::option::Option<crate::model::Dashboard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dashboard = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDashboardRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.CreateDashboardRequest"
    }
}

/// The `ListDashboards` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDashboardsRequest {
    /// Required. The scope of the dashboards to list. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A positive number that is the maximum number of results to return.
    /// If unspecified, a default of 1000 is used.
    pub page_size: i32,

    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return additional results from the previous
    /// method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDashboardsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDashboardsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDashboardsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDashboardsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDashboardsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ListDashboardsRequest"
    }
}

/// The `ListDashboards` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDashboardsResponse {
    /// The list of requested dashboards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dashboards: std::vec::Vec<crate::model::Dashboard>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDashboardsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDashboardsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [dashboards][crate::model::ListDashboardsResponse::dashboards].
    pub fn set_dashboards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dashboard>,
    {
        use std::iter::Iterator;
        self.dashboards = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDashboardsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ListDashboardsResponse"
    }
}

impl gax::paginator::PageableResponse for ListDashboardsResponse {
    type PageItem = crate::model::Dashboard;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dashboards
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The `GetDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is one of:
    ///
    /// - `dashboards/[DASHBOARD_ID]` (for system dashboards)
    /// - `projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID]`
    ///   (for custom dashboards).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDashboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.GetDashboardRequest"
    }
}

/// The `DeleteDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDashboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.DeleteDashboardRequest"
    }
}

/// The `UpdateDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDashboardRequest {
    /// Required. The dashboard that will replace the existing dashboard.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dashboard: std::option::Option<crate::model::Dashboard>,

    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    pub validate_only: bool,
}

impl UpdateDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dashboard][crate::model::UpdateDashboardRequest::dashboard].
    pub fn set_dashboard<T: std::convert::Into<std::option::Option<crate::model::Dashboard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dashboard = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDashboardRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.UpdateDashboardRequest"
    }
}

/// A widget that displays a list of error groups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorReportingPanel {
    /// The resource name of the Google Cloud Platform project. Written
    /// as `projects/{projectID}` or `projects/{projectNumber}`, where
    /// `{projectID}` and `{projectNumber}` can be found in the
    /// [Google Cloud console](https://support.google.com/cloud/answer/6158840).
    ///
    /// Examples: `projects/my-project-123`, `projects/5551234`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub project_names: std::vec::Vec<std::string::String>,

    /// An identifier of the service, such as the name of the
    /// executable, job, or Google App Engine service name. This field is expected
    /// to have a low number of values that are relatively stable over time, as
    /// opposed to `version`, which can be changed whenever new code is deployed.
    ///
    /// Contains the service name for error reports extracted from Google
    /// App Engine logs or `default` if the App Engine default service is used.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services: std::vec::Vec<std::string::String>,

    /// Represents the source code version that the developer provided,
    /// which could represent a version label or a Git SHA-1 hash, for example.
    /// For App Engine standard environment, the version is set to the version of
    /// the app.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<std::string::String>,
}

impl ErrorReportingPanel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_names][crate::model::ErrorReportingPanel::project_names].
    pub fn set_project_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.project_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [services][crate::model::ErrorReportingPanel::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [versions][crate::model::ErrorReportingPanel::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorReportingPanel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ErrorReportingPanel"
    }
}

/// A widget that displays a list of incidents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IncidentList {
    /// Optional. The monitored resource for which incidents are listed.
    /// The resource doesn't need to be fully specified. That is, you can specify
    /// the resource type but not the values of the resource labels.
    /// The resource type and labels are used for filtering.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub monitored_resources: std::vec::Vec<api::model::MonitoredResource>,

    /// Optional. A list of alert policy names to filter the incident list by.
    /// Don't include the project ID prefix in the policy name. For
    /// example, use `alertPolicies/utilization`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policy_names: std::vec::Vec<std::string::String>,
}

impl IncidentList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [monitored_resources][crate::model::IncidentList::monitored_resources].
    pub fn set_monitored_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResource>,
    {
        use std::iter::Iterator;
        self.monitored_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [policy_names][crate::model::IncidentList::policy_names].
    pub fn set_policy_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.policy_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IncidentList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.IncidentList"
    }
}

/// A basic layout divides the available space into vertical columns of equal
/// width and arranges a list of widgets using a row-first strategy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GridLayout {
    /// The number of columns into which the view's width is divided. If omitted
    /// or set to zero, a system default will be used while rendering.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub columns: i64,

    /// The informational elements that are arranged into the columns row-first.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub widgets: std::vec::Vec<crate::model::Widget>,
}

impl GridLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::GridLayout::columns].
    pub fn set_columns<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.columns = v.into();
        self
    }

    /// Sets the value of [widgets][crate::model::GridLayout::widgets].
    pub fn set_widgets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Widget>,
    {
        use std::iter::Iterator;
        self.widgets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GridLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.GridLayout"
    }
}

/// A mosaic layout divides the available space into a grid of blocks, and
/// overlays the grid with tiles. Unlike `GridLayout`, tiles may span multiple
/// grid blocks and can be placed at arbitrary locations in the grid.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MosaicLayout {
    /// The number of columns in the mosaic grid. The number of columns must be
    /// between 1 and 12, inclusive.
    pub columns: i32,

    /// The tiles to display.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tiles: std::vec::Vec<crate::model::mosaic_layout::Tile>,
}

impl MosaicLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::MosaicLayout::columns].
    pub fn set_columns<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.columns = v.into();
        self
    }

    /// Sets the value of [tiles][crate::model::MosaicLayout::tiles].
    pub fn set_tiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::mosaic_layout::Tile>,
    {
        use std::iter::Iterator;
        self.tiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MosaicLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.MosaicLayout"
    }
}

/// Defines additional types related to MosaicLayout
pub mod mosaic_layout {
    #[allow(unused_imports)]
    use super::*;

    /// A single tile in the mosaic. The placement and size of the tile are
    /// configurable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Tile {
        /// The zero-indexed position of the tile in grid blocks relative to the
        /// left edge of the grid. Tiles must be contained within the specified
        /// number of columns. `x_pos` cannot be negative.
        pub x_pos: i32,

        /// The zero-indexed position of the tile in grid blocks relative to the
        /// top edge of the grid. `y_pos` cannot be negative.
        pub y_pos: i32,

        /// The width of the tile, measured in grid blocks. Tiles must have a
        /// minimum width of 1.
        pub width: i32,

        /// The height of the tile, measured in grid blocks. Tiles must have a
        /// minimum height of 1.
        pub height: i32,

        /// The informational widget contained in the tile. For example an `XyChart`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub widget: std::option::Option<crate::model::Widget>,
    }

    impl Tile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [x_pos][crate::model::mosaic_layout::Tile::x_pos].
        pub fn set_x_pos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.x_pos = v.into();
            self
        }

        /// Sets the value of [y_pos][crate::model::mosaic_layout::Tile::y_pos].
        pub fn set_y_pos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.y_pos = v.into();
            self
        }

        /// Sets the value of [width][crate::model::mosaic_layout::Tile::width].
        pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.width = v.into();
            self
        }

        /// Sets the value of [height][crate::model::mosaic_layout::Tile::height].
        pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.height = v.into();
            self
        }

        /// Sets the value of [widget][crate::model::mosaic_layout::Tile::widget].
        pub fn set_widget<T: std::convert::Into<std::option::Option<crate::model::Widget>>>(
            mut self,
            v: T,
        ) -> Self {
            self.widget = v.into();
            self
        }
    }

    impl wkt::message::Message for Tile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.MosaicLayout.Tile"
        }
    }
}

/// A simplified layout that divides the available space into rows
/// and arranges a set of widgets horizontally in each row.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RowLayout {
    /// The rows of content to display.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rows: std::vec::Vec<crate::model::row_layout::Row>,
}

impl RowLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rows][crate::model::RowLayout::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::row_layout::Row>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RowLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.RowLayout"
    }
}

/// Defines additional types related to RowLayout
pub mod row_layout {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the layout properties and content for a row.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Row {
        /// The relative weight of this row. The row weight is used to adjust the
        /// height of rows on the screen (relative to peers). Greater the weight,
        /// greater the height of the row on the screen. If omitted, a value
        /// of 1 is used while rendering.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub weight: i64,

        /// The display widgets arranged horizontally in this row.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub widgets: std::vec::Vec<crate::model::Widget>,
    }

    impl Row {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [weight][crate::model::row_layout::Row::weight].
        pub fn set_weight<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.weight = v.into();
            self
        }

        /// Sets the value of [widgets][crate::model::row_layout::Row::widgets].
        pub fn set_widgets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Widget>,
        {
            use std::iter::Iterator;
            self.widgets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Row {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.RowLayout.Row"
        }
    }
}

/// A simplified layout that divides the available space into vertical columns
/// and arranges a set of widgets vertically in each column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnLayout {
    /// The columns of content to display.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::column_layout::Column>,
}

impl ColumnLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::ColumnLayout::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::column_layout::Column>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ColumnLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ColumnLayout"
    }
}

/// Defines additional types related to ColumnLayout
pub mod column_layout {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the layout properties and content for a column.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Column {
        /// The relative weight of this column. The column weight is used to adjust
        /// the width of columns on the screen (relative to peers).
        /// Greater the weight, greater the width of the column on the screen.
        /// If omitted, a value of 1 is used while rendering.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub weight: i64,

        /// The display widgets arranged vertically in this column.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub widgets: std::vec::Vec<crate::model::Widget>,
    }

    impl Column {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [weight][crate::model::column_layout::Column::weight].
        pub fn set_weight<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.weight = v.into();
            self
        }

        /// Sets the value of [widgets][crate::model::column_layout::Column::widgets].
        pub fn set_widgets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Widget>,
        {
            use std::iter::Iterator;
            self.widgets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Column {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.ColumnLayout.Column"
        }
    }
}

/// A widget that displays a stream of log.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogsPanel {
    /// A filter that chooses which log entries to return.  See [Advanced Logs
    /// Queries](https://cloud.google.com/logging/docs/view/advanced-queries).
    /// Only log entries that match the filter are returned.  An empty filter
    /// matches all log entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The names of logging resources to collect logs for. Currently only projects
    /// are supported. If empty, the widget will default to the host project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_names: std::vec::Vec<std::string::String>,
}

impl LogsPanel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::LogsPanel::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [resource_names][crate::model::LogsPanel::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LogsPanel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.LogsPanel"
    }
}

/// TimeSeriesQuery collects the set of supported methods for querying time
/// series data from the Stackdriver metrics API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesQuery {
    /// The unit of data contained in fetched time series. If non-empty, this
    /// unit will override any unit that accompanies fetched data. The format is
    /// the same as the
    /// [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors)
    /// field in `MetricDescriptor`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub unit_override: std::string::String,

    /// Optional. If set, Cloud Monitoring will treat the full query duration as
    /// the alignment period so that there will be only 1 output value.
    ///
    /// *Note: This could override the configured alignment period except for
    /// the cases where a series of data points are expected, like
    ///
    /// - XyChart
    /// - Scorecard's spark chart
    pub output_full_duration: bool,

    /// Parameters needed to obtain data for the chart.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::time_series_query::Source>,
}

impl TimeSeriesQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [unit_override][crate::model::TimeSeriesQuery::unit_override].
    pub fn set_unit_override<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.unit_override = v.into();
        self
    }

    /// Sets the value of [output_full_duration][crate::model::TimeSeriesQuery::output_full_duration].
    pub fn set_output_full_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.output_full_duration = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::time_series_query::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesFilterRatio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_time_series_filter_ratio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesFilterRatio>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesFilterRatio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesQueryLanguage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_time_series_query_language(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesQueryLanguage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `PrometheusQuery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_prometheus_query(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::PrometheusQuery(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesFilter(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesFilterRatio`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_filter_ratio<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesFilterRatio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesFilterRatio(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesQueryLanguage`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_query_language<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesQueryLanguage(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `PrometheusQuery`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_prometheus_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::PrometheusQuery(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesQuery"
    }
}

/// Defines additional types related to TimeSeriesQuery
pub mod time_series_query {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters needed to obtain data for the chart.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Filter parameters to fetch time series.
        TimeSeriesFilter(std::boxed::Box<crate::model::TimeSeriesFilter>),
        /// Parameters to fetch a ratio between two time series filters.
        TimeSeriesFilterRatio(std::boxed::Box<crate::model::TimeSeriesFilterRatio>),
        /// A query used to fetch time series with MQL.
        TimeSeriesQueryLanguage(std::string::String),
        /// A query used to fetch time series with PromQL.
        PrometheusQuery(std::string::String),
    }
}

/// A filter that defines a subset of time series data that is displayed in a
/// widget. Time series data is fetched using the
/// [`ListTimeSeries`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesFilter {
    /// Required. The [monitoring
    /// filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies
    /// the metric types, resources, and projects to query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// By default, the raw time series data is returned.
    /// Use this field to combine multiple time series for different views of the
    /// data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aggregation: std::option::Option<crate::model::Aggregation>,

    /// Apply a second aggregation after `aggregation` is applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Selects an optional time series filter.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output_filter: std::option::Option<crate::model::time_series_filter::OutputFilter>,
}

impl TimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::TimeSeriesFilter::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [aggregation][crate::model::TimeSeriesFilter::aggregation].
    pub fn set_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation = v.into();
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::TimeSeriesFilter::secondary_aggregation].
    pub fn set_secondary_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_aggregation = v.into();
        self
    }

    /// Sets the value of `output_filter`.
    pub fn set_output_filter<
        T: std::convert::Into<std::option::Option<crate::model::time_series_filter::OutputFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = v.into();
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// if it holds a `PickTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pick_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PickTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// if it holds a `StatisticalTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_statistical_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// to hold a `PickTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_pick_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::PickTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(v.into()),
        );
        self
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// to hold a `StatisticalTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_statistical_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilter"
    }
}

/// Defines additional types related to TimeSeriesFilter
pub mod time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Selects an optional time series filter.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        PickTimeSeriesFilter(std::boxed::Box<crate::model::PickTimeSeriesFilter>),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        StatisticalTimeSeriesFilter(std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>),
    }
}

/// A pair of time series filters that define a ratio computation. The output
/// time series is the pair-wise division of each aligned element from the
/// numerator and denominator time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesFilterRatio {
    /// The numerator of the ratio.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub numerator: std::option::Option<crate::model::time_series_filter_ratio::RatioPart>,

    /// The denominator of the ratio.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub denominator: std::option::Option<crate::model::time_series_filter_ratio::RatioPart>,

    /// Apply a second aggregation after the ratio is computed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output_filter: std::option::Option<crate::model::time_series_filter_ratio::OutputFilter>,
}

impl TimeSeriesFilterRatio {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [numerator][crate::model::TimeSeriesFilterRatio::numerator].
    pub fn set_numerator<
        T: std::convert::Into<std::option::Option<crate::model::time_series_filter_ratio::RatioPart>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.numerator = v.into();
        self
    }

    /// Sets the value of [denominator][crate::model::TimeSeriesFilterRatio::denominator].
    pub fn set_denominator<
        T: std::convert::Into<std::option::Option<crate::model::time_series_filter_ratio::RatioPart>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.denominator = v.into();
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::TimeSeriesFilterRatio::secondary_aggregation].
    pub fn set_secondary_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_aggregation = v.into();
        self
    }

    /// Sets the value of `output_filter`.
    pub fn set_output_filter<
        T: std::convert::Into<
            std::option::Option<crate::model::time_series_filter_ratio::OutputFilter>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = v.into();
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// if it holds a `PickTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pick_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PickTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// if it holds a `StatisticalTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_statistical_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// to hold a `PickTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_pick_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::PickTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(v.into()),
        );
        self
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// to hold a `StatisticalTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_statistical_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesFilterRatio {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilterRatio"
    }
}

/// Defines additional types related to TimeSeriesFilterRatio
pub mod time_series_filter_ratio {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a query to build the numerator or denominator of a
    /// TimeSeriesFilterRatio.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RatioPart {
        /// Required. The [monitoring
        /// filter](https://cloud.google.com/monitoring/api/v3/filters) that
        /// identifies the metric types, resources, and projects to query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        /// By default, the raw time series data is returned.
        /// Use this field to combine multiple time series for different views of the
        /// data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub aggregation: std::option::Option<crate::model::Aggregation>,
    }

    impl RatioPart {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::time_series_filter_ratio::RatioPart::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }

        /// Sets the value of [aggregation][crate::model::time_series_filter_ratio::RatioPart::aggregation].
        pub fn set_aggregation<
            T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregation = v.into();
            self
        }
    }

    impl wkt::message::Message for RatioPart {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilterRatio.RatioPart"
        }
    }

    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        PickTimeSeriesFilter(std::boxed::Box<crate::model::PickTimeSeriesFilter>),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        StatisticalTimeSeriesFilter(std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>),
    }
}

/// Defines a threshold for categorizing time series values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Threshold {
    /// A label for the threshold.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label: std::string::String,

    /// The value of the threshold. The value should be defined in the native scale
    /// of the metric.
    pub value: f64,

    /// The state color for this threshold. Color is not allowed in a XyChart.
    pub color: crate::model::threshold::Color,

    /// The direction for the current threshold. Direction is not allowed in a
    /// XyChart.
    pub direction: crate::model::threshold::Direction,

    /// The target axis to use for plotting the threshold. Target axis is not
    /// allowed in a Scorecard.
    pub target_axis: crate::model::threshold::TargetAxis,
}

impl Threshold {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label][crate::model::Threshold::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Threshold::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [color][crate::model::Threshold::color].
    pub fn set_color<T: std::convert::Into<crate::model::threshold::Color>>(
        mut self,
        v: T,
    ) -> Self {
        self.color = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::Threshold::direction].
    pub fn set_direction<T: std::convert::Into<crate::model::threshold::Direction>>(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [target_axis][crate::model::Threshold::target_axis].
    pub fn set_target_axis<T: std::convert::Into<crate::model::threshold::TargetAxis>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_axis = v.into();
        self
    }
}

impl wkt::message::Message for Threshold {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Threshold"
    }
}

/// Defines additional types related to Threshold
pub mod threshold {
    #[allow(unused_imports)]
    use super::*;

    /// The color suggests an interpretation to the viewer when actual values cross
    /// the threshold. Comments on each color provide UX guidance on how users can
    /// be expected to interpret a given state color.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Color(i32);

    impl Color {
        /// Color is unspecified. Not allowed in well-formed requests.
        pub const COLOR_UNSPECIFIED: Color = Color::new(0);

        /// Crossing the threshold is "concerning" behavior.
        pub const YELLOW: Color = Color::new(4);

        /// Crossing the threshold is "emergency" behavior.
        pub const RED: Color = Color::new(6);

        /// Creates a new Color instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COLOR_UNSPECIFIED"),
                4 => std::borrow::Cow::Borrowed("YELLOW"),
                6 => std::borrow::Cow::Borrowed("RED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COLOR_UNSPECIFIED" => std::option::Option::Some(Self::COLOR_UNSPECIFIED),
                "YELLOW" => std::option::Option::Some(Self::YELLOW),
                "RED" => std::option::Option::Some(Self::RED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Color {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Color {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Whether the threshold is considered crossed by an actual value above or
    /// below its threshold value.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Direction(i32);

    impl Direction {
        /// Not allowed in well-formed requests.
        pub const DIRECTION_UNSPECIFIED: Direction = Direction::new(0);

        /// The threshold will be considered crossed if the actual value is above
        /// the threshold value.
        pub const ABOVE: Direction = Direction::new(1);

        /// The threshold will be considered crossed if the actual value is below
        /// the threshold value.
        pub const BELOW: Direction = Direction::new(2);

        /// Creates a new Direction instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DIRECTION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ABOVE"),
                2 => std::borrow::Cow::Borrowed("BELOW"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DIRECTION_UNSPECIFIED" => std::option::Option::Some(Self::DIRECTION_UNSPECIFIED),
                "ABOVE" => std::option::Option::Some(Self::ABOVE),
                "BELOW" => std::option::Option::Some(Self::BELOW),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// An axis identifier.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TargetAxis(i32);

    impl TargetAxis {
        /// The target axis was not specified. Defaults to Y1.
        pub const TARGET_AXIS_UNSPECIFIED: TargetAxis = TargetAxis::new(0);

        /// The y_axis (the right axis of chart).
        pub const Y1: TargetAxis = TargetAxis::new(1);

        /// The y2_axis (the left axis of chart).
        pub const Y2: TargetAxis = TargetAxis::new(2);

        /// Creates a new TargetAxis instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TARGET_AXIS_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("Y1"),
                2 => std::borrow::Cow::Borrowed("Y2"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TARGET_AXIS_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TARGET_AXIS_UNSPECIFIED)
                }
                "Y1" => std::option::Option::Some(Self::Y1),
                "Y2" => std::option::Option::Some(Self::Y2),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TargetAxis {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TargetAxis {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A widget that displays timeseries data as a pie or a donut.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PieChart {
    /// Required. The queries for the chart's data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sets: std::vec::Vec<crate::model::pie_chart::PieChartDataSet>,

    /// Required. Indicates the visualization type for the PieChart.
    pub chart_type: crate::model::pie_chart::PieChartType,

    /// Optional. Indicates whether or not the pie chart should show slices' labels
    pub show_labels: bool,
}

impl PieChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [chart_type][crate::model::PieChart::chart_type].
    pub fn set_chart_type<T: std::convert::Into<crate::model::pie_chart::PieChartType>>(
        mut self,
        v: T,
    ) -> Self {
        self.chart_type = v.into();
        self
    }

    /// Sets the value of [show_labels][crate::model::PieChart::show_labels].
    pub fn set_show_labels<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_labels = v.into();
        self
    }

    /// Sets the value of [data_sets][crate::model::PieChart::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pie_chart::PieChartDataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PieChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.PieChart"
    }
}

/// Defines additional types related to PieChart
pub mod pie_chart {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PieChartDataSet {
        /// Required. The query for the PieChart. See,
        /// `google.monitoring.dashboard.v1.TimeSeriesQuery`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// Optional. A template for the name of the slice. This name will be
        /// displayed in the legend and the tooltip of the pie chart. It replaces the
        /// auto-generated names for the slices. For example, if the template is set
        /// to
        /// `${resource.labels.zone}`, the zone's value will be used for the name
        /// instead of the default name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub slice_name_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query. For example, if the data is published once every 10
        /// minutes, the `min_alignment_period` should be at least 10 minutes. It
        /// would not make sense to fetch and align data at one minute intervals.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,
    }

    impl PieChartDataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::pie_chart::PieChartDataSet::time_series_query].
        pub fn set_time_series_query<
            T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series_query = v.into();
            self
        }

        /// Sets the value of [slice_name_template][crate::model::pie_chart::PieChartDataSet::slice_name_template].
        pub fn set_slice_name_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.slice_name_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::pie_chart::PieChartDataSet::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }
    }

    impl wkt::message::Message for PieChartDataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.PieChart.PieChartDataSet"
        }
    }

    /// Types for the pie chart.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PieChartType(i32);

    impl PieChartType {
        /// The zero value. No type specified. Do not use.
        pub const PIE_CHART_TYPE_UNSPECIFIED: PieChartType = PieChartType::new(0);

        /// A Pie type PieChart.
        pub const PIE: PieChartType = PieChartType::new(1);

        /// Similar to PIE, but the DONUT type PieChart has a hole in the middle.
        pub const DONUT: PieChartType = PieChartType::new(2);

        /// Creates a new PieChartType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PIE_CHART_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PIE"),
                2 => std::borrow::Cow::Borrowed("DONUT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PIE_CHART_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PIE_CHART_TYPE_UNSPECIFIED)
                }
                "PIE" => std::option::Option::Some(Self::PIE),
                "DONUT" => std::option::Option::Some(Self::DONUT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for PieChartType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for PieChartType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A widget showing the latest value of a metric, and how this value relates to
/// one or more thresholds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Scorecard {
    /// Required. Fields for querying time series data from the
    /// Stackdriver metrics API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

    /// The thresholds used to determine the state of the scorecard given the
    /// time series' current value. For an actual value x, the scorecard is in a
    /// danger state if x is less than or equal to a danger threshold that triggers
    /// below, or greater than or equal to a danger threshold that triggers above.
    /// Similarly, if x is above/below a warning threshold that triggers
    /// above/below, then the scorecard is in a warning state - unless x also puts
    /// it in a danger state. (Danger trumps warning.)
    ///
    /// As an example, consider a scorecard with the following four thresholds:
    ///
    /// ```norust
    /// {
    ///   value: 90,
    ///   category: 'DANGER',
    ///   trigger: 'ABOVE',
    /// },
    /// {
    ///   value: 70,
    ///   category: 'WARNING',
    ///   trigger: 'ABOVE',
    /// },
    /// {
    ///   value: 10,
    ///   category: 'DANGER',
    ///   trigger: 'BELOW',
    /// },
    /// {
    ///   value: 20,
    ///   category: 'WARNING',
    ///   trigger: 'BELOW',
    /// }
    /// ```
    ///
    /// Then: values less than or equal to 10 would put the scorecard in a DANGER
    /// state, values greater than 10 but less than or equal to 20 a WARNING state,
    /// values strictly between 20 and 70 an OK state, values greater than or equal
    /// to 70 but less than 90 a WARNING state, and values greater than or equal to
    /// 90 a DANGER state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub thresholds: std::vec::Vec<crate::model::Threshold>,

    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_view: std::option::Option<crate::model::scorecard::DataView>,
}

impl Scorecard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_query][crate::model::Scorecard::time_series_query].
    pub fn set_time_series_query<
        T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_series_query = v.into();
        self
    }

    /// Sets the value of [thresholds][crate::model::Scorecard::thresholds].
    pub fn set_thresholds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Threshold>,
    {
        use std::iter::Iterator;
        self.thresholds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `data_view`.
    pub fn set_data_view<
        T: std::convert::Into<std::option::Option<crate::model::scorecard::DataView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view = v.into();
        self
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `GaugeView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gauge_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scorecard::GaugeView>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::GaugeView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `SparkChartView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_spark_chart_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scorecard::SparkChartView>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::SparkChartView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `BlankView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_blank_view(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::BlankView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `GaugeView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_gauge_view<
        T: std::convert::Into<std::boxed::Box<crate::model::scorecard::GaugeView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::GaugeView(v.into()));
        self
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `SparkChartView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_spark_chart_view<
        T: std::convert::Into<std::boxed::Box<crate::model::scorecard::SparkChartView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::SparkChartView(v.into()));
        self
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `BlankView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_blank_view<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::BlankView(v.into()));
        self
    }
}

impl wkt::message::Message for Scorecard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard"
    }
}

/// Defines additional types related to Scorecard
pub mod scorecard {
    #[allow(unused_imports)]
    use super::*;

    /// A gauge chart shows where the current value sits within a pre-defined
    /// range. The upper and lower bounds should define the possible range of
    /// values for the scorecard's query (inclusive).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GaugeView {
        /// The lower bound for this gauge chart. The value of the chart should
        /// always be greater than or equal to this.
        pub lower_bound: f64,

        /// The upper bound for this gauge chart. The value of the chart should
        /// always be less than or equal to this.
        pub upper_bound: f64,
    }

    impl GaugeView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lower_bound][crate::model::scorecard::GaugeView::lower_bound].
        pub fn set_lower_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.lower_bound = v.into();
            self
        }

        /// Sets the value of [upper_bound][crate::model::scorecard::GaugeView::upper_bound].
        pub fn set_upper_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.upper_bound = v.into();
            self
        }
    }

    impl wkt::message::Message for GaugeView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard.GaugeView"
        }
    }

    /// A sparkChart is a small chart suitable for inclusion in a table-cell or
    /// inline in text. This message contains the configuration for a sparkChart
    /// to show up on a Scorecard, showing recent trends of the scorecard's
    /// timeseries.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SparkChartView {
        /// Required. The type of sparkchart to show in this chartView.
        pub spark_chart_type: crate::model::SparkChartType,

        /// The lower bound on data point frequency in the chart implemented by
        /// specifying the minimum alignment period to use in a time series query.
        /// For example, if the data is published once every 10 minutes it would not
        /// make sense to fetch and align data at one minute intervals. This field is
        /// optional and exists only as a hint.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,
    }

    impl SparkChartView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [spark_chart_type][crate::model::scorecard::SparkChartView::spark_chart_type].
        pub fn set_spark_chart_type<T: std::convert::Into<crate::model::SparkChartType>>(
            mut self,
            v: T,
        ) -> Self {
            self.spark_chart_type = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::scorecard::SparkChartView::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }
    }

    impl wkt::message::Message for SparkChartView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard.SparkChartView"
        }
    }

    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataView {
        /// Will cause the scorecard to show a gauge chart.
        GaugeView(std::boxed::Box<crate::model::scorecard::GaugeView>),
        /// Will cause the scorecard to show a spark chart.
        SparkChartView(std::boxed::Box<crate::model::scorecard::SparkChartView>),
        /// Will cause the `Scorecard` to show only the value, with no indicator to
        /// its value relative to its thresholds.
        BlankView(std::boxed::Box<wkt::Empty>),
    }
}

/// A widget that defines a new section header. Sections populate a table of
/// contents and allow easier navigation of long-form content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SectionHeader {
    /// The subtitle of the section
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subtitle: std::string::String,

    /// Whether to insert a divider below the section in the table of contents
    pub divider_below: bool,
}

impl SectionHeader {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subtitle][crate::model::SectionHeader::subtitle].
    pub fn set_subtitle<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subtitle = v.into();
        self
    }

    /// Sets the value of [divider_below][crate::model::SectionHeader::divider_below].
    pub fn set_divider_below<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.divider_below = v.into();
        self
    }
}

impl wkt::message::Message for SectionHeader {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.SectionHeader"
    }
}

/// A widget that groups the other widgets by using a dropdown menu. All widgets
/// that are within the area spanned by the grouping widget are considered
/// member widgets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SingleViewGroup {}

impl SingleViewGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SingleViewGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.SingleViewGroup"
    }
}

/// A table that displays time series data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesTable {
    /// Required. The data displayed in this table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sets: std::vec::Vec<crate::model::time_series_table::TableDataSet>,

    /// Optional. Store rendering strategy
    pub metric_visualization: crate::model::time_series_table::MetricVisualization,

    /// Optional. The list of the persistent column settings for the table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub column_settings: std::vec::Vec<crate::model::time_series_table::ColumnSettings>,
}

impl TimeSeriesTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_visualization][crate::model::TimeSeriesTable::metric_visualization].
    pub fn set_metric_visualization<
        T: std::convert::Into<crate::model::time_series_table::MetricVisualization>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_visualization = v.into();
        self
    }

    /// Sets the value of [data_sets][crate::model::TimeSeriesTable::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_table::TableDataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [column_settings][crate::model::TimeSeriesTable::column_settings].
    pub fn set_column_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_table::ColumnSettings>,
    {
        use std::iter::Iterator;
        self.column_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable"
    }
}

/// Defines additional types related to TimeSeriesTable
pub mod time_series_table {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition with table options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TableDataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// Optional. A template string for naming `TimeSeries` in the resulting data
        /// set. This should be a string with interpolations of the form
        /// `${label_name}`, which will resolve to the label's value i.e.
        /// "${resource.labels.project_id}."
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        /// Optional. Table display options for configuring how the table is
        /// rendered.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub table_display_options: std::option::Option<crate::model::TableDisplayOptions>,
    }

    impl TableDataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::time_series_table::TableDataSet::time_series_query].
        pub fn set_time_series_query<
            T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series_query = v.into();
            self
        }

        /// Sets the value of [table_template][crate::model::time_series_table::TableDataSet::table_template].
        pub fn set_table_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.table_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::time_series_table::TableDataSet::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }

        /// Sets the value of [table_display_options][crate::model::time_series_table::TableDataSet::table_display_options].
        pub fn set_table_display_options<
            T: std::convert::Into<std::option::Option<crate::model::TableDisplayOptions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.table_display_options = v.into();
            self
        }
    }

    impl wkt::message::Message for TableDataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable.TableDataSet"
        }
    }

    /// The persistent settings for a table's columns.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ColumnSettings {
        /// Required. The id of the column.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub column: std::string::String,

        /// Required. Whether the column should be visible on page load.
        pub visible: bool,
    }

    impl ColumnSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [column][crate::model::time_series_table::ColumnSettings::column].
        pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }

        /// Sets the value of [visible][crate::model::time_series_table::ColumnSettings::visible].
        pub fn set_visible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.visible = v.into();
            self
        }
    }

    impl wkt::message::Message for ColumnSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable.ColumnSettings"
        }
    }

    /// Enum for metric metric_visualization
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MetricVisualization(i32);

    impl MetricVisualization {
        /// Unspecified state
        pub const METRIC_VISUALIZATION_UNSPECIFIED: MetricVisualization =
            MetricVisualization::new(0);

        /// Default text rendering
        pub const NUMBER: MetricVisualization = MetricVisualization::new(1);

        /// Horizontal bar rendering
        pub const BAR: MetricVisualization = MetricVisualization::new(2);

        /// Creates a new MetricVisualization instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("METRIC_VISUALIZATION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NUMBER"),
                2 => std::borrow::Cow::Borrowed("BAR"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "METRIC_VISUALIZATION_UNSPECIFIED" => {
                    std::option::Option::Some(Self::METRIC_VISUALIZATION_UNSPECIFIED)
                }
                "NUMBER" => std::option::Option::Some(Self::NUMBER),
                "BAR" => std::option::Option::Some(Self::BAR),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MetricVisualization {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MetricVisualization {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Table display options that can be reused.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableDisplayOptions {
    /// Optional. This field is unused and has been replaced by
    /// TimeSeriesTable.column_settings
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub shown_columns: std::vec::Vec<std::string::String>,
}

impl TableDisplayOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shown_columns][crate::model::TableDisplayOptions::shown_columns].
    pub fn set_shown_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.shown_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableDisplayOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TableDisplayOptions"
    }
}

/// A widget that displays textual content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Text {
    /// The text content to be displayed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// How the text content is formatted.
    pub format: crate::model::text::Format,

    /// How the text is styled
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub style: std::option::Option<crate::model::text::TextStyle>,
}

impl Text {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::Text::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Text::format].
    pub fn set_format<T: std::convert::Into<crate::model::text::Format>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [style][crate::model::Text::style].
    pub fn set_style<T: std::convert::Into<std::option::Option<crate::model::text::TextStyle>>>(
        mut self,
        v: T,
    ) -> Self {
        self.style = v.into();
        self
    }
}

impl wkt::message::Message for Text {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Text"
    }
}

/// Defines additional types related to Text
pub mod text {
    #[allow(unused_imports)]
    use super::*;

    /// Properties that determine how the title and content are styled
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TextStyle {
        /// The background color as a hex string. "#RRGGBB" or "#RGB"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub background_color: std::string::String,

        /// The text color as a hex string. "#RRGGBB" or "#RGB"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text_color: std::string::String,

        /// The horizontal alignment of both the title and content
        pub horizontal_alignment: crate::model::text::text_style::HorizontalAlignment,

        /// The vertical alignment of both the title and content
        pub vertical_alignment: crate::model::text::text_style::VerticalAlignment,

        /// The amount of padding around the widget
        pub padding: crate::model::text::text_style::PaddingSize,

        /// Font sizes for both the title and content. The title will still be larger
        /// relative to the content.
        pub font_size: crate::model::text::text_style::FontSize,

        /// The pointer location for this widget (also sometimes called a "tail")
        pub pointer_location: crate::model::text::text_style::PointerLocation,
    }

    impl TextStyle {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [background_color][crate::model::text::TextStyle::background_color].
        pub fn set_background_color<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.background_color = v.into();
            self
        }

        /// Sets the value of [text_color][crate::model::text::TextStyle::text_color].
        pub fn set_text_color<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text_color = v.into();
            self
        }

        /// Sets the value of [horizontal_alignment][crate::model::text::TextStyle::horizontal_alignment].
        pub fn set_horizontal_alignment<
            T: std::convert::Into<crate::model::text::text_style::HorizontalAlignment>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.horizontal_alignment = v.into();
            self
        }

        /// Sets the value of [vertical_alignment][crate::model::text::TextStyle::vertical_alignment].
        pub fn set_vertical_alignment<
            T: std::convert::Into<crate::model::text::text_style::VerticalAlignment>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vertical_alignment = v.into();
            self
        }

        /// Sets the value of [padding][crate::model::text::TextStyle::padding].
        pub fn set_padding<T: std::convert::Into<crate::model::text::text_style::PaddingSize>>(
            mut self,
            v: T,
        ) -> Self {
            self.padding = v.into();
            self
        }

        /// Sets the value of [font_size][crate::model::text::TextStyle::font_size].
        pub fn set_font_size<T: std::convert::Into<crate::model::text::text_style::FontSize>>(
            mut self,
            v: T,
        ) -> Self {
            self.font_size = v.into();
            self
        }

        /// Sets the value of [pointer_location][crate::model::text::TextStyle::pointer_location].
        pub fn set_pointer_location<
            T: std::convert::Into<crate::model::text::text_style::PointerLocation>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.pointer_location = v.into();
            self
        }
    }

    impl wkt::message::Message for TextStyle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Text.TextStyle"
        }
    }

    /// Defines additional types related to TextStyle
    pub mod text_style {
        #[allow(unused_imports)]
        use super::*;

        /// The horizontal alignment of both the title and content on a text widget
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct HorizontalAlignment(i32);

        impl HorizontalAlignment {
            /// No horizontal alignment specified, will default to H_LEFT
            pub const HORIZONTAL_ALIGNMENT_UNSPECIFIED: HorizontalAlignment =
                HorizontalAlignment::new(0);

            /// Left-align
            pub const H_LEFT: HorizontalAlignment = HorizontalAlignment::new(1);

            /// Center-align
            pub const H_CENTER: HorizontalAlignment = HorizontalAlignment::new(2);

            /// Right-align
            pub const H_RIGHT: HorizontalAlignment = HorizontalAlignment::new(3);

            /// Creates a new HorizontalAlignment instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("HORIZONTAL_ALIGNMENT_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("H_LEFT"),
                    2 => std::borrow::Cow::Borrowed("H_CENTER"),
                    3 => std::borrow::Cow::Borrowed("H_RIGHT"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                        std::option::Option::Some(Self::HORIZONTAL_ALIGNMENT_UNSPECIFIED)
                    }
                    "H_LEFT" => std::option::Option::Some(Self::H_LEFT),
                    "H_CENTER" => std::option::Option::Some(Self::H_CENTER),
                    "H_RIGHT" => std::option::Option::Some(Self::H_RIGHT),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for HorizontalAlignment {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for HorizontalAlignment {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// The vertical alignment of both the title and content on a text widget
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct VerticalAlignment(i32);

        impl VerticalAlignment {
            /// No vertical alignment specified, will default to V_TOP
            pub const VERTICAL_ALIGNMENT_UNSPECIFIED: VerticalAlignment = VerticalAlignment::new(0);

            /// Top-align
            pub const V_TOP: VerticalAlignment = VerticalAlignment::new(1);

            /// Center-align
            pub const V_CENTER: VerticalAlignment = VerticalAlignment::new(2);

            /// Bottom-align
            pub const V_BOTTOM: VerticalAlignment = VerticalAlignment::new(3);

            /// Creates a new VerticalAlignment instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("VERTICAL_ALIGNMENT_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("V_TOP"),
                    2 => std::borrow::Cow::Borrowed("V_CENTER"),
                    3 => std::borrow::Cow::Borrowed("V_BOTTOM"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "VERTICAL_ALIGNMENT_UNSPECIFIED" => {
                        std::option::Option::Some(Self::VERTICAL_ALIGNMENT_UNSPECIFIED)
                    }
                    "V_TOP" => std::option::Option::Some(Self::V_TOP),
                    "V_CENTER" => std::option::Option::Some(Self::V_CENTER),
                    "V_BOTTOM" => std::option::Option::Some(Self::V_BOTTOM),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for VerticalAlignment {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for VerticalAlignment {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// Specifies padding size around a text widget
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PaddingSize(i32);

        impl PaddingSize {
            /// No padding size specified, will default to P_EXTRA_SMALL
            pub const PADDING_SIZE_UNSPECIFIED: PaddingSize = PaddingSize::new(0);

            /// Extra small padding
            pub const P_EXTRA_SMALL: PaddingSize = PaddingSize::new(1);

            /// Small padding
            pub const P_SMALL: PaddingSize = PaddingSize::new(2);

            /// Medium padding
            pub const P_MEDIUM: PaddingSize = PaddingSize::new(3);

            /// Large padding
            pub const P_LARGE: PaddingSize = PaddingSize::new(4);

            /// Extra large padding
            pub const P_EXTRA_LARGE: PaddingSize = PaddingSize::new(5);

            /// Creates a new PaddingSize instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("PADDING_SIZE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("P_EXTRA_SMALL"),
                    2 => std::borrow::Cow::Borrowed("P_SMALL"),
                    3 => std::borrow::Cow::Borrowed("P_MEDIUM"),
                    4 => std::borrow::Cow::Borrowed("P_LARGE"),
                    5 => std::borrow::Cow::Borrowed("P_EXTRA_LARGE"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "PADDING_SIZE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::PADDING_SIZE_UNSPECIFIED)
                    }
                    "P_EXTRA_SMALL" => std::option::Option::Some(Self::P_EXTRA_SMALL),
                    "P_SMALL" => std::option::Option::Some(Self::P_SMALL),
                    "P_MEDIUM" => std::option::Option::Some(Self::P_MEDIUM),
                    "P_LARGE" => std::option::Option::Some(Self::P_LARGE),
                    "P_EXTRA_LARGE" => std::option::Option::Some(Self::P_EXTRA_LARGE),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for PaddingSize {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for PaddingSize {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// Specifies a font size for the title and content of a text widget
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct FontSize(i32);

        impl FontSize {
            /// No font size specified, will default to FS_LARGE
            pub const FONT_SIZE_UNSPECIFIED: FontSize = FontSize::new(0);

            /// Extra small font size
            pub const FS_EXTRA_SMALL: FontSize = FontSize::new(1);

            /// Small font size
            pub const FS_SMALL: FontSize = FontSize::new(2);

            /// Medium font size
            pub const FS_MEDIUM: FontSize = FontSize::new(3);

            /// Large font size
            pub const FS_LARGE: FontSize = FontSize::new(4);

            /// Extra large font size
            pub const FS_EXTRA_LARGE: FontSize = FontSize::new(5);

            /// Creates a new FontSize instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("FONT_SIZE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("FS_EXTRA_SMALL"),
                    2 => std::borrow::Cow::Borrowed("FS_SMALL"),
                    3 => std::borrow::Cow::Borrowed("FS_MEDIUM"),
                    4 => std::borrow::Cow::Borrowed("FS_LARGE"),
                    5 => std::borrow::Cow::Borrowed("FS_EXTRA_LARGE"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "FONT_SIZE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::FONT_SIZE_UNSPECIFIED)
                    }
                    "FS_EXTRA_SMALL" => std::option::Option::Some(Self::FS_EXTRA_SMALL),
                    "FS_SMALL" => std::option::Option::Some(Self::FS_SMALL),
                    "FS_MEDIUM" => std::option::Option::Some(Self::FS_MEDIUM),
                    "FS_LARGE" => std::option::Option::Some(Self::FS_LARGE),
                    "FS_EXTRA_LARGE" => std::option::Option::Some(Self::FS_EXTRA_LARGE),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for FontSize {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for FontSize {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// Specifies where a visual pointer is placed on a text widget (also
        /// sometimes called a "tail")
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PointerLocation(i32);

        impl PointerLocation {
            /// No visual pointer
            pub const POINTER_LOCATION_UNSPECIFIED: PointerLocation = PointerLocation::new(0);

            /// Placed in the middle of the top of the widget
            pub const PL_TOP: PointerLocation = PointerLocation::new(1);

            /// Placed in the middle of the right side of the widget
            pub const PL_RIGHT: PointerLocation = PointerLocation::new(2);

            /// Placed in the middle of the bottom of the widget
            pub const PL_BOTTOM: PointerLocation = PointerLocation::new(3);

            /// Placed in the middle of the left side of the widget
            pub const PL_LEFT: PointerLocation = PointerLocation::new(4);

            /// Placed on the left side of the top of the widget
            pub const PL_TOP_LEFT: PointerLocation = PointerLocation::new(5);

            /// Placed on the right side of the top of the widget
            pub const PL_TOP_RIGHT: PointerLocation = PointerLocation::new(6);

            /// Placed on the top of the right side of the widget
            pub const PL_RIGHT_TOP: PointerLocation = PointerLocation::new(7);

            /// Placed on the bottom of the right side of the widget
            pub const PL_RIGHT_BOTTOM: PointerLocation = PointerLocation::new(8);

            /// Placed on the right side of the bottom of the widget
            pub const PL_BOTTOM_RIGHT: PointerLocation = PointerLocation::new(9);

            /// Placed on the left side of the bottom of the widget
            pub const PL_BOTTOM_LEFT: PointerLocation = PointerLocation::new(10);

            /// Placed on the bottom of the left side of the widget
            pub const PL_LEFT_BOTTOM: PointerLocation = PointerLocation::new(11);

            /// Placed on the top of the left side of the widget
            pub const PL_LEFT_TOP: PointerLocation = PointerLocation::new(12);

            /// Creates a new PointerLocation instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("POINTER_LOCATION_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("PL_TOP"),
                    2 => std::borrow::Cow::Borrowed("PL_RIGHT"),
                    3 => std::borrow::Cow::Borrowed("PL_BOTTOM"),
                    4 => std::borrow::Cow::Borrowed("PL_LEFT"),
                    5 => std::borrow::Cow::Borrowed("PL_TOP_LEFT"),
                    6 => std::borrow::Cow::Borrowed("PL_TOP_RIGHT"),
                    7 => std::borrow::Cow::Borrowed("PL_RIGHT_TOP"),
                    8 => std::borrow::Cow::Borrowed("PL_RIGHT_BOTTOM"),
                    9 => std::borrow::Cow::Borrowed("PL_BOTTOM_RIGHT"),
                    10 => std::borrow::Cow::Borrowed("PL_BOTTOM_LEFT"),
                    11 => std::borrow::Cow::Borrowed("PL_LEFT_BOTTOM"),
                    12 => std::borrow::Cow::Borrowed("PL_LEFT_TOP"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "POINTER_LOCATION_UNSPECIFIED" => {
                        std::option::Option::Some(Self::POINTER_LOCATION_UNSPECIFIED)
                    }
                    "PL_TOP" => std::option::Option::Some(Self::PL_TOP),
                    "PL_RIGHT" => std::option::Option::Some(Self::PL_RIGHT),
                    "PL_BOTTOM" => std::option::Option::Some(Self::PL_BOTTOM),
                    "PL_LEFT" => std::option::Option::Some(Self::PL_LEFT),
                    "PL_TOP_LEFT" => std::option::Option::Some(Self::PL_TOP_LEFT),
                    "PL_TOP_RIGHT" => std::option::Option::Some(Self::PL_TOP_RIGHT),
                    "PL_RIGHT_TOP" => std::option::Option::Some(Self::PL_RIGHT_TOP),
                    "PL_RIGHT_BOTTOM" => std::option::Option::Some(Self::PL_RIGHT_BOTTOM),
                    "PL_BOTTOM_RIGHT" => std::option::Option::Some(Self::PL_BOTTOM_RIGHT),
                    "PL_BOTTOM_LEFT" => std::option::Option::Some(Self::PL_BOTTOM_LEFT),
                    "PL_LEFT_BOTTOM" => std::option::Option::Some(Self::PL_LEFT_BOTTOM),
                    "PL_LEFT_TOP" => std::option::Option::Some(Self::PL_LEFT_TOP),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for PointerLocation {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for PointerLocation {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// The format type of the text content.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Format(i32);

    impl Format {
        /// Format is unspecified. Defaults to MARKDOWN.
        pub const FORMAT_UNSPECIFIED: Format = Format::new(0);

        /// The text contains Markdown formatting.
        pub const MARKDOWN: Format = Format::new(1);

        /// The text contains no special formatting.
        pub const RAW: Format = Format::new(2);

        /// Creates a new Format instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FORMAT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("MARKDOWN"),
                2 => std::borrow::Cow::Borrowed("RAW"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FORMAT_UNSPECIFIED" => std::option::Option::Some(Self::FORMAT_UNSPECIFIED),
                "MARKDOWN" => std::option::Option::Some(Self::MARKDOWN),
                "RAW" => std::option::Option::Some(Self::RAW),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Format {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Format {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Widget contains a single dashboard component and configuration of how to
/// present the component in the dashboard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Widget {
    /// Optional. The title of the widget.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Optional. The widget id. Ids may be made up of alphanumerics, dashes and
    /// underscores. Widget ids are optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Content defines the component used to populate the widget.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::widget::Content>,
}

impl Widget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::Widget::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Widget::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of `content`.
    pub fn set_content<
        T: std::convert::Into<std::option::Option<crate::model::widget::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `XyChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_xy_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::XyChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::XyChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Scorecard`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_scorecard(&self) -> std::option::Option<&std::boxed::Box<crate::model::Scorecard>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Scorecard(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_text(&self) -> std::option::Option<&std::boxed::Box<crate::model::Text>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Blank`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_blank(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Blank(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `AlertChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_alert_chart(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AlertChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::AlertChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `TimeSeriesTable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_time_series_table(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesTable>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::TimeSeriesTable(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `CollapsibleGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_collapsible_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CollapsibleGroup>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::CollapsibleGroup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `LogsPanel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_logs_panel(&self) -> std::option::Option<&std::boxed::Box<crate::model::LogsPanel>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::LogsPanel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `IncidentList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_incident_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IncidentList>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::IncidentList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `PieChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pie_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::PieChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::PieChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `ErrorReportingPanel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_error_reporting_panel(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ErrorReportingPanel>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::ErrorReportingPanel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `SectionHeader`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_section_header(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SectionHeader>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::SectionHeader(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `SingleViewGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_single_view_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleViewGroup>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::SingleViewGroup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `XyChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_xy_chart<T: std::convert::Into<std::boxed::Box<crate::model::XyChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::XyChart(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Scorecard`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_scorecard<T: std::convert::Into<std::boxed::Box<crate::model::Scorecard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::Scorecard(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::boxed::Box<crate::model::Text>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::Text(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Blank`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_blank<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::Blank(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `AlertChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_alert_chart<T: std::convert::Into<std::boxed::Box<crate::model::AlertChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::AlertChart(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `TimeSeriesTable`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_time_series_table<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::TimeSeriesTable(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `CollapsibleGroup`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_collapsible_group<
        T: std::convert::Into<std::boxed::Box<crate::model::CollapsibleGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::CollapsibleGroup(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `LogsPanel`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_logs_panel<T: std::convert::Into<std::boxed::Box<crate::model::LogsPanel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::LogsPanel(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `IncidentList`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_incident_list<T: std::convert::Into<std::boxed::Box<crate::model::IncidentList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::IncidentList(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `PieChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_pie_chart<T: std::convert::Into<std::boxed::Box<crate::model::PieChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::PieChart(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `ErrorReportingPanel`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_error_reporting_panel<
        T: std::convert::Into<std::boxed::Box<crate::model::ErrorReportingPanel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::ErrorReportingPanel(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `SectionHeader`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_section_header<
        T: std::convert::Into<std::boxed::Box<crate::model::SectionHeader>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::SectionHeader(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `SingleViewGroup`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_single_view_group<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleViewGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::SingleViewGroup(v.into()));
        self
    }
}

impl wkt::message::Message for Widget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Widget"
    }
}

/// Defines additional types related to Widget
pub mod widget {
    #[allow(unused_imports)]
    use super::*;

    /// Content defines the component used to populate the widget.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Content {
        /// A chart of time series data.
        XyChart(std::boxed::Box<crate::model::XyChart>),
        /// A scorecard summarizing time series data.
        Scorecard(std::boxed::Box<crate::model::Scorecard>),
        /// A raw string or markdown displaying textual content.
        Text(std::boxed::Box<crate::model::Text>),
        /// A blank space.
        Blank(std::boxed::Box<wkt::Empty>),
        /// A chart of alert policy data.
        AlertChart(std::boxed::Box<crate::model::AlertChart>),
        /// A widget that displays time series data in a tabular format.
        TimeSeriesTable(std::boxed::Box<crate::model::TimeSeriesTable>),
        /// A widget that groups the other widgets. All widgets that are within
        /// the area spanned by the grouping widget are considered member widgets.
        CollapsibleGroup(std::boxed::Box<crate::model::CollapsibleGroup>),
        /// A widget that shows a stream of logs.
        LogsPanel(std::boxed::Box<crate::model::LogsPanel>),
        /// A widget that shows list of incidents.
        IncidentList(std::boxed::Box<crate::model::IncidentList>),
        /// A widget that displays timeseries data as a pie chart.
        PieChart(std::boxed::Box<crate::model::PieChart>),
        /// A widget that displays a list of error groups.
        ErrorReportingPanel(std::boxed::Box<crate::model::ErrorReportingPanel>),
        /// A widget that defines a section header for easier navigation of the
        /// dashboard.
        SectionHeader(std::boxed::Box<crate::model::SectionHeader>),
        /// A widget that groups the other widgets by using a dropdown menu.
        SingleViewGroup(std::boxed::Box<crate::model::SingleViewGroup>),
    }
}

/// A chart that displays data on a 2D (X and Y axes) plane.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct XyChart {
    /// Required. The data displayed in this chart.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sets: std::vec::Vec<crate::model::xy_chart::DataSet>,

    /// The duration used to display a comparison chart. A comparison chart
    /// simultaneously shows values from two similar-length time periods
    /// (e.g., week-over-week metrics).
    /// The duration must be positive, and it can only be applied to charts with
    /// data sets of LINE plot type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeshift_duration: std::option::Option<wkt::Duration>,

    /// Threshold lines drawn horizontally across the chart.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub thresholds: std::vec::Vec<crate::model::Threshold>,

    /// The properties applied to the x-axis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub x_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// The properties applied to the y-axis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub y_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// The properties applied to the y2-axis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub y2_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// Display options for the chart.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub chart_options: std::option::Option<crate::model::ChartOptions>,
}

impl XyChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timeshift_duration][crate::model::XyChart::timeshift_duration].
    pub fn set_timeshift_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeshift_duration = v.into();
        self
    }

    /// Sets the value of [x_axis][crate::model::XyChart::x_axis].
    pub fn set_x_axis<T: std::convert::Into<std::option::Option<crate::model::xy_chart::Axis>>>(
        mut self,
        v: T,
    ) -> Self {
        self.x_axis = v.into();
        self
    }

    /// Sets the value of [y_axis][crate::model::XyChart::y_axis].
    pub fn set_y_axis<T: std::convert::Into<std::option::Option<crate::model::xy_chart::Axis>>>(
        mut self,
        v: T,
    ) -> Self {
        self.y_axis = v.into();
        self
    }

    /// Sets the value of [y2_axis][crate::model::XyChart::y2_axis].
    pub fn set_y2_axis<T: std::convert::Into<std::option::Option<crate::model::xy_chart::Axis>>>(
        mut self,
        v: T,
    ) -> Self {
        self.y2_axis = v.into();
        self
    }

    /// Sets the value of [chart_options][crate::model::XyChart::chart_options].
    pub fn set_chart_options<
        T: std::convert::Into<std::option::Option<crate::model::ChartOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chart_options = v.into();
        self
    }

    /// Sets the value of [data_sets][crate::model::XyChart::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::xy_chart::DataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [thresholds][crate::model::XyChart::thresholds].
    pub fn set_thresholds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Threshold>,
    {
        use std::iter::Iterator;
        self.thresholds = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for XyChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.XyChart"
    }
}

/// Defines additional types related to XyChart
pub mod xy_chart {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition with charting options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// How this data should be plotted on the chart.
        pub plot_type: crate::model::xy_chart::data_set::PlotType,

        /// A template string for naming `TimeSeries` in the resulting data set.
        /// This should be a string with interpolations of the form `${label_name}`,
        /// which will resolve to the label's value.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub legend_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        /// Optional. The target axis to use for plotting the metric.
        pub target_axis: crate::model::xy_chart::data_set::TargetAxis,
    }

    impl DataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::xy_chart::DataSet::time_series_query].
        pub fn set_time_series_query<
            T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series_query = v.into();
            self
        }

        /// Sets the value of [plot_type][crate::model::xy_chart::DataSet::plot_type].
        pub fn set_plot_type<T: std::convert::Into<crate::model::xy_chart::data_set::PlotType>>(
            mut self,
            v: T,
        ) -> Self {
            self.plot_type = v.into();
            self
        }

        /// Sets the value of [legend_template][crate::model::xy_chart::DataSet::legend_template].
        pub fn set_legend_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.legend_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::xy_chart::DataSet::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }

        /// Sets the value of [target_axis][crate::model::xy_chart::DataSet::target_axis].
        pub fn set_target_axis<
            T: std::convert::Into<crate::model::xy_chart::data_set::TargetAxis>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target_axis = v.into();
            self
        }
    }

    impl wkt::message::Message for DataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.XyChart.DataSet"
        }
    }

    /// Defines additional types related to DataSet
    pub mod data_set {
        #[allow(unused_imports)]
        use super::*;

        /// The types of plotting strategies for data sets.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PlotType(i32);

        impl PlotType {
            /// Plot type is unspecified. The view will default to `LINE`.
            pub const PLOT_TYPE_UNSPECIFIED: PlotType = PlotType::new(0);

            /// The data is plotted as a set of lines (one line per series).
            pub const LINE: PlotType = PlotType::new(1);

            /// The data is plotted as a set of filled areas (one area per series),
            /// with the areas stacked vertically (the base of each area is the top of
            /// its predecessor, and the base of the first area is the x-axis). Since
            /// the areas do not overlap, each is filled with a different opaque color.
            pub const STACKED_AREA: PlotType = PlotType::new(2);

            /// The data is plotted as a set of rectangular boxes (one box per series),
            /// with the boxes stacked vertically (the base of each box is the top of
            /// its predecessor, and the base of the first box is the x-axis). Since
            /// the boxes do not overlap, each is filled with a different opaque color.
            pub const STACKED_BAR: PlotType = PlotType::new(3);

            /// The data is plotted as a heatmap. The series being plotted must have a
            /// `DISTRIBUTION` value type. The value of each bucket in the distribution
            /// is displayed as a color. This type is not currently available in the
            /// Stackdriver Monitoring application.
            pub const HEATMAP: PlotType = PlotType::new(4);

            /// Creates a new PlotType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("PLOT_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("LINE"),
                    2 => std::borrow::Cow::Borrowed("STACKED_AREA"),
                    3 => std::borrow::Cow::Borrowed("STACKED_BAR"),
                    4 => std::borrow::Cow::Borrowed("HEATMAP"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "PLOT_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::PLOT_TYPE_UNSPECIFIED)
                    }
                    "LINE" => std::option::Option::Some(Self::LINE),
                    "STACKED_AREA" => std::option::Option::Some(Self::STACKED_AREA),
                    "STACKED_BAR" => std::option::Option::Some(Self::STACKED_BAR),
                    "HEATMAP" => std::option::Option::Some(Self::HEATMAP),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for PlotType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for PlotType {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// An axis identifier.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct TargetAxis(i32);

        impl TargetAxis {
            /// The target axis was not specified. Defaults to Y1.
            pub const TARGET_AXIS_UNSPECIFIED: TargetAxis = TargetAxis::new(0);

            /// The y_axis (the right axis of chart).
            pub const Y1: TargetAxis = TargetAxis::new(1);

            /// The y2_axis (the left axis of chart).
            pub const Y2: TargetAxis = TargetAxis::new(2);

            /// Creates a new TargetAxis instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("TARGET_AXIS_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("Y1"),
                    2 => std::borrow::Cow::Borrowed("Y2"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "TARGET_AXIS_UNSPECIFIED" => {
                        std::option::Option::Some(Self::TARGET_AXIS_UNSPECIFIED)
                    }
                    "Y1" => std::option::Option::Some(Self::Y1),
                    "Y2" => std::option::Option::Some(Self::Y2),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for TargetAxis {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for TargetAxis {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// A chart axis.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Axis {
        /// The label of the axis.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub label: std::string::String,

        /// The axis scale. By default, a linear scale is used.
        pub scale: crate::model::xy_chart::axis::Scale,
    }

    impl Axis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [label][crate::model::xy_chart::Axis::label].
        pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.label = v.into();
            self
        }

        /// Sets the value of [scale][crate::model::xy_chart::Axis::scale].
        pub fn set_scale<T: std::convert::Into<crate::model::xy_chart::axis::Scale>>(
            mut self,
            v: T,
        ) -> Self {
            self.scale = v.into();
            self
        }
    }

    impl wkt::message::Message for Axis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.XyChart.Axis"
        }
    }

    /// Defines additional types related to Axis
    pub mod axis {
        #[allow(unused_imports)]
        use super::*;

        /// Types of scales used in axes.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Scale(i32);

        impl Scale {
            /// Scale is unspecified. The view will default to `LINEAR`.
            pub const SCALE_UNSPECIFIED: Scale = Scale::new(0);

            /// Linear scale.
            pub const LINEAR: Scale = Scale::new(1);

            /// Logarithmic scale (base 10).
            pub const LOG10: Scale = Scale::new(2);

            /// Creates a new Scale instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("SCALE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("LINEAR"),
                    2 => std::borrow::Cow::Borrowed("LOG10"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "SCALE_UNSPECIFIED" => std::option::Option::Some(Self::SCALE_UNSPECIFIED),
                    "LINEAR" => std::option::Option::Some(Self::LINEAR),
                    "LOG10" => std::option::Option::Some(Self::LOG10),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for Scale {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for Scale {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }
}

/// Options to control visual rendering of a chart.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChartOptions {
    /// The chart mode.
    pub mode: crate::model::chart_options::Mode,
}

impl ChartOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::ChartOptions::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::chart_options::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for ChartOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ChartOptions"
    }
}

/// Defines additional types related to ChartOptions
pub mod chart_options {
    #[allow(unused_imports)]
    use super::*;

    /// Chart mode options.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Mode(i32);

    impl Mode {
        /// Mode is unspecified. The view will default to `COLOR`.
        pub const MODE_UNSPECIFIED: Mode = Mode::new(0);

        /// The chart distinguishes data series using different color. Line
        /// colors may get reused when there are many lines in the chart.
        pub const COLOR: Mode = Mode::new(1);

        /// The chart uses the Stackdriver x-ray mode, in which each
        /// data set is plotted using the same semi-transparent color.
        pub const X_RAY: Mode = Mode::new(2);

        /// The chart displays statistics such as average, median, 95th percentile,
        /// and more.
        pub const STATS: Mode = Mode::new(3);

        /// Creates a new Mode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("COLOR"),
                2 => std::borrow::Cow::Borrowed("X_RAY"),
                3 => std::borrow::Cow::Borrowed("STATS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MODE_UNSPECIFIED" => std::option::Option::Some(Self::MODE_UNSPECIFIED),
                "COLOR" => std::option::Option::Some(Self::COLOR),
                "X_RAY" => std::option::Option::Some(Self::X_RAY),
                "STATS" => std::option::Option::Some(Self::STATS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Defines the possible types of spark chart supported by the `Scorecard`.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct SparkChartType(i32);

impl SparkChartType {
    /// Not allowed in well-formed requests.
    pub const SPARK_CHART_TYPE_UNSPECIFIED: SparkChartType = SparkChartType::new(0);

    /// The sparkline will be rendered as a small line chart.
    pub const SPARK_LINE: SparkChartType = SparkChartType::new(1);

    /// The sparkbar will be rendered as a small bar chart.
    pub const SPARK_BAR: SparkChartType = SparkChartType::new(2);

    /// Creates a new SparkChartType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SPARK_CHART_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("SPARK_LINE"),
            2 => std::borrow::Cow::Borrowed("SPARK_BAR"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SPARK_CHART_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::SPARK_CHART_TYPE_UNSPECIFIED)
            }
            "SPARK_LINE" => std::option::Option::Some(Self::SPARK_LINE),
            "SPARK_BAR" => std::option::Option::Some(Self::SPARK_BAR),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for SparkChartType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for SparkChartType {
    fn default() -> Self {
        Self::new(0)
    }
}
