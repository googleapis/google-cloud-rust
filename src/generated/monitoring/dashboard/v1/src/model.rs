// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A chart that displays alert policy data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlertChart {
    /// Required. The resource name of the alert policy. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlertChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AlertChart::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AlertChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.AlertChart"
    }
}

/// A widget that groups the other widgets. All widgets that are within
/// the area spanned by the grouping widget are considered member widgets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CollapsibleGroup {
    /// The collapsed state of the widget on first page load.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub collapsed: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CollapsibleGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [collapsed][crate::model::CollapsibleGroup::collapsed].
    pub fn set_collapsed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.collapsed = v.into();
        self
    }
}

impl wkt::message::Message for CollapsibleGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.CollapsibleGroup"
    }
}

/// Describes how to combine multiple time series to provide a different view of
/// the data.  Aggregation of time series is done in two steps. First, each time
/// series in the set is _aligned_ to the same time interval boundaries, then the
/// set of time series is optionally _reduced_ in number.
///
/// Alignment consists of applying the `per_series_aligner` operation
/// to each time series after its data has been divided into regular
/// `alignment_period` time intervals. This process takes _all_ of the data
/// points in an alignment period, applies a mathematical transformation such as
/// averaging, minimum, maximum, delta, etc., and converts them into a single
/// data point per period.
///
/// Reduction is when the aligned and transformed time series can optionally be
/// combined, reducing the number of time series through similar mathematical
/// transformations. Reduction involves applying a `cross_series_reducer` to
/// all the time series, optionally sorting the time series into subsets with
/// `group_by_fields`, and applying the reducer to each subset.
///
/// The raw time series data can contain a huge amount of information from
/// multiple sources. Alignment and reduction transforms this mass of data into
/// a more manageable and representative collection of data, for example "the
/// 95% latency across the average of all tasks in a cluster". This
/// representative data can be more easily graphed and comprehended, and the
/// individual time series data is still available for later drilldown. For more
/// details, see [Filtering and
/// aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Aggregation {
    /// The `alignment_period` specifies a time interval, in seconds, that is used
    /// to divide the data in all the
    /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
    /// time. This will be done before the per-series aligner can be applied to
    /// the data.
    ///
    /// The value must be at least 60 seconds. If a per-series aligner other than
    /// `ALIGN_NONE` is specified, this field is required or an error is returned.
    /// If no per-series aligner is specified, or the aligner `ALIGN_NONE` is
    /// specified, then this field is ignored.
    ///
    /// The maximum value of the `alignment_period` is 2 years, or 104 weeks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub alignment_period: std::option::Option<wkt::Duration>,

    /// An `Aligner` describes how to bring the data points in a single
    /// time series into temporal alignment. Except for `ALIGN_NONE`, all
    /// alignments cause all the data points in an `alignment_period` to be
    /// mathematically grouped together, resulting in a single data point for
    /// each `alignment_period` with end timestamp at the end of the period.
    ///
    /// Not all alignment operations may be applied to all time series. The valid
    /// choices depend on the `metric_kind` and `value_type` of the original time
    /// series. Alignment can change the `metric_kind` or the `value_type` of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `cross_series_reducer` is specified, then
    /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
    /// and `alignment_period` must be specified; otherwise, an error is
    /// returned.
    pub per_series_aligner: crate::model::aggregation::Aligner,

    /// The reduction operation to be used to combine time series into a single
    /// time series, where the value of each data point in the resulting series is
    /// a function of all the already aligned values in the input time series.
    ///
    /// Not all reducer operations can be applied to all time series. The valid
    /// choices depend on the `metric_kind` and the `value_type` of the original
    /// time series. Reduction can yield a time series with a different
    /// `metric_kind` or `value_type` than the input time series.
    ///
    /// Time series data must first be aligned (see `per_series_aligner`) in order
    /// to perform cross-time series reduction. If `cross_series_reducer` is
    /// specified, then `per_series_aligner` must be specified, and must not be
    /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
    /// error is returned.
    pub cross_series_reducer: crate::model::aggregation::Reducer,

    /// The set of fields to preserve when `cross_series_reducer` is
    /// specified. The `group_by_fields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// operation. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `cross_series_reducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `group_by_fields` are aggregated away.  If
    /// `group_by_fields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `cross_series_reducer` is not
    /// defined, this field is ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group_by_fields: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Aggregation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alignment_period][crate::model::Aggregation::alignment_period].
    pub fn set_alignment_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.alignment_period = v.into();
        self
    }

    /// Sets the value of [per_series_aligner][crate::model::Aggregation::per_series_aligner].
    pub fn set_per_series_aligner<T: std::convert::Into<crate::model::aggregation::Aligner>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_series_aligner = v.into();
        self
    }

    /// Sets the value of [cross_series_reducer][crate::model::Aggregation::cross_series_reducer].
    pub fn set_cross_series_reducer<T: std::convert::Into<crate::model::aggregation::Reducer>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_series_reducer = v.into();
        self
    }

    /// Sets the value of [group_by_fields][crate::model::Aggregation::group_by_fields].
    pub fn set_group_by_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.group_by_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Aggregation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Aggregation"
    }
}

/// Defines additional types related to [Aggregation].
pub mod aggregation {
    #[allow(unused_imports)]
    use super::*;

    /// The `Aligner` specifies the operation that will be applied to the data
    /// points in each alignment period in a time series. Except for
    /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
    /// operation replaces the set of data values in each alignment period with
    /// a single value: the result of applying the operation to the data values.
    /// An aligned time series has a single data value at the end of each
    /// `alignment_period`.
    ///
    /// An alignment operation can change the data type of the values, too. For
    /// example, if you apply a counting operation to boolean values, the data
    /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
    /// in the aligned result is `INT64`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Aligner {
        /// No alignment. Raw data is returned. Not valid if cross-series reduction
        /// is requested. The `value_type` of the result is the same as the
        /// `value_type` of the input.
        AlignNone,
        /// Align and convert to
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
        /// The output is `delta = y1 - y0`.
        ///
        /// This alignment is valid for
        /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
        /// `DELTA` metrics. If the selected alignment period results in periods
        /// with no data, then the aligned value for such a period is created by
        /// interpolation. The `value_type`  of the aligned result is the same as
        /// the `value_type` of the input.
        AlignDelta,
        /// Align and convert to a rate. The result is computed as
        /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
        /// Think of this aligner as providing the slope of the line that passes
        /// through the value at the start and at the end of the `alignment_period`.
        ///
        /// This aligner is valid for `CUMULATIVE`
        /// and `DELTA` metrics with numeric values. If the selected alignment
        /// period results in periods with no data, then the aligned value for
        /// such a period is created by interpolation. The output is a `GAUGE`
        /// metric with `value_type` `DOUBLE`.
        ///
        /// If, by "rate", you mean "percentage change", see the
        /// `ALIGN_PERCENT_CHANGE` aligner instead.
        AlignRate,
        /// Align by interpolating between adjacent points around the alignment
        /// period boundary. This aligner is valid for `GAUGE` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as the
        /// `value_type` of the input.
        AlignInterpolate,
        /// Align by moving the most recent data point before the end of the
        /// alignment period to the boundary at the end of the alignment
        /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
        /// the aligned result is the same as the `value_type` of the input.
        AlignNextOlder,
        /// Align the time series by returning the minimum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMin,
        /// Align the time series by returning the maximum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMax,
        /// Align the time series by returning the mean value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
        AlignMean,
        /// Align the time series by returning the number of values in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric or Boolean values. The `value_type` of the aligned result is
        /// `INT64`.
        AlignCount,
        /// Align the time series by returning the sum of the values in each
        /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with numeric and distribution values. The `value_type` of the
        /// aligned result is the same as the `value_type` of the input.
        AlignSum,
        /// Align the time series by returning the standard deviation of the values
        /// in each alignment period. This aligner is valid for `GAUGE` and
        /// `DELTA` metrics with numeric values. The `value_type` of the output is
        /// `DOUBLE`.
        AlignStddev,
        /// Align the time series by returning the number of `True` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountTrue,
        /// Align the time series by returning the number of `False` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountFalse,
        /// Align the time series by returning the ratio of the number of `True`
        /// values to the total number of values in each alignment period. This
        /// aligner is valid for `GAUGE` metrics with Boolean values. The output
        /// value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
        AlignFractionTrue,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 99th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile99,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 95th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile95,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 50th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile50,
        /// Align the time series by using [percentile
        /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
        /// data point in each alignment period is the 5th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile05,
        /// Align and convert to a percentage change. This aligner is valid for
        /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
        /// `((current - previous)/previous) * 100`, where the value of `previous` is
        /// determined based on the `alignment_period`.
        ///
        /// If the values of `current` and `previous` are both 0, then the returned
        /// value is 0. If only `previous` is 0, the returned value is infinity.
        ///
        /// A 10-minute moving mean is computed at each point of the alignment period
        /// prior to the above calculation to smooth the metric and prevent false
        /// positives from very short-lived spikes. The moving mean is only
        /// applicable for data whose values are `>= 0`. Any values `< 0` are
        /// treated as a missing datapoint, and are ignored. While `DELTA`
        /// metrics are accepted by this alignment, special care should be taken that
        /// the values for the metric will always be positive. The output is a
        /// `GAUGE` metric with `value_type` `DOUBLE`.
        AlignPercentChange,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Aligner::value] or
        /// [Aligner::name].
        UnknownValue(aligner::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aligner {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Aligner {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AlignNone => std::option::Option::Some(0),
                Self::AlignDelta => std::option::Option::Some(1),
                Self::AlignRate => std::option::Option::Some(2),
                Self::AlignInterpolate => std::option::Option::Some(3),
                Self::AlignNextOlder => std::option::Option::Some(4),
                Self::AlignMin => std::option::Option::Some(10),
                Self::AlignMax => std::option::Option::Some(11),
                Self::AlignMean => std::option::Option::Some(12),
                Self::AlignCount => std::option::Option::Some(13),
                Self::AlignSum => std::option::Option::Some(14),
                Self::AlignStddev => std::option::Option::Some(15),
                Self::AlignCountTrue => std::option::Option::Some(16),
                Self::AlignCountFalse => std::option::Option::Some(24),
                Self::AlignFractionTrue => std::option::Option::Some(17),
                Self::AlignPercentile99 => std::option::Option::Some(18),
                Self::AlignPercentile95 => std::option::Option::Some(19),
                Self::AlignPercentile50 => std::option::Option::Some(20),
                Self::AlignPercentile05 => std::option::Option::Some(21),
                Self::AlignPercentChange => std::option::Option::Some(23),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AlignNone => std::option::Option::Some("ALIGN_NONE"),
                Self::AlignDelta => std::option::Option::Some("ALIGN_DELTA"),
                Self::AlignRate => std::option::Option::Some("ALIGN_RATE"),
                Self::AlignInterpolate => std::option::Option::Some("ALIGN_INTERPOLATE"),
                Self::AlignNextOlder => std::option::Option::Some("ALIGN_NEXT_OLDER"),
                Self::AlignMin => std::option::Option::Some("ALIGN_MIN"),
                Self::AlignMax => std::option::Option::Some("ALIGN_MAX"),
                Self::AlignMean => std::option::Option::Some("ALIGN_MEAN"),
                Self::AlignCount => std::option::Option::Some("ALIGN_COUNT"),
                Self::AlignSum => std::option::Option::Some("ALIGN_SUM"),
                Self::AlignStddev => std::option::Option::Some("ALIGN_STDDEV"),
                Self::AlignCountTrue => std::option::Option::Some("ALIGN_COUNT_TRUE"),
                Self::AlignCountFalse => std::option::Option::Some("ALIGN_COUNT_FALSE"),
                Self::AlignFractionTrue => std::option::Option::Some("ALIGN_FRACTION_TRUE"),
                Self::AlignPercentile99 => std::option::Option::Some("ALIGN_PERCENTILE_99"),
                Self::AlignPercentile95 => std::option::Option::Some("ALIGN_PERCENTILE_95"),
                Self::AlignPercentile50 => std::option::Option::Some("ALIGN_PERCENTILE_50"),
                Self::AlignPercentile05 => std::option::Option::Some("ALIGN_PERCENTILE_05"),
                Self::AlignPercentChange => std::option::Option::Some("ALIGN_PERCENT_CHANGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Aligner {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Aligner {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Aligner {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AlignNone,
                1 => Self::AlignDelta,
                2 => Self::AlignRate,
                3 => Self::AlignInterpolate,
                4 => Self::AlignNextOlder,
                10 => Self::AlignMin,
                11 => Self::AlignMax,
                12 => Self::AlignMean,
                13 => Self::AlignCount,
                14 => Self::AlignSum,
                15 => Self::AlignStddev,
                16 => Self::AlignCountTrue,
                17 => Self::AlignFractionTrue,
                18 => Self::AlignPercentile99,
                19 => Self::AlignPercentile95,
                20 => Self::AlignPercentile50,
                21 => Self::AlignPercentile05,
                23 => Self::AlignPercentChange,
                24 => Self::AlignCountFalse,
                _ => Self::UnknownValue(aligner::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Aligner {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALIGN_NONE" => Self::AlignNone,
                "ALIGN_DELTA" => Self::AlignDelta,
                "ALIGN_RATE" => Self::AlignRate,
                "ALIGN_INTERPOLATE" => Self::AlignInterpolate,
                "ALIGN_NEXT_OLDER" => Self::AlignNextOlder,
                "ALIGN_MIN" => Self::AlignMin,
                "ALIGN_MAX" => Self::AlignMax,
                "ALIGN_MEAN" => Self::AlignMean,
                "ALIGN_COUNT" => Self::AlignCount,
                "ALIGN_SUM" => Self::AlignSum,
                "ALIGN_STDDEV" => Self::AlignStddev,
                "ALIGN_COUNT_TRUE" => Self::AlignCountTrue,
                "ALIGN_COUNT_FALSE" => Self::AlignCountFalse,
                "ALIGN_FRACTION_TRUE" => Self::AlignFractionTrue,
                "ALIGN_PERCENTILE_99" => Self::AlignPercentile99,
                "ALIGN_PERCENTILE_95" => Self::AlignPercentile95,
                "ALIGN_PERCENTILE_50" => Self::AlignPercentile50,
                "ALIGN_PERCENTILE_05" => Self::AlignPercentile05,
                "ALIGN_PERCENT_CHANGE" => Self::AlignPercentChange,
                _ => Self::UnknownValue(aligner::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Aligner {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AlignNone => serializer.serialize_i32(0),
                Self::AlignDelta => serializer.serialize_i32(1),
                Self::AlignRate => serializer.serialize_i32(2),
                Self::AlignInterpolate => serializer.serialize_i32(3),
                Self::AlignNextOlder => serializer.serialize_i32(4),
                Self::AlignMin => serializer.serialize_i32(10),
                Self::AlignMax => serializer.serialize_i32(11),
                Self::AlignMean => serializer.serialize_i32(12),
                Self::AlignCount => serializer.serialize_i32(13),
                Self::AlignSum => serializer.serialize_i32(14),
                Self::AlignStddev => serializer.serialize_i32(15),
                Self::AlignCountTrue => serializer.serialize_i32(16),
                Self::AlignCountFalse => serializer.serialize_i32(24),
                Self::AlignFractionTrue => serializer.serialize_i32(17),
                Self::AlignPercentile99 => serializer.serialize_i32(18),
                Self::AlignPercentile95 => serializer.serialize_i32(19),
                Self::AlignPercentile50 => serializer.serialize_i32(20),
                Self::AlignPercentile05 => serializer.serialize_i32(21),
                Self::AlignPercentChange => serializer.serialize_i32(23),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Aligner {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Aligner>::new(
                ".google.monitoring.dashboard.v1.Aggregation.Aligner",
            ))
        }
    }

    /// A Reducer operation describes how to aggregate data points from multiple
    /// time series into a single time series, where the value of each data point
    /// in the resulting series is a function of all the already aligned values in
    /// the input time series.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reducer {
        /// No cross-time series reduction. The output of the `Aligner` is
        /// returned.
        ReduceNone,
        /// Reduce by computing the mean value across time series for each
        /// alignment period. This reducer is valid for
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
        /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
        /// numeric or distribution values. The `value_type` of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        ReduceMean,
        /// Reduce by computing the minimum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMin,
        /// Reduce by computing the maximum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMax,
        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric and distribution values. The `value_type` of the output is
        /// the same as the `value_type` of the input.
        ReduceSum,
        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics with numeric or distribution values. The `value_type`
        /// of the output is `DOUBLE`.
        ReduceStddev,
        /// Reduce by computing the number of data points across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of numeric, Boolean, distribution, and string
        /// `value_type`. The `value_type` of the output is `INT64`.
        ReduceCount,
        /// Reduce by computing the number of `True`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountTrue,
        /// Reduce by computing the number of `False`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountFalse,
        /// Reduce by computing the ratio of the number of `True`-valued data points
        /// to the total number of data points for each alignment period. This
        /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
        /// The output value is in the range [0.0, 1.0] and has `value_type`
        /// `DOUBLE`.
        ReduceFractionTrue,
        /// Reduce by computing the [99th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile99,
        /// Reduce by computing the [95th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile95,
        /// Reduce by computing the [50th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile50,
        /// Reduce by computing the [5th
        /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile05,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Reducer::value] or
        /// [Reducer::name].
        UnknownValue(reducer::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reducer {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Reducer {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ReduceNone => std::option::Option::Some(0),
                Self::ReduceMean => std::option::Option::Some(1),
                Self::ReduceMin => std::option::Option::Some(2),
                Self::ReduceMax => std::option::Option::Some(3),
                Self::ReduceSum => std::option::Option::Some(4),
                Self::ReduceStddev => std::option::Option::Some(5),
                Self::ReduceCount => std::option::Option::Some(6),
                Self::ReduceCountTrue => std::option::Option::Some(7),
                Self::ReduceCountFalse => std::option::Option::Some(15),
                Self::ReduceFractionTrue => std::option::Option::Some(8),
                Self::ReducePercentile99 => std::option::Option::Some(9),
                Self::ReducePercentile95 => std::option::Option::Some(10),
                Self::ReducePercentile50 => std::option::Option::Some(11),
                Self::ReducePercentile05 => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ReduceNone => std::option::Option::Some("REDUCE_NONE"),
                Self::ReduceMean => std::option::Option::Some("REDUCE_MEAN"),
                Self::ReduceMin => std::option::Option::Some("REDUCE_MIN"),
                Self::ReduceMax => std::option::Option::Some("REDUCE_MAX"),
                Self::ReduceSum => std::option::Option::Some("REDUCE_SUM"),
                Self::ReduceStddev => std::option::Option::Some("REDUCE_STDDEV"),
                Self::ReduceCount => std::option::Option::Some("REDUCE_COUNT"),
                Self::ReduceCountTrue => std::option::Option::Some("REDUCE_COUNT_TRUE"),
                Self::ReduceCountFalse => std::option::Option::Some("REDUCE_COUNT_FALSE"),
                Self::ReduceFractionTrue => std::option::Option::Some("REDUCE_FRACTION_TRUE"),
                Self::ReducePercentile99 => std::option::Option::Some("REDUCE_PERCENTILE_99"),
                Self::ReducePercentile95 => std::option::Option::Some("REDUCE_PERCENTILE_95"),
                Self::ReducePercentile50 => std::option::Option::Some("REDUCE_PERCENTILE_50"),
                Self::ReducePercentile05 => std::option::Option::Some("REDUCE_PERCENTILE_05"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Reducer {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Reducer {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Reducer {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ReduceNone,
                1 => Self::ReduceMean,
                2 => Self::ReduceMin,
                3 => Self::ReduceMax,
                4 => Self::ReduceSum,
                5 => Self::ReduceStddev,
                6 => Self::ReduceCount,
                7 => Self::ReduceCountTrue,
                8 => Self::ReduceFractionTrue,
                9 => Self::ReducePercentile99,
                10 => Self::ReducePercentile95,
                11 => Self::ReducePercentile50,
                12 => Self::ReducePercentile05,
                15 => Self::ReduceCountFalse,
                _ => Self::UnknownValue(reducer::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Reducer {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDUCE_NONE" => Self::ReduceNone,
                "REDUCE_MEAN" => Self::ReduceMean,
                "REDUCE_MIN" => Self::ReduceMin,
                "REDUCE_MAX" => Self::ReduceMax,
                "REDUCE_SUM" => Self::ReduceSum,
                "REDUCE_STDDEV" => Self::ReduceStddev,
                "REDUCE_COUNT" => Self::ReduceCount,
                "REDUCE_COUNT_TRUE" => Self::ReduceCountTrue,
                "REDUCE_COUNT_FALSE" => Self::ReduceCountFalse,
                "REDUCE_FRACTION_TRUE" => Self::ReduceFractionTrue,
                "REDUCE_PERCENTILE_99" => Self::ReducePercentile99,
                "REDUCE_PERCENTILE_95" => Self::ReducePercentile95,
                "REDUCE_PERCENTILE_50" => Self::ReducePercentile50,
                "REDUCE_PERCENTILE_05" => Self::ReducePercentile05,
                _ => Self::UnknownValue(reducer::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Reducer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ReduceNone => serializer.serialize_i32(0),
                Self::ReduceMean => serializer.serialize_i32(1),
                Self::ReduceMin => serializer.serialize_i32(2),
                Self::ReduceMax => serializer.serialize_i32(3),
                Self::ReduceSum => serializer.serialize_i32(4),
                Self::ReduceStddev => serializer.serialize_i32(5),
                Self::ReduceCount => serializer.serialize_i32(6),
                Self::ReduceCountTrue => serializer.serialize_i32(7),
                Self::ReduceCountFalse => serializer.serialize_i32(15),
                Self::ReduceFractionTrue => serializer.serialize_i32(8),
                Self::ReducePercentile99 => serializer.serialize_i32(9),
                Self::ReducePercentile95 => serializer.serialize_i32(10),
                Self::ReducePercentile50 => serializer.serialize_i32(11),
                Self::ReducePercentile05 => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Reducer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reducer>::new(
                ".google.monitoring.dashboard.v1.Aggregation.Reducer",
            ))
        }
    }
}

/// Describes a ranking-based time series filter. Each input time series is
/// ranked with an aligner. The filter will allow up to `num_time_series` time
/// series to pass through it, selecting them based on the relative ranking.
///
/// For example, if `ranking_method` is `METHOD_MEAN`,`direction` is `BOTTOM`,
/// and `num_time_series` is 3, then the 3 times series with the lowest mean
/// values will pass through the filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PickTimeSeriesFilter {
    /// `ranking_method` is applied to each time series independently to produce
    /// the value which will be used to compare the time series to other time
    /// series.
    pub ranking_method: crate::model::pick_time_series_filter::Method,

    /// How many time series to allow to pass through the filter.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub num_time_series: i32,

    /// How to use the ranking to select time series that pass through the filter.
    pub direction: crate::model::pick_time_series_filter::Direction,

    /// Select the top N streams/time series within this time interval
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<gtype::model::Interval>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PickTimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ranking_method][crate::model::PickTimeSeriesFilter::ranking_method].
    pub fn set_ranking_method<
        T: std::convert::Into<crate::model::pick_time_series_filter::Method>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_method = v.into();
        self
    }

    /// Sets the value of [num_time_series][crate::model::PickTimeSeriesFilter::num_time_series].
    pub fn set_num_time_series<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_time_series = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::PickTimeSeriesFilter::direction].
    pub fn set_direction<
        T: std::convert::Into<crate::model::pick_time_series_filter::Direction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::PickTimeSeriesFilter::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<gtype::model::Interval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }
}

impl wkt::message::Message for PickTimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.PickTimeSeriesFilter"
    }
}

/// Defines additional types related to [PickTimeSeriesFilter].
pub mod pick_time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The value reducers that can be applied to a `PickTimeSeriesFilter`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Not allowed. You must specify a different `Method` if you specify a
        /// `PickTimeSeriesFilter`.
        Unspecified,
        /// Select the mean of all values.
        Mean,
        /// Select the maximum value.
        Max,
        /// Select the minimum value.
        Min,
        /// Compute the sum of all values.
        Sum,
        /// Select the most recent value.
        Latest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Method::value] or
        /// [Method::name].
        UnknownValue(method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Method {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Mean => std::option::Option::Some(1),
                Self::Max => std::option::Option::Some(2),
                Self::Min => std::option::Option::Some(3),
                Self::Sum => std::option::Option::Some(4),
                Self::Latest => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                Self::Mean => std::option::Option::Some("METHOD_MEAN"),
                Self::Max => std::option::Option::Some("METHOD_MAX"),
                Self::Min => std::option::Option::Some("METHOD_MIN"),
                Self::Sum => std::option::Option::Some("METHOD_SUM"),
                Self::Latest => std::option::Option::Some("METHOD_LATEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Method {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Mean,
                2 => Self::Max,
                3 => Self::Min,
                4 => Self::Sum,
                5 => Self::Latest,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Method {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_UNSPECIFIED" => Self::Unspecified,
                "METHOD_MEAN" => Self::Mean,
                "METHOD_MAX" => Self::Max,
                "METHOD_MIN" => Self::Min,
                "METHOD_SUM" => Self::Sum,
                "METHOD_LATEST" => Self::Latest,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Method {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Mean => serializer.serialize_i32(1),
                Self::Max => serializer.serialize_i32(2),
                Self::Min => serializer.serialize_i32(3),
                Self::Sum => serializer.serialize_i32(4),
                Self::Latest => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Method {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                ".google.monitoring.dashboard.v1.PickTimeSeriesFilter.Method",
            ))
        }
    }

    /// Describes the ranking directions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Not allowed. You must specify a different `Direction` if you specify a
        /// `PickTimeSeriesFilter`.
        Unspecified,
        /// Pass the highest `num_time_series` ranking inputs.
        Top,
        /// Pass the lowest `num_time_series` ranking inputs.
        Bottom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Top => std::option::Option::Some(1),
                Self::Bottom => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Top => std::option::Option::Some("TOP"),
                Self::Bottom => std::option::Option::Some("BOTTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Top,
                2 => Self::Bottom,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "TOP" => Self::Top,
                "BOTTOM" => Self::Bottom,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Top => serializer.serialize_i32(1),
                Self::Bottom => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.monitoring.dashboard.v1.PickTimeSeriesFilter.Direction",
            ))
        }
    }
}

/// A filter that ranks streams based on their statistical relation to other
/// streams in a request.
/// Note: This field is deprecated and completely ignored by the API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StatisticalTimeSeriesFilter {
    /// `rankingMethod` is applied to a set of time series, and then the produced
    /// value for each individual time series is used to compare a given time
    /// series to others.
    /// These are methods that cannot be applied stream-by-stream, but rather
    /// require the full context of a request to evaluate time series.
    pub ranking_method: crate::model::statistical_time_series_filter::Method,

    /// How many time series to output.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub num_time_series: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatisticalTimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ranking_method][crate::model::StatisticalTimeSeriesFilter::ranking_method].
    pub fn set_ranking_method<
        T: std::convert::Into<crate::model::statistical_time_series_filter::Method>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_method = v.into();
        self
    }

    /// Sets the value of [num_time_series][crate::model::StatisticalTimeSeriesFilter::num_time_series].
    pub fn set_num_time_series<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_time_series = v.into();
        self
    }
}

impl wkt::message::Message for StatisticalTimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter"
    }
}

/// Defines additional types related to [StatisticalTimeSeriesFilter].
pub mod statistical_time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The filter methods that can be applied to a stream.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Not allowed in well-formed requests.
        Unspecified,
        /// Compute the outlier score of each stream.
        ClusterOutlier,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Method::value] or
        /// [Method::name].
        UnknownValue(method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Method {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ClusterOutlier => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                Self::ClusterOutlier => std::option::Option::Some("METHOD_CLUSTER_OUTLIER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Method {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Method {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Method {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ClusterOutlier,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Method {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METHOD_UNSPECIFIED" => Self::Unspecified,
                "METHOD_CLUSTER_OUTLIER" => Self::ClusterOutlier,
                _ => Self::UnknownValue(method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Method {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ClusterOutlier => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Method {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                ".google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter.Method",
            ))
        }
    }
}

/// A Google Stackdriver dashboard. Dashboards define the content and layout
/// of pages in the Stackdriver web application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dashboard {
    /// Identifier. The resource name of the dashboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The mutable, human-readable name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// `etag` is used for optimistic concurrency control as a way to help
    /// prevent simultaneous updates of a policy from overwriting each other.
    /// An `etag` is returned in the response to `GetDashboard`, and
    /// users are expected to put that etag in the request to `UpdateDashboard` to
    /// ensure that their change will be applied to the same version of the
    /// Dashboard configuration. The field should not be passed during
    /// dashboard creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Filters to reduce the amount of data charted based on the filter criteria.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dashboard_filters: std::vec::Vec<crate::model::DashboardFilter>,

    /// Labels applied to the dashboard
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A dashboard's root container element that defines the layout style.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub layout: std::option::Option<crate::model::dashboard::Layout>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dashboard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dashboard::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Dashboard::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Dashboard::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [dashboard_filters][crate::model::Dashboard::dashboard_filters].
    pub fn set_dashboard_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DashboardFilter>,
    {
        use std::iter::Iterator;
        self.dashboard_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Dashboard::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout].
    ///
    /// Note that all the setters affecting `layout` are mutually
    /// exclusive.
    pub fn set_layout<
        T: std::convert::Into<std::option::Option<crate::model::dashboard::Layout>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.layout = v.into();
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `GridLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn grid_layout(&self) -> std::option::Option<&std::boxed::Box<crate::model::GridLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::GridLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `GridLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_grid_layout<T: std::convert::Into<std::boxed::Box<crate::model::GridLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::GridLayout(v.into()));
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `MosaicLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mosaic_layout(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MosaicLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::MosaicLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `MosaicLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_mosaic_layout<T: std::convert::Into<std::boxed::Box<crate::model::MosaicLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::MosaicLayout(v.into()));
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `RowLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn row_layout(&self) -> std::option::Option<&std::boxed::Box<crate::model::RowLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::RowLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `RowLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_row_layout<T: std::convert::Into<std::boxed::Box<crate::model::RowLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::RowLayout(v.into()));
        self
    }

    /// The value of [layout][crate::model::Dashboard::layout]
    /// if it holds a `ColumnLayout`, `None` if the field is not set or
    /// holds a different branch.
    pub fn column_layout(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ColumnLayout>> {
        #[allow(unreachable_patterns)]
        self.layout.as_ref().and_then(|v| match v {
            crate::model::dashboard::Layout::ColumnLayout(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [layout][crate::model::Dashboard::layout]
    /// to hold a `ColumnLayout`.
    ///
    /// Note that all the setters affecting `layout` are
    /// mutually exclusive.
    pub fn set_column_layout<T: std::convert::Into<std::boxed::Box<crate::model::ColumnLayout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.layout =
            std::option::Option::Some(crate::model::dashboard::Layout::ColumnLayout(v.into()));
        self
    }
}

impl wkt::message::Message for Dashboard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Dashboard"
    }
}

/// Defines additional types related to [Dashboard].
pub mod dashboard {
    #[allow(unused_imports)]
    use super::*;

    /// A dashboard's root container element that defines the layout style.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Layout {
        /// Content is arranged with a basic layout that re-flows a simple list of
        /// informational elements like widgets or tiles.
        GridLayout(std::boxed::Box<crate::model::GridLayout>),
        /// The content is arranged as a grid of tiles, with each content widget
        /// occupying one or more grid blocks.
        MosaicLayout(std::boxed::Box<crate::model::MosaicLayout>),
        /// The content is divided into equally spaced rows and the widgets are
        /// arranged horizontally.
        RowLayout(std::boxed::Box<crate::model::RowLayout>),
        /// The content is divided into equally spaced columns and the widgets are
        /// arranged vertically.
        ColumnLayout(std::boxed::Box<crate::model::ColumnLayout>),
    }
}

/// A filter to reduce the amount of data charted in relevant widgets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DashboardFilter {
    /// Required. The key for the label
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label_key: std::string::String,

    /// The placeholder text that can be referenced in a filter string or MQL
    /// query. If omitted, the dashboard filter will be applied to all relevant
    /// widgets in the dashboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_variable: std::string::String,

    /// The specified filter type
    pub filter_type: crate::model::dashboard_filter::FilterType,

    /// The default value used in the filter comparison
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub default_value: std::option::Option<crate::model::dashboard_filter::DefaultValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DashboardFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_key][crate::model::DashboardFilter::label_key].
    pub fn set_label_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label_key = v.into();
        self
    }

    /// Sets the value of [template_variable][crate::model::DashboardFilter::template_variable].
    pub fn set_template_variable<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.template_variable = v.into();
        self
    }

    /// Sets the value of [filter_type][crate::model::DashboardFilter::filter_type].
    pub fn set_filter_type<T: std::convert::Into<crate::model::dashboard_filter::FilterType>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_type = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::DashboardFilter::default_value].
    ///
    /// Note that all the setters affecting `default_value` are mutually
    /// exclusive.
    pub fn set_default_value<
        T: std::convert::Into<std::option::Option<crate::model::dashboard_filter::DefaultValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_value = v.into();
        self
    }

    /// The value of [default_value][crate::model::DashboardFilter::default_value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.default_value.as_ref().and_then(|v| match v {
            crate::model::dashboard_filter::DefaultValue::StringValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [default_value][crate::model::DashboardFilter::default_value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `default_value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = std::option::Option::Some(
            crate::model::dashboard_filter::DefaultValue::StringValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DashboardFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.DashboardFilter"
    }
}

/// Defines additional types related to [DashboardFilter].
pub mod dashboard_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The type for the dashboard filter
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FilterType {
        /// Filter type is unspecified. This is not valid in a well-formed request.
        Unspecified,
        /// Filter on a resource label value
        ResourceLabel,
        /// Filter on a metrics label value
        MetricLabel,
        /// Filter on a user metadata label value
        UserMetadataLabel,
        /// Filter on a system metadata label value
        SystemMetadataLabel,
        /// Filter on a group id
        Group,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FilterType::value] or
        /// [FilterType::name].
        UnknownValue(filter_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod filter_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FilterType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceLabel => std::option::Option::Some(1),
                Self::MetricLabel => std::option::Option::Some(2),
                Self::UserMetadataLabel => std::option::Option::Some(3),
                Self::SystemMetadataLabel => std::option::Option::Some(4),
                Self::Group => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FILTER_TYPE_UNSPECIFIED"),
                Self::ResourceLabel => std::option::Option::Some("RESOURCE_LABEL"),
                Self::MetricLabel => std::option::Option::Some("METRIC_LABEL"),
                Self::UserMetadataLabel => std::option::Option::Some("USER_METADATA_LABEL"),
                Self::SystemMetadataLabel => std::option::Option::Some("SYSTEM_METADATA_LABEL"),
                Self::Group => std::option::Option::Some("GROUP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FilterType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FilterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FilterType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResourceLabel,
                2 => Self::MetricLabel,
                3 => Self::UserMetadataLabel,
                4 => Self::SystemMetadataLabel,
                5 => Self::Group,
                _ => Self::UnknownValue(filter_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FilterType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FILTER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_LABEL" => Self::ResourceLabel,
                "METRIC_LABEL" => Self::MetricLabel,
                "USER_METADATA_LABEL" => Self::UserMetadataLabel,
                "SYSTEM_METADATA_LABEL" => Self::SystemMetadataLabel,
                "GROUP" => Self::Group,
                _ => Self::UnknownValue(filter_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FilterType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceLabel => serializer.serialize_i32(1),
                Self::MetricLabel => serializer.serialize_i32(2),
                Self::UserMetadataLabel => serializer.serialize_i32(3),
                Self::SystemMetadataLabel => serializer.serialize_i32(4),
                Self::Group => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FilterType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilterType>::new(
                ".google.monitoring.dashboard.v1.DashboardFilter.FilterType",
            ))
        }
    }

    /// The default value used in the filter comparison
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DefaultValue {
        /// A variable-length string value.
        StringValue(std::string::String),
    }
}

/// The `CreateDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDashboardRequest {
    /// Required. The project on which to execute the request. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    ///
    /// The `[PROJECT_ID_OR_NUMBER]` must match the dashboard resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The initial dashboard specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dashboard: std::option::Option<crate::model::Dashboard>,

    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDashboardRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dashboard][crate::model::CreateDashboardRequest::dashboard].
    pub fn set_dashboard<T: std::convert::Into<std::option::Option<crate::model::Dashboard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dashboard = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDashboardRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.CreateDashboardRequest"
    }
}

/// The `ListDashboards` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDashboardsRequest {
    /// Required. The scope of the dashboards to list. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A positive number that is the maximum number of results to return.
    /// If unspecified, a default of 1000 is used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return additional results from the previous
    /// method call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDashboardsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDashboardsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDashboardsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDashboardsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDashboardsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ListDashboardsRequest"
    }
}

/// The `ListDashboards` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDashboardsResponse {
    /// The list of requested dashboards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dashboards: std::vec::Vec<crate::model::Dashboard>,

    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDashboardsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dashboards][crate::model::ListDashboardsResponse::dashboards].
    pub fn set_dashboards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dashboard>,
    {
        use std::iter::Iterator;
        self.dashboards = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDashboardsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDashboardsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ListDashboardsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDashboardsResponse {
    type PageItem = crate::model::Dashboard;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dashboards
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The `GetDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is one of:
    ///
    /// - `dashboards/[DASHBOARD_ID]` (for system dashboards)
    /// - `projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID]`
    ///   (for custom dashboards).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDashboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.GetDashboardRequest"
    }
}

/// The `DeleteDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is:
    ///
    /// ```norust
    /// projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID]
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDashboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.DeleteDashboardRequest"
    }
}

/// The `UpdateDashboard` request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDashboardRequest {
    /// Required. The dashboard that will replace the existing dashboard.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dashboard: std::option::Option<crate::model::Dashboard>,

    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDashboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dashboard][crate::model::UpdateDashboardRequest::dashboard].
    pub fn set_dashboard<T: std::convert::Into<std::option::Option<crate::model::Dashboard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dashboard = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDashboardRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDashboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.UpdateDashboardRequest"
    }
}

/// A widget that displays a list of error groups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorReportingPanel {
    /// The resource name of the Google Cloud Platform project. Written
    /// as `projects/{projectID}` or `projects/{projectNumber}`, where
    /// `{projectID}` and `{projectNumber}` can be found in the
    /// [Google Cloud console](https://support.google.com/cloud/answer/6158840).
    ///
    /// Examples: `projects/my-project-123`, `projects/5551234`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub project_names: std::vec::Vec<std::string::String>,

    /// An identifier of the service, such as the name of the
    /// executable, job, or Google App Engine service name. This field is expected
    /// to have a low number of values that are relatively stable over time, as
    /// opposed to `version`, which can be changed whenever new code is deployed.
    ///
    /// Contains the service name for error reports extracted from Google
    /// App Engine logs or `default` if the App Engine default service is used.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services: std::vec::Vec<std::string::String>,

    /// Represents the source code version that the developer provided,
    /// which could represent a version label or a Git SHA-1 hash, for example.
    /// For App Engine standard environment, the version is set to the version of
    /// the app.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorReportingPanel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_names][crate::model::ErrorReportingPanel::project_names].
    pub fn set_project_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.project_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [services][crate::model::ErrorReportingPanel::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [versions][crate::model::ErrorReportingPanel::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorReportingPanel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ErrorReportingPanel"
    }
}

/// A widget that displays a list of incidents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IncidentList {
    /// Optional. The monitored resource for which incidents are listed.
    /// The resource doesn't need to be fully specified. That is, you can specify
    /// the resource type but not the values of the resource labels.
    /// The resource type and labels are used for filtering.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub monitored_resources: std::vec::Vec<api::model::MonitoredResource>,

    /// Optional. A list of alert policy names to filter the incident list by.
    /// Don't include the project ID prefix in the policy name. For
    /// example, use `alertPolicies/utilization`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policy_names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IncidentList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [monitored_resources][crate::model::IncidentList::monitored_resources].
    pub fn set_monitored_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResource>,
    {
        use std::iter::Iterator;
        self.monitored_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [policy_names][crate::model::IncidentList::policy_names].
    pub fn set_policy_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.policy_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IncidentList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.IncidentList"
    }
}

/// A basic layout divides the available space into vertical columns of equal
/// width and arranges a list of widgets using a row-first strategy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GridLayout {
    /// The number of columns into which the view's width is divided. If omitted
    /// or set to zero, a system default will be used while rendering.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub columns: i64,

    /// The informational elements that are arranged into the columns row-first.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub widgets: std::vec::Vec<crate::model::Widget>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GridLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::GridLayout::columns].
    pub fn set_columns<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.columns = v.into();
        self
    }

    /// Sets the value of [widgets][crate::model::GridLayout::widgets].
    pub fn set_widgets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Widget>,
    {
        use std::iter::Iterator;
        self.widgets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GridLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.GridLayout"
    }
}

/// A mosaic layout divides the available space into a grid of blocks, and
/// overlays the grid with tiles. Unlike `GridLayout`, tiles may span multiple
/// grid blocks and can be placed at arbitrary locations in the grid.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MosaicLayout {
    /// The number of columns in the mosaic grid. The number of columns must be
    /// between 1 and 12, inclusive.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub columns: i32,

    /// The tiles to display.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tiles: std::vec::Vec<crate::model::mosaic_layout::Tile>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MosaicLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::MosaicLayout::columns].
    pub fn set_columns<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.columns = v.into();
        self
    }

    /// Sets the value of [tiles][crate::model::MosaicLayout::tiles].
    pub fn set_tiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::mosaic_layout::Tile>,
    {
        use std::iter::Iterator;
        self.tiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MosaicLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.MosaicLayout"
    }
}

/// Defines additional types related to [MosaicLayout].
pub mod mosaic_layout {
    #[allow(unused_imports)]
    use super::*;

    /// A single tile in the mosaic. The placement and size of the tile are
    /// configurable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Tile {
        /// The zero-indexed position of the tile in grid blocks relative to the
        /// left edge of the grid. Tiles must be contained within the specified
        /// number of columns. `x_pos` cannot be negative.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub x_pos: i32,

        /// The zero-indexed position of the tile in grid blocks relative to the
        /// top edge of the grid. `y_pos` cannot be negative.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub y_pos: i32,

        /// The width of the tile, measured in grid blocks. Tiles must have a
        /// minimum width of 1.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub width: i32,

        /// The height of the tile, measured in grid blocks. Tiles must have a
        /// minimum height of 1.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub height: i32,

        /// The informational widget contained in the tile. For example an `XyChart`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub widget: std::option::Option<crate::model::Widget>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Tile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [x_pos][crate::model::mosaic_layout::Tile::x_pos].
        pub fn set_x_pos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.x_pos = v.into();
            self
        }

        /// Sets the value of [y_pos][crate::model::mosaic_layout::Tile::y_pos].
        pub fn set_y_pos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.y_pos = v.into();
            self
        }

        /// Sets the value of [width][crate::model::mosaic_layout::Tile::width].
        pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.width = v.into();
            self
        }

        /// Sets the value of [height][crate::model::mosaic_layout::Tile::height].
        pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.height = v.into();
            self
        }

        /// Sets the value of [widget][crate::model::mosaic_layout::Tile::widget].
        pub fn set_widget<T: std::convert::Into<std::option::Option<crate::model::Widget>>>(
            mut self,
            v: T,
        ) -> Self {
            self.widget = v.into();
            self
        }
    }

    impl wkt::message::Message for Tile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.MosaicLayout.Tile"
        }
    }
}

/// A simplified layout that divides the available space into rows
/// and arranges a set of widgets horizontally in each row.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RowLayout {
    /// The rows of content to display.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rows: std::vec::Vec<crate::model::row_layout::Row>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RowLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rows][crate::model::RowLayout::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::row_layout::Row>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RowLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.RowLayout"
    }
}

/// Defines additional types related to [RowLayout].
pub mod row_layout {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the layout properties and content for a row.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Row {
        /// The relative weight of this row. The row weight is used to adjust the
        /// height of rows on the screen (relative to peers). Greater the weight,
        /// greater the height of the row on the screen. If omitted, a value
        /// of 1 is used while rendering.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub weight: i64,

        /// The display widgets arranged horizontally in this row.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub widgets: std::vec::Vec<crate::model::Widget>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Row {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [weight][crate::model::row_layout::Row::weight].
        pub fn set_weight<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.weight = v.into();
            self
        }

        /// Sets the value of [widgets][crate::model::row_layout::Row::widgets].
        pub fn set_widgets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Widget>,
        {
            use std::iter::Iterator;
            self.widgets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Row {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.RowLayout.Row"
        }
    }
}

/// A simplified layout that divides the available space into vertical columns
/// and arranges a set of widgets vertically in each column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnLayout {
    /// The columns of content to display.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::column_layout::Column>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnLayout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::ColumnLayout::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::column_layout::Column>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ColumnLayout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ColumnLayout"
    }
}

/// Defines additional types related to [ColumnLayout].
pub mod column_layout {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the layout properties and content for a column.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Column {
        /// The relative weight of this column. The column weight is used to adjust
        /// the width of columns on the screen (relative to peers).
        /// Greater the weight, greater the width of the column on the screen.
        /// If omitted, a value of 1 is used while rendering.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub weight: i64,

        /// The display widgets arranged vertically in this column.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub widgets: std::vec::Vec<crate::model::Widget>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Column {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [weight][crate::model::column_layout::Column::weight].
        pub fn set_weight<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.weight = v.into();
            self
        }

        /// Sets the value of [widgets][crate::model::column_layout::Column::widgets].
        pub fn set_widgets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Widget>,
        {
            use std::iter::Iterator;
            self.widgets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Column {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.ColumnLayout.Column"
        }
    }
}

/// A widget that displays a stream of log.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogsPanel {
    /// A filter that chooses which log entries to return.  See [Advanced Logs
    /// Queries](https://cloud.google.com/logging/docs/view/advanced-queries).
    /// Only log entries that match the filter are returned.  An empty filter
    /// matches all log entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The names of logging resources to collect logs for. Currently only projects
    /// are supported. If empty, the widget will default to the host project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogsPanel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::LogsPanel::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [resource_names][crate::model::LogsPanel::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LogsPanel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.LogsPanel"
    }
}

/// TimeSeriesQuery collects the set of supported methods for querying time
/// series data from the Stackdriver metrics API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesQuery {
    /// The unit of data contained in fetched time series. If non-empty, this
    /// unit will override any unit that accompanies fetched data. The format is
    /// the same as the
    /// [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors)
    /// field in `MetricDescriptor`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub unit_override: std::string::String,

    /// Optional. If set, Cloud Monitoring will treat the full query duration as
    /// the alignment period so that there will be only 1 output value.
    ///
    /// *Note: This could override the configured alignment period except for
    /// the cases where a series of data points are expected, like
    ///
    /// - XyChart
    /// - Scorecard's spark chart
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub output_full_duration: bool,

    /// Parameters needed to obtain data for the chart.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::time_series_query::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [unit_override][crate::model::TimeSeriesQuery::unit_override].
    pub fn set_unit_override<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.unit_override = v.into();
        self
    }

    /// Sets the value of [output_full_duration][crate::model::TimeSeriesQuery::output_full_duration].
    pub fn set_output_full_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.output_full_duration = v.into();
        self
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::time_series_query::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesFilter(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesFilterRatio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_filter_ratio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesFilterRatio>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesFilterRatio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesFilterRatio`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_filter_ratio<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesFilterRatio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesFilterRatio(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `TimeSeriesQueryLanguage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_query_language(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::TimeSeriesQueryLanguage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `TimeSeriesQueryLanguage`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_time_series_query_language<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::TimeSeriesQueryLanguage(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::TimeSeriesQuery::source]
    /// if it holds a `PrometheusQuery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn prometheus_query(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::time_series_query::Source::PrometheusQuery(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::TimeSeriesQuery::source]
    /// to hold a `PrometheusQuery`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_prometheus_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::time_series_query::Source::PrometheusQuery(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesQuery"
    }
}

/// Defines additional types related to [TimeSeriesQuery].
pub mod time_series_query {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters needed to obtain data for the chart.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Filter parameters to fetch time series.
        TimeSeriesFilter(std::boxed::Box<crate::model::TimeSeriesFilter>),
        /// Parameters to fetch a ratio between two time series filters.
        TimeSeriesFilterRatio(std::boxed::Box<crate::model::TimeSeriesFilterRatio>),
        /// A query used to fetch time series with MQL.
        TimeSeriesQueryLanguage(std::string::String),
        /// A query used to fetch time series with PromQL.
        PrometheusQuery(std::string::String),
    }
}

/// A filter that defines a subset of time series data that is displayed in a
/// widget. Time series data is fetched using the
/// [`ListTimeSeries`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesFilter {
    /// Required. The [monitoring
    /// filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies
    /// the metric types, resources, and projects to query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// By default, the raw time series data is returned.
    /// Use this field to combine multiple time series for different views of the
    /// data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aggregation: std::option::Option<crate::model::Aggregation>,

    /// Apply a second aggregation after `aggregation` is applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Selects an optional time series filter.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output_filter: std::option::Option<crate::model::time_series_filter::OutputFilter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::TimeSeriesFilter::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [aggregation][crate::model::TimeSeriesFilter::aggregation].
    pub fn set_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation = v.into();
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::TimeSeriesFilter::secondary_aggregation].
    pub fn set_secondary_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_aggregation = v.into();
        self
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter].
    ///
    /// Note that all the setters affecting `output_filter` are mutually
    /// exclusive.
    pub fn set_output_filter<
        T: std::convert::Into<std::option::Option<crate::model::time_series_filter::OutputFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = v.into();
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// if it holds a `PickTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pick_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PickTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// to hold a `PickTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_pick_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::PickTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter::OutputFilter::PickTimeSeriesFilter(v.into()),
        );
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// if it holds a `StatisticalTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn statistical_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilter::output_filter]
    /// to hold a `StatisticalTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_statistical_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter::OutputFilter::StatisticalTimeSeriesFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilter"
    }
}

/// Defines additional types related to [TimeSeriesFilter].
pub mod time_series_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Selects an optional time series filter.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        PickTimeSeriesFilter(std::boxed::Box<crate::model::PickTimeSeriesFilter>),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        #[deprecated]
        StatisticalTimeSeriesFilter(std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>),
    }
}

/// A pair of time series filters that define a ratio computation. The output
/// time series is the pair-wise division of each aligned element from the
/// numerator and denominator time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesFilterRatio {
    /// The numerator of the ratio.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub numerator: std::option::Option<crate::model::time_series_filter_ratio::RatioPart>,

    /// The denominator of the ratio.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub denominator: std::option::Option<crate::model::time_series_filter_ratio::RatioPart>,

    /// Apply a second aggregation after the ratio is computed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_aggregation: std::option::Option<crate::model::Aggregation>,

    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output_filter: std::option::Option<crate::model::time_series_filter_ratio::OutputFilter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesFilterRatio {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [numerator][crate::model::TimeSeriesFilterRatio::numerator].
    pub fn set_numerator<
        T: std::convert::Into<std::option::Option<crate::model::time_series_filter_ratio::RatioPart>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.numerator = v.into();
        self
    }

    /// Sets the value of [denominator][crate::model::TimeSeriesFilterRatio::denominator].
    pub fn set_denominator<
        T: std::convert::Into<std::option::Option<crate::model::time_series_filter_ratio::RatioPart>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.denominator = v.into();
        self
    }

    /// Sets the value of [secondary_aggregation][crate::model::TimeSeriesFilterRatio::secondary_aggregation].
    pub fn set_secondary_aggregation<
        T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_aggregation = v.into();
        self
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter].
    ///
    /// Note that all the setters affecting `output_filter` are mutually
    /// exclusive.
    pub fn set_output_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::time_series_filter_ratio::OutputFilter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = v.into();
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// if it holds a `PickTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pick_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PickTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// to hold a `PickTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    pub fn set_pick_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::PickTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter_ratio::OutputFilter::PickTimeSeriesFilter(v.into()),
        );
        self
    }

    /// The value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// if it holds a `StatisticalTimeSeriesFilter`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn statistical_time_series_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>> {
        #[allow(unreachable_patterns)]
        self.output_filter.as_ref().and_then(|v| match v {
            crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_filter][crate::model::TimeSeriesFilterRatio::output_filter]
    /// to hold a `StatisticalTimeSeriesFilter`.
    ///
    /// Note that all the setters affecting `output_filter` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_statistical_time_series_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_filter = std::option::Option::Some(
            crate::model::time_series_filter_ratio::OutputFilter::StatisticalTimeSeriesFilter(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for TimeSeriesFilterRatio {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilterRatio"
    }
}

/// Defines additional types related to [TimeSeriesFilterRatio].
pub mod time_series_filter_ratio {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a query to build the numerator or denominator of a
    /// TimeSeriesFilterRatio.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RatioPart {
        /// Required. The [monitoring
        /// filter](https://cloud.google.com/monitoring/api/v3/filters) that
        /// identifies the metric types, resources, and projects to query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        /// By default, the raw time series data is returned.
        /// Use this field to combine multiple time series for different views of the
        /// data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub aggregation: std::option::Option<crate::model::Aggregation>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RatioPart {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::time_series_filter_ratio::RatioPart::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }

        /// Sets the value of [aggregation][crate::model::time_series_filter_ratio::RatioPart::aggregation].
        pub fn set_aggregation<
            T: std::convert::Into<std::option::Option<crate::model::Aggregation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregation = v.into();
            self
        }
    }

    impl wkt::message::Message for RatioPart {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesFilterRatio.RatioPart"
        }
    }

    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        PickTimeSeriesFilter(std::boxed::Box<crate::model::PickTimeSeriesFilter>),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        #[deprecated]
        StatisticalTimeSeriesFilter(std::boxed::Box<crate::model::StatisticalTimeSeriesFilter>),
    }
}

/// Defines a threshold for categorizing time series values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Threshold {
    /// A label for the threshold.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label: std::string::String,

    /// The value of the threshold. The value should be defined in the native scale
    /// of the metric.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub value: f64,

    /// The state color for this threshold. Color is not allowed in a XyChart.
    pub color: crate::model::threshold::Color,

    /// The direction for the current threshold. Direction is not allowed in a
    /// XyChart.
    pub direction: crate::model::threshold::Direction,

    /// The target axis to use for plotting the threshold. Target axis is not
    /// allowed in a Scorecard.
    pub target_axis: crate::model::threshold::TargetAxis,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Threshold {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label][crate::model::Threshold::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Threshold::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [color][crate::model::Threshold::color].
    pub fn set_color<T: std::convert::Into<crate::model::threshold::Color>>(
        mut self,
        v: T,
    ) -> Self {
        self.color = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::Threshold::direction].
    pub fn set_direction<T: std::convert::Into<crate::model::threshold::Direction>>(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [target_axis][crate::model::Threshold::target_axis].
    pub fn set_target_axis<T: std::convert::Into<crate::model::threshold::TargetAxis>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_axis = v.into();
        self
    }
}

impl wkt::message::Message for Threshold {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Threshold"
    }
}

/// Defines additional types related to [Threshold].
pub mod threshold {
    #[allow(unused_imports)]
    use super::*;

    /// The color suggests an interpretation to the viewer when actual values cross
    /// the threshold. Comments on each color provide UX guidance on how users can
    /// be expected to interpret a given state color.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Color {
        /// Color is unspecified. Not allowed in well-formed requests.
        Unspecified,
        /// Crossing the threshold is "concerning" behavior.
        Yellow,
        /// Crossing the threshold is "emergency" behavior.
        Red,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Color::value] or
        /// [Color::name].
        UnknownValue(color::UnknownValue),
    }

    #[doc(hidden)]
    pub mod color {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Color {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Yellow => std::option::Option::Some(4),
                Self::Red => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COLOR_UNSPECIFIED"),
                Self::Yellow => std::option::Option::Some("YELLOW"),
                Self::Red => std::option::Option::Some("RED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Color {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Color {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Color {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                4 => Self::Yellow,
                6 => Self::Red,
                _ => Self::UnknownValue(color::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Color {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COLOR_UNSPECIFIED" => Self::Unspecified,
                "YELLOW" => Self::Yellow,
                "RED" => Self::Red,
                _ => Self::UnknownValue(color::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Color {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Yellow => serializer.serialize_i32(4),
                Self::Red => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Color {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Color>::new(
                ".google.monitoring.dashboard.v1.Threshold.Color",
            ))
        }
    }

    /// Whether the threshold is considered crossed by an actual value above or
    /// below its threshold value.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Not allowed in well-formed requests.
        Unspecified,
        /// The threshold will be considered crossed if the actual value is above
        /// the threshold value.
        Above,
        /// The threshold will be considered crossed if the actual value is below
        /// the threshold value.
        Below,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Above => std::option::Option::Some(1),
                Self::Below => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Above => std::option::Option::Some("ABOVE"),
                Self::Below => std::option::Option::Some("BELOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Above,
                2 => Self::Below,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "ABOVE" => Self::Above,
                "BELOW" => Self::Below,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Above => serializer.serialize_i32(1),
                Self::Below => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.monitoring.dashboard.v1.Threshold.Direction",
            ))
        }
    }

    /// An axis identifier.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetAxis {
        /// The target axis was not specified. Defaults to Y1.
        Unspecified,
        /// The y_axis (the right axis of chart).
        Y1,
        /// The y2_axis (the left axis of chart).
        Y2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TargetAxis::value] or
        /// [TargetAxis::name].
        UnknownValue(target_axis::UnknownValue),
    }

    #[doc(hidden)]
    pub mod target_axis {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TargetAxis {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Y1 => std::option::Option::Some(1),
                Self::Y2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARGET_AXIS_UNSPECIFIED"),
                Self::Y1 => std::option::Option::Some("Y1"),
                Self::Y2 => std::option::Option::Some("Y2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TargetAxis {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TargetAxis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TargetAxis {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Y1,
                2 => Self::Y2,
                _ => Self::UnknownValue(target_axis::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TargetAxis {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARGET_AXIS_UNSPECIFIED" => Self::Unspecified,
                "Y1" => Self::Y1,
                "Y2" => Self::Y2,
                _ => Self::UnknownValue(target_axis::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TargetAxis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Y1 => serializer.serialize_i32(1),
                Self::Y2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TargetAxis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetAxis>::new(
                ".google.monitoring.dashboard.v1.Threshold.TargetAxis",
            ))
        }
    }
}

/// A widget that displays timeseries data as a pie or a donut.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PieChart {
    /// Required. The queries for the chart's data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sets: std::vec::Vec<crate::model::pie_chart::PieChartDataSet>,

    /// Required. Indicates the visualization type for the PieChart.
    pub chart_type: crate::model::pie_chart::PieChartType,

    /// Optional. Indicates whether or not the pie chart should show slices' labels
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub show_labels: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PieChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sets][crate::model::PieChart::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pie_chart::PieChartDataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [chart_type][crate::model::PieChart::chart_type].
    pub fn set_chart_type<T: std::convert::Into<crate::model::pie_chart::PieChartType>>(
        mut self,
        v: T,
    ) -> Self {
        self.chart_type = v.into();
        self
    }

    /// Sets the value of [show_labels][crate::model::PieChart::show_labels].
    pub fn set_show_labels<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_labels = v.into();
        self
    }
}

impl wkt::message::Message for PieChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.PieChart"
    }
}

/// Defines additional types related to [PieChart].
pub mod pie_chart {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PieChartDataSet {
        /// Required. The query for the PieChart. See,
        /// `google.monitoring.dashboard.v1.TimeSeriesQuery`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// Optional. A template for the name of the slice. This name will be
        /// displayed in the legend and the tooltip of the pie chart. It replaces the
        /// auto-generated names for the slices. For example, if the template is set
        /// to
        /// `${resource.labels.zone}`, the zone's value will be used for the name
        /// instead of the default name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub slice_name_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query. For example, if the data is published once every 10
        /// minutes, the `min_alignment_period` should be at least 10 minutes. It
        /// would not make sense to fetch and align data at one minute intervals.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PieChartDataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::pie_chart::PieChartDataSet::time_series_query].
        pub fn set_time_series_query<
            T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series_query = v.into();
            self
        }

        /// Sets the value of [slice_name_template][crate::model::pie_chart::PieChartDataSet::slice_name_template].
        pub fn set_slice_name_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.slice_name_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::pie_chart::PieChartDataSet::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }
    }

    impl wkt::message::Message for PieChartDataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.PieChart.PieChartDataSet"
        }
    }

    /// Types for the pie chart.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PieChartType {
        /// The zero value. No type specified. Do not use.
        Unspecified,
        /// A Pie type PieChart.
        Pie,
        /// Similar to PIE, but the DONUT type PieChart has a hole in the middle.
        Donut,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PieChartType::value] or
        /// [PieChartType::name].
        UnknownValue(pie_chart_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod pie_chart_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PieChartType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pie => std::option::Option::Some(1),
                Self::Donut => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PIE_CHART_TYPE_UNSPECIFIED"),
                Self::Pie => std::option::Option::Some("PIE"),
                Self::Donut => std::option::Option::Some("DONUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PieChartType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PieChartType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PieChartType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pie,
                2 => Self::Donut,
                _ => Self::UnknownValue(pie_chart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PieChartType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PIE_CHART_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PIE" => Self::Pie,
                "DONUT" => Self::Donut,
                _ => Self::UnknownValue(pie_chart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PieChartType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pie => serializer.serialize_i32(1),
                Self::Donut => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PieChartType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PieChartType>::new(
                ".google.monitoring.dashboard.v1.PieChart.PieChartType",
            ))
        }
    }
}

/// A widget showing the latest value of a metric, and how this value relates to
/// one or more thresholds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Scorecard {
    /// Required. Fields for querying time series data from the
    /// Stackdriver metrics API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

    /// The thresholds used to determine the state of the scorecard given the
    /// time series' current value. For an actual value x, the scorecard is in a
    /// danger state if x is less than or equal to a danger threshold that triggers
    /// below, or greater than or equal to a danger threshold that triggers above.
    /// Similarly, if x is above/below a warning threshold that triggers
    /// above/below, then the scorecard is in a warning state - unless x also puts
    /// it in a danger state. (Danger trumps warning.)
    ///
    /// As an example, consider a scorecard with the following four thresholds:
    ///
    /// ```norust
    /// {
    ///   value: 90,
    ///   category: 'DANGER',
    ///   trigger: 'ABOVE',
    /// },
    /// {
    ///   value: 70,
    ///   category: 'WARNING',
    ///   trigger: 'ABOVE',
    /// },
    /// {
    ///   value: 10,
    ///   category: 'DANGER',
    ///   trigger: 'BELOW',
    /// },
    /// {
    ///   value: 20,
    ///   category: 'WARNING',
    ///   trigger: 'BELOW',
    /// }
    /// ```
    ///
    /// Then: values less than or equal to 10 would put the scorecard in a DANGER
    /// state, values greater than 10 but less than or equal to 20 a WARNING state,
    /// values strictly between 20 and 70 an OK state, values greater than or equal
    /// to 70 but less than 90 a WARNING state, and values greater than or equal to
    /// 90 a DANGER state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub thresholds: std::vec::Vec<crate::model::Threshold>,

    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_view: std::option::Option<crate::model::scorecard::DataView>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Scorecard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_query][crate::model::Scorecard::time_series_query].
    pub fn set_time_series_query<
        T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_series_query = v.into();
        self
    }

    /// Sets the value of [thresholds][crate::model::Scorecard::thresholds].
    pub fn set_thresholds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Threshold>,
    {
        use std::iter::Iterator;
        self.thresholds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view].
    ///
    /// Note that all the setters affecting `data_view` are mutually
    /// exclusive.
    pub fn set_data_view<
        T: std::convert::Into<std::option::Option<crate::model::scorecard::DataView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view = v.into();
        self
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `GaugeView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gauge_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scorecard::GaugeView>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::GaugeView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `GaugeView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_gauge_view<
        T: std::convert::Into<std::boxed::Box<crate::model::scorecard::GaugeView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::GaugeView(v.into()));
        self
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `SparkChartView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_chart_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scorecard::SparkChartView>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::SparkChartView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `SparkChartView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_spark_chart_view<
        T: std::convert::Into<std::boxed::Box<crate::model::scorecard::SparkChartView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::SparkChartView(v.into()));
        self
    }

    /// The value of [data_view][crate::model::Scorecard::data_view]
    /// if it holds a `BlankView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn blank_view(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.data_view.as_ref().and_then(|v| match v {
            crate::model::scorecard::DataView::BlankView(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_view][crate::model::Scorecard::data_view]
    /// to hold a `BlankView`.
    ///
    /// Note that all the setters affecting `data_view` are
    /// mutually exclusive.
    pub fn set_blank_view<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_view =
            std::option::Option::Some(crate::model::scorecard::DataView::BlankView(v.into()));
        self
    }
}

impl wkt::message::Message for Scorecard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard"
    }
}

/// Defines additional types related to [Scorecard].
pub mod scorecard {
    #[allow(unused_imports)]
    use super::*;

    /// A gauge chart shows where the current value sits within a pre-defined
    /// range. The upper and lower bounds should define the possible range of
    /// values for the scorecard's query (inclusive).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GaugeView {
        /// The lower bound for this gauge chart. The value of the chart should
        /// always be greater than or equal to this.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F64")]
        pub lower_bound: f64,

        /// The upper bound for this gauge chart. The value of the chart should
        /// always be less than or equal to this.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F64")]
        pub upper_bound: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GaugeView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lower_bound][crate::model::scorecard::GaugeView::lower_bound].
        pub fn set_lower_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.lower_bound = v.into();
            self
        }

        /// Sets the value of [upper_bound][crate::model::scorecard::GaugeView::upper_bound].
        pub fn set_upper_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.upper_bound = v.into();
            self
        }
    }

    impl wkt::message::Message for GaugeView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard.GaugeView"
        }
    }

    /// A sparkChart is a small chart suitable for inclusion in a table-cell or
    /// inline in text. This message contains the configuration for a sparkChart
    /// to show up on a Scorecard, showing recent trends of the scorecard's
    /// timeseries.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SparkChartView {
        /// Required. The type of sparkchart to show in this chartView.
        pub spark_chart_type: crate::model::SparkChartType,

        /// The lower bound on data point frequency in the chart implemented by
        /// specifying the minimum alignment period to use in a time series query.
        /// For example, if the data is published once every 10 minutes it would not
        /// make sense to fetch and align data at one minute intervals. This field is
        /// optional and exists only as a hint.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SparkChartView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [spark_chart_type][crate::model::scorecard::SparkChartView::spark_chart_type].
        pub fn set_spark_chart_type<T: std::convert::Into<crate::model::SparkChartType>>(
            mut self,
            v: T,
        ) -> Self {
            self.spark_chart_type = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::scorecard::SparkChartView::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }
    }

    impl wkt::message::Message for SparkChartView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Scorecard.SparkChartView"
        }
    }

    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataView {
        /// Will cause the scorecard to show a gauge chart.
        GaugeView(std::boxed::Box<crate::model::scorecard::GaugeView>),
        /// Will cause the scorecard to show a spark chart.
        SparkChartView(std::boxed::Box<crate::model::scorecard::SparkChartView>),
        /// Will cause the `Scorecard` to show only the value, with no indicator to
        /// its value relative to its thresholds.
        BlankView(std::boxed::Box<wkt::Empty>),
    }
}

/// A widget that defines a new section header. Sections populate a table of
/// contents and allow easier navigation of long-form content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SectionHeader {
    /// The subtitle of the section
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subtitle: std::string::String,

    /// Whether to insert a divider below the section in the table of contents
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub divider_below: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SectionHeader {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subtitle][crate::model::SectionHeader::subtitle].
    pub fn set_subtitle<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subtitle = v.into();
        self
    }

    /// Sets the value of [divider_below][crate::model::SectionHeader::divider_below].
    pub fn set_divider_below<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.divider_below = v.into();
        self
    }
}

impl wkt::message::Message for SectionHeader {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.SectionHeader"
    }
}

/// A widget that groups the other widgets by using a dropdown menu. All widgets
/// that are within the area spanned by the grouping widget are considered
/// member widgets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SingleViewGroup {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SingleViewGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SingleViewGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.SingleViewGroup"
    }
}

/// A table that displays time series data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesTable {
    /// Required. The data displayed in this table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sets: std::vec::Vec<crate::model::time_series_table::TableDataSet>,

    /// Optional. Store rendering strategy
    pub metric_visualization: crate::model::time_series_table::MetricVisualization,

    /// Optional. The list of the persistent column settings for the table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub column_settings: std::vec::Vec<crate::model::time_series_table::ColumnSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeriesTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sets][crate::model::TimeSeriesTable::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_table::TableDataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metric_visualization][crate::model::TimeSeriesTable::metric_visualization].
    pub fn set_metric_visualization<
        T: std::convert::Into<crate::model::time_series_table::MetricVisualization>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_visualization = v.into();
        self
    }

    /// Sets the value of [column_settings][crate::model::TimeSeriesTable::column_settings].
    pub fn set_column_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::time_series_table::ColumnSettings>,
    {
        use std::iter::Iterator;
        self.column_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable"
    }
}

/// Defines additional types related to [TimeSeriesTable].
pub mod time_series_table {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition with table options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TableDataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// Optional. A template string for naming `TimeSeries` in the resulting data
        /// set. This should be a string with interpolations of the form
        /// `${label_name}`, which will resolve to the label's value i.e.
        /// "${resource.labels.project_id}."
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        /// Optional. Table display options for configuring how the table is
        /// rendered.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub table_display_options: std::option::Option<crate::model::TableDisplayOptions>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TableDataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::time_series_table::TableDataSet::time_series_query].
        pub fn set_time_series_query<
            T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series_query = v.into();
            self
        }

        /// Sets the value of [table_template][crate::model::time_series_table::TableDataSet::table_template].
        pub fn set_table_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.table_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::time_series_table::TableDataSet::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }

        /// Sets the value of [table_display_options][crate::model::time_series_table::TableDataSet::table_display_options].
        pub fn set_table_display_options<
            T: std::convert::Into<std::option::Option<crate::model::TableDisplayOptions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.table_display_options = v.into();
            self
        }
    }

    impl wkt::message::Message for TableDataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable.TableDataSet"
        }
    }

    /// The persistent settings for a table's columns.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ColumnSettings {
        /// Required. The id of the column.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub column: std::string::String,

        /// Required. Whether the column should be visible on page load.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub visible: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ColumnSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [column][crate::model::time_series_table::ColumnSettings::column].
        pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }

        /// Sets the value of [visible][crate::model::time_series_table::ColumnSettings::visible].
        pub fn set_visible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.visible = v.into();
            self
        }
    }

    impl wkt::message::Message for ColumnSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.TimeSeriesTable.ColumnSettings"
        }
    }

    /// Enum for metric metric_visualization
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MetricVisualization {
        /// Unspecified state
        Unspecified,
        /// Default text rendering
        Number,
        /// Horizontal bar rendering
        Bar,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MetricVisualization::value] or
        /// [MetricVisualization::name].
        UnknownValue(metric_visualization::UnknownValue),
    }

    #[doc(hidden)]
    pub mod metric_visualization {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MetricVisualization {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Number => std::option::Option::Some(1),
                Self::Bar => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METRIC_VISUALIZATION_UNSPECIFIED"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Bar => std::option::Option::Some("BAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MetricVisualization {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MetricVisualization {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MetricVisualization {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Number,
                2 => Self::Bar,
                _ => Self::UnknownValue(metric_visualization::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MetricVisualization {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METRIC_VISUALIZATION_UNSPECIFIED" => Self::Unspecified,
                "NUMBER" => Self::Number,
                "BAR" => Self::Bar,
                _ => Self::UnknownValue(metric_visualization::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MetricVisualization {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Number => serializer.serialize_i32(1),
                Self::Bar => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MetricVisualization {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetricVisualization>::new(
                ".google.monitoring.dashboard.v1.TimeSeriesTable.MetricVisualization",
            ))
        }
    }
}

/// Table display options that can be reused.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableDisplayOptions {
    /// Optional. This field is unused and has been replaced by
    /// TimeSeriesTable.column_settings
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub shown_columns: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableDisplayOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shown_columns][crate::model::TableDisplayOptions::shown_columns].
    #[deprecated]
    pub fn set_shown_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.shown_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableDisplayOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.TableDisplayOptions"
    }
}

/// A widget that displays textual content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Text {
    /// The text content to be displayed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// How the text content is formatted.
    pub format: crate::model::text::Format,

    /// How the text is styled
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub style: std::option::Option<crate::model::text::TextStyle>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Text {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::Text::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Text::format].
    pub fn set_format<T: std::convert::Into<crate::model::text::Format>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [style][crate::model::Text::style].
    pub fn set_style<T: std::convert::Into<std::option::Option<crate::model::text::TextStyle>>>(
        mut self,
        v: T,
    ) -> Self {
        self.style = v.into();
        self
    }
}

impl wkt::message::Message for Text {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Text"
    }
}

/// Defines additional types related to [Text].
pub mod text {
    #[allow(unused_imports)]
    use super::*;

    /// Properties that determine how the title and content are styled
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TextStyle {
        /// The background color as a hex string. "#RRGGBB" or "#RGB"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub background_color: std::string::String,

        /// The text color as a hex string. "#RRGGBB" or "#RGB"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text_color: std::string::String,

        /// The horizontal alignment of both the title and content
        pub horizontal_alignment: crate::model::text::text_style::HorizontalAlignment,

        /// The vertical alignment of both the title and content
        pub vertical_alignment: crate::model::text::text_style::VerticalAlignment,

        /// The amount of padding around the widget
        pub padding: crate::model::text::text_style::PaddingSize,

        /// Font sizes for both the title and content. The title will still be larger
        /// relative to the content.
        pub font_size: crate::model::text::text_style::FontSize,

        /// The pointer location for this widget (also sometimes called a "tail")
        pub pointer_location: crate::model::text::text_style::PointerLocation,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextStyle {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [background_color][crate::model::text::TextStyle::background_color].
        pub fn set_background_color<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.background_color = v.into();
            self
        }

        /// Sets the value of [text_color][crate::model::text::TextStyle::text_color].
        pub fn set_text_color<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text_color = v.into();
            self
        }

        /// Sets the value of [horizontal_alignment][crate::model::text::TextStyle::horizontal_alignment].
        pub fn set_horizontal_alignment<
            T: std::convert::Into<crate::model::text::text_style::HorizontalAlignment>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.horizontal_alignment = v.into();
            self
        }

        /// Sets the value of [vertical_alignment][crate::model::text::TextStyle::vertical_alignment].
        pub fn set_vertical_alignment<
            T: std::convert::Into<crate::model::text::text_style::VerticalAlignment>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vertical_alignment = v.into();
            self
        }

        /// Sets the value of [padding][crate::model::text::TextStyle::padding].
        pub fn set_padding<T: std::convert::Into<crate::model::text::text_style::PaddingSize>>(
            mut self,
            v: T,
        ) -> Self {
            self.padding = v.into();
            self
        }

        /// Sets the value of [font_size][crate::model::text::TextStyle::font_size].
        pub fn set_font_size<T: std::convert::Into<crate::model::text::text_style::FontSize>>(
            mut self,
            v: T,
        ) -> Self {
            self.font_size = v.into();
            self
        }

        /// Sets the value of [pointer_location][crate::model::text::TextStyle::pointer_location].
        pub fn set_pointer_location<
            T: std::convert::Into<crate::model::text::text_style::PointerLocation>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.pointer_location = v.into();
            self
        }
    }

    impl wkt::message::Message for TextStyle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.Text.TextStyle"
        }
    }

    /// Defines additional types related to [TextStyle].
    pub mod text_style {
        #[allow(unused_imports)]
        use super::*;

        /// The horizontal alignment of both the title and content on a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum HorizontalAlignment {
            /// No horizontal alignment specified, will default to H_LEFT
            Unspecified,
            /// Left-align
            HLeft,
            /// Center-align
            HCenter,
            /// Right-align
            HRight,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [HorizontalAlignment::value] or
            /// [HorizontalAlignment::name].
            UnknownValue(horizontal_alignment::UnknownValue),
        }

        #[doc(hidden)]
        pub mod horizontal_alignment {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl HorizontalAlignment {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::HLeft => std::option::Option::Some(1),
                    Self::HCenter => std::option::Option::Some(2),
                    Self::HRight => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("HORIZONTAL_ALIGNMENT_UNSPECIFIED")
                    }
                    Self::HLeft => std::option::Option::Some("H_LEFT"),
                    Self::HCenter => std::option::Option::Some("H_CENTER"),
                    Self::HRight => std::option::Option::Some("H_RIGHT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for HorizontalAlignment {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for HorizontalAlignment {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for HorizontalAlignment {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::HLeft,
                    2 => Self::HCenter,
                    3 => Self::HRight,
                    _ => Self::UnknownValue(horizontal_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for HorizontalAlignment {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => Self::Unspecified,
                    "H_LEFT" => Self::HLeft,
                    "H_CENTER" => Self::HCenter,
                    "H_RIGHT" => Self::HRight,
                    _ => Self::UnknownValue(horizontal_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for HorizontalAlignment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::HLeft => serializer.serialize_i32(1),
                    Self::HCenter => serializer.serialize_i32(2),
                    Self::HRight => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for HorizontalAlignment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(
                    wkt::internal::EnumVisitor::<HorizontalAlignment>::new(
                        ".google.monitoring.dashboard.v1.Text.TextStyle.HorizontalAlignment",
                    ),
                )
            }
        }

        /// The vertical alignment of both the title and content on a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum VerticalAlignment {
            /// No vertical alignment specified, will default to V_TOP
            Unspecified,
            /// Top-align
            VTop,
            /// Center-align
            VCenter,
            /// Bottom-align
            VBottom,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [VerticalAlignment::value] or
            /// [VerticalAlignment::name].
            UnknownValue(vertical_alignment::UnknownValue),
        }

        #[doc(hidden)]
        pub mod vertical_alignment {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl VerticalAlignment {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::VTop => std::option::Option::Some(1),
                    Self::VCenter => std::option::Option::Some(2),
                    Self::VBottom => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("VERTICAL_ALIGNMENT_UNSPECIFIED")
                    }
                    Self::VTop => std::option::Option::Some("V_TOP"),
                    Self::VCenter => std::option::Option::Some("V_CENTER"),
                    Self::VBottom => std::option::Option::Some("V_BOTTOM"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for VerticalAlignment {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for VerticalAlignment {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for VerticalAlignment {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::VTop,
                    2 => Self::VCenter,
                    3 => Self::VBottom,
                    _ => Self::UnknownValue(vertical_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for VerticalAlignment {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VERTICAL_ALIGNMENT_UNSPECIFIED" => Self::Unspecified,
                    "V_TOP" => Self::VTop,
                    "V_CENTER" => Self::VCenter,
                    "V_BOTTOM" => Self::VBottom,
                    _ => Self::UnknownValue(vertical_alignment::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for VerticalAlignment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::VTop => serializer.serialize_i32(1),
                    Self::VCenter => serializer.serialize_i32(2),
                    Self::VBottom => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for VerticalAlignment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<VerticalAlignment>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.VerticalAlignment",
                ))
            }
        }

        /// Specifies padding size around a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PaddingSize {
            /// No padding size specified, will default to P_EXTRA_SMALL
            Unspecified,
            /// Extra small padding
            PExtraSmall,
            /// Small padding
            PSmall,
            /// Medium padding
            PMedium,
            /// Large padding
            PLarge,
            /// Extra large padding
            PExtraLarge,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PaddingSize::value] or
            /// [PaddingSize::name].
            UnknownValue(padding_size::UnknownValue),
        }

        #[doc(hidden)]
        pub mod padding_size {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PaddingSize {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::PExtraSmall => std::option::Option::Some(1),
                    Self::PSmall => std::option::Option::Some(2),
                    Self::PMedium => std::option::Option::Some(3),
                    Self::PLarge => std::option::Option::Some(4),
                    Self::PExtraLarge => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PADDING_SIZE_UNSPECIFIED"),
                    Self::PExtraSmall => std::option::Option::Some("P_EXTRA_SMALL"),
                    Self::PSmall => std::option::Option::Some("P_SMALL"),
                    Self::PMedium => std::option::Option::Some("P_MEDIUM"),
                    Self::PLarge => std::option::Option::Some("P_LARGE"),
                    Self::PExtraLarge => std::option::Option::Some("P_EXTRA_LARGE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PaddingSize {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PaddingSize {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PaddingSize {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::PExtraSmall,
                    2 => Self::PSmall,
                    3 => Self::PMedium,
                    4 => Self::PLarge,
                    5 => Self::PExtraLarge,
                    _ => Self::UnknownValue(padding_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PaddingSize {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PADDING_SIZE_UNSPECIFIED" => Self::Unspecified,
                    "P_EXTRA_SMALL" => Self::PExtraSmall,
                    "P_SMALL" => Self::PSmall,
                    "P_MEDIUM" => Self::PMedium,
                    "P_LARGE" => Self::PLarge,
                    "P_EXTRA_LARGE" => Self::PExtraLarge,
                    _ => Self::UnknownValue(padding_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PaddingSize {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::PExtraSmall => serializer.serialize_i32(1),
                    Self::PSmall => serializer.serialize_i32(2),
                    Self::PMedium => serializer.serialize_i32(3),
                    Self::PLarge => serializer.serialize_i32(4),
                    Self::PExtraLarge => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PaddingSize {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PaddingSize>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.PaddingSize",
                ))
            }
        }

        /// Specifies a font size for the title and content of a text widget
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FontSize {
            /// No font size specified, will default to FS_LARGE
            Unspecified,
            /// Extra small font size
            FsExtraSmall,
            /// Small font size
            FsSmall,
            /// Medium font size
            FsMedium,
            /// Large font size
            FsLarge,
            /// Extra large font size
            FsExtraLarge,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FontSize::value] or
            /// [FontSize::name].
            UnknownValue(font_size::UnknownValue),
        }

        #[doc(hidden)]
        pub mod font_size {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FontSize {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::FsExtraSmall => std::option::Option::Some(1),
                    Self::FsSmall => std::option::Option::Some(2),
                    Self::FsMedium => std::option::Option::Some(3),
                    Self::FsLarge => std::option::Option::Some(4),
                    Self::FsExtraLarge => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FONT_SIZE_UNSPECIFIED"),
                    Self::FsExtraSmall => std::option::Option::Some("FS_EXTRA_SMALL"),
                    Self::FsSmall => std::option::Option::Some("FS_SMALL"),
                    Self::FsMedium => std::option::Option::Some("FS_MEDIUM"),
                    Self::FsLarge => std::option::Option::Some("FS_LARGE"),
                    Self::FsExtraLarge => std::option::Option::Some("FS_EXTRA_LARGE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FontSize {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FontSize {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FontSize {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::FsExtraSmall,
                    2 => Self::FsSmall,
                    3 => Self::FsMedium,
                    4 => Self::FsLarge,
                    5 => Self::FsExtraLarge,
                    _ => Self::UnknownValue(font_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FontSize {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FONT_SIZE_UNSPECIFIED" => Self::Unspecified,
                    "FS_EXTRA_SMALL" => Self::FsExtraSmall,
                    "FS_SMALL" => Self::FsSmall,
                    "FS_MEDIUM" => Self::FsMedium,
                    "FS_LARGE" => Self::FsLarge,
                    "FS_EXTRA_LARGE" => Self::FsExtraLarge,
                    _ => Self::UnknownValue(font_size::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FontSize {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::FsExtraSmall => serializer.serialize_i32(1),
                    Self::FsSmall => serializer.serialize_i32(2),
                    Self::FsMedium => serializer.serialize_i32(3),
                    Self::FsLarge => serializer.serialize_i32(4),
                    Self::FsExtraLarge => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FontSize {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FontSize>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.FontSize",
                ))
            }
        }

        /// Specifies where a visual pointer is placed on a text widget (also
        /// sometimes called a "tail")
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PointerLocation {
            /// No visual pointer
            Unspecified,
            /// Placed in the middle of the top of the widget
            PlTop,
            /// Placed in the middle of the right side of the widget
            PlRight,
            /// Placed in the middle of the bottom of the widget
            PlBottom,
            /// Placed in the middle of the left side of the widget
            PlLeft,
            /// Placed on the left side of the top of the widget
            PlTopLeft,
            /// Placed on the right side of the top of the widget
            PlTopRight,
            /// Placed on the top of the right side of the widget
            PlRightTop,
            /// Placed on the bottom of the right side of the widget
            PlRightBottom,
            /// Placed on the right side of the bottom of the widget
            PlBottomRight,
            /// Placed on the left side of the bottom of the widget
            PlBottomLeft,
            /// Placed on the bottom of the left side of the widget
            PlLeftBottom,
            /// Placed on the top of the left side of the widget
            PlLeftTop,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PointerLocation::value] or
            /// [PointerLocation::name].
            UnknownValue(pointer_location::UnknownValue),
        }

        #[doc(hidden)]
        pub mod pointer_location {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PointerLocation {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::PlTop => std::option::Option::Some(1),
                    Self::PlRight => std::option::Option::Some(2),
                    Self::PlBottom => std::option::Option::Some(3),
                    Self::PlLeft => std::option::Option::Some(4),
                    Self::PlTopLeft => std::option::Option::Some(5),
                    Self::PlTopRight => std::option::Option::Some(6),
                    Self::PlRightTop => std::option::Option::Some(7),
                    Self::PlRightBottom => std::option::Option::Some(8),
                    Self::PlBottomRight => std::option::Option::Some(9),
                    Self::PlBottomLeft => std::option::Option::Some(10),
                    Self::PlLeftBottom => std::option::Option::Some(11),
                    Self::PlLeftTop => std::option::Option::Some(12),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("POINTER_LOCATION_UNSPECIFIED"),
                    Self::PlTop => std::option::Option::Some("PL_TOP"),
                    Self::PlRight => std::option::Option::Some("PL_RIGHT"),
                    Self::PlBottom => std::option::Option::Some("PL_BOTTOM"),
                    Self::PlLeft => std::option::Option::Some("PL_LEFT"),
                    Self::PlTopLeft => std::option::Option::Some("PL_TOP_LEFT"),
                    Self::PlTopRight => std::option::Option::Some("PL_TOP_RIGHT"),
                    Self::PlRightTop => std::option::Option::Some("PL_RIGHT_TOP"),
                    Self::PlRightBottom => std::option::Option::Some("PL_RIGHT_BOTTOM"),
                    Self::PlBottomRight => std::option::Option::Some("PL_BOTTOM_RIGHT"),
                    Self::PlBottomLeft => std::option::Option::Some("PL_BOTTOM_LEFT"),
                    Self::PlLeftBottom => std::option::Option::Some("PL_LEFT_BOTTOM"),
                    Self::PlLeftTop => std::option::Option::Some("PL_LEFT_TOP"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PointerLocation {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PointerLocation {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PointerLocation {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::PlTop,
                    2 => Self::PlRight,
                    3 => Self::PlBottom,
                    4 => Self::PlLeft,
                    5 => Self::PlTopLeft,
                    6 => Self::PlTopRight,
                    7 => Self::PlRightTop,
                    8 => Self::PlRightBottom,
                    9 => Self::PlBottomRight,
                    10 => Self::PlBottomLeft,
                    11 => Self::PlLeftBottom,
                    12 => Self::PlLeftTop,
                    _ => Self::UnknownValue(pointer_location::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PointerLocation {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "POINTER_LOCATION_UNSPECIFIED" => Self::Unspecified,
                    "PL_TOP" => Self::PlTop,
                    "PL_RIGHT" => Self::PlRight,
                    "PL_BOTTOM" => Self::PlBottom,
                    "PL_LEFT" => Self::PlLeft,
                    "PL_TOP_LEFT" => Self::PlTopLeft,
                    "PL_TOP_RIGHT" => Self::PlTopRight,
                    "PL_RIGHT_TOP" => Self::PlRightTop,
                    "PL_RIGHT_BOTTOM" => Self::PlRightBottom,
                    "PL_BOTTOM_RIGHT" => Self::PlBottomRight,
                    "PL_BOTTOM_LEFT" => Self::PlBottomLeft,
                    "PL_LEFT_BOTTOM" => Self::PlLeftBottom,
                    "PL_LEFT_TOP" => Self::PlLeftTop,
                    _ => Self::UnknownValue(pointer_location::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PointerLocation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::PlTop => serializer.serialize_i32(1),
                    Self::PlRight => serializer.serialize_i32(2),
                    Self::PlBottom => serializer.serialize_i32(3),
                    Self::PlLeft => serializer.serialize_i32(4),
                    Self::PlTopLeft => serializer.serialize_i32(5),
                    Self::PlTopRight => serializer.serialize_i32(6),
                    Self::PlRightTop => serializer.serialize_i32(7),
                    Self::PlRightBottom => serializer.serialize_i32(8),
                    Self::PlBottomRight => serializer.serialize_i32(9),
                    Self::PlBottomLeft => serializer.serialize_i32(10),
                    Self::PlLeftBottom => serializer.serialize_i32(11),
                    Self::PlLeftTop => serializer.serialize_i32(12),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PointerLocation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PointerLocation>::new(
                    ".google.monitoring.dashboard.v1.Text.TextStyle.PointerLocation",
                ))
            }
        }
    }

    /// The format type of the text content.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Format {
        /// Format is unspecified. Defaults to MARKDOWN.
        Unspecified,
        /// The text contains Markdown formatting.
        Markdown,
        /// The text contains no special formatting.
        Raw,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Format::value] or
        /// [Format::name].
        UnknownValue(format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Format {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Markdown => std::option::Option::Some(1),
                Self::Raw => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                Self::Markdown => std::option::Option::Some("MARKDOWN"),
                Self::Raw => std::option::Option::Some("RAW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Format {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Format {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Format {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Markdown,
                2 => Self::Raw,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Format {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FORMAT_UNSPECIFIED" => Self::Unspecified,
                "MARKDOWN" => Self::Markdown,
                "RAW" => Self::Raw,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Format {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Markdown => serializer.serialize_i32(1),
                Self::Raw => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Format {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                ".google.monitoring.dashboard.v1.Text.Format",
            ))
        }
    }
}

/// Widget contains a single dashboard component and configuration of how to
/// present the component in the dashboard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Widget {
    /// Optional. The title of the widget.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Optional. The widget id. Ids may be made up of alphanumerics, dashes and
    /// underscores. Widget ids are optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Content defines the component used to populate the widget.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::widget::Content>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Widget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::Widget::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Widget::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Widget::content].
    ///
    /// Note that all the setters affecting `content` are mutually
    /// exclusive.
    pub fn set_content<
        T: std::convert::Into<std::option::Option<crate::model::widget::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `XyChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn xy_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::XyChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::XyChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `XyChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_xy_chart<T: std::convert::Into<std::boxed::Box<crate::model::XyChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::XyChart(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Scorecard`, `None` if the field is not set or
    /// holds a different branch.
    pub fn scorecard(&self) -> std::option::Option<&std::boxed::Box<crate::model::Scorecard>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Scorecard(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Scorecard`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_scorecard<T: std::convert::Into<std::boxed::Box<crate::model::Scorecard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::Scorecard(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::boxed::Box<crate::model::Text>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::boxed::Box<crate::model::Text>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::Text(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `Blank`, `None` if the field is not set or
    /// holds a different branch.
    pub fn blank(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::Blank(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `Blank`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_blank<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::Blank(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `AlertChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alert_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::AlertChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::AlertChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `AlertChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_alert_chart<T: std::convert::Into<std::boxed::Box<crate::model::AlertChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::AlertChart(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `TimeSeriesTable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_series_table(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeSeriesTable>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::TimeSeriesTable(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `TimeSeriesTable`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_time_series_table<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeSeriesTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::TimeSeriesTable(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `CollapsibleGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collapsible_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CollapsibleGroup>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::CollapsibleGroup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `CollapsibleGroup`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_collapsible_group<
        T: std::convert::Into<std::boxed::Box<crate::model::CollapsibleGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::CollapsibleGroup(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `LogsPanel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn logs_panel(&self) -> std::option::Option<&std::boxed::Box<crate::model::LogsPanel>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::LogsPanel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `LogsPanel`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_logs_panel<T: std::convert::Into<std::boxed::Box<crate::model::LogsPanel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::LogsPanel(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `IncidentList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn incident_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IncidentList>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::IncidentList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `IncidentList`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_incident_list<T: std::convert::Into<std::boxed::Box<crate::model::IncidentList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::IncidentList(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `PieChart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pie_chart(&self) -> std::option::Option<&std::boxed::Box<crate::model::PieChart>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::PieChart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `PieChart`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_pie_chart<T: std::convert::Into<std::boxed::Box<crate::model::PieChart>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = std::option::Option::Some(crate::model::widget::Content::PieChart(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `ErrorReportingPanel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error_reporting_panel(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ErrorReportingPanel>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::ErrorReportingPanel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `ErrorReportingPanel`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_error_reporting_panel<
        T: std::convert::Into<std::boxed::Box<crate::model::ErrorReportingPanel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::ErrorReportingPanel(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `SectionHeader`, `None` if the field is not set or
    /// holds a different branch.
    pub fn section_header(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SectionHeader>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::SectionHeader(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `SectionHeader`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_section_header<
        T: std::convert::Into<std::boxed::Box<crate::model::SectionHeader>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::SectionHeader(v.into()));
        self
    }

    /// The value of [content][crate::model::Widget::content]
    /// if it holds a `SingleViewGroup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_view_group(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleViewGroup>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::widget::Content::SingleViewGroup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Widget::content]
    /// to hold a `SingleViewGroup`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_single_view_group<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleViewGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::widget::Content::SingleViewGroup(v.into()));
        self
    }
}

impl wkt::message::Message for Widget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.Widget"
    }
}

/// Defines additional types related to [Widget].
pub mod widget {
    #[allow(unused_imports)]
    use super::*;

    /// Content defines the component used to populate the widget.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Content {
        /// A chart of time series data.
        XyChart(std::boxed::Box<crate::model::XyChart>),
        /// A scorecard summarizing time series data.
        Scorecard(std::boxed::Box<crate::model::Scorecard>),
        /// A raw string or markdown displaying textual content.
        Text(std::boxed::Box<crate::model::Text>),
        /// A blank space.
        Blank(std::boxed::Box<wkt::Empty>),
        /// A chart of alert policy data.
        AlertChart(std::boxed::Box<crate::model::AlertChart>),
        /// A widget that displays time series data in a tabular format.
        TimeSeriesTable(std::boxed::Box<crate::model::TimeSeriesTable>),
        /// A widget that groups the other widgets. All widgets that are within
        /// the area spanned by the grouping widget are considered member widgets.
        CollapsibleGroup(std::boxed::Box<crate::model::CollapsibleGroup>),
        /// A widget that shows a stream of logs.
        LogsPanel(std::boxed::Box<crate::model::LogsPanel>),
        /// A widget that shows list of incidents.
        IncidentList(std::boxed::Box<crate::model::IncidentList>),
        /// A widget that displays timeseries data as a pie chart.
        PieChart(std::boxed::Box<crate::model::PieChart>),
        /// A widget that displays a list of error groups.
        ErrorReportingPanel(std::boxed::Box<crate::model::ErrorReportingPanel>),
        /// A widget that defines a section header for easier navigation of the
        /// dashboard.
        SectionHeader(std::boxed::Box<crate::model::SectionHeader>),
        /// A widget that groups the other widgets by using a dropdown menu.
        SingleViewGroup(std::boxed::Box<crate::model::SingleViewGroup>),
    }
}

/// A chart that displays data on a 2D (X and Y axes) plane.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct XyChart {
    /// Required. The data displayed in this chart.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sets: std::vec::Vec<crate::model::xy_chart::DataSet>,

    /// The duration used to display a comparison chart. A comparison chart
    /// simultaneously shows values from two similar-length time periods
    /// (e.g., week-over-week metrics).
    /// The duration must be positive, and it can only be applied to charts with
    /// data sets of LINE plot type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeshift_duration: std::option::Option<wkt::Duration>,

    /// Threshold lines drawn horizontally across the chart.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub thresholds: std::vec::Vec<crate::model::Threshold>,

    /// The properties applied to the x-axis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub x_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// The properties applied to the y-axis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub y_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// The properties applied to the y2-axis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub y2_axis: std::option::Option<crate::model::xy_chart::Axis>,

    /// Display options for the chart.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub chart_options: std::option::Option<crate::model::ChartOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl XyChart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sets][crate::model::XyChart::data_sets].
    pub fn set_data_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::xy_chart::DataSet>,
    {
        use std::iter::Iterator;
        self.data_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timeshift_duration][crate::model::XyChart::timeshift_duration].
    pub fn set_timeshift_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeshift_duration = v.into();
        self
    }

    /// Sets the value of [thresholds][crate::model::XyChart::thresholds].
    pub fn set_thresholds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Threshold>,
    {
        use std::iter::Iterator;
        self.thresholds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [x_axis][crate::model::XyChart::x_axis].
    pub fn set_x_axis<T: std::convert::Into<std::option::Option<crate::model::xy_chart::Axis>>>(
        mut self,
        v: T,
    ) -> Self {
        self.x_axis = v.into();
        self
    }

    /// Sets the value of [y_axis][crate::model::XyChart::y_axis].
    pub fn set_y_axis<T: std::convert::Into<std::option::Option<crate::model::xy_chart::Axis>>>(
        mut self,
        v: T,
    ) -> Self {
        self.y_axis = v.into();
        self
    }

    /// Sets the value of [y2_axis][crate::model::XyChart::y2_axis].
    pub fn set_y2_axis<T: std::convert::Into<std::option::Option<crate::model::xy_chart::Axis>>>(
        mut self,
        v: T,
    ) -> Self {
        self.y2_axis = v.into();
        self
    }

    /// Sets the value of [chart_options][crate::model::XyChart::chart_options].
    pub fn set_chart_options<
        T: std::convert::Into<std::option::Option<crate::model::ChartOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chart_options = v.into();
        self
    }
}

impl wkt::message::Message for XyChart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.XyChart"
    }
}

/// Defines additional types related to [XyChart].
pub mod xy_chart {
    #[allow(unused_imports)]
    use super::*;

    /// Groups a time series query definition with charting options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series_query: std::option::Option<crate::model::TimeSeriesQuery>,

        /// How this data should be plotted on the chart.
        pub plot_type: crate::model::xy_chart::data_set::PlotType,

        /// A template string for naming `TimeSeries` in the resulting data set.
        /// This should be a string with interpolations of the form `${label_name}`,
        /// which will resolve to the label's value.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub legend_template: std::string::String,

        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_alignment_period: std::option::Option<wkt::Duration>,

        /// Optional. The target axis to use for plotting the metric.
        pub target_axis: crate::model::xy_chart::data_set::TargetAxis,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_series_query][crate::model::xy_chart::DataSet::time_series_query].
        pub fn set_time_series_query<
            T: std::convert::Into<std::option::Option<crate::model::TimeSeriesQuery>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series_query = v.into();
            self
        }

        /// Sets the value of [plot_type][crate::model::xy_chart::DataSet::plot_type].
        pub fn set_plot_type<T: std::convert::Into<crate::model::xy_chart::data_set::PlotType>>(
            mut self,
            v: T,
        ) -> Self {
            self.plot_type = v.into();
            self
        }

        /// Sets the value of [legend_template][crate::model::xy_chart::DataSet::legend_template].
        pub fn set_legend_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.legend_template = v.into();
            self
        }

        /// Sets the value of [min_alignment_period][crate::model::xy_chart::DataSet::min_alignment_period].
        pub fn set_min_alignment_period<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_alignment_period = v.into();
            self
        }

        /// Sets the value of [target_axis][crate::model::xy_chart::DataSet::target_axis].
        pub fn set_target_axis<
            T: std::convert::Into<crate::model::xy_chart::data_set::TargetAxis>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target_axis = v.into();
            self
        }
    }

    impl wkt::message::Message for DataSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.XyChart.DataSet"
        }
    }

    /// Defines additional types related to [DataSet].
    pub mod data_set {
        #[allow(unused_imports)]
        use super::*;

        /// The types of plotting strategies for data sets.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PlotType {
            /// Plot type is unspecified. The view will default to `LINE`.
            Unspecified,
            /// The data is plotted as a set of lines (one line per series).
            Line,
            /// The data is plotted as a set of filled areas (one area per series),
            /// with the areas stacked vertically (the base of each area is the top of
            /// its predecessor, and the base of the first area is the x-axis). Since
            /// the areas do not overlap, each is filled with a different opaque color.
            StackedArea,
            /// The data is plotted as a set of rectangular boxes (one box per series),
            /// with the boxes stacked vertically (the base of each box is the top of
            /// its predecessor, and the base of the first box is the x-axis). Since
            /// the boxes do not overlap, each is filled with a different opaque color.
            StackedBar,
            /// The data is plotted as a heatmap. The series being plotted must have a
            /// `DISTRIBUTION` value type. The value of each bucket in the distribution
            /// is displayed as a color. This type is not currently available in the
            /// Stackdriver Monitoring application.
            Heatmap,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PlotType::value] or
            /// [PlotType::name].
            UnknownValue(plot_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod plot_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PlotType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Line => std::option::Option::Some(1),
                    Self::StackedArea => std::option::Option::Some(2),
                    Self::StackedBar => std::option::Option::Some(3),
                    Self::Heatmap => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PLOT_TYPE_UNSPECIFIED"),
                    Self::Line => std::option::Option::Some("LINE"),
                    Self::StackedArea => std::option::Option::Some("STACKED_AREA"),
                    Self::StackedBar => std::option::Option::Some("STACKED_BAR"),
                    Self::Heatmap => std::option::Option::Some("HEATMAP"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PlotType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PlotType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PlotType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Line,
                    2 => Self::StackedArea,
                    3 => Self::StackedBar,
                    4 => Self::Heatmap,
                    _ => Self::UnknownValue(plot_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PlotType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PLOT_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "LINE" => Self::Line,
                    "STACKED_AREA" => Self::StackedArea,
                    "STACKED_BAR" => Self::StackedBar,
                    "HEATMAP" => Self::Heatmap,
                    _ => Self::UnknownValue(plot_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PlotType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Line => serializer.serialize_i32(1),
                    Self::StackedArea => serializer.serialize_i32(2),
                    Self::StackedBar => serializer.serialize_i32(3),
                    Self::Heatmap => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PlotType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PlotType>::new(
                    ".google.monitoring.dashboard.v1.XyChart.DataSet.PlotType",
                ))
            }
        }

        /// An axis identifier.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TargetAxis {
            /// The target axis was not specified. Defaults to Y1.
            Unspecified,
            /// The y_axis (the right axis of chart).
            Y1,
            /// The y2_axis (the left axis of chart).
            Y2,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TargetAxis::value] or
            /// [TargetAxis::name].
            UnknownValue(target_axis::UnknownValue),
        }

        #[doc(hidden)]
        pub mod target_axis {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TargetAxis {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Y1 => std::option::Option::Some(1),
                    Self::Y2 => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TARGET_AXIS_UNSPECIFIED"),
                    Self::Y1 => std::option::Option::Some("Y1"),
                    Self::Y2 => std::option::Option::Some("Y2"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TargetAxis {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TargetAxis {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TargetAxis {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Y1,
                    2 => Self::Y2,
                    _ => Self::UnknownValue(target_axis::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TargetAxis {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TARGET_AXIS_UNSPECIFIED" => Self::Unspecified,
                    "Y1" => Self::Y1,
                    "Y2" => Self::Y2,
                    _ => Self::UnknownValue(target_axis::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TargetAxis {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Y1 => serializer.serialize_i32(1),
                    Self::Y2 => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TargetAxis {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetAxis>::new(
                    ".google.monitoring.dashboard.v1.XyChart.DataSet.TargetAxis",
                ))
            }
        }
    }

    /// A chart axis.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Axis {
        /// The label of the axis.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub label: std::string::String,

        /// The axis scale. By default, a linear scale is used.
        pub scale: crate::model::xy_chart::axis::Scale,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Axis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [label][crate::model::xy_chart::Axis::label].
        pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.label = v.into();
            self
        }

        /// Sets the value of [scale][crate::model::xy_chart::Axis::scale].
        pub fn set_scale<T: std::convert::Into<crate::model::xy_chart::axis::Scale>>(
            mut self,
            v: T,
        ) -> Self {
            self.scale = v.into();
            self
        }
    }

    impl wkt::message::Message for Axis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.monitoring.dashboard.v1.XyChart.Axis"
        }
    }

    /// Defines additional types related to [Axis].
    pub mod axis {
        #[allow(unused_imports)]
        use super::*;

        /// Types of scales used in axes.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Scale {
            /// Scale is unspecified. The view will default to `LINEAR`.
            Unspecified,
            /// Linear scale.
            Linear,
            /// Logarithmic scale (base 10).
            Log10,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Scale::value] or
            /// [Scale::name].
            UnknownValue(scale::UnknownValue),
        }

        #[doc(hidden)]
        pub mod scale {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Scale {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Linear => std::option::Option::Some(1),
                    Self::Log10 => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SCALE_UNSPECIFIED"),
                    Self::Linear => std::option::Option::Some("LINEAR"),
                    Self::Log10 => std::option::Option::Some("LOG10"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Scale {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Scale {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Scale {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Linear,
                    2 => Self::Log10,
                    _ => Self::UnknownValue(scale::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Scale {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SCALE_UNSPECIFIED" => Self::Unspecified,
                    "LINEAR" => Self::Linear,
                    "LOG10" => Self::Log10,
                    _ => Self::UnknownValue(scale::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Scale {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Linear => serializer.serialize_i32(1),
                    Self::Log10 => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Scale {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scale>::new(
                    ".google.monitoring.dashboard.v1.XyChart.Axis.Scale",
                ))
            }
        }
    }
}

/// Options to control visual rendering of a chart.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChartOptions {
    /// The chart mode.
    pub mode: crate::model::chart_options::Mode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChartOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::ChartOptions::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::chart_options::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for ChartOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.monitoring.dashboard.v1.ChartOptions"
    }
}

/// Defines additional types related to [ChartOptions].
pub mod chart_options {
    #[allow(unused_imports)]
    use super::*;

    /// Chart mode options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode is unspecified. The view will default to `COLOR`.
        Unspecified,
        /// The chart distinguishes data series using different color. Line
        /// colors may get reused when there are many lines in the chart.
        Color,
        /// The chart uses the Stackdriver x-ray mode, in which each
        /// data set is plotted using the same semi-transparent color.
        XRay,
        /// The chart displays statistics such as average, median, 95th percentile,
        /// and more.
        Stats,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Color => std::option::Option::Some(1),
                Self::XRay => std::option::Option::Some(2),
                Self::Stats => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Color => std::option::Option::Some("COLOR"),
                Self::XRay => std::option::Option::Some("X_RAY"),
                Self::Stats => std::option::Option::Some("STATS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Color,
                2 => Self::XRay,
                3 => Self::Stats,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "COLOR" => Self::Color,
                "X_RAY" => Self::XRay,
                "STATS" => Self::Stats,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Color => serializer.serialize_i32(1),
                Self::XRay => serializer.serialize_i32(2),
                Self::Stats => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.monitoring.dashboard.v1.ChartOptions.Mode",
            ))
        }
    }
}

/// Defines the possible types of spark chart supported by the `Scorecard`.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SparkChartType {
    /// Not allowed in well-formed requests.
    Unspecified,
    /// The sparkline will be rendered as a small line chart.
    SparkLine,
    /// The sparkbar will be rendered as a small bar chart.
    SparkBar,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SparkChartType::value] or
    /// [SparkChartType::name].
    UnknownValue(spark_chart_type::UnknownValue),
}

#[doc(hidden)]
pub mod spark_chart_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SparkChartType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SparkLine => std::option::Option::Some(1),
            Self::SparkBar => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SPARK_CHART_TYPE_UNSPECIFIED"),
            Self::SparkLine => std::option::Option::Some("SPARK_LINE"),
            Self::SparkBar => std::option::Option::Some("SPARK_BAR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SparkChartType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SparkChartType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SparkChartType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::SparkLine,
            2 => Self::SparkBar,
            _ => Self::UnknownValue(spark_chart_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SparkChartType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SPARK_CHART_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SPARK_LINE" => Self::SparkLine,
            "SPARK_BAR" => Self::SparkBar,
            _ => Self::UnknownValue(spark_chart_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SparkChartType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SparkLine => serializer.serialize_i32(1),
            Self::SparkBar => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SparkChartType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SparkChartType>::new(
            ".google.monitoring.dashboard.v1.SparkChartType",
        ))
    }
}
